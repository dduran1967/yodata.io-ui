<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for src/lib/solid-client.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../index.html">All files</a> / <a href="index.html">src/lib</a> solid-client.min.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/11133</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/11121</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/2978</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/22</span>
      </div>
    </div>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var SolidClient=function(e){function t(r){if(n[r])retur<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n </span>n[r].exports;var i=<span class="fstat-no" title="function not covered" >n[</span>r]=<span class="cstat-no" title="statement not covered" >{exports<span class="cstat-no" title="statement not covered" >:{},id:r,loaded:!1};r</span></span>eturn<span class="cstat-no" title="statement not covered" > e[r].call(i.exports,i,i.exports,<span class="cstat-no" title="statement not covered" ></span>t),i.loaded=!0,i.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}</span>(funct<span class="cstat-no" title="statement not covered" >ion<span class="cstat-no" title="statement not covered" ></span>(e){for(var t in e)if(Object.pro</span>t<span class="fstat-no" title="function not covered" >ot</span>ype.hasOwn<span class="cstat-no" title="statement not covered" >Property.call(e<span class="cstat-no" title="statement not covered" >,t))switch(typeof e[t]){case"function":break;<span class="cstat-no" title="statement not covered" >case"object":e[t]=function(t){var n<span class="cstat-no" title="statement not covered" >=t.slic</span>e(1),r=e[t[0<span class="cstat-no" title="statement not covered" >]];re<span class="fstat-no" title="function not covered" >tu</span>rn function(e,t,<span class="cstat-no" title="statement not covered" >i){r.apply(</span>th<span class="cstat-no" title="statement not covered" >is,[e,t,<span class="cstat-no" title="statement not covered" ></span>i].conc<span class="fstat-no" title="function not covered" >at</span>(n))}}(e[t]);b<span class="cstat-no" title="statement not covered" >reak;default:e[t]=e[e[t]]}return </span>e}</span>([funct<span class="cstat-no" title="statement not covered" >i</span>on(e,t</span>,n){e.e<span class="cstat-no" title="statement not covered" >xports=n(1)},f<span class="cstat-no" title="statement not covered" ></span>u</span></span></span>nction(e,</span>t,<span class="fstat-no" title="function not covered" >n)</span>{"use strict";<span class="cstat-no" title="statement not covered" >var r=n(2),i=n(8</span>9<span class="fstat-no" title="function not covered" >),</span>o=new i,a=n(137)(r,{auth:o}),s=n(<span class="cstat-no" title="statement not covered" >150),</span>u=<span class="cstat-no" title="statement not covered" >new s(</span>a)<span class="cstat-no" title="statement not covered" >,l=n(152</span>),<span class="cstat-no" title="statement not covered" >c=n(158)(r),f=n(164</span>),<span class="cstat-no" title="statement not covered" >h={acl:</span>f,<span class="cstat-no" title="statement not covered" >AppRegist</span>ra<span class="cstat-no" title="statement not covered" >tion:n(</span>15<span class="cstat-no" title="statement not covered" >5),appRegi</span>st<span class="cstat-no" title="statement not covered" >ry:n(15</span>4)<span class="cstat-no" title="statement not covered" >,auth:o,tls:u,config:n(168),currentUser:o.currentUser.bind(o),identity:n(152),login:o.login.bind(o),logout:o.logout.bind(o),meta:n(169),rdflib:r,signup:u.signup.bind(u),status:n(171),typeRegistry:n(162),vocab:c,web:a};h.clearPermissions=function(e){return f.clearPer<span class="cstat-no" title="statement not covered" ></span>missions(e,a)},h.di<span class="fstat-no" title="function not covered" >sc</span>overWebID=<span class="cstat-no" title="statement not covered" >function(e){return l.discoverWeb</span>ID(e,a,c)},h.getP<span class="fstat-no" title="function not covered" >er</span>missions=f<span class="cstat-no" title="statement not covered" >unction(e){return f.getPermissi</span>ons(e,a,r)},h.getP<span class="fstat-no" title="function not covered" >ro</span>file=funct<span class="cstat-no" title="statement not covered" >ion(e,t){return l.getProfile(e,t</span>,a,r)},e.expor<span class="fstat-no" title="function not covered" >ts</span>=h},function<span class="cstat-no" title="statement not covered" >(e,t,n){"use strict";var r;r="</span>undefined"!=ty</span>p<span class="fstat-no" title="function not covered" >eo</span>f $rdf?$rdf:"undefined"!=typeof t<span class="cstat-no" title="statement not covered" >abulator?tabulator.rdf:n(3),e.exports=r},function(e,t,n){"use strict";function r(e){return e&amp;&amp;</span>e<span class="fstat-no" title="function not covered" >._</span>_esModule?e:{default:e}}var i=n(4),o<span class="fstat-no" title="function not covered" >=r</span>(i)<span class="cstat-no" title="statement not covered" >,a={BlankNode:n(12),Collection:n(11),c</span>onvert<span class="cstat-no" title="statement not covered" >:n(22</span>),<span class="cstat-no" title="statement not covered" >DataF</span>ac<span class="cstat-no" title="statement not covered" >tory:n(75),Empty:n(83),Fetcher:n(77),Formula:n(20),IndexedFormula:o.default,jsonParser:n(84),Literal:n(13),log:n(15),N3Parser:n(78),NamedNode:n(8),Namespace:n(73),Node:n(10),parse:n(79),Query:n(74).Query,queryToSPARQL:n(85),RDFaProcessor:n(80),RDFParser:n(81),serialize:n(21),Serializer:n(70),SPARQLToQuery:n(86),sparqlUpdateParser:n(82),Statement:n(71),term:n(10).fromValue,UpdateManager:n(87),UpdatesSocket:n(88).UpdatesSocket,UpdatesVia:n(88).UpdatesVia,uri:n(7),Util:n(5),Variable:n(72)};a.NextId=a.BlankNode.nextId,a.fromNT=a.Formula.prototyp<span class="cstat-no" title="statement not covered" ></span>e.fromNT,a.fetcher=a.DataFactory.fetcher,a.graph=a.DataFactory.graph,a.lit=a.DataFactory.lit,a.st=a.DataFactory.st,a.sym=a.DataFactory.namedNode,a.variable=a.DataFactory.variable,a.blankNode=a.DataFactory.blankNode,a.defaultGraph=a.DataFactory.defaultGraph,a.literal=a.DataFactory.literal,a.namedNode=a.DataFactory.namedNode,a.quad=a.DataFactory.quad,a.triple=a.DataFactory.triple,e.exports=a},function(e,t,n){"use strict";function r(e,t){if(!(e ins</span>t<span class="fstat-no" title="function not covered" >an</span>ceof t))throw new TypeError("Cannot <span class="fstat-no" title="function not covered" >ca</span>ll a <span class="cstat-no" title="statement not covered" >class as a function")<span class="cstat-no" title="statement not covered" >}function i(e,t){if(!e)throw new ReferenceError("this hasn</span></span>'t been i<span class="fstat-no" title="function not covered" >ni</span>tiali<span class="cstat-no" title="statement not covered" >sed - <span class="cstat-no" title="statement not covered" >super() hasn't been called");return!t||"object"!=typeof t&amp;&amp;"function"!=typeof t?e:t}fu<span class="cstat-no" title="statement not covered" >n</span></span>ction o(e,t){if("function"!=typeof t&amp;&amp;null!==t)throw ne</span>w TypeErr<span class="fstat-no" title="function not covered" >or</span>("Sup<span class="cstat-no" title="statement not covered" >er expression must either be null <span class="cstat-no" title="statement not covered" >or a function, not "+typeof t);e.prototype=Object.create(t&amp;&amp;t.prototype,{constructor:{val<span class="cstat-no" title="statement not covered" >u</span></span>e:e,enumerable:!1,writable:!0,configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function a(e,t,n,r){var i=e.any(t,n,void 0);return!!i&amp;&amp;(e.e</span>quate(i,r<span class="fstat-no" title="function not covered" >),</span>!0)}function s(<span class="cstat-no" title="statement not covered" >e,t,n,r){var i=e.a<span class="cstat-no" title="statement not covered" ></span>ny(void 0,n,r);return!!i&amp;&amp;(e.eq</span>uate(i,t)<span class="fstat-no" title="function not covered" >,!</span>0)}function u(e<span class="cstat-no" title="statement not covered" >,t,n,r,i){e.typeCa<span class="cstat-no" title="statement not covered" ></span>llback&amp;&amp;e.typeCallback(e,r,i);v</span>ar o=e.cl<span class="fstat-no" title="function not covered" >as</span>sActions[r.<span class="cstat-no" title="statement not covered" >hashString()],a=!1;if(o)for(var s=0;s&lt;o</span>.leng<span class="cstat-no" title="statement not covered" >th;s++)a=a||o[s](e,t,n,r,i);ret</span>ur<span class="cstat-no" title="statement not covered" >n a<span class="cstat-no" title="statement not covered" ></span>}Obje<span class="cstat-no" title="statement not covered" >ct.defineProperty(t,"__esMo<span class="cstat-no" title="statement not covered" >dule",{value:!0});var<span class="cstat-no" title="statement not covered" > </span></span></span>l=functio<span class="cstat-no" title="statement not covered" ></span>n(){function e(e,t){for(var n=0;n&lt;t.length;n++){va</span>r r=t<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >[n</span>];r.enumerable=r.e<span class="fstat-no" title="function not covered" >nu</span>merab<span class="cstat-no" title="statement not covered" >le||!1,r.configurable=!0,"value"in<span class="cstat-no" title="statement not covered" > r&amp;&amp;(<span class="cstat-no" title="statement not covered" ></span>r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}</span>}<span class="cstat-no" title="statement not covered" ></span>(),c=n(<span class="fstat-no" title="function not covered" >5)</span>.ArrayIndexOf,<span class="cstat-no" title="statement not covered" >f=n(20),h=n(5).RDFArrayRemove,d=n(71),p=</span>n(</span>10)</span>,v<span class="cstat-no" title="statement not covered" >=n(72),g="http://w</span>ww<span class="cstat-no" title="statement not covered" >.w3.or</span>g/<span class="cstat-no" title="statement not covered" >2002/07/owl#",y=func</span>ti<span class="cstat-no" title="statement not covered" >on(e){</span>fu<span class="cstat-no" title="statement not covered" >nction</span> t<span class="cstat-no" title="statement not covered" >(e){r(</span>th<span class="cstat-no" title="statement not covered" >is,t);var n=i(this,Object.getProt</span>ot<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >yp</span>eOf(t).call(this));<span class="fstat-no" title="function not covered" >re</span>tur<span class="cstat-no" title="statement not covered" >n n.propert</span>yActi<span class="cstat-no" title="statement not covered" >ons=[],n.classActions=[],n.redirections=[],n<span class="cstat-no" title="statement not covered" ></span>.aliases=[],n.HTTPRedirects=[],n.subjectIndex=[],n.predicateIndex=[],n.objectIndex=[],n.whyIndex=[],n.index=[n.subjectIndex,n.predicateIndex,n.objectIndex,n.whyIndex],n.namespaces={},n.features=e||["sameAs","InverseFunctionalProperty","FunctionalProperty"],n.initPropertyActions(n.features),n}return o(t,e),l(t,[{key:"substitute",value:function(e){var n=this.<span class="cstat-no" title="statement not covered" ></span>statements.map(function(t){return t.substitute(e)}),r=new t;return r.add(n),r<span class="fstat-no" title="function not covered" >}},{ke</span>y:"applyP<span class="cstat-no" title="statement not covered" >atch",value:function<span class="fstat-no" title="function not covered" >(e</span>,t,r){var <span class="cstat-no" title="statement not covered" >i,o=n(74).Query,a=this,s</span>=n</span>ul<span class="cstat-no" title="statement not covered" >l,u=func<span class="cstat-no" title="statement not covered" ></span>tion(n){if(e.delete</span>){i=e.delete,s&amp;&amp;(i=i.substitute(s)),i=i.statements;var o=[],<span class="fstat-no" title="function not covered" >u=i.ma</span>p(function(e){v<span class="cstat-no" title="statement not covered" >ar n=a.state</span>me<span class="cstat-no" title="statement not covered" >ntsMa</span>tc<span class="cstat-no" title="statement not covered" >hing(</span>e.<span class="cstat-no" title="statement not covered" >subject,e.predicate,e.object,t);re<span class="fstat-no" title="function not covered" >tu</span>rn <span class="cstat-no" title="statement not covered" >0===n.length?<span class="cstat-no" title="statement not covered" >(o.push(e),null):n[0]});if(o.length)return r("Coul</span>d not<span class="cstat-no" title="statement not covered" > fi</span>nd<span class="cstat-no" title="statement not covered" > to de<span class="fstat-no" title="function not covered" >le</span>te: "+o.join("\n<span class="cstat-no" title="statement not covered" > or "));u.map(function(e){a.remove(e)})}e.insert&amp;&amp;(i=e.<span class="cstat-no" title="statement not covered" ></span>insert,s&amp;&amp;(i=i.substitute(s)),i=i.statement</span>s,<span class="cstat-no" title="statement not covered" ></span>i.map(functi<span class="cstat-no" title="statement not covered" >on(e){e.why=t,a.add(e.subject,e.predicate,e.object,e.why<span class="cstat-no" title="statement not covered" >)</span></span>})),n<span class="fstat-no" title="function not covered" >()</span>};if(e.whe<span class="cstat-no" title="statement not covered" >re){var l=new</span> o(<span class="cstat-no" title="statement not covered" ></span>"</span>patch");l.pat=e.where,l.pat.statements.map(function(e){e.why=t});<span class="fstat-no" title="function not covered" >va</span>r c=[];a.q<span class="cstat-no" title="statement not covered" >uery(l,function(e){c.push(e)},a.fetcher,function(){re</span>turn 0==</span>=<span class="cstat-no" title="statement not covered" ></span>c.length?r("No mat<span class="cstat-no" title="statement not covered" >ch found to be <span class="cstat-no" title="statement not covered" ></span>patched:"+e.where):c.length&gt;1?r("Pa<span class="fstat-no" title="function not covered" >tc</span>h ambiguou<span class="cstat-no" title="statement not covered" >s. No pat</span>ch </span>done.<span class="cstat-no" title="statement not covered" >"):<span class="cstat-no" title="statement not covered" ></span>(s=c[0],vo<span class="fstat-no" title="function not covered" >id</span> u(r))})}e<span class="cstat-no" title="statement not covered" >lse u(r)}},</span>{key:"decla<span class="fstat-no" title="function not covered" >re</span>Existenti<span class="cstat-no" title="statement not covered" >al",value:function(e){return this._existentialVariables||(this._existentialVariables=[]),this._existentialVariables.push(e),e}},{ke</span>y:"</span>initP<span class="cstat-no" title="statement not covered" >ropert</span></span>yActions",value:function(e){this.propertyActions["&lt;http://www.w3.org<span class="fstat-no" title="function not covered" >/1999/</span>02/<span class="cstat-no" title="statement not covered" >22-rdf-syntax-ns#type&gt;"]=[u],c(e,"sameAs")&gt;=0&amp;&amp;(this.propertyActions["&lt;http://www.w3.org/2002/07/owl#same</span>As&gt;"]=[function(e,t,n,r,i){return e.equate(t,r),!0}]),c(e,"InverseFun<span class="fstat-no" title="function not covered" >ctiona</span>lPr<span class="cstat-no" title="statement not covered" >operty")&gt;=0&amp;&amp;(this.classActions["&lt;"+g+"InverseFunctionalProperty&gt;"]=[function(e,t,n,r,i){return e.newPropertyAction(t,s)}]),c(e,"FunctionalProperty")&gt;=0&amp;&amp;(this.c<span class="fstat-no" title="function not covered" >la</span>ssActions["&lt;"+g+"F<span class="cstat-no" title="statement not covered" >unctionalProperty&gt;"]=[fun</span>ction(e,t,n,r,i){return e.newPropertyAction(t,a)}])}},{key:"add",value:function(e,n,r,i){var o;i<span class="fstat-no" title="function not covered" >f(</span>1===arguments.leng<span class="cstat-no" title="statement not covered" >th){if(e instanceof Array)for(o=0</span>;o&lt;e.length;o++)this.add(e[o]);else e instanceof d?this.add(e.subject,e.predicate,<span class="fstat-no" title="function not covered" >e.</span>object,e.why):e in<span class="cstat-no" title="statement not covered" >stanceof t&amp;&amp;this.add(e.statements</span>);re</span>turn this}var a,s;i||(i=this.fetcher?this.fetcher.app<span class="fstat-no" title="function not covered" >Node:t</span>his.sym("chrome<span class="cstat-no" title="statement not covered" >:theSession")),e=p.fromVa<span class="cstat-no" title="statement not covered" >lue(e),n=p.fromValue(n<span class="cstat-no" title="statement not covered" >),r=p.fromValue(r),i=p.<span class="cstat-no" title="statement not covered" >fromValue(i),thi</span></span>s.pr<span class="cstat-no" title="statement not covered" >edicateCallback&amp;&amp;this.predicateCallback(this,n,i);var u=this.canon(n).hashString();a=this.propertyAct<span class="cstat-no" title="statement not covered" >i</span></span>ons[u];var l</span>=</span>!1;if(a<span class="cstat-no" title="statement not covered" >)for(o=0;o&lt;a.length;o++)l=l||a[o](this,e,n,r,i);if(this.holds(e,n,r,i))return null;var c=[this.canon(e).hashString(),u,this.canon(r).hashString(),this.canon(i).hashString()];for(s=new d(e,n,r,i),o=</span>0;o&lt;4<span class="cstat-no" title="statement not covered" >;o++){var f=this.index[o],h<span class="cstat-no" title="statement not covered" ></span>=c[o];f[h]||(f[h]=[]),f[h].</span>push(<span class="cstat-no" title="statement not covered" >s)}<span class="cstat-no" title="statement not covered" ></span>retur<span class="cstat-no" title="statement not covered" >n this.statements.push(<span class="cstat-no" title="statement not covered" >s),s}},{key:"addAll",val<span class="cstat-no" title="statement not covered" >u</span></span></span>e:function(e){var t=th<span class="cstat-no" title="statement not covered" >is;e.forEach(</span></span>funct<span class="cstat-no" title="statement not covered" >ion(e){t.add(e.subject,e.predicate,e.object,e.graph)})}},{key:"any",value:function(e,<span class="cstat-no" title="statement not covered" ></span>t,n,r){var i=this.anyStatementMatching(e<span class="cstat-no" title="statement not covered" >,t,n,r);if(nul</span>l!<span class="cstat-no" title="statement not covered" >=i)re<span class="cstat-no" title="statement not covered" ></span>turn null==e?i.subject:null==t<span class="cstat-no" title="statement not covered" ></span>?</span>i.predicate:null==n?i.object:void</span> 0}},{key:"anyValue",value:function(e,t,n,r){var i=this.<span class="fstat-no" title="function not covered" >any(e,</span>t,n,r);re<span class="cstat-no" title="statement not covered" >turn <span class="cstat-no" title="statement not covered" ></span>i?i.value:<span class="fstat-no" title="function not covered" >vo</span>id 0}},{ke<span class="cstat-no" title="statement not covered" >y:"anyStatementMatching",value:function(e,t,n,r</span>){v</span>ar i=this.statementsMatching(e,t,n,r,!0);if(i&amp;&amp;0!==i.<span class="fstat-no" title="function not covered" >length</span>)return i[0]}},<span class="cstat-no" title="statement not covered" >{key:"canon",value:function(e){if(!<span class="cstat-no" title="statement not covered" ></span>e)return e;<span class="cstat-no" title="statement not covered" >var t=this.redirections[e.hashString()];return t?t:e}},{key:"check",va</span></span>lue:function(){this.checkStatementList(this.statements);fo<span class="fstat-no" title="function not covered" >r(var </span>e=0;e&lt;4;e++){va<span class="cstat-no" title="statement not covered" >r t=this.index[e];<span class="cstat-no" title="statement not covered" ></span>for(var n in t)t.hasOwnPr</span>operty(n)&amp;&amp;this.checkStatementList(t[n],e)}}},{key:"checkStatementList<span class="fstat-no" title="function not covered" >",valu</span>e:function(e,t)<span class="cstat-no" title="statement not covered" >{for(var n,r=["subject","predicate",<span class="cstat-no" title="statement not covered" ></span>"object","why"],i="<span class="cstat-no" title="statement not covered" > found in "+r</span></span>[t]+" index.",o=0;o&lt;e.length;o++){n=e[o];for(var a=[n.s<span class="fstat-no" title="function not covered" >ubject</span>,n.<span class="cstat-no" title="statement not covered" >predic<span class="cstat-no" title="statement not covered" >ate,n.obje</span></span>ct,n.<span class="cstat-no" title="statement not covered" >why],s=function(e,t){for(var n=0;n<span class="cstat-no" title="statement not covered" ></span>&lt;e.length;n++)</span>if(e[n].subject.sameTerm(t.subject)&amp;&amp;e[n].predicate.sam<span class="fstat-no" title="function not covered" >eTerm(</span>t.<span class="cstat-no" title="statement not covered" >predicate)&amp;&amp;e[n].object.sameTerm(t.object<span class="cstat-no" title="statement not covered" >)</span>&amp;&amp;e[n].why.sameTerm(t.why)<span class="cstat-no" title="statement not covered" >)return!0},u=0<span class="cstat-no" title="statement not covered" ></span>;u&lt;4;u++){var l<span class="cstat-no" title="statement not covered" >=this.canon(a[u]),c=l.hashString();this.index[u][c]&amp;&amp;!</span></span>s</span>(this.index[u][c],n)}if(!s(this.statements,n))throw new Error("State<span class="fstat-no" title="function not covered" >ment l</span>ist d<span class="cstat-no" title="statement not covered" >oes not statement "+n+"@"+n.why+i)}}},{key:"close",value:function(){return this}},{key:"copyTo",value<span class="cstat-no" title="statement not covered" >:functi<span class="cstat-no" title="statement not covered" >o</span>n(e,t,n){n||(n=[]);var r=this.statementsMatching(e);c(n,"two-direction")!==-1&amp;&amp;r.concat(this.statementsMatching(void 0,void 0,e));for(var i=0;i&lt;r.length;i++){var o=r[i];switch(o.object.termType){case"NamedNode":this.add(t,o.predicate,o.object);break;case"<span class="cstat-no" title="statement not covered" >Literal":case"Bla</span>nk<span class="cstat-no" title="statement not covered" >Node":case"coll<span class="cstat-no" title="statement not covered" ></span>ection":this.add(t,o.predicate,o.object.co<span class="cstat-no" title="statement not covered" ></span>p</span>y(this))}c(n,"delete")!=<span class="cstat-no" title="statement not covered" >=-1&amp;&amp;this.remove(o)}}},{key:"equate",value:function(e,t){e=this.canon</span></span>(</span>e),t=this.canon(t);var n=e.compareTerm(t);return!n||(n&lt;<span class="fstat-no" title="function not covered" >0?this</span>.r<span class="cstat-no" title="statement not covered" >eplaceWith(t,</span>e):this.replaceWith(e,t))}},{key:"formula",value:functio<span class="fstat-no" title="function not covered" >n(e){r</span>eturn n<span class="cstat-no" title="statement not covered" >ew t(e)}},{</span>key:"<span class="cstat-no" title="statement not covered" >match",value:function(e,t,n<span class="cstat-no" title="statement not covered" ></span>,r){return this.statementsMatching(p.fromValue(e),p.fromValue(t),p.fromValue(n<span class="cstat-no" title="statement not covered" >)</span>,p.fromValue(r))}},{key:"mentions<span class="cstat-no" title="statement not covered" >URI",<span class="cstat-no" title="statement not covered" ></span>value:function(e){var t="&lt;"+e+"&gt;";return!!<span class="cstat-no" title="statement not covered" >this.subjectIndex[t]||!!this.obje<span class="cstat-no" title="statement not covered" >c</span>tIndex</span>[t]||!!this.predicateIndex[t]}},{key:"newExist<span class="cstat-no" title="statement not covered" >ential",value:function(e){if(!e)return this.b<span class="cstat-no" title="statement not covered" ></span>n</span>ode();var t=this.sym(e);return this</span>.</span>declareExistential(t)}},{key:"newPropertyAction",value:f<span class="fstat-no" title="function not covered" >unctio</span>n(e,t<span class="cstat-no" title="statement not covered" >){var n=e.hashString();this.prope</span>rtyAc<span class="cstat-no" title="statement not covered" >tions[n]||(this.p<span class="cstat-no" title="statement not covered" ></span>ropertyActions[n]=[]),this.propertyActions[n].push(t);for(var</span> r=this.statementsMatching(void 0,e,void 0),i=!1,o=0;o&lt;r.<span class="fstat-no" title="function not covered" >length</span>;o+<span class="cstat-no" title="statement not covered" >+)i=i||t(this,r[o</span>].subject,e,r[o].object);return i}},{key:"newUniversal"<span class="fstat-no" title="function not covered" >,value</span>:function<span class="cstat-no" title="statement not covered" >(e){var t=this.sym(e);return this._universalVariables||(this._universalVariables=[]),this._un</span>iversalVariables.push(t),t}},{key:"variable",value:function(e<span class="fstat-no" title="function not covered" >){retu</span>rn new v(<span class="cstat-no" title="statement not covered" >e)}},{key:<span class="cstat-no" title="statement not covered" ></span>"nextSymbol",value:function(e){for(var t=0;;t++){var n=e.uri+"#n"+t;if(!this.me</span>ntionsURI(n))return this.sym(n)}}},{key:"query",value:function(e<span class="fstat-no" title="function not covered" >,t,r,i</span>){v<span class="cstat-no" title="statement not covered" >ar o=n<span class="cstat-no" title="statement not covered" >(74).indexedFormulaQu</span></span>ery;r<span class="cstat-no" title="statement not covered" >eturn o.call<span class="cstat-no" title="statement not covered" ></span>(this,e,t,r,i)}},{key:"remove",valu</span>e:function(e){if(e instanceof Array){for(var n=0;n&lt;e.length;n++)thi<span class="fstat-no" title="function not covered" >s.remo</span>ve(e[n]);re<span class="cstat-no" title="statement not covered" >turn this}if(e <span class="cstat-no" title="statement not covered" ></span>instanceof t)return this.remove(e.statements);var r=this.statementsMatching(e.subject,<span class="cstat-no" title="statement not covered" >e</span>.predicate,e.object,e.why);if(!r.length)throw new Error("Statement to be r<span class="cstat-no" title="statement not covered" >emoved is not on store: "+e);return this<span class="cstat-no" title="statement not covered" >.</span></span>removeSta</span>tement(r[0]),this}},{key:"removeDocument",value:function(e){fo<span class="fstat-no" title="function not covered" >r(var </span>t=this.st<span class="cstat-no" title="statement not covered" >atementsMatc<span class="cstat-no" title="statement not covered" ></span>hing(void 0,void 0,void 0,e).slice(),n=0;n&lt;t.length;n++)this.removeStatement(t[n]);return this}},{k</span>ey:"removeMany",value:function(e,t,n,r,i){for(var o=this.s<span class="fstat-no" title="function not covered" >tateme</span>nts<span class="cstat-no" title="statement not covered" >Matching(e,t,n,r,</span>!1),a=[],s=0;s&lt;o.length;s++)a.push(o[s]);for(i&amp;&amp;(a=a.slice(0<span class="fstat-no" title="function not covered" >,i)),s</span>=0;<span class="cstat-no" title="statement not covered" >s&lt;a.length;s++)this.remo<span class="cstat-no" title="statement not covered" >ve(a[s])}},{k<span class="cstat-no" title="statement not covered" ></span>ey:"removeMatches",value<span class="cstat-no" title="statement not covered" >:function(e,t,n,r){r</span></span>e</span>turn this.removeStatements(this.statementsMatching(e,t,<span class="fstat-no" title="function not covered" >n,r)),</span>this}},{key:"re<span class="cstat-no" title="statement not covered" >moveStatement",value:funct<span class="cstat-no" title="statement not covered" ></span>ion(e){for(var t=[e.subject,e</span>.predicate,e.object,e.why],n=0;n&lt;4;n++){var r=this.canon<span class="fstat-no" title="function not covered" >(t[n])</span>,i=<span class="cstat-no" title="statement not covered" >r.hashString();this.ind<span class="cstat-no" title="statement not covered" >ex[n][i]&amp;&amp;h(this.index[n][i<span class="cstat-no" title="statement not covered" >],e)}return h(this<span class="cstat-no" title="statement not covered" >.</span></span>statements,e<span class="cstat-no" title="statement not covered" ></span>)</span>,this}},{key:"rem<span class="cstat-no" title="statement not covered" >oveStatements",value:function(e){f</span></span>or(va<span class="cstat-no" title="statement not covered" >r t=0;t&lt;e.length;t++)this.remove(e[t]);return this}},{key:"rep<span class="cstat-no" title="statement not covered" ></span>laceWith",val<span class="cstat-no" title="statement not covered" >ue:function(e,t){for(var n=e.hashString(),r=t.hashString(),i=fu<span class="cstat-no" title="statement not covered" >n</span></span>ction(e){var t=e[n];if(t){var i=e[r];i?</span>e[r]=t.concat(i):e[r]=t,delete e[n]}},o=0;o&lt;4;o++)i(this.index[o<span class="fstat-no" title="function not covered" >]);if(</span>thi<span class="cstat-no" title="statement not covered" >s.redirections[n]=t,e.uri){if(this.aliases[r]||(this.aliases[r]=[]),this.aliases[r].p<span class="cstat-no" title="statement not covered" >ush(e),this.aliases[n])for(<span class="cstat-no" title="statement not covered" >o</span></span>=0;o&lt;this.al</span>iases[n].length;o++)this.redirections[this.aliases[n][o].has<span class="fstat-no" title="function not covered" >hStrin</span>g()]=t,this<span class="cstat-no" title="statement not covered" >.aliases[r].push(this.aliases[n][o]);this.add(t,this.sym("http://www.w<span class="cstat-no" title="statement not covered" >3.org/2007/on<span class="cstat-no" title="statement not covered" >t</span></span>/link#uri"),e.uri),this.fetcher&amp;&amp;this.fetc<span class="cstat-no" title="statement not covered" >her.nowKnownAs(e,t)</span></span>}return i(this.classActions),i(this.propertyActions),!0}},{key:<span class="fstat-no" title="function not covered" >"allAl</span>iases",va<span class="cstat-no" title="statement not covered" >lue:function(e){var t=this.aliases[this.canon(e).hashString()]||[];re</span>turn t.push(this.canon(e)),t}},{key:"sameThings",value:function(e<span class="fstat-no" title="function not covered" >,t){if</span>(e.<span class="cstat-no" title="statement not covered" >sameTerm(t))return!0;var n=this.canon(e);if(!n)return!1;var r=this.c<span class="cstat-no" title="statement not covered" >anon(t);return!!r</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >n.uri===r.uri}}<span class="cstat-no" title="statement not covered" ></span>,{key:"setPrefixForURI",value:function(e,<span class="cstat-no" title="statement not covered" ></span>t</span>){"tab"===e&amp;&amp;this.namespaces.tab|</span>|"ns"!==e.slice(0,2)&amp;&amp;"default"!==e.slice(0,7)&amp;&amp;(this.namespaces[e<span class="fstat-no" title="function not covered" >]=t)}}</span>,{k<span class="cstat-no" title="statement not covered" >ey:"statementsMatching",val<span class="cstat-no" title="statement not covered" >ue:function(e,t,n,<span class="cstat-no" title="statement not covered" >r</span></span>,i){var o,a,</span>s=[e,t,n,r],u=[],l=[],c=[],f=[];for(o=0;o&lt;4;o++)u[o]=this.can<span class="fstat-no" title="function not covered" >on(p.f</span>romVa<span class="cstat-no" title="statement not covered" >lue(s[o])),u[o]?(f.push(o),l[o]=u[o].hashString()):c.push(o);if(0===f.length)return this.statements;if(1===f.length)return o=f[0],a=this.index[o][l[o]],a&amp;&amp;i&amp;&amp;a.leng<span class="cstat-no" title="statement not covered" >th&gt;1&amp;&amp;(a=a.slice(<span class="cstat-no" title="statement not covered" >0</span></span>,1)),a=a||[];var h,d,v=1e10;for(<span class="cstat-no" title="statement not covered" >d=0;d&lt;f.length;d++){if(o=f[d],a=this.index[o][l[o]],!a)return[];a.length&lt;v&amp;&amp;(v=a.<span class="cstat-no" title="statement not covered" >length,h=d)}for(var g=f[h],y=this.ind<span class="cstat-no" title="statement not covered" >ex[g][l[g]],m=f.slice(0,h).concat(f.slice(h+1)),b=[],w=["subject","predicate","object","why"],<span class="cstat-no" title="statement not covered" >x</span></span></span>=0;x&lt;y.length;x++){var _=y[x];for(d=0;d&lt;m.length;d++)if(o=m[d],!this.canon(_[w[o]]).sameTerm(u[o])){_=null;br<span class="cstat-no" title="statement not covered" ></span>e</span>ak}if(null!=_&amp;&amp;(b.push(_),i))break}return b}},{key:"uri</span>s",value:function(e){var t=this.canon(e),n=this.aliases[t.ha<span class="fstat-no" title="function not covered" >shStri</span>ng()];if(<span class="cstat-no" title="statement not covered" >!t.uri)return[];var r=[t.uri];if(n)for(var i=<span class="cstat-no" title="statement not covered" ></span>0;i&lt;n.length;i++)r.push(n[i].uri</span>);return r}},{key:"length",get:function(){return this.statem<span class="fstat-no" title="function not covered" >ents.l</span>ength<span class="cstat-no" title="statement not covered" >}}]),t}(f);t.defa<span class="cstat-no" title="statement not covered" >ult=y,y.ha</span></span>ndleR<span class="cstat-no" title="statement not covered" >DFType=u},func<span class="cstat-no" title="statement not covered" ></span>tion(e<span class="cstat-no" title="statement not covered" >,t,n){(fun</span></span>ction<span class="cstat-no" title="statement not covered" >(e){"use stric<span class="cstat-no" title="statement not covered" ></span>t";function t(e,t,n){var r</span>=null;if("undefined"!=typeof e.fetcher&amp;&amp;(r=e.fetcher,"NamedNode"=<span class="fstat-no" title="function not covered" >==t.te</span>rmTyp<span class="cstat-no" title="statement not covered" >e)){var i,o=b(t.uri);if(t.uri.indexOf("#")&lt;0){if(v(t.uri,"http://dbpedia.org/resource/Category:"))retur</span>n;v(t.uri,"http://purl.org/dc/elements/1.1/")||v(t.uri,"http://purl.<span class="fstat-no" title="function not covered" >org/dc</span>/terms/")?i="http://d<span class="cstat-no" title="statement not covered" >ublincore.</span>or<span class="cstat-no" title="statement not covered" >g/2</span>00<span class="cstat-no" title="statement not covered" >5/0</span>6/<span class="cstat-no" title="statement not covered" >13/</span>dc<span class="cstat-no" title="statement not covered" >q":<span class="cstat-no" title="statement not covered" ></span>v(t.uri,"http://<span class="cstat-no" title="statement not covered" >xmlns.com/wot/0.1/")?i="http://xmlns.com/wot/0.1/index.rdf":v(t.uri,"http://web.resou<span class="cstat-no" title="statement not covered" >r</span></span>ce.org/cc/")&amp;&amp;(<span class="cstat-no" title="statement not covered" >i="http://web.resource.<span class="cstat-no" title="statement not covered" >o</span></span>rg/cc/schema.rd<span class="cstat-no" title="statement not covered" >f")}i&amp;&amp;(o=i),r&amp;&amp;"unrequested"!==r.getState(o)||(i&amp;&amp;w.warn("Assuming server still</span></span> broken, <span class="cstat-no" title="statement not covered" >fakin<span class="cstat-no" title="statement not covered" ></span>g redirect of &lt;"+t.uri+"<span class="cstat-no" title="statement not covered" >&gt; to &lt;"+o+"&gt;"),r.requestURI(o,n))}}<span class="cstat-no" title="statement not covered" >function <span class="cstat-no" title="statement not covered" >r</span></span>(e,t,n){n||(n=0);var r=e.leng<span class="cstat-no" title="statement not covered" ></span>t</span>h;for(n&lt;0&amp;&amp;(n=r+n);n&lt;r;n++)if(e[n]===t)return n;return-1}function i(e,t){e.callbacks={};for(var n=t.length-1;n&gt;=0;n--)e.callbacks[t[n]]=[];e.add<span class="cstat-no" title="statement not covered" >Hook=<span class="cstat-no" title="statement not covered" ></span>function(t){e.callbacks<span class="cstat-no" title="statement not covered" >[t]||(e.callbacks[t]=[])},e.addCallback=functio<span class="cstat-no" title="statement not covered" >n(t,n){<span class="cstat-no" title="statement not covered" >e</span>.callb<span class="cstat-no" title="statement not covered" ></span>a</span></span>cks[t].push(n)},e.removeC<span class="cstat-no" title="statement not covered" >allback<span class="cstat-no" title="statement not covered" ></span></span>=</span>function(</span>t,n){for(var r=0;r&lt;e.callbacks[t].length;r++)if(e.call<span class="fstat-no" title="function not covered" >backs[</span>t][r].nam<span class="cstat-no" title="statement not covered" >e===n)return e</span>.c<span class="cstat-no" title="statement not covered" >allbacks[t].splice(r,1),!0;re<span class="cstat-no" title="statement not covered" ></span>turn!1},e.<span class="cstat-no" title="statement not covered" >insertCall</span></span>back=<span class="cstat-no" title="statement not covered" >function<span class="cstat-no" title="statement not covered" ></span>(t,n)<span class="cstat-no" title="statement not covered" >{e.callbacks[t].unshift(n)}<span class="cstat-no" title="statement not covered" >,e.fireCallbacks=<span class="cstat-no" title="statement not covered" >f</span></span></span>unction(t</span>,n){var r,i=[],o=[],a=e.callbacks[t].length;for(r=a-1;<span class="fstat-no" title="function not covered" >r&gt;=0</span>;r<span class="cstat-no" title="statement not covered" >--)e.callbacks[t][r].apply(e,n)</span>&amp;&amp;i.pus</span>h(e.<span class="cstat-no" title="statement not covered" ></span>callbacks[t][r]);for(r=i.length</span>-<span class="fstat-no" title="function not covered" >1;</span>r&gt;=0;r--)o.pus<span class="cstat-no" title="statement not covered" >h<span class="fstat-no" title="function not covered" >(i</span>[r]);for(r=a;r&lt;e.callbacks[t].le<span class="fstat-no" title="function not covered" >ng</span>th;r++)o.push<span class="cstat-no" title="statement not covered" >(e.ca<span class="cstat-no" title="statement not covered" ></span>llbacks[t][r]);e.callbacks[t]=o}}function o(){return tabulator&amp;&amp;tabulator.isExtens<span class="cstat-no" title="statement not covered" >ion?Compo<span class="cstat-no" title="statement not covered" ></span>nents.classes["@mozilla.o<span class="cstat-no" title="statement not covered" >rg/xmlextras/domparser;1"].getService(Components.int<span class="cstat-no" title="statement not covered" >erfaces<span class="cstat-no" title="statement not covered" >.</span></span>nsIDOMParser):window.DOMParser?new DOMParser:!!window.ActiveXObject&amp;&amp;new ActiveXObject("Microsoft.XMLDOM")}function a(e,t){t=t||{};var n=[];"selfClosing"in t&amp;&amp;t.selfClosing.split(" ").forEach(function(e){n[e]=!0});var r=[];return"skipAttributes"in t&amp;&amp;t.skipAttributes.split(" ").forE<span class="cstat-no" title="statement not covered" ></span>a</span>ch(function(e){r[e]=!0}),s(e,t,n,r)}function s(e,t,n,r){var i,o="",a=[!1];if("undefined"==typeof e.nodeType)return o;if(1===e.nodeType){if(e.hasAttr</span>i</span>bute("cla<span class="fstat-no" title="function not covered" >ss</span>")&amp;&amp;"cl<span class="cstat-no" title="statement not covered" >assWithChi</span>ldTex<span class="cstat-no" title="statement not covered" >t"in t&amp;&amp;e<span class="cstat-no" title="statement not covered" ></span>.matches(t.classWithChild<span class="cstat-no" title="statement not covered" >Text.class))<span class="cstat-no" title="statement not covered" >o+=e.quer<span class="cstat-no" title="statement not covered" >y</span></span></span>Selector(</span>t.classWi<span class="fstat-no" title="function not covered" >th</span>Child<span class="cstat-no" title="statement not covered" >Text.element).t<span class="cstat-no" title="statement not covered" >e</span>xtContent;else if(!("skipNode<span class="cstat-no" title="statement not covered" >WithClass"in t&amp;&amp;e.mat<span class="cstat-no" title="statement not covered" >c</span></span>hes("."+t<span class="fstat-no" title="function not covered" >.s</span>kipNodeWit<span class="cstat-no" title="statement not covered" >hClass))){var u=e.nodeName.toLowerCas</span>e();o+="&lt;"+u;va<span class="fstat-no" title="function not covered" >r </span>l=[];for(i=e<span class="cstat-no" title="statement not covered" >.attributes.length-1;i&gt;=</span>0;i--){var c=e.att<span class="fstat-no" title="function not covered" >ri</span>butes[i];if(<span class="cstat-no" title="statement not covered" >!(r.length&gt;0&amp;&amp;r[c.name]||/^\d+$/.test(c.<span class="cstat-no" title="statement not covered" >name))){if("class"===c.name&amp;&amp;"<span class="cstat-no" title="statement not covered" >replaceClassItemWith"in t&amp;&amp;c.value.sp<span class="cstat-no" title="statement not covered" >l</span></span></span>it(" ").i</span>ndexOf(t.replaceCl<span class="fstat-no" title="function not covered" >as</span>sItemWith.so<span class="cstat-no" title="statement not covered" >urce)&gt;-1){var f=new RegExp(</span>t.replaceClassIte<span class="fstat-no" title="function not covered" >mW</span>ith.source,"g");c.va<span class="cstat-no" title="statement not covered" >lue</span>=c<span class="cstat-no" title="statement not covered" >.va</span>lu<span class="cstat-no" title="statement not covered" >e.replace(f,t.replaceC<span class="cstat-no" title="statement not covered" ></span>lassItemWith.target<span class="cstat-no" title="statement not covered" >).trim()}"class"===c.name&amp;&amp;"skipClassWithValue"in t&amp;&amp;t.s<span class="cstat-no" title="statement not covered" >k</span></span>ipClassWithValue===c.valu<span class="cstat-no" title="statement not covered" >e||l.push(c.n<span class="cstat-no" title="statement not covered" >a</span></span>me+"='"+c.value.replace(/&amp;/g,"&amp;amp;<span class="cstat-no" title="statement not covered" >").replace(/&lt;/g,"&amp;lt;").re<span class="cstat-no" title="statement not covered" >p</span></span>lace(/&gt;/g,"&amp;gt;")</span>.r</span>eplace(/'<span class="fstat-no" title="function not covered" >/g</span>,"<span class="cstat-no" title="statement not covered" >&amp;quot;")+"'")}}if(l.length&gt;0&amp;&amp;("sortAttributes"in t&amp;&amp;t.sortAttributes&amp;&amp;l.sort(function(e,t){return e.toLowerCase().localeCompare(t.toLowerCase())}),o+=" "+l.join(" ")),n[u])o+=" /&gt;";else{for(o+="&gt;",o+="html"===u?"\n  ":"",a.push("style"===u</span>||"script<span class="fstat-no" title="function not covered" >"=</span>==u),<span class="cstat-no" title="statement not covered" >i=0;i&lt;e.c</span>hildN<span class="cstat-no" title="statement not covered" >ode<span class="cstat-no" title="statement not covered" ></span>s.length;i++)o+=s(e.childNodes[i]);a.pop(),o+="body"<span class="fstat-no" title="function not covered" >==</span>=u?"&lt;/"+u+<span class="cstat-no" title="statement not covered" >"&gt;\n":"&lt;/</span>"+u</span>+"&gt;"}<span class="cstat-no" title="statement not covered" >}}e<span class="cstat-no" title="statement not covered" ></span>lse if(8===e.nodeType)o+="&lt;!--"+e.nodeValue+"--&gt;";else if(3===e.<span class="fstat-no" title="function not covered" >no</span>deType||4=<span class="cstat-no" title="statement not covered" >==e.nodeT</span>ype){var h=e.n</span>odeValue.<span class="fstat-no" title="function not covered" >re</span>place(/\n+$/,"");<span class="cstat-no" title="statement not covered" >o+=</span>a[<span class="cstat-no" title="statement not covered" >a.len<span class="cstat-no" title="statement not covered" ></span>gth-1]?h:h.replace(/&amp;/g,"&amp;amp;").r<span class="cstat-no" title="statement not covered" >eplace(/&lt;<span class="cstat-no" title="statement not covered" >/</span></span>g,"&amp;lt;").replace(<span class="cstat-no" title="statement not covered" >/&gt;/g,"&amp;gt;")}else console.log("Warning; Cannot handle serialising nodes of type: "+e.nodeTyp<span class="cstat-no" title="statement not covered" >e),console.log(e);return o}function u(){var e=new Date,t=e.get</span>Year<span class="cstat-no" title="statement not covered" >()+1900,n=e.getMonth()+1,r=e.getDate(),i=e.getUTCHours(),o=e.getUTCMinute<span class="cstat-no" title="statement not covered" >s(),a=e.getSeconds();retu<span class="cstat-no" title="statement not covered" ></span>rn n&lt;10&amp;&amp;(</span>n="0"<span class="cstat-no" title="statement not covered" >+n)<span class="cstat-no" title="statement not covered" ></span>,r&lt;10&amp;&amp;(r="0"+r),i&lt;10&amp;&amp;(i="0"+i),o&lt;10&amp;&amp;(o="0<span class="cstat-no" title="statement not covered" >"+o),a&lt;10&amp;&amp;(a="0<span class="cstat-no" title="statement not covered" ></span>"+a),t+"-"+n+"-"+r+"T"+i+":"+o+":"+a+"Z"}function l<span class="cstat-no" title="statement not covered" >(e){for(var t,n=e.getAllResponseHeaders().split("\n"),r={},i=0;i&lt;n.length;i++)if(n[i].length&gt;0){var o=n[i].split(": "<span class="cstat-no" title="statement not covered" >);"undefined"==typeof o[1]?r[t]+="\n"+o[0]:(t=<span class="cstat-no" title="statement not covered" ></span>o[0].toLowerCase(),r[t]=o[1])}return r}function c(e,t,n){var r=fu<span class="cstat-no" title="statement not covered" ></span>n</span>ction(e){return"BlankNode"===e.termType?null:e},i=function(t){var i=n.statementsMatching(e).map(function(e){return""+r(e.subject)+" "+r(e.predicate)+" "+r(e.object)}).concat(n.statementsMatching(</span>v<span class="cstat-no" title="statement not covered" ></span>o</span>id 0,void 0,e).map(function(e){return""+r(e.subject)+" "+r(e.p<span class="fstat-no" title="function not covered" >re</span>dicate)+" "+<span class="cstat-no" title="statement not covered" >r(e.object)}));return i.sort(),i.join("\n")};return"Bla</span>nkNode"===e.termType||"Blan<span class="cstat-no" title="statement not covered" >kNode"===t</span>.ter<span class="cstat-no" title="statement not covered" >mType?0===e.compareTerm(t)?0:i(e)&gt;i(t)?1:i(e)&lt;i(t)?-1:e.compareTerm(t):e.compareTerm(t)}function f(<span class="cstat-no" title="statement not covered" >e,t,n){var r=c(e.subje<span class="cstat-no" title="statement not covered" >c</span></span>t,t.subject,n);return r?r:(r=c(e.predicate,t.p</span>r</span>e</span></span>dicat<span class="cstat-no" title="statement not covered" >e,n),r?r:c(e.objec<span class="cstat-no" title="statement not covered" >t,t.object,n))}function h(e){</span>var <span class="cstat-no" title="statement not covered" >t=document.createElement("div");t.textCon<span class="cstat-no" title="statement not covered" >tent=e,document.body.appendChil<span class="cstat-no" title="statement not covered" ></span>d(t)}function d(t,r){var i;if(r=r||{},"undefined"!=typeof tabulator&amp;&amp;tabulator.isExten</span>sion)<span class="cstat-no" title="statement not covered" >i=Components.classes["@mozilla.org/xmlextras/domparser;1"].getService(Components.interfaces.<span class="cstat-no" title="statement not covered" >n</span></span></span></span>sIDOMPars</span>er);else{<span class="fstat-no" title="function not covered" >if</span>("undefi<span class="cstat-no" title="statement not covered" >ned"!=typeo</span>f <span class="cstat-no" title="statement not covered" >e&amp;&amp;e&amp;&amp;e.exports){</span>va<span class="cstat-no" title="statement not covered" >r o=n(16).DOMPa</span>rs<span class="cstat-no" title="statement not covered" >er,a=(new o)</span>.p<span class="cstat-no" title="statement not covered" >arseFromString(t</span>,r<span class="cstat-no" title="statement not covered" >.contentType||"app</span>li<span class="cstat-no" title="statement not covered" >cation/xhtml+xm<span class="cstat-no" title="statement not covered" ></span>l");return a}i="undefined"!=typeof window&amp;&amp;window.DOMParser?new window.DOMParser:new o}return i.parseFromString(t,"applicati</span>on/xml")}<span class="fstat-no" title="function not covered" >fu</span>nct<span class="cstat-no" title="statement not covered" >ion p(e,t){for(var n=0;n&lt;e.length;n++)if(e[n].subject.sameTerm(t.subject)&amp;<span class="cstat-no" title="statement not covered" >&amp;e[n].predicate.sameTerm<span class="cstat-no" title="statement not covered" >(t.predicate)&amp;&amp;e[<span class="cstat-no" title="statement not covered" ></span>n].object.sameTerm(t.object)&amp;&amp;e[n].why.sameTerm(t.why))return void e.splice<span class="cstat-no" title="statement not covered" ></span>(</span></span>n,1);thro</span>w new Err<span class="fstat-no" title="function not covered" >or</span>("RDFArrayRem<span class="cstat-no" title="statement not covered" >ove: Arra<span class="fstat-no" title="function not covered" >y </span>did<span class="cstat-no" title="statement not covered" > not contain "+t+" "+t.why)}function v(</span>e</span>,t<span class="cstat-no" title="statement not covered" >){return e.slice(0,t.length)===t}f<span class="fstat-no" title="function not covered" >un</span>ction g(e<span class="cstat-no" title="statement not covered" >,t){for(var n=e.split("%s"),<span class="fstat-no" title="function not covered" >r=</span>"",i=0;i&lt;t<span class="cstat-no" title="statement not covered" >.length;i++)t[i]+="",r+=n[i]+t[i];return r+n.slice(t.lengt</span>h).join()}function y(e){var t=""+e+"\n";if(!e.stack<span class="fstat-no" title="function not covered" >)r</span>eturn t+"N<span class="cstat-no" title="statement not covered" >o stack available.\n";for(var n=e.stack.toString().split("</span>\n"<span class="cstat-no" title="statement not covered" ></span>),r=[],i=0;i&lt;n.length;i++){var</span> <span class="cstat-no" title="statement not covered" ></span>o=n[i];if(o.indexOf("ecmaunit.js")&gt;-1)break;"("==o.charAt(0)&amp;&amp;(o="function"+o);var a=o.split("@");r.push(a)}for(var i=0;i&lt;r.length;i++)t+=" </span> "+r[i][1<span class="fstat-no" title="function not covered" >]+</span>"\n    "+r[i]<span class="cstat-no" title="statement not covered" >[0];return t}function m()<span class="cstat-no" title="statement not covered" ></span>{var t;if("undefined"!=typeof tabulator&amp;&amp;tabulator.isExtension)return Co</span>mponents.<span class="fstat-no" title="function not covered" >cl</span>asses["@m<span class="cstat-no" title="statement not covered" >ozilla.org/xmlextras/xmlhttpre<span class="cstat-no" title="statement not covered" ></span>quest;1"].createInstance().QueryInterface(Comp</span>onents.in<span class="fstat-no" title="function not covered" >te</span>rfaces.nsIX<span class="cstat-no" title="statement not covered" >MLHttpRequest);if("undefined"!=typeof window&amp;&amp;"XMLHttpRequest"in<span class="cstat-no" title="statement not covered" > window)return new(t=window.XMLHttpRequest);if("undefined"!=typeof e&amp;&amp;e&amp;&amp;e.exports)return new(t=n(19).XMLHt</span>tpRe<span class="cstat-no" title="statement not covered" >quest);if(!window.ActiveXObject)return!1;try{r<span class="cstat-no" title="statement not covered" >eturn new Active</span>XO<span class="cstat-no" title="statement not covered" >bject("Msxml2.XMLHTTP")}catch(e){return new ActiveXObject("Microso<span class="cstat-no" title="statement not covered" ></span>ft.XMLHTTP<span class="cstat-no" title="statement not covered" ></span>"</span>)}}var b=n(7).docpart,w=n(15),x=n(8);e.exports.AJAR_handleNewTerm=t,e.exports.<span class="cstat-no" title="statement not covered" ></span>A</span>rrayIndexOf=r,e.exports.callbackify=i,e.export</span>s.dtstamp<span class="fstat-no" title="function not covered" >=u</span>,e.ex<span class="cstat-no" title="statement not covered" >ports.DOMParserFactory=o,e.<span class="cstat-no" title="statement not covered" >exports.domToString=a,e.exports.dumpNode=s,e.exports.getHTTPHeaders=l,e.exports.heavyCompare=c,e.exports.heavyCompareSPO=f,e.exports<span class="cstat-no" title="statement not covered" >.output=h,e.exports.parseX<span class="cstat-no" title="statement not covered" >M</span></span></span>L=d,e.exports.RDFArrayRemove=p,e.exports.stackString=y,e.exports.strin</span>g_startsw<span class="fstat-no" title="function not covered" >it</span>h=v,e<span class="cstat-no" title="statement not covered" >.exports.string={},e.exports.str</span>ing.templ<span class="fstat-no" title="function not covered" >at</span>e=g,e<span class="cstat-no" title="statement not covered" >.exports.uri=n(7),e.exports.XMLHTTPFactory=m,e.e<span class="cstat-no" title="statement not covered" >xports.log=w,e.exports<span class="cstat-no" title="statement not covered" >.</span></span>mediaTypeClass=function(e){return </span>new x("ht<span class="fstat-no" title="function not covered" >tp</span>://www.w3<span class="cstat-no" title="statement not covered" >.org/ns/ia<span class="cstat-no" title="statement not covered" ></span>na/media-typ<span class="cstat-no" title="statement not covered" >es/"+e+"#Resource")}}).call(t,n(6<span class="cstat-no" title="statement not covered" >)</span></span>(e))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.<span class="cstat-no" title="statement not covered" >depre<span class="cstat-no" title="statement not covered" ></span>cate=function(){},e.paths=[],e.<span class="cstat-no" title="statement not covered" >childr<span class="cstat-no" title="statement not covered" >e</span></span>n=[],e.webpackPolyfill=1),e}},funct</span>ion(e<span class="cstat-no" title="statement not covered" >,t,n){"use st<span class="cstat-no" title="statement not covered" ></span>rict";funct<span class="cstat-no" title="statement not covered" ></span>i</span>on r(e){var t;return t=e.i<span class="cstat-no" title="statement not covered" >ndexOf("#"),t&lt;0?e:e.slice(0,t)}fu<span class="cstat-no" title="statement not covered" >n</span></span>ction i(e</span>){return <span class="fstat-no" title="function not covered" >ne</span>w c(r(e.<span class="cstat-no" title="statement not covered" >uri))}function o(e){var t=/[^\/]*\/\/([^\/]*)\//.exec(e)<span class="cstat-no" title="statement not covered" >;return t?t[1]:""}function a(e,t){var n,r,i,o,a,s,u=t.indexOf("#");if(u&gt;0&amp;&amp;(t=t.slice(0,u)),0===e.length)return t;if(0===e.indexOf("#"))return<span class="cstat-no" title="statement not covered" > </span></span>t+e;if(o=e.indexOf(":"),o&gt;=0)return e;if(n=t.indexOf(":"<span class="cstat-no" title="statement not covered" >),0===t.length)return e;if(n&lt;0)return <span class="cstat-no" title="statement not covered" >l</span></span>("Invalid base: "+t+" in join with giv<span class="cstat-no" title="statement not covered" >en: "+e),e;if(r=t.slice(0,+n+1||9e9),<span class="cstat-no" title="statement not covered" >0</span></span>===e.indexOf("//"))retur<span class="cstat-no" title="statement not covered" >n r+e;if(<span class="cstat-no" title="statement not covered" >t</span></span>.in<span class="cstat-no" title="statement not covered" >dexOf("//",n)===n+1){if(i=t.indexOf("/",n+3)</span>,i&lt;0)retu<span class="cstat-no" title="statement not covered" >rn t.length-n-3&gt;0?t+"/"+e:r+e}else if(i=t.index</span>O</span>f("/",<span class="cstat-no" title="statement not covered" >n+1),i&lt;0)retu</span>rn<span class="cstat-no" title="statement not covered" > t.len</span>gt<span class="cstat-no" title="statement not covered" >h-n-1<span class="cstat-no" title="statement not covered" ></span>&gt;0?t+"/"+e:r+e;if(0===e.indexOf("/"))return t.slice(0,i)+e;if(s=t.slice(i),a=s.lastIndexOf("/"),a&lt;0)return r+e;for(a&gt;=0&amp;&amp;a&lt;s.length-1&amp;&amp;(s=s.slice(0,+a+1||9e9)),s+=e;s.match(/[^\/]*\/\.\.\//);)s=s.replace(/[^\/]*\/\.\.\//,"");return s=s.replace(/\.\//g,""),s=s.replace(/\/\.$/,"/"),t.slice(0,i)+s}function s(e){var t;return t=e.indexOf(":"),t&lt;0?null:e.slice(0,t)}function u(e,t){var n,r,i,o,a,s,u,l,c,f,h,d,p,v=new RegExp("^[-_a-zA-Z0-9.]+:(//[^/]*)?/[^/]*$");if(!e)return t;if(e===t)return"";for(r=l=0,a=t.leng<span class="fstat-no" title="function not covered" >th</span>;l&lt;a&amp;&amp;(n=t<span class="cstat-no" title="statement not covered" >[r],n===e[r]);r=++l);if(e.slice(0,r).match(v)&amp;&amp;(i=t.indexOf("//"),i&lt;0&amp;</span>&amp;(</span>i=-2),o=t.indexOf("</span>/<span class="fstat-no" title="function not covered" >",</span>i+2),"/"!==t<span class="cstat-no" title="statement not covered" >[o+1]&amp;&amp;"/"<span class="fstat-no" title="function not covered" >!=</span>=e[o+1]&amp;&amp;t<span class="cstat-no" title="statement not covered" >.slice(0,o)===e.slice(0,o)))return t.sl<span class="fstat-no" title="function not covered" >ic</span>e(o);if("#"===t[r]&amp;&amp;e.length===r)return t.slice(r);for(;r&gt;0&amp;</span>&amp;"</span>/<span class="fstat-no" title="function not covered" >"!</span>==t[r-1];)r--;if(r&lt;3)return t;if(e.i<span class="fstat-no" title="function not covered" >nd</span>exOf("//"<span class="cstat-no" title="statement not covered" >,r-2)&gt;0||t.indexOf("//",r-2)&gt;0)return t;if(e</span>.indexOf(<span class="fstat-no" title="function not covered" >":</span>",r<span class="cstat-no" title="statement not covered" >)&gt;0)return t;for(u=0,h=e</span>.slice(r)<span class="fstat-no" title="function not covered" >,c</span>=0,s=h.le<span class="cstat-no" title="statement not covered" >ngth;c&lt;s;c++)n=h[c],"/"===n&amp;&amp;u+<span class="cstat-no" title="statement not covered" ></span>+;if(0===u&amp;&amp;r&lt;t.le</span>ngth&amp;&amp;"#"<span class="fstat-no" title="function not covered" >==</span>=t[r])return"./"+t.slic<span class="cstat-no" title="statement not covered" >e(r);if(0===u&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>r===t.length)return"./";if(p="",u&gt;0)fo<span class="cstat-no" title="statement not covered" >r(f=1,d=u<span class="cstat-no" title="statement not covered" >;</span></span>d&gt;=1?f&lt;=d:f&gt;=d;d&gt;=1?+<span class="cstat-no" title="statement not covered" >+f:--f)p+="<span class="cstat-no" title="statement not covered" >.</span></span>./";return p+t.slice(r)}<span class="cstat-no" title="statement not covered" >var l=l||<span class="cstat-no" title="statement not covered" >c</span></span>onsole.log;e.exports.docpart=r,e<span class="cstat-no" title="statement not covered" >.exports.<span class="cstat-no" title="statement not covered" >d</span></span>ocumen<span class="cstat-no" title="statement not covered" >t=i,e.exports.hostpart=o,e.exports.join=a,e.exports.proto<span class="cstat-no" title="statement not covered" >c</span></span>ol=s,e.exports.refTo=u;var c=n(8)},function(e<span class="cstat-no" title="statement not covered" >,t,n){"use <span class="cstat-no" title="statement not covered" >s</span></span>trict";function r(e,t){if(!<span class="cstat-no" title="statement not covered" >(e instanceof t))throw new T<span class="cstat-no" title="statement not covered" >ypeError("Cannot call a class as a </span></span>funct<span class="cstat-no" title="statement not covered" >ion")}function i(e,t){if(!e)<span class="cstat-no" title="statement not covered" >throw new ReferenceError("this has<span class="cstat-no" title="statement not covered" >n</span></span></span>'t been initialised -<span class="cstat-no" title="statement not covered" > super() hasn't been c<span class="cstat-no" title="statement not covered" >a</span></span>lled");return!t||"object"!=typeof t&amp;&amp;"fu<span class="cstat-no" title="statement not covered" >nction"!=ty<span class="cstat-no" title="statement not covered" >p</span></span>eof t?e:t}function o(e,t){if("function"!=typeof t&amp;&amp;null!==t)throw new TypeError(<span class="cstat-no" title="statement not covered" >"Super expression must either be <span class="cstat-no" title="statement not covered" >n</span></span>ull or a function, not "+typeof t);e.prototype=Object.create(t&amp;&amp;t.proto</span>type,{con<span class="fstat-no" title="function not covered" >st</span>ructor:{v<span class="cstat-no" title="statement not covered" >alue:e,enumerable:!1,writable:!0,configurable:!</span>0}}),t&amp;&amp;(<span class="fstat-no" title="function not covered" >Ob</span>ject.setPrototypeOf?Object.setPrototy<span class="cstat-no" title="statement not covered" >peOf(e,t):e.__proto__=t)}var a=function(){functio<span class="cstat-no" title="statement not covered" ></span>n e(e,<span class="cstat-no" title="statement not covered" >t){for(va<span class="cstat-no" title="statement not covered" >r</span></span> n=0;n&lt;t<span class="cstat-no" title="statement not covered" >.length;n<span class="cstat-no" title="statement not covered" >+</span></span>+){var r=t[n];r.enumerable=r.enumerable||!1,r.conf<span class="cstat-no" title="statement not covered" >i</span>gurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),<span class="cstat-no" title="statement not covered" >t}}(),s=n(9),u=n(1<span class="cstat-no" title="statement not covered" >0</span></span>),l=function(e){function t(<span class="cstat-no" title="statement not covered" >e){r(this,t);var n<span class="cstat-no" title="statement not covered" >=</span></span>i(this,Object.getProtot<span class="cstat-no" title="statement not covered" >ypeO<span class="cstat-no" title="statement not covered" >f</span></span>(t).ca<span class="cstat-no" title="statement not covered" >ll(this))<span class="cstat-no" title="statement not covered" >;</span></span>return n.termType=t.termType,e.indexOf(":")&lt;0&amp;&amp;<span class="cstat-no" title="statement not covered" >console.l<span class="cstat-no" title="statement not covered" >o</span></span>g('Warning: NamedNode<span class="cstat-no" title="statement not covered" > IRI "'+e<span class="cstat-no" title="statement not covered" >+</span></span>'" must be absolute. Relative URIs will fai<span class="cstat-no" title="statement not covered" >l in future versions<span class="cstat-no" title="statement not covered" >'</span></span>),n.value=e,n}return o(t,e),a(t,<span class="cstat-no" title="statement not covered" >[{key:"dir",value:func<span class="cstat-no" title="statement not covered" >t</span></span>ion(){var e=this.uri.s<span class="cstat-no" title="statement not covered" >plit("#")[0<span class="cstat-no" title="statement not covered" >]</span></span>,n=e.slice(<span class="cstat-no" title="statement not covered" >0,-1).lastIndexOf("/"),r=e.indexOf("//")<span class="cstat-no" title="statement not covered" >;return r<span class="cstat-no" title="statement not covered" >&gt;</span></span></span>=0&amp;&amp;n&lt;r+2||n&lt;0?null:</span>new t(<span class="cstat-no" title="statement not covered" >e.slice(0,n+1))<span class="cstat-no" title="statement not covered" ></span>}},{key:"site",value:function(){var e=this.uri.split("#")[0],n=e.indexOf("//");if(n&lt;0)throw new Error("This URI does no</span>t hav<span class="cstat-no" title="statement not covered" >e a w</span>eb<span class="fstat-no" title="function not covered" > s</span>ite part (origin)");var r=e.indexOf(<span class="fstat-no" title="function not covered" >"/</span>",n+2<span class="cstat-no" title="statement not covered" >);if(r&lt;0)throw new Er<span class="cstat-no" title="statement not covered" >ror("This URI does not have a web site part. (origin)");re</span></span>turn new <span class="fstat-no" title="function not covered" >t(</span>e.sli<span class="cstat-no" title="statement not covered" >ce(0,r<span class="cstat-no" title="statement not covered" >+1))}},{key:"doc",value:function(){return this.uri.indexOf("#")&lt;0?this:new t(this.uri.<span class="cstat-no" title="statement not covered" >s</span></span>plit("#")[0])}},{key:"toString",value:function(){return</span>"&lt;"+this.<span class="fstat-no" title="function not covered" >ur</span>i+"&gt;"<span class="cstat-no" title="statement not covered" >}},{key:"uri",get:function(){retur<span class="cstat-no" title="statement not covered" >n this.value},set:function(e){this.value=e}}],[{key:"fromValue",value:function(e){if("und<span class="cstat-no" title="statement not covered" >e</span></span>fined"==typeof e||null===e)return e;var n=e&amp;&amp;e.termType;return n?e:new t(e)}}]),t}(u);l.termType="NamedNode",l.prototype.classOrder=s.NamedNode,l.prototype.isVar=0,e.exports=l}</span>,funct<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >io</span>n(e,t){"use strict<span class="fstat-no" title="function not covered" >";</span>var n<span class="cstat-no" title="statement not covered" >={Literal:1,Collection:3,Formula:4<span class="cstat-no" title="statement not covered" >,Name<span class="cstat-no" title="statement not covered" ></span>dNode:5,BlankNode:6,Variable:7};e.exports=n},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))</span>t<span class="cstat-no" title="statement not covered" ></span>hrow ne<span class="fstat-no" title="function not covered" >w </span>TypeError("Can<span class="cstat-no" title="statement not covered" >not call a class as a function")}var i=f</span>un</span>cti</span>on<span class="cstat-no" title="statement not covered" >(){fu</span>nc<span class="cstat-no" title="statement not covered" >tion e</span>(e<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >,t</span>){for(var n=0;n&lt;t.l<span class="fstat-no" title="function not covered" >en</span>gth<span class="cstat-no" title="statement not covered" >;n++){var r</span>=t[n]<span class="cstat-no" title="statement not covered" >;r.enumerable=r.enumerable||!1,r.configurabl<span class="cstat-no" title="statement not covered" ></span>e=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),o=function(){function e(){r(this,<span class="cstat-no" title="statement not covered" ></span>e)}return i(e,[{key:"substitute",value:function(e){return console.log(<span class="fstat-no" title="function not covered" >"@@@ n</span>ode subs<span class="cstat-no" title="statement not covered" >titute"+this),this}},{k</span>ey<span class="cstat-no" title="statement not covered" >:"compareTerm",value:function(e</span>){<span class="cstat-no" title="statement not covered" >return this.clas<span class="cstat-no" title="statement not covered" ></span>sOrder&lt;e.classOrder?-1:this.classOrder&gt;e.classOrder?</span>1:this.value&lt;e.value?-1:this.value&gt;e.value?1:0}},{key:<span class="fstat-no" title="function not covered" >"equal</span>s",value<span class="cstat-no" title="statement not covered" >:function(e){return!!e&amp;</span>&amp;(<span class="cstat-no" title="statement not covered" >this.termType===<span class="cstat-no" title="statement not covered" ></span>e.termT<span class="cstat-no" title="statement not covered" >ype&amp;&amp;this.value===e.value)}},{key:"hashString",value:function(){retu</span></span>rn th<span class="cstat-no" title="statement not covered" >is.toCanonical()}},<span class="cstat-no" title="statement not covered" ></span>{key:"s<span class="cstat-no" title="statement not covered" >ameTerm",value:function(e){return this.equals(e)}},{key:"toCanonical<span class="cstat-no" title="statement not covered" >"</span></span>,value:function(){return this</span>.toNT()}},{key:"toNT",value:function(){return this.to<span class="fstat-no" title="function not covered" >String</span>()<span class="cstat-no" title="statement not covered" >}},{key:"toString",value:function(){throw new Error("Node.toString(</span>) is abstract - see the subclasses instead")}}]),e}();e.ex<span class="fstat-no" title="function not covered" >ports=</span>o,<span class="cstat-no" title="statement not covered" >o.fromValue=function(e){</span>var t=n(11),r=n(13);n(8);if("undefined"==typeof e||<span class="fstat-no" title="function not covered" >null</span>==<span class="cstat-no" title="statement not covered" >=e)return e;var i=e</span>&amp;&amp;e.termType;return i?e:Array.isArray(e<span class="fstat-no" title="function not covered" >)?ne</span>w t<span class="cstat-no" title="statement not covered" >(e):r.fromValu</span>e(e)}},function(e,t,n){"use strict";function r(e,t){if(!(e in<span class="fstat-no" title="function not covered" >stance</span>of <span class="cstat-no" title="statement not covered" >t))throw new TypeError("Cannot call<span class="cstat-no" title="statement not covered" > a class a</span></span>s a f<span class="cstat-no" title="statement not covered" >unction")}func<span class="cstat-no" title="statement not covered" ></span>tion i(e,t){if(!e)thr</span>ow new </span>Refe<span class="cstat-no" title="statement not covered" ></span>renceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!</span>=<span class="fstat-no" title="function not covered" >ty</span>peof t&amp;&amp;"function"!=typeof t?e:<span class="cstat-no" title="statement not covered" >t}function o(e,t){if("function"!=typeof t&amp;&amp;null!==t)throw new TypeErro<span class="cstat-no" title="statement not covered" ></span>r("Super expr</span>e<span class="fstat-no" title="function not covered" >ss</span>ion must either be null or a functio<span class="fstat-no" title="function not covered" >n,</span> not <span class="cstat-no" title="statement not covered" >"+typeof t);e.prototy<span class="cstat-no" title="statement not covered" >pe=Object.create(t&amp;&amp;t.prototype,{constructor:{value:e,enum</span></span>erable<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >:!</span>1,writable:!0,conf<span class="fstat-no" title="function not covered" >ig</span>urabl<span class="cstat-no" title="statement not covered" >e:!0}}),t&amp;&amp;(Object.setPrototypeOf?<span class="cstat-no" title="statement not covered" >Objec<span class="cstat-no" title="statement not covered" ></span>t.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.</span>e<span class="cstat-no" title="statement not covered" ></span>numerab<span class="fstat-no" title="function not covered" >le</span>=r.enumerable|<span class="cstat-no" title="statement not covered" >|!1,r.configurable=!0,"value"in r&amp;&amp;(r.wr</span>it</span>abl</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >!0</span>),Object.definePro<span class="fstat-no" title="function not covered" >pe</span>rt<span class="cstat-no" title="statement not covered" >y(e,r.key,r<span class="cstat-no" title="statement not covered" ></span>)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s<span class="fstat-no" title="function not covered" >=n(12)</span>,u=<span class="cstat-no" title="statement not covered" >n(9),l=n(10),c=function(e){function t(e){r(this,t);va</span>r n=i(this,Object.getPrototypeOf(t).call(this));return n.term<span class="fstat-no" title="function not covered" >Type=t</span>.te<span class="cstat-no" title="statement not covered" >rmType,n.id=s.nextId++,n.elements=[],n.closed=!1,e&amp;&amp;e.length&gt;0&amp;&amp;e.forEach(function(e){n.elements.push(l.fromValue(e)</span>)}),n}return o(t,e),a(t,[{key:"append",value:function(e)<span class="fstat-no" title="function not covered" >{retur</span>n t<span class="cstat-no" title="statement not covered" >his.elements.push(e)}},{key:"close",value:function(){return t</span>his.closed=!0,this.closed}},{key:"shift",value:function(){re<span class="fstat-no" title="function not covered" >turn t</span>hi<span class="cstat-no" title="statement not covered" >s.elements.shift()}},{key:"</span>substitute",value:function(e){var n=this.elements.map(func<span class="fstat-no" title="function not covered" >tion(t</span>){t<span class="cstat-no" title="statement not covered" >.substitute(e)});return</span> new t(n)}},{key:"toNT",value:function(){return s.NTAnonymous<span class="fstat-no" title="function not covered" >NodePr</span>ef<span class="cstat-no" title="statement not covered" >ix+this.id}},{key:"t</span>oString",value:function(){return"("+this.elements.join<span class="fstat-no" title="function not covered" >(" ")+</span>")<span class="cstat-no" title="statement not covered" >"}},{key:"unshift",value</span>:function(e){return this.elements.unshift(e)}}]),t}(l);c.t<span class="fstat-no" title="function not covered" >ermTyp</span>e=<span class="cstat-no" title="statement not covered" >"collection",c.prototype.classOrder=u.Collection,c.prototype.compareTerm=s.pr</span>ototype</span>.co<span class="cstat-no" title="statement not covered" ></span>mpareTerm,c.prototype.is<span class="fstat-no" title="function not covered" >Va</span>r=0,e.exports=c}<span class="cstat-no" title="statement not covered" >,funct</span>io<span class="cstat-no" title="statement not covered" >n(e,t,<span class="cstat-no" title="statement not covered" ></span>n){"u<span class="cstat-no" title="statement not covered" >s</span>e strict";function r(e,t){if(!(e i<span class="cstat-no" title="statement not covered" >nstanceof </span></span>t))th<span class="cstat-no" title="statement not covered" >row new TypeEr<span class="cstat-no" title="statement not covered" ></span>ror("Cannot call a class as a function")}function i(e</span>,t</span>)<span class="fstat-no" title="function not covered" >{i</span>f(!e)throw new ReferenceError("this <span class="fstat-no" title="function not covered" >ha</span>sn't <span class="cstat-no" title="statement not covered" >been initialised - su<span class="cstat-no" title="statement not covered" >per() hasn't been called");return!t||"object"!=typeof t&amp;&amp;"</span></span>function"<span class="fstat-no" title="function not covered" >!=</span>typeo<span class="cstat-no" title="statement not covered" >f t?e:<span class="cstat-no" title="statement not covered" >t}function o(e,t){if("function"!=typeof t&amp;&amp;null!==t)throw new TypeError("Super express<span class="cstat-no" title="statement not covered" >i</span></span>on must either be null or a function, not "+typeof t);e</span>.prototyp<span class="fstat-no" title="function not covered" >e=</span>Objec<span class="cstat-no" title="statement not covered" >t.create(t&amp;&amp;t.prototype,{construct<span class="cstat-no" title="statement not covered" >or:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object<span class="cstat-no" title="statement not covered" >.</span></span>setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&amp;&amp;(r.writa</span>ble=!0<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >),</span>Object.definePrope<span class="fstat-no" title="function not covered" >rt</span>y(e,r<span class="cstat-no" title="statement not covered" >.key,r)}}return function(t,n,r){re<span class="cstat-no" title="statement not covered" >turn <span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s=n(9),u=n(10),l=function(e){function t(e){r(this,t);var n=i(this,Object.ge</span>t<span class="cstat-no" title="statement not covered" ></span>Prototy<span class="fstat-no" title="function not covered" >pe</span>Of(t).call(thi<span class="cstat-no" title="statement not covered" >s));return n.termType=t.termType,n.id=t.</span>ne</span>xtI</span>d+<span class="cstat-no" title="statement not covered" >+,n.va</span>lu<span class="cstat-no" title="statement not covered" >e=e||</span>n.<span class="cstat-no" title="statement not covered" >id.toS</span>tr<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >in</span>g(),n}return o(t,e)<span class="fstat-no" title="function not covered" >,a</span>(t,<span class="cstat-no" title="statement not covered" >[{key:"comp</span>areTe<span class="cstat-no" title="statement not covered" >rm",value:function(e){return this.classOrder<span class="cstat-no" title="statement not covered" ></span>&lt;e.classOrder?-1:this.classOrder&gt;e.classOrder?1:this.id&lt;e.id?-1:this.id&gt;e.id?1:0}},{key:"copy",v<span class="fstat-no" title="function not covered" >al</span>ue:functio<span class="cstat-no" title="statement not covered" >n(e){var n=new t;return e.copyTo(</span>this,<span class="cstat-no" title="statement not covered" ></span>n),n}},{key:"toCanonical",value:function(){return"_:"+this.value}},{key:"<span class="fstat-no" title="function not covered" >toStri</span>ng"<span class="cstat-no" title="statement not covered" >,value:function(){return t.NTA</span>nonymousNodePrefix+this.id}}]),t}(u);l.nextId=0,l.termT<span class="fstat-no" title="function not covered" >ype="B</span>la<span class="cstat-no" title="statement not covered" >nkNode",l.NTAnonymousNodePrefix="_:</span>n",l.prototype.classOrder=s.BlankNode,l.prototype.isBla<span class="fstat-no" title="function not covered" >nk=1,l</span>.p<span class="cstat-no" title="statement not covered" >rototype.isVar=1,e.exports=l},</span>function(e,t,n){"use strict";function r(e,t){if(!(e instance<span class="fstat-no" title="function not covered" >of t))</span>throw new<span class="cstat-no" title="statement not covered" > TypeError("Cannot<span class="fstat-no" title="function not covered" > c</span>all a clas<span class="cstat-no" title="statement not covered" >s as a function")</span>}f<span class="cstat-no" title="statement not covered" ></span>unction i(e,t){if</span>(!e)throw new ReferenceError("this hasn't been initial<span class="fstat-no" title="function not covered" >ised -</span> s<span class="cstat-no" title="statement not covered" >uper() hasn't been called");return!t||"o</span>bject"!=typeof t&amp;&amp;"function"!=typeof t?e:t}function o(e,t)<span class="fstat-no" title="function not covered" >{if("f</span>un<span class="cstat-no" title="statement not covered" >ction"!=typeof t&amp;&amp;null!==t)throw new Ty</span>peError("Super expression must either be null or a functi<span class="fstat-no" title="function not covered" >on, no</span>t "<span class="cstat-no" title="statement not covered" >+typeof t);e.prototype=Object.cre</span>ate(t&amp;&amp;</span>t.pr<span class="cstat-no" title="statement not covered" ></span>ototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t</span>)<span class="fstat-no" title="function not covered" >}v</span>ar a="function"==typeof Symbol&amp;&amp;"sym<span class="fstat-no" title="function not covered" >bo</span>l"==t<span class="cstat-no" title="statement not covered" >ypeof Symbol.iterator<span class="cstat-no" title="statement not covered" >?function(e){return typeof e}:function(e){return e&amp;&amp;"funct</span></span>ion"==typ<span class="fstat-no" title="function not covered" >eo</span>f Sym<span class="cstat-no" title="statement not covered" >bol&amp;&amp;e<span class="cstat-no" title="statement not covered" >.constructor===Symbol?"symbol":typeof e},s=function(){function e(e,t){for(var n=0;n&lt;t.<span class="cstat-no" title="statement not covered" >l</span></span>ength;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.c</span>onfigurab<span class="fstat-no" title="function not covered" >le</span>=!0,"<span class="cstat-no" title="statement not covered" >value"in r&amp;&amp;(r.writable=!0),Object<span class="cstat-no" title="statement not covered" >.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t<span class="cstat-no" title="statement not covered" >}</span></span>}(),u=n(9),l=n(8),c=n(10),f=n(14),h=function(e){function t(e,n,o){r(this,t);var a=i(this,Object.getPrototypeOf(t).call(this));return a.termType=t.termType,a.value=e,n&amp;&amp;(a.lang=</span>n,o=f.<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >la</span>ngString),o&amp;&amp;(a.da<span class="fstat-no" title="function not covered" >ta</span>type=<span class="cstat-no" title="statement not covered" >l.fromValue(o)),a}return o(t,e),s(<span class="cstat-no" title="statement not covered" >t,[{k<span class="cstat-no" title="statement not covered" ></span>ey:"copy",value:function(){return new t(this.value,this.lang,this.datatype)}},{key:"equals",value:function(e){r</span>e<span class="cstat-no" title="statement not covered" ></span>turn!!e<span class="fstat-no" title="function not covered" >&amp;&amp;</span>(this.termType<span class="cstat-no" title="statement not covered" >===e.termType&amp;&amp;this.value===e.value&amp;&amp;thi</span>s.</span>lan</span>gu<span class="cstat-no" title="statement not covered" >age==</span>=e<span class="cstat-no" title="statement not covered" >.langu</span>ag<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e&amp;</span>&amp;(!this.datatype&amp;&amp;!<span class="fstat-no" title="function not covered" >e.</span>dat<span class="cstat-no" title="statement not covered" >atype||this</span>.data<span class="cstat-no" title="statement not covered" >type&amp;&amp;this.datatype.equals(e.datatype)))}},{<span class="cstat-no" title="statement not covered" ></span>key:"toNT",value:function(){if("number"==typeof this.value)return this.toSt<span class="cstat-no" title="statement not covered" ></span>ring();if("string"!=typeof this.value)throw new Error("Value of RDF literal is<span class="fstat-no" title="function not covered" > not s</span>tri<span class="cstat-no" title="statement not covered" >ng or number: "+this.value);var e=this.value;return e=e.replace(/\\/g,"\\\\"),e=e.replace(/\"/g,'\\"'),e</span>=e.replace(/\n/g,"\\n"),e='"'+e+'"',this.language?e+="<span class="fstat-no" title="function not covered" >@"+thi</span>s.languag<span class="cstat-no" title="statement not covered" >e:this.d<span class="cstat-no" title="statement not covered" ></span>atatype.equals(f.string)||(</span>e+="^^"+this.datatype.toCanonical()),e}},{key:"toString",valu<span class="fstat-no" title="function not covered" >e:func</span>ti<span class="cstat-no" title="statement not covered" >on(){return""+this.valu</span>e}},{key:"language",get:function(){return this.lang},set:f<span class="fstat-no" title="function not covered" >unctio</span>n(<span class="cstat-no" title="statement not covered" >e){this.lang=e||""}}],[{key:"fromBoolean</span>",value</span>:fun<span class="cstat-no" title="statement not covered" ></span>ction(e){var n=e?"1":"0";return new t(n,null,f.boolean)}},{key:"fromDate",value:function(e){if(!(e instanceof Date))throw new TypeError("Invalid argument </span>t<span class="fstat-no" title="function not covered" >o </span>Literal.fromDate()");var n=function(<span class="fstat-no" title="function not covered" >e)</span>{retu<span class="cstat-no" title="statement not covered" >rn(""+(100+e)).slice(<span class="cstat-no" title="statement not covered" >1,3)},r=""+e.getUTCFullYear()+"-"+n(e.getUTCMonth()+1)+"-"</span></span>+n(e.getU<span class="fstat-no" title="function not covered" >TC</span>Date(<span class="cstat-no" title="statement not covered" >))+"T"<span class="cstat-no" title="statement not covered" >+n(e.getUTCHours())+":"+n(e.getUTCMinutes())+":"+n(e.getUTCSeconds())+"Z";return new t<span class="cstat-no" title="statement not covered" >(</span></span>r,null,f.dateTime)}},{key:"fromNumber",value:function(e</span>){if("num<span class="fstat-no" title="function not covered" >be</span>r"!=t<span class="cstat-no" title="statement not covered" >ypeof e)throw new TypeError("Inval<span class="cstat-no" title="statement not covered" >id argument to Literal.fromNumber()");var n=void 0,r=e.toString();return n=r.indexOf("e")<span class="cstat-no" title="statement not covered" >&lt;</span></span>0&amp;&amp;Math.abs(e)&lt;=Number.MAX_SAFE_INTEGER?Number.isInteger(e)?f.integer:f.decimal:f.double,new t(r,null,n)}},{key:"fromValue",value:function(e){if("undefined"==typeof e||null===e</span>)retur<span class="cstat-no" title="statement not covered" >n e;if("object"===("undefined"==typeof e?"undefined":a(e))&amp;&amp;<span class="fstat-no" title="function not covered" >e.</span>termType)r<span class="cstat-no" title="statement not covered" >eturn e;switch("u</span>n<span class="fstat-no" title="function not covered" >de</span>fined"==ty<span class="cstat-no" title="statement not covered" >peof e?"undefined":a(e)){case"object":if(e instanceof Date)return t.fromDate(e)</span>;</span>ca<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >se</span>"boolean":return t<span class="fstat-no" title="function not covered" >.f</span>romBo<span class="cstat-no" title="statement not covered" >olean(e);case"number":return t.fro<span class="cstat-no" title="statement not covered" >mNumb<span class="cstat-no" title="statement not covered" ></span>er(e);case"string":return new t(e)}throw new Error("Can't make literal from "+e+" of type "+("undefined"==typeo</span>f<span class="cstat-no" title="statement not covered" ></span> e?"und<span class="fstat-no" title="function not covered" >ef</span>ined":a(e)))}<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
}]),t}(<span class="cstat-no" title="statement not covered" >c);h.termType="Literal",h.prototype.classOrder=u.Literal,h.prototype.datatype=f.string,h.prototype.lang="",h.prototype.isVar=0,e.exports=</span>h<span class="fstat-no" title="function not covered" >},</span>function(e,t,n){"use strict";functio<span class="fstat-no" title="function not covered" >n </span>r(e,t<span class="cstat-no" title="statement not covered" >){if(!(e instanceof t<span class="cstat-no" title="statement not covered" >))throw new TypeError("Cannot call a class as a function")</span></span>}var i<span class="cstat-no" title="statement not covered" >=n(8)</span>,o<span class="cstat-no" title="statement not covered" >=function<span class="fstat-no" title="function not covered" > e</span>()<span class="cstat-no" title="statement not covered" >{r(this,e)}</span>;<span class="cstat-no" title="statement not covered" ></span>o.boolean=new i("http://www.w3.org/2001/XMLSchema#boolean"),o.dateTime=new i("http://www.w3.org/2001/XMLSchema#dateTime"),o.decimal=new i("http://www.w3.org/2001/XMLSchema#decimal"),o.double=new i("http://www.w3.org/2001/XMLSchema#double"),o.integer=new i("http://www.w3.org/2001/XMLSchema#integer"),o.langString=new i("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"),o.string=new i("http://www.w3.org/2001/XMLSchema#string"),e.exports=o},</span>f<span class="fstat-no" title="function not covered" >un</span>ction(e,t){"use strict";e<span class="cstat-no" title="statement not covered" >.exports={debug:function(e){},warn:function(e){},in<span class="fstat-no" title="function not covered" >fo:fun</span>ction(e){},error:function(e){},success:funct<span class="fstat-no" title="function not covered" >ion(e</span>){},msg:function(e){}}},function(e,t,n){func<span class="fstat-no" title="function not covered" >tion </span>r(e){this.options=e||{locator:{}}}function i(<span class="fstat-no" title="function not covered" >e,t,n)</span>{function r(t){var r=e[t];!r&amp;&amp;a&amp;&amp;(r=2==e.length<span class="fstat-no" title="function not covered" >?functio</span>n(n){e(t,n)}:e),i[t]=r&amp;&amp;function(e){r("[xml<span class="fstat-no" title="function not covered" >dom </span>"+t+"]\</span>t<span class="fstat-no" title="function not covered" >"+</span>e+s(n))}||function(){}}<span class="fstat-no" title="function not covered" >if</span>(!e<span class="cstat-no" title="statement not covered" >){if(t instanceof o)return t;e</span>=t}var i=<span class="fstat-no" title="function not covered" >{}</span>,a=e instanceof <span class="fstat-no" title="function not covered" >Fu</span>nction;re<span class="cstat-no" title="statement not covered" >turn <span class="cstat-no" title="statement not covered" ></span>n=n||{},r("warning"),r<span class="fstat-no" title="function not covered" >("</span>error"),r(<span class="cstat-no" title="statement not covered" >"fatalEr</span>ror"),i}func<span class="fstat-no" title="function not covered" >ti</span>on o(){thi<span class="cstat-no" title="statement not covered" >s.cdata=!1}function a(e,t){t.l</span>in<span class="fstat-no" title="function not covered" >eN</span>umber=e.line<span class="cstat-no" title="statement not covered" ></span>Number,<span class="cstat-no" title="statement not covered" >t.columnNumber=e.c<span class="cstat-no" title="statement not covered" >olumnNumb<span class="cstat-no" title="statement not covered" >e</span></span>r}fu</span>n</span>ction<span class="cstat-no" title="statement not covered" > s(</span>e)<span class="cstat-no" title="statement not covered" >{if(e)return"\n@"+(e.s<span class="cstat-no" title="statement not covered" ></span>ystemId||"")+"#[line:"+e.lineNumber+",col:"+e.columnNumber</span>+"]"}func<span class="fstat-no" title="function not covered" >ti</span>on<span class="cstat-no" title="statement not covered" > u(e,t,n){retur</span>n"string"<span class="fstat-no" title="function not covered" >==</span>typeo<span class="cstat-no" title="statement not covered" >f e?e.substr(t,n):e.length&gt;=t+n||t?new java.lang.String(e</span>,t,n)+"":<span class="fstat-no" title="function not covered" >e}</span>fun<span class="cstat-no" title="statement not covered" >ction<span class="cstat-no" title="statement not covered" > l(e,t){e.currentElement?e.currentElement.appendChild(t):e.doc.appendChild(t)}r.</span></span>prototype<span class="fstat-no" title="function not covered" >.p</span>arseFro<span class="cstat-no" title="statement not covered" >mString=function(e,t){var n=this.options,r=new c,a=n.domBuilder||new o,s=n.errorHandler,u=</span>n.locator<span class="fstat-no" title="function not covered" >,l</span>=n.xm<span class="cstat-no" title="statement not covered" >lns||{},f={lt:"&lt;",gt:"&gt;",amp:"&amp;",quot:'"',apos:"'"};return u&amp;&amp;a.setDocu<span class="cstat-no" title="statement not covered" ></span>mentLocator(u),r.errorHandle<span class="fstat-no" title="function not covered" >r=</span>i(s,a,u),r.domBuil<span class="cstat-no" title="statement not covered" >der=n.domBuil</span>de<span class="cstat-no" title="statement not covered" >r||a,/\/</span>x?<span class="cstat-no" title="statement not covered" >html?$/.test(t)&amp;&amp;(f.nb</span>sp<span class="cstat-no" title="statement not covered" >=" ",f.copy="©"</span>,l<span class="cstat-no" title="statement not covered" >[""]="http</span>:/<span class="cstat-no" title="statement not covered" >/www.w3.org/</span>19<span class="cstat-no" title="statement not covered" >99/xhtml"),l.xml=l.xml||"http://www.w3.org<span class="cstat-no" title="statement not covered" ></span>/XML/1998/namespace",e?r.parse(e,l,f):r.errorHandler.error("invalid doc source"),a.doc},o.prototype={startDocument:function(){this.doc=(new f).createDocument(null,null,null),this.locator&amp;&amp;(this.doc.documentURI=this.locator.systemId)},startElement:function(e,t,n,r){var i=this.doc,o=i.creat</span>eElementNS(e,n||t),s=r.length;l(this,o),this.currentElement=o,<span class="fstat-no" title="function not covered" >this.locator&amp;&amp;</span>a(<span class="cstat-no" title="statement not covered" >this.locator,o);for(var u=0;u&lt;s;u++){var e=r.getURI(u),c=r.getValue(u),n=r.getQName(u),f=i.createAttributeNS</span>(e,n);this.locator&amp;&amp;a(r.getLocator(u),f),f.value<span class="fstat-no" title="function not covered" >=f.nodeValue=</span>c,o.setAttribut<span class="cstat-no" title="statement not covered" >eNode(f)}</span>},<span class="cstat-no" title="statement not covered" >endElement:function(e,t,n)</span>{v<span class="cstat-no" title="statement not covered" >ar r=this<span class="cstat-no" title="statement not covered" ></span>.currentElement;r.tagName;this.currentElement=r.parentNode},star<span class="cstat-no" title="statement not covered" >t</span>PrefixMapping:function(e,t<span class="cstat-no" title="statement not covered" >){},endPrefi</span>xM<span class="cstat-no" title="statement not covered" >apping:functio</span>n(<span class="cstat-no" title="statement not covered" >e){},processin</span>gI<span class="cstat-no" title="statement not covered" >nstruction:function(e,t){<span class="cstat-no" title="statement not covered" ></span>var n=this.doc.createProcessingInstruction(e,t);this.locator&amp;&amp;a(this.locator,n),</span>l</span>(this,n)},ignorableWhitespace:function(e,t,n){<span class="fstat-no" title="function not covered" >},character</span>s:function(e,<span class="cstat-no" title="statement not covered" >t,n){if(e=u.apply(th<span class="cstat-no" title="statement not covered" ></span>is,argumen<span class="cstat-no" title="statement not covered" >t</span>s)){if(this.cdata)var r=this.doc.</span>createCDATASection(e);else var r=this.doc.createTextNo<span class="fstat-no" title="function not covered" >de(e);this.currentE</span>lement?this.currentElement.appendChild(r):/^\s*$/.test(e)&amp;<span class="fstat-no" title="function not covered" >&amp;this.doc.appendC</span>hild(r),this.locator&amp;&amp;a(this.locator,r)}},skippedEntity:funct<span class="fstat-no" title="function not covered" >ion(e){},endDocument:f</span>unction(){t<span class="cstat-no" title="statement not covered" >his.doc.normalize()},setDocumentLocator:fu<span class="cstat-no" title="statement not covered" ></span>nction(e){(this.locator=e)&amp;&amp;(e.lineNumber=0</span>)},comment:function(e,t,n){e=u.apply(this,arguments);va<span class="fstat-no" title="function not covered" >r r=this.doc.createC</span>omment(e);this.locator&amp;&amp;a(this.locator,r),l(this,r)},s<span class="fstat-no" title="function not covered" >tartCDATA:f</span>unction<span class="cstat-no" title="statement not covered" >(){this.cdata=!0},endCDATA:fun<span class="cstat-no" title="statement not covered" >ction(){this.cdata=!<span class="cstat-no" title="statement not covered" >1},startDTD:function(e,t,n){var</span> r=this.doc<span class="cstat-no" title="statement not covered" >.implementation;if(r&amp;&amp;r.cre<span class="cstat-no" title="statement not covered" ></span>a</span>teDocumentType){var i=r.createDocumentType(e,t,n);this.locator&amp;&amp;a(this.locator,i),l(this,i)}},warning:function(e){console.warn("</span>[</span>xmldom warning]\t"+e,s(this.locator))},error:func<span class="fstat-no" title="function not covered" >tion(e){consol</span>e.error("[xmldom error]\t"+e,s(this.locator))},fata<span class="fstat-no" title="function not covered" >lError:funct</span>io<span class="cstat-no" title="statement not covered" >n(e){throw console.err</span>or("[xmldom fatalError]\t"+e,s(this.locator)),e}},"end<span class="fstat-no" title="function not covered" >DTD,startEntity,end</span>Ent<span class="cstat-no" title="statement not covered" >ity,attributeDecl,elementDecl,extern</span>alEntityDecl,internalEntityDecl,resolveEnti<span class="fstat-no" title="function not covered" >ty,getEx</span>ternalS<span class="cstat-no" title="statement not covered" >ubset,notationDecl,unparsed</span>Entit<span class="cstat-no" title="statement not covered" >yDecl".replace(/\w+/g,func<span class="cstat-no" title="statement not covered" ></span>tion(e){o.prototype[e]=function(){return nu</span>ll}});var c=n(17).XMLReader,f=t.DOMImplementat<span class="fstat-no" title="function not covered" >ion=n(18).D</span>OM<span class="cstat-no" title="statement not covered" >Implementation;</span>t.XMLSerializer=n(18).XMLSerializer,t.DOMPar<span class="fstat-no" title="function not covered" >ser=r},fu</span>nc<span class="cstat-no" title="statement not covered" >tion(e,t){funct</span>ion n(){}function r(e,t,n,r,l){function d(e)<span class="fstat-no" title="function not covered" >{if(e&gt;655</span>35){e-=65536;<span class="cstat-no" title="statement not covered" >var t=55296+(e&gt;&gt;10),n=56<span class="cstat-no" title="statement not covered" ></span>320+(1023&amp;e);return String.fromCha<span class="cstat-no" title="statement not covered" >rCode(t,n)}return String.fro<span class="cstat-no" title="statement not covered" ></span>mCharCode(e)}function p(e){var t=e.slice(1,</span>-</span>1);return t in n?n[t]:"#"===t.charAt(0)?d(p<span class="fstat-no" title="function not covered" >arseInt(</span>t.s<span class="cstat-no" title="statement not covered" >ubstr(1).replace("x","0x"))):(l.error("entity not foun</span>d:"+e),e)}function v(t){if(t&gt;k){var n=e.s<span class="fstat-no" title="function not covered" >ubstri</span>ng(<span class="cstat-no" title="statement not covered" >k,t).replace(/&amp;#?\w+;/g,p);w&amp;&amp;g(k),r.characters(n,0,t</span>-k),k=t}}function g(t,n){for(;t&gt;=m&amp;&amp;(n=b.exec(<span class="fstat-no" title="function not covered" >e));)y=n.in</span>dex<span class="cstat-no" title="statement not covered" >,m=y+n[0].length,w.lineNumber++;w.columnNumber=t-y+1}for(var y=0,m</span>=0,b=/.*(?:\r\n?|\n)|.*$/g,w=r.locator,x=[{currentNSMap:t}],_={},k=0;;){try{var T=e.indexOf("&lt;",k);if(T&lt;0){if(!e.substr(k).match(/^\s*$/)){var E=r.doc,S=E.createTextNode(e.subs<span class="fstat-no" title="function not covered" >tr</span>(k));E.app<span class="cstat-no" title="statement not covered" >endChild(S),r.c<span class="fstat-no" title="function not covered" >ur</span>rentEleme<span class="cstat-no" title="statement not covered" >nt=S}return}s</span>wi</span>tch</span>(T&gt;k&amp;<span class="cstat-no" title="statement not covered" >&amp;v(T),e.charAt(T</span>+1<span class="cstat-no" title="statement not covered" >)){case"/":var N=e.indexOf("&gt;",T+3),R=e.subs<span class="cstat-no" title="statement not covered" ></span>tring(T+2,N),j=x.pop();N&lt;0?(R=e.substring(T+2).repl</span>a<span class="fstat-no" title="function not covered" >ce</span>(/[\s&lt;].*/,""),l.erro<span class="fstat-no" title="function not covered" >r(</span>"end tag nam<span class="fstat-no" title="function not covered" >e:</span> "+R+" is not comple<span class="fstat-no" title="function not covered" >te</span>:"+<span class="cstat-no" title="statement not covered" >j.tagName),N<span class="cstat-no" title="statement not covered" >=T+1+R.len</span>gth):<span class="cstat-no" title="statement not covered" >R.match(/\s&lt;/)</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >(R=R.replace(/[<span class="cstat-no" title="statement not covered" ></span>\s&lt;].*/,""),l.error("end tag name<span class="cstat-no" title="statement not covered" ></span>:</span> "+R+" maybe not complete"),N=</span>T+1+R.len<span class="fstat-no" title="function not covered" >gt</span>h);var O=<span class="cstat-no" title="statement not covered" >j.localNSMap,I<span class="cstat-no" title="statement not covered" ></span>=j.tagName==R,C=I||j.tagName&amp;&amp;j.tagName.toLowerCase()==R.toLowerCase();if(C){if(r.endElement(j.uri,j.localName,R),O)</span>for(var A<span class="fstat-no" title="function not covered" > i</span>n O<span class="cstat-no" title="statement not covered" >)r.endPrefixMa<span class="cstat-no" title="statement not covered" >pping(A);I||l.fatalError("end tag name:<span class="cstat-no" title="statement not covered" ></span> "+R+" is not match the current sta</span>r</span>t tagName<span class="fstat-no" title="function not covered" >:"</span>+j.ta<span class="cstat-no" title="statement not covered" >gName)}else x.push(j);N++;<span class="cstat-no" title="statement not covered" >break;case"?":w&amp;&amp;g(T),N=f(e,T,r);break;ca<span class="cstat-no" title="statement not covered" >s</span></span>e"!":w&amp;&amp;g(T),N=c(e,T,<span class="cstat-no" title="statement not covered" ></span>r,l);break;default:w&amp;&amp;g(T);var L=new h,D=x[x.length-1].currentNSMap,N=o(e,T,L,D,p,l),<span class="cstat-no" title="statement not covered" >P=L.length<span class="cstat-no" title="statement not covered" >;if(!L.closed&amp;&amp;u(<span class="cstat-no" title="statement not covered" ></span>e,N,L.ta<span class="cstat-no" title="statement not covered" >gName,_)&amp;&amp;(L.closed=!0,n.nbsp||l.warni<span class="cstat-no" title="statement not covered" >ng("un</span>cl<span class="cstat-no" title="statement not covered" >osed xml attribute")),w&amp;&amp;P){fo<span class="cstat-no" title="statement not covered" ></span>r(var U=i(w,{}),M=0;M&lt;P;M++){var q=L[<span class="cstat-no" title="statement not covered" ></span>M</span>];g(q.o<span class="cstat-no" title="statement not covered" ></span>f</span>fset),q.locator=i(w,{})}r.locator=U,a(L,r,D)&amp;<span class="cstat-no" title="statement not covered" >&amp;x.push(L),r.locato</span>r=<span class="cstat-no" title="statement not covered" >w}else a(L,r,D)&amp;&amp;x.</span>pu<span class="cstat-no" title="statement not covered" >sh(L);"h<span class="cstat-no" title="statement not covered" ></span>ttp://www.w3.org/1999/xhtml"!==L.uri||L.closed?N++:N=s(e,N,L.tagName,p,r)}}catch(e){l.error("element parse error: "+e),N=-1}N&gt;k?k=N:v(Math.max(T,k)+1)}}function i(e,t){return t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber</span>,t}fu<span class="cstat-no" title="statement not covered" >nction o(e,t,</span>n,<span class="cstat-no" title="statement not covered" >r,i,o){for(va</span>r <span class="cstat-no" title="statement not covered" >a,s,u=++t,l=m;;){var c=e.charAt(u);switch(c){case"=":if<span class="cstat-no" title="statement not covered" ></span>(l===b<span class="cstat-no" title="statement not covered" >)a=e.slice(t,u),l=x;else{if(l!==w)throw<span class="cstat-no" title="statement not covered" > new Error("att<span class="cstat-no" title="statement not covered" >ribute equal must afte<span class="cstat-no" title="statement not covered" >r</span></span></span> attrName");l=x}break;case"'":case'"':if(l===x||l===b){if(l===b&amp;&amp;(o.warning('attribute va</span>lue m<span class="cstat-no" title="statement not covered" >ust after <span class="cstat-no" title="statement not covered" >"</span></span>="'<span class="cstat-no" title="statement not covered" >)</span>,a=e.s</span>lice(t,<span class="cstat-no" title="statement not covered" >u)),t=u+1,u=e.index<span class="cstat-no" title="statement not covered" >O</span>f(c,t)</span>,!(u&gt;0)<span class="cstat-no" title="statement not covered" >)throw new Error("att<span class="cstat-no" title="statement not covered" >r</span>ibute </span>value n<span class="cstat-no" title="statement not covered" >o end '"+</span>c+"' <span class="cstat-no" title="statement not covered" >match");</span>s=<span class="cstat-no" title="statement not covered" >e.slice(t,u).replace(/&amp;#?\w</span>+;<span class="cstat-no" title="statement not covered" >/g,i),n.add(a,s</span>,t<span class="cstat-no" title="statement not covered" >-1),l=k}e<span class="cstat-no" title="statement not covered" ></span>lse{if(l!=_)throw new Error('attribute value must after "="');s=e.slice(t,u).replace(/&amp;#?\w+;/g,i)<span class="cstat-no" title="statement not covered" >,n.add(a,s,t),o.warning('attribute "'<span class="cstat-no" title="statement not covered" >+a+'"<span class="cstat-no" title="statement not covered" ></span> missed start quot('+c+")!!"),t<span class="cstat-no" title="statement not covered" ></span>=</span>u+1,l=k}break;case"/":switch(l){case m:n.set</span>TagNa<span class="cstat-no" title="statement not covered" >me(e.slice(t,u));cas<span class="cstat-no" title="statement not covered" >e</span></span> k:case T:case E:l=E,n.closed=!0;case _:case b:case w:break;default:throw ne</span>w</span> Error("a<span class="cstat-no" title="statement not covered" >ttribute invalid close char('/')")}break;<span class="cstat-no" title="statement not covered" ></span>c</span>ase"":return o.error("unexp</span>e</span>cted end <span class="fstat-no" title="function not covered" >of</span> inpu<span class="cstat-no" title="statement not covered" >t"),l==m&amp;&amp;n.setTagName(e.slice(t,u)),u;case"&gt;":switch(l){case m:n.</span>setTagNam<span class="fstat-no" title="function not covered" >e(</span>e.slice(t,u))<span class="cstat-no" title="statement not covered" >;case k:case T:case E:break;cas<span class="cstat-no" title="statement not covered" >e _:case b:s<span class="cstat-no" title="statement not covered" ></span>=e.slice(t,u),"/"=<span class="cstat-no" title="statement not covered" >==s.slice<span class="cstat-no" title="statement not covered" >(-1)&amp;&amp;(n.closed=!0,s</span>=s.s<span class="cstat-no" title="statement not covered" >lice(0,-1<span class="cstat-no" title="statement not covered" >));case w:l===w&amp;&amp;(s=a),l==_?(o.warning('attribute "'+s+<span class="cstat-no" title="statement not covered" >'</span></span>" mi<span class="cstat-no" title="statement not covered" ></span>s</span>sed qu</span>ot(")!!'),n.add<span class="cstat-no" title="statement not covered" >(a,s.replace(/&amp;#?<span class="cstat-no" title="statement not covered" >\w+;/g,i),t)):("http://www.w3.org/1999/xhtml"===r[""]&amp;&amp;s.match(/^(?:disabled|checked|selected)$/i)||o<span class="cstat-no" title="statement not covered" >.warning('attribute "'+s+'" missed value!! "'+s+'" inste<span class="cstat-no" title="statement not covered" >a</span></span>d!!'),n.add(s,s,t));break;case x:throw new Error("attrib</span>ute v<span class="cstat-no" title="statement not covered" >alue mis<span class="cstat-no" title="statement not covered" >sed!!")}return u;case"":c=" ";default:if(c&lt;=" ")s<span class="cstat-no" title="statement not covered" >w</span></span>itch(l){case m:n.setTagName(e.slice(t,u)),l=T;break;case b:a=e.slice(t,u),l=w;break;case _:var s=e.slice(t,u).replace(<span class="cstat-no" title="statement not covered" ></span>/</span>&amp;#?\w+</span>;/g,i);<span class="cstat-no" title="statement not covered" >o.warning('attrib<span class="cstat-no" title="statement not covered" >ute "'+s+'" missed quot(")!!</span>'),n.add(a,s,t);case<span class="cstat-no" title="statement not covered" > k:l=T}else switc</span>h(l){case w:n.tagNam<span class="cstat-no" title="statement not covered" >e;"http</span>://www.<span class="cstat-no" title="statement not covered" >w3.org/1999/xhtml"===r[""]&amp;&amp;a.match(/^(?:disabled|chec<span class="cstat-no" title="statement not covered" ></span>k</span>ed|sel</span>ected)<span class="cstat-no" title="statement not covered" >$/i)||o.warning('attribute "'+a+'" missed value!! "'+a+'" instead2!!'),n.add(a</span>,a,t),t<span class="cstat-no" title="statement not covered" >=u,l=b;break;case<span class="cstat-no" title="statement not covered" > k:o.warning('attribute spac</span>e is required"'+a+'"<span class="cstat-no" title="statement not covered" >!!');ca</span>se T:l=b,t=u;<span class="cstat-no" title="statement not covered" >break;case x:l=_,t=u;break;case E:throw new Error("elements close</span>d char<span class="cstat-no" title="statement not covered" >acter '/' and '&gt;' must be connected to")}}u++}}function a(e,t,n){for(var r=e.tagName,i=null,o=e.length;o--;){var a=e[o],s=a.qName,u=a.value,c=s.indexOf(":");if(c&gt;0)var f=a.prefix=s.slice(0,c),h=s.slice(c+1),d="xmlns"===f&amp;&amp;h;else h=s,f=null,d="xmlns"===s&amp;&amp;"";a.localNa<span class="cstat-no" title="statement not covered" >m</span>e=h,d!</span>==!1&amp;&amp;<span class="cstat-no" title="statement not covered" >(null==i&amp;&amp;(i={},l(n,n={})),n[d]=i[d]=u,a.uri=<span class="cstat-no" title="statement not covered" ></span>"</span>http://ww</span>w.w3.or<span class="cstat-no" title="statement not covered" >g/2000/</span>xmlns/"<span class="cstat-no" title="statement not covered" >,t.startPr<span class="cstat-no" title="statement not covered" >efixMapping(d,u))<span class="cstat-no" title="statement not covered" >}for(var o=e.length;o--;){a=e[o<span class="cstat-no" title="statement not covered" >]</span>;var f</span>=a.pre<span class="cstat-no" title="statement not covered" >fix;f&amp;&amp;("xml"===f&amp;&amp;<span class="cstat-no" title="statement not covered" >(</span>a.uri=</span>"http://www.<span class="cstat-no" title="statement not covered" >w3.org/XML/1998/namespace"),"xmlns"<span class="cstat-no" title="statement not covered" ></span>!==f&amp;&amp;(a.uri=n[f||""]))}var c=r.indexOf(":");c&gt;0?(f=e.prefix=r</span>.slice<span class="cstat-no" title="statement not covered" >(0,c)</span>,</span>h=e.<span class="cstat-no" title="statement not covered" >localName=r.slice<span class="cstat-no" title="statement not covered" >(c+1)):(f=<span class="cstat-no" title="statement not covered" >n</span>ull,h=e.localName=r);var p=e.uri=n[f||""];if(t.startElement(p,h,r,e),!e.closed)return e.currentNSMap=n,e.localNSMap=i,!0;if(t.endElement(p,h,r),i)for(f in i)t.endPrefixMa<span class="cstat-no" title="statement not covered" >p</span>ping(f</span>)}func<span class="cstat-no" title="statement not covered" >tion s(e,t,n,r,i){if(/^(?:script|textarea)$/i.test(</span>n)){va<span class="cstat-no" title="statement not covered" >r o=e.in<span class="cstat-no" title="statement not covered" >d</span>exOf("</span>&lt;/"+n+<span class="cstat-no" title="statement not covered" >"&gt;",t),a<span class="cstat-no" title="statement not covered" >=</span>e.subs</span>tring(<span class="cstat-no" title="statement not covered" >t+1,o);if(/[&amp;&lt;]/.test(a))return/^script$/i.test(n)?(i.characters(a,0,a.length),</span>o<span class="cstat-no" title="statement not covered" ></span></span>)</span>:(a=</span>a</span>.replace(<span class="fstat-no" title="function not covered" >/&amp;</span>#?\w+;/<span class="cstat-no" title="statement not covered" >g,r),i.characters(a,0,a.length),o)}return t+1}func<span class="cstat-no" title="statement not covered" >tion </span>u(<span class="cstat-no" title="statement not covered" >e,t,n,r)</span>{v<span class="cstat-no" title="statement not covered" >ar i=r[n</span>];<span class="cstat-no" title="statement not covered" >return null==i&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(i=e.lastInd<span class="cstat-no" title="statement not covered" >exOf("&lt;/"+n+"&gt;"),i&lt;t&amp;&amp;</span>(i<span class="cstat-no" title="statement not covered" >=e.lastIndexO</span>f(<span class="cstat-no" title="statement not covered" >"&lt;/"+n)),r[n]=i</span>),i&lt;t<span class="cstat-no" title="statement not covered" >}function l(e,t){for(var n in<span class="cstat-no" title="statement not covered" > </span></span>e)t[n]=e[n]}function c(e,t,n,r){var i=e.charAt(t+2);switch(i){case"-":if("-"===e.charAt(t+3)){var o=e.indexOf("--&gt;",t+4);retur<span class="cstat-no" title="statement not covered" ></span>n</span> o&gt;t?(n.comment(e,t+4,o-<span class="cstat-no" title="statement not covered" >t-4),o+3</span>):(r.<span class="cstat-no" title="statement not covered" >error("Un<span class="cstat-no" title="statement not covered" ></span>closed comment"),-1)}return-1;default:if("CDATA["==e.substr(t+3,6)){var o=e.indexOf("]]&gt;",t+9)</span>;</span>retur<span class="cstat-no" title="statement not covered" >n n.startCDATA(<span class="cstat-no" title="statement not covered" ></span>),n.characters(e,t+9,o-t-9),n.endCDATA(),o+3}var a=p(e,t),s=a.length;if(s&gt;1&amp;&amp;/!doct</span>ype/i<span class="cstat-no" title="statement not covered" >.test(a[0][0]))<span class="cstat-no" title="statement not covered" ></span>{var u=a[1][0],l=s&gt;3&amp;&amp;/^public$/i.tes<span class="cstat-no" title="statement not covered" >t(a[2][0])&amp;&amp;a[3][0],c=s&gt;4&amp;&amp;a[4][0],f=a[s-1<span class="cstat-no" title="statement not covered" >]</span></span>;return n.startDTD(u,l&amp;&amp;<span class="cstat-no" title="statement not covered" >l.replace(/<span class="cstat-no" title="statement not covered" >^(['"])(.*?)\1$/,"$2"),</span></span></span>c&amp;&amp;c.repl<span class="fstat-no" title="function not covered" >ac</span>e(/^(['"])(<span class="cstat-no" title="statement not covered" >.*?)\1$/,"$2")),n.endDTD(),f.index+f[0].len<span class="cstat-no" title="statement not covered" >gth}}return-1}function f</span>(e<span class="cstat-no" title="statement not covered" >,t,n){var r=e.index<span class="cstat-no" title="statement not covered" ></span>Of("?&gt;",t);if(r){v<span class="cstat-no" title="statement not covered" >ar i=e.substring(t,r).match(/^&lt;\?(\S*)\s*([\s\S]*?)\s*$/);if(i){i[0].length;return n.processingInstruction(i[1],i[2]<span class="cstat-no" title="statement not covered" ></span></span>)</span>,r+2}return</span>-1}return<span class="fstat-no" title="function not covered" >-1</span>}function h(e){<span class="cstat-no" title="statement not covered" >}func<span class="cstat-no" title="statement not covered" ></span>tion d(e,t){return e.__proto__=t,e}function p(e,t){var n,r=[],i=/'[^']+'|"[^"]+"|[^\s&lt;&gt;\/</span>=]+=?|(\/<span class="fstat-no" title="function not covered" >?\</span>s*&gt;|&lt;<span class="cstat-no" title="statement not covered" >)/g;for(i.lastI<span class="cstat-no" title="statement not covered" >ndex=t,i.ex</span></span>ec(e);n=i<span class="fstat-no" title="function not covered" >.e</span>xec(e);)if(r.pu<span class="cstat-no" title="statement not covered" >sh(n),n[1])ret<span class="cstat-no" title="statement not covered" ></span>urn r}var v=/[A-Z_<span class="cstat-no" title="statement not covered" >a-z\xC0-\xD6\xD8-\xF6\u00F8-\u<span class="cstat-no" title="statement not covered" >02FF\u0370-\u037D\u03<span class="cstat-no" title="statement not covered" ></span>7F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF<span class="cstat-no" title="statement not covered" ></span>\</span>uFDF0-\uF</span>FFD]/,g<span class="cstat-no" title="statement not covered" >=new RegExp("[\\-\\.0-9"+v.source.sl<span class="cstat-no" title="statement not covered" >ice(1,-1)+"\\u00B7\\u<span class="cstat-no" title="statement not covered" ></span>0300-\\u036F\\u203F-\\u2040]"),y=new RegExp("^"+v.source+g.source+</span>"</span>*(?::<span class="cstat-no" title="statement not covered" >"+v.sou</span>rc<span class="cstat-no" title="statement not covered" >e+g.sourc<span class="cstat-no" title="statement not covered" ></span>e+"*)?$"),m=0,b=1,w=2,x=3,_=4,k=5,T=6,E=7<span class="cstat-no" title="statement not covered" >;n.proto</span>ty<span class="cstat-no" title="statement not covered" >pe={parse:function(e,t,n){var i=this.dom</span>Bu<span class="cstat-no" title="statement not covered" >ilder;i.start</span>Do<span class="cstat-no" title="statement not covered" >cument(<span class="cstat-no" title="statement not covered" ></span>),l(t,t={}),r(e,t,n,i,this.errorHandler),i.endDocument()}},h.prototype={setTagName:function(e){if(!y.test(e))throw new Error("i</span>n<span class="cstat-no" title="statement not covered" ></span>v</span>alid tagN</span>ame:"+e);<span class="fstat-no" title="function not covered" >th</span>is.tagName=e}<span class="cstat-no" title="statement not covered" >,add:function(e,t,<span class="cstat-no" title="statement not covered" ></span>n){if(!y.tes<span class="cstat-no" title="statement not covered" >t(e))throw new Error("invalid attribute:"+e);this[thi<span class="cstat-no" title="statement not covered" ></span>s.leng<span class="cstat-no" title="statement not covered" >th++]={qName<span class="cstat-no" title="statement not covered" >:</span>e,value:t,offset:n}},length:0,getLocalName:fun<span class="cstat-no" title="statement not covered" ></span>c</span>tion(e){r<span class="cstat-no" title="statement not covered" ></span>e</span>turn this</span>[e].local<span class="fstat-no" title="function not covered" >Na</span>me},getLocato<span class="fstat-no" title="function not covered" >r:</span>funct<span class="cstat-no" title="statement not covered" >ion(e){return this[e].lo</span>cator},ge<span class="fstat-no" title="function not covered" >tQ</span>Name:function<span class="cstat-no" title="statement not covered" >(e)</span>{r<span class="cstat-no" title="statement not covered" >eturn this[e].qName},getURI:function(e){retur<span class="cstat-no" title="statement not covered" ></span>n this[e].uri},getValue:function(e){retur<span class="cstat-no" title="statement not covered" >n this[e].value}},<span class="cstat-no" title="statement not covered" >d({},d.pro</span></span></span>totype<span class="cstat-no" title="statement not covered" >)instanceof d||(d=function(e,t){function n(){}n.prototype=t,n=new n;for(t in e)n[t]=e[t];return n}),t.XMLReader=n},function(e,t){function n(e,t){fo</span>r(<span class="cstat-no" title="statement not covered" >var n in e)t[n]=e[n]}function r(e,t){function r(){}var i=e.prototype;if(Object.create){</span>va<span class="cstat-no" title="statement not covered" >r o=Object.create(t.prototype);i.__proto__=o}i instanceof t||(r.pro</span>to<span class="cstat-no" title="statement not covered" >ty</span>pe<span class="cstat-no" title="statement not covered" >=t</span>.p<span class="cstat-no" title="statement not covered" >ro</span>to<span class="cstat-no" title="statement not covered" >ty</span>pe<span class="cstat-no" title="statement not covered" >,r</span>=n<span class="cstat-no" title="statement not covered" >ew</span> r<span class="cstat-no" title="statement not covered" >,n</span>(i<span class="cstat-no" title="statement not covered" >,r<span class="cstat-no" title="statement not covered" ></span>),e.prototype=i=r),i.constructor!=e&amp;&amp;("function"!=typ<span class="fstat-no" title="function not covered" >eof e&amp;</span>&amp;console.erro<span class="cstat-no" title="statement not covered" >r("unknow Class:<span class="cstat-no" title="statement not covered" ></span>"+e),i.constructor=e)}function i(e,t){if(t instanceof Error)var n=t;else n</span>=this,Error.call(this,ie[e]),this.message=ie[e],Error.captur<span class="fstat-no" title="function not covered" >eStackTrace</span>&amp;&amp;E<span class="cstat-no" title="statement not covered" >rror.captureSt<span class="cstat-no" title="statement not covered" >ackTrace(this,i);return n.code=e,t&amp;&amp;(t<span class="cstat-no" title="statement not covered" >h</span></span>is.message=this</span>.message+": "+t),n}function o(){}functi<span class="fstat-no" title="function not covered" >on a</span>(e,t){t<span class="cstat-no" title="statement not covered" >his._node=e,th<span class="cstat-no" title="statement not covered" >is._refresh=t,s(this)}function s(e){var <span class="cstat-no" title="statement not covered" >t</span></span>=e._node._inc||e._node.ownerDocument._inc;if(e.</span>_inc!=t){var r=e._refresh(e._node);B(e,"length",r.length)<span class="fstat-no" title="function not covered" >,n(r,e),e._in</span>c=t<span class="cstat-no" title="statement not covered" >}}function u(){}function l</span>(e,t){for(var n=e.length;n--;)if(e[n]===t)retu<span class="fstat-no" title="function not covered" >rn n}functi</span>on <span class="cstat-no" title="statement not covered" >c(e,t,n,r){if(r?t[l(t,r)</span>]=n:t[t.length++]=n,e){n.ownerElement=e;var <span class="fstat-no" title="function not covered" >i=e.owner</span>Doc<span class="cstat-no" title="statement not covered" >ument;i&amp;&amp;(r&amp;&amp;m(i,e,r),</span>y(i,e,n))}}function f(e,t,n){var r=l(t,n);<span class="fstat-no" title="function not covered" >if(!(r&gt;</span>=0)<span class="cstat-no" title="statement not covered" >)throw i(ae,new Erro</span>r(e.tagName+"@"+n));for(var o=t.length-1;r&lt;o<span class="fstat-no" title="function not covered" >;)t[r]=t[</span>++r<span class="cstat-no" title="statement not covered" >];if(t.length=o,e){var</span> a=e.ownerDocument;a&amp;&amp;(m(a,e,n),n.ownerElement=null)}}function h(e){if<span class="fstat-no" title="function not covered" >(t</span>his._features=<span class="fstat-no" title="function not covered" >{}</span>,e)<span class="cstat-no" title="statement not covered" >for(var t in e)this._fea<span class="cstat-no" title="statement not covered" >t</span>ures=e[t]}<span class="cstat-no" title="statement not covered" >function d<span class="cstat-no" title="statement not covered" >(</span></span>){}functi</span>on p(e){return"&lt;"</span>=<span class="fstat-no" title="function not covered" >=e</span>&amp;&amp;"&amp;lt;"||"&gt;"==e&amp;&amp;"&amp;g<span class="fstat-no" title="function not covered" >t;</span>"||"&amp;<span class="cstat-no" title="statement not covered" >"==e&amp;&amp;"&amp;amp;"||<span class="cstat-no" title="statement not covered" >'"'==e&amp;&amp;"&amp;q</span></span>uot;"||"&amp;<span class="fstat-no" title="function not covered" >#"</span>+e.charCodeAt(<span class="fstat-no" title="function not covered" >)+</span>";"}funct<span class="cstat-no" title="statement not covered" >ion v(e,t){i<span class="cstat-no" title="statement not covered" ></span>f(t(e))return!0;if(e=e.f<span class="cstat-no" title="statement not covered" >irstChild)do if(v(e,t))retu<span class="cstat-no" title="statement not covered" ></span>rn!0;while(e=e.<span class="cstat-no" title="statement not covered" ></span>n</span>extSibling)}function g(){}function y(e,t,n){e&amp;&amp;e._inc++;var r=n.namespaceURI;"http://www.w3.org/2000/xmlns/"==r&amp;&amp;(t._nsMap[n.prefix?n.localName:""]=n.value)}function </span>m(e,t,n,r<span class="fstat-no" title="function not covered" >){</span>e&amp;&amp;e.<span class="cstat-no" title="statement not covered" >_inc++;var i=n.namespaceURI;<span class="cstat-no" title="statement not covered" >"h</span>ttp:/<span class="cstat-no" title="statement not covered" >/www.w3.org/2000/xmlns/"==i&amp;&amp;delete t._nsMap[n.prefix?n.localName:""]}function b(e,t,n){if(e&amp;&amp;e._inc){e._i<span class="cstat-no" title="statement not covered" >n</span></span>c++;var r=t.childNodes;if(n)r[r.length++]=n;else{for(var</span> i=t.firs<span class="fstat-no" title="function not covered" >tC</span>hild,o=0;i;)<span class="fstat-no" title="function not covered" >r[</span>o++]=<span class="cstat-no" title="statement not covered" >i,i=i.nextSibling;r.length=o}}}functio</span>n w(e,t){<span class="fstat-no" title="function not covered" >va</span>r n=t.pre<span class="cstat-no" title="statement not covered" >viousSibling,r=t.nextSibling;return n?n.n<span class="cstat-no" title="statement not covered" ></span>extSibling=r:e.first<span class="cstat-no" title="statement not covered" >Child=r,r?r.previous<span class="cstat-no" title="statement not covered" ></span>Sibling=n:e.lastChild=n,b(e.ownerDocumen</span>t</span>,e),t}fun<span class="fstat-no" title="function not covered" >ct</span>ion x(e,t,n)<span class="fstat-no" title="function not covered" >{v</span>ar r=<span class="cstat-no" title="statement not covered" >t.parentNode;if(r&amp;&amp;r.rem<span class="cstat-no" title="statement not covered" >oveChild(t),<span class="cstat-no" title="statement not covered" >t.nodeType</span></span></span>===te){va<span class="fstat-no" title="function not covered" >r </span>i=t.first<span class="cstat-no" title="statement not covered" >Child;if(null==i)return t;var o=t.la<span class="cstat-no" title="statement not covered" >stChild}else i=o=t</span>;var <span class="cstat-no" title="statement not covered" >a=n?n.previousSi<span class="cstat-no" title="statement not covered" ></span>bling:e.lastChild;i.previou</span>s</span>Sibling=a<span class="fstat-no" title="function not covered" >,o</span>.nextSibling=<span class="cstat-no" title="statement not covered" >n,a?a.n<span class="cstat-no" title="statement not covered" ></span>extSibling=<span class="cstat-no" title="statement not covered" >i:e.firstChild=i,null==n?e.lastChild=o:<span class="cstat-no" title="statement not covered" >n</span></span>.previousSibling=o;do i.p<span class="cstat-no" title="statement not covered" >arentNode=e;<span class="cstat-no" title="statement not covered" >w</span></span>hile(i!==o&amp;&amp;(i=i.nextS<span class="cstat-no" title="statement not covered" >ibling));return <span class="cstat-no" title="statement not covered" ></span>b(e.ownerDocument||e,e),t.nodeType=</span>=</span>te&amp;&amp;(t.fi<span class="fstat-no" title="function not covered" >rs</span>tCh<span class="cstat-no" title="statement not covered" >ild=t.lastChild=null),t<span class="cstat-no" title="statement not covered" >}function _(e,t<span class="cstat-no" title="statement not covered" >){var n=t.parentNode;</span></span></span>if(n){var<span class="fstat-no" title="function not covered" > r</span>=e.lastChild<span class="fstat-no" title="function not covered" >;n</span>.re<span class="cstat-no" title="statement not covered" >moveChild(t);var r=e.lastChild}var r=e.lastChild;return t.parentNode=e,t.previousSibling=r,t.nextS</span>ibling=nu<span class="fstat-no" title="function not covered" >ll</span>,r?r.<span class="cstat-no" title="statement not covered" >nextSibl<span class="cstat-no" title="statement not covered" >ing=t:e.f<span class="cstat-no" title="statement not covered" >i</span></span>rstChild=t,e.last<span class="cstat-no" title="statement not covered" >Chi<span class="cstat-no" title="statement not covered" >ld=t,b(e.o<span class="cstat-no" title="statement not covered" >wnerDocume</span></span>nt,e,t),t}function k(){</span></span>this._nsM<span class="fstat-no" title="function not covered" >ap</span>={}}function<span class="fstat-no" title="function not covered" > T</span>(){}fun<span class="cstat-no" title="statement not covered" >ction E(){}fu</span>nctio<span class="cstat-no" title="statement not covered" >n S(){}function<span class="cstat-no" title="statement not covered" ></span> N(){}function R(){}function j(){}function O(){}function I(){}function C(){}funct</span>ion A(){}<span class="fstat-no" title="function not covered" >fu</span>nction L(<span class="cstat-no" title="statement not covered" >){}function D</span>(){}f<span class="cstat-no" title="statement not covered" >unction P(e,t){<span class="cstat-no" title="statement not covered" ></span>var n=[],r=9==this.nodeType?this.documentElement:this,i=r.prefix,o=r.namespace</span>URI;if(o&amp;<span class="fstat-no" title="function not covered" >&amp;n</span>ull==i)<span class="cstat-no" title="statement not covered" >{var i=r.looku<span class="cstat-no" title="statement not covered" >pPrefix(o)</span>;if(n<span class="cstat-no" title="statement not covered" >ull==i)var a=<span class="cstat-no" title="statement not covered" ></span>[{nam<span class="cstat-no" title="statement not covered" >espace:o,prefix:n</span>ull}<span class="cstat-no" title="statement not covered" >]}return M(this,n,e,t,a),n.joi<span class="cstat-no" title="statement not covered" >n("")}function U(e,t,n){v<span class="cstat-no" title="statement not covered" >a</span></span>r r=e.prefi</span>x</span>|</span>|"",i=e.n<span class="fstat-no" title="function not covered" >am</span>espaceURI;i<span class="cstat-no" title="statement not covered" >f(!r&amp;&amp;!i)return!1;</span>if<span class="cstat-no" title="statement not covered" >("xml"===r&amp;&amp;"h<span class="cstat-no" title="statement not covered" ></span>ttp://www.w3.org/XML/1998/namespace"===i||"http://www.w3.org/2000/xmlns/"==i)return!1;for(var o=n.le</span>ngth;o--;<span class="fstat-no" title="function not covered" >){</span>var a=n[o];if<span class="cstat-no" title="statement not covered" >(a.prefix==r)<span class="cstat-no" title="statement not covered" ></span>return a.namespace!=i}return!0}function M(e,t,<span class="cstat-no" title="statement not covered" >n,r,i){if(r){<span class="cstat-no" title="statement not covered" ></span>if(e=r(e),!<span class="cstat-no" title="statement not covered" >e)return;i</span></span>f("st<span class="cstat-no" title="statement not covered" >ring"==typeo</span>f e)re<span class="cstat-no" title="statement not covered" >turn vo</span></span>id t.<span class="cstat-no" title="statement not covered" >push(e)}switch(e.nodeType){case <span class="cstat-no" title="statement not covered" ></span>W:i||(i=[]);var o=(i.length,e.attributes),a=o.length,s=e.firstChild,u=e.tagName;n=z===e.namespaceURI||n,t.push(<span class="cstat-no" title="statement not covered" >"</span>&lt;"<span class="cstat-no" title="statement not covered" >,u);for(var l=0;</span>l&lt;a;l++){var c=o.item(l);"xmlns<span class="cstat-no" title="statement not covered" >"</span>==c.prefix?i.push({prefix:c.localName,namespace:c.value}):"xmlns"==c.nodeName&amp;&amp;i.</span>push({pre<span class="fstat-no" title="function not covered" >fi</span>x:"",namesp<span class="cstat-no" title="statement not covered" >ace:c.value})<span class="cstat-no" title="statement not covered" ></span>}for(var l=0<span class="cstat-no" title="statement not covered" >;l&lt;a;l++){va<span class="cstat-no" title="statement not covered" ></span>r c=o.item(l);if(U</span>(c,n,<span class="cstat-no" title="statement not covered" >i)){var f=c.</span>pr</span>efix|<span class="cstat-no" title="statement not covered" >|"",h=c.name<span class="cstat-no" title="statement not covered" ></span>spaceURI,d=f?" xmlns:"+f:" xmlns";t.push(d,'="',h,'"'),i.push({prefix:f,namespace:h})}M(c,t,n,r,i)}if(U(e,n,i)){var f=e.prefix||"",h=e</span>.namespac<span class="fstat-no" title="function not covered" >eU</span>RI<span class="cstat-no" title="statement not covered" >,d=f?" xmlns:"+f</span>:" xmlns"<span class="fstat-no" title="function not covered" >;t</span>.push(d,'="'<span class="fstat-no" title="function not covered" >,h</span>,'"'),i.push<span class="fstat-no" title="function not covered" >({</span>prefix:f,nam<span class="fstat-no" title="function not covered" >es</span>pace:h})}if(<span class="fstat-no" title="function not covered" >s|</span>|n&amp;&amp;!/^(?:me<span class="fstat-no" title="function not covered" >ta</span>|link|img|br<span class="fstat-no" title="function not covered" >|h</span>r|input)$/i.<span class="fstat-no" title="function not covered" >te</span>st(u)){if(t.<span class="fstat-no" title="function not covered" >pu</span>sh("&gt;"),n&amp;&amp;/<span class="fstat-no" title="function not covered" >^s</span>cript$/i.tes<span class="fstat-no" title="function not covered" >t(</span>u))for(;s;)s<span class="fstat-no" title="function not covered" >.d</span>ata?t.push(s<span class="fstat-no" title="function not covered" >.d</span>ata):M(s,t,<span class="cstat-no" title="statement not covered" >n,r</span>,i<span class="cstat-no" title="statement not covered" >),s=s.nextSibling;else for(;s;)M(s,t,n,r,i)</span>,s<span class="cstat-no" title="statement not covered" >=s.nextSi</span>bl<span class="cstat-no" title="statement not covered" >ing;t.push("&lt;/"<span class="cstat-no" title="statement not covered" ></span>,u,"&gt;")}else t.push("<span class="cstat-no" title="statement not covered" >/&gt;");return;case Z<span class="cstat-no" title="statement not covered" ></span>:case te:for(var <span class="cstat-no" title="statement not covered" >s=e.firstChild;s;)M(s,t,n,r,</span>i<span class="cstat-no" title="statement not covered" ></span>)</span>,s=s.nextSibling;return;case X:ret</span>urn t.pus<span class="fstat-no" title="function not covered" >h(</span>" ",e.name,'=<span class="cstat-no" title="statement not covered" >"',e.value.re</span>pl<span class="cstat-no" title="statement not covered" >ace(/[&lt;&amp;"]/g,p)<span class="cstat-no" title="statement not covered" ></span>,'"');case<span class="cstat-no" title="statement not covered" > J:return<span class="cstat-no" title="statement not covered" > </span></span>t.push(e.data.replace(/[&lt;&amp;]/g,p));case G:return t.push("&lt;![CDATA[",e.data,"]]&gt;");case K:retu<span class="cstat-no" title="statement not covered" >rn t.push<span class="cstat-no" title="statement not covered" >(</span></span>"&lt;!--",e.data,"--&gt;");case ee:v<span class="cstat-no" title="statement not covered" >ar v=<span class="cstat-no" title="statement not covered" ></span>e.publicId,g=e.<span class="cstat-no" title="statement not covered" >systemId;if(t.push("&lt;!D<span class="cstat-no" title="statement not covered" ></span></span>O</span>CTYPE ",e</span>.name),v)<span class="fstat-no" title="function not covered" >t.</span>push(' PUBL<span class="cstat-no" title="statement not covered" >IC "',<span class="cstat-no" title="statement not covered" >v),g&amp;&amp;"."!=g&amp;<span class="cstat-no" title="statement not covered" >&amp;t.push<span class="cstat-no" title="statement not covered" >(</span></span>'" "',g),t.push('"&gt;')<span class="cstat-no" title="statement not covered" >;else if(g&amp;&amp;"."!=g)t.pu<span class="cstat-no" title="statement not covered" ></span></span>s</span>h(' SYSTEM "',g,'"&gt;');els<span class="cstat-no" title="statement not covered" >e{var y=e.i</span>nterna<span class="cstat-no" title="statement not covered" >lSubset;y&amp;&amp;t.push(" ["</span>,y,<span class="cstat-no" title="statement not covered" >"]"),t.pu</span>sh<span class="cstat-no" title="statement not covered" >("&gt;")}return;</span>ca<span class="cstat-no" title="statement not covered" >se Q:retur<span class="cstat-no" title="statement not covered" ></span>n t.push("&lt;?",e.target," ",e.data,"?&gt;"<span class="cstat-no" title="statement not covered" >)</span>;case $:return t.push("&amp;",<span class="cstat-no" title="statement not covered" >e.nodeName<span class="cstat-no" title="statement not covered" ></span>,";");default:t.push("??",e.nodeName)}}function q(e,t,n){var r;switch(t.nodeType){case W:r=t.cloneNode(!1),r.ownerDocument=e;<span class="cstat-no" title="statement not covered" ></span>c</span>ase te:break;case X:n=!0}i<span class="cstat-no" title="statement not covered" >f(r||(r=t.<span class="cstat-no" title="statement not covered" ></span>cloneNode(!1)),r.ow<span class="cstat-no" title="statement not covered" >nerDocument=e</span>,r<span class="cstat-no" title="statement not covered" >.parentNode=nul</span>l,<span class="cstat-no" title="statement not covered" >n)for(var i=t.firstChil<span class="cstat-no" title="statement not covered" ></span>d;i;)r.appendChild(q(e,i,n)),i=i.nextSibling;return r<span class="cstat-no" title="statement not covered" ></span>}</span>function F(e,<span class="cstat-no" title="statement not covered" ></span>t</span>,n){var r=new t.co<span class="cstat-no" title="statement not covered" >nstructor;for</span>(v<span class="cstat-no" title="statement not covered" >ar i in t){var </span>a=<span class="cstat-no" title="statement not covered" >t[i];"object"!=typeof a<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;a!=r[i]&amp;&amp;(r[i]=a)}switch(t.childNodes&amp;&amp;(r.childNode<span class="cstat-no" title="statement not covered" ></span>s</span>=new o),r.ownerDocument=e,r.nodeType){case W:var s=t.<span class="cstat-no" title="statement not covered" >attributes,l=r.attributes=new u,c=s.le<span class="cstat-no" title="statement not covered" >ngth;l._<span class="cstat-no" title="statement not covered" >ownerElement=r;for(var f=0;f&lt;c;f++)r.setAttributeNod</span></span>e(F(<span class="cstat-no" title="statement not covered" >e,s.item<span class="cstat-no" title="statement not covered" >(f),!0));break;case X:n=!0}if<span class="cstat-no" title="statement not covered" >(</span></span></span>n)for(var h=t.first</span>Child<span class="cstat-no" title="statement not covered" >;h;)r.appendC<span class="cstat-no" title="statement not covered" >h</span></span>ild(F(e</span>,h,n)),h=h.nex<span class="cstat-no" title="statement not covered" >tSibling;return r}function<span class="cstat-no" title="statement not covered" > B(e,t,n){e[t]=n}function H(e<span class="cstat-no" title="statement not covered" >)</span></span>{switch</span>(e.nod<span class="cstat-no" title="statement not covered" >eType){case W:case te:var t=[];for(e=e.firstChild;e;)7!==e.nodeT</span>ype&amp;&amp;8<span class="cstat-no" title="statement not covered" >!==e.nodeType&amp;&amp;t.push(H(e)),e=e.nextSiblin</span>g;retu<span class="cstat-no" title="statement not covered" >rn t.join("");default:return e.nodeValue}</span>}var z<span class="cstat-no" title="statement not covered" >="http://www.w3.org/1999/xhtml",V={}</span>,W=V.ELEMENT_<span class="cstat-no" title="statement not covered" >NODE=1,X=V.</span>AT<span class="cstat-no" title="statement not covered" >TRIBUTE_NOD<span class="cstat-no" title="statement not covered" ></span>E=2,J=V.TEXT_NODE=3,G=V.CDATA_SEC<span class="cstat-no" title="statement not covered" >TION_NODE=4,$=V.ENTITY_REFERENCE_NODE=5,Y=V.ENTITY_NODE=6,Q=V.P</span>ROCE<span class="cstat-no" title="statement not covered" >SSING_INSTRUC<span class="cstat-no" title="statement not covered" >TION_NODE=7,K=V.COMMENT_NODE</span>=8,Z=V.DOC<span class="cstat-no" title="statement not covered" >UMENT_NODE=9,ee=V<span class="cstat-no" title="statement not covered" ></span>.DOCUMENT_TYPE_NODE=10,te=V.DOCUMEN<span class="cstat-no" title="statement not covered" ></span>T</span></span>_FRAGME</span>NT_NOD<span class="cstat-no" title="statement not covered" >E=11,ne=V.NOTATION_NODE=12,re={},ie={},oe=(re.</span>INDEX_<span class="cstat-no" title="statement not covered" >SIZE_ERR=(ie[1]="Index size error",</span>1),re.D<span class="cstat-no" title="statement not covered" >OMSTRING_SIZE_ERR=(ie[2]=</span>"</span>DOMString<span class="fstat-no" title="function not covered" > s</span>ize error",2)<span class="cstat-no" title="statement not covered" >,re.HIERARCHY_REQUEST_ERR=<span class="cstat-no" title="statement not covered" >(ie[3]="Hierarchy request error",3)),</span>ae=(re.<span class="cstat-no" title="statement not covered" >WRONG_D</span>OCUMEN<span class="cstat-no" title="statement not covered" >T_ERR=<span class="cstat-no" title="statement not covered" ></span>(</span>ie[4]="Wrong document",4),re.INVALID_CHARACTER_ERR=(ie[5]="Inva<span class="cstat-no" title="statement not covered" >lid character",5),re.NO_DA<span class="cstat-no" title="statement not covered" >TA_ALLOWED_ERR=(ie[6]="No data allowed",<span class="cstat-no" title="statement not covered" >6</span></span></span>),re.NO_M</span>ODIFICATI<span class="fstat-no" title="function not covered" >ON</span>_ALLOWED_ERR=<span class="cstat-no" title="statement not covered" >(ie[7]="No modificat<span class="cstat-no" title="statement not covered" ></span>ion allowed",7),re.NOT<span class="cstat-no" title="statement not covered" >_FOUN<span class="cstat-no" title="statement not covered" ></span>D_ERR=(ie[8]="Not found",8)),se=(re.NOT<span class="cstat-no" title="statement not covered" ></span>_</span>SUPPORTED_ERR=(ie[9]="Not supported",9),re.INUSE_ATTRIBUTE_ERR=(ie[10]="Attribute in u<span class="cstat-no" title="statement not covered" >se",10));re.I</span>NV<span class="cstat-no" title="statement not covered" >ALID_STATE_ERR=(ie[11</span>]=<span class="cstat-no" title="statement not covered" >"Invalid <span class="cstat-no" title="statement not covered" ></span>state",11),re.SYNT<span class="cstat-no" title="statement not covered" >A</span>X_ERR=(ie[12]="Synt<span class="cstat-no" title="statement not covered" >ax error",12),re.INVALID_MODIFICATION_<span class="cstat-no" title="statement not covered" >E</span></span>RR=(ie</span>[13]="<span class="cstat-no" title="statement not covered" >Invali<span class="cstat-no" title="statement not covered" ></span>d</span> mod<span class="cstat-no" title="statement not covered" >ification",13),re.NAMESPAC<span class="cstat-no" title="statement not covered" >E_ERR=(ie[14]="Invalid namespace",14),re<span class="cstat-no" title="statement not covered" >.</span></span></span>INVALID_A</span>CCESS_ERR<span class="fstat-no" title="function not covered" >=(</span>ie[15]=<span class="cstat-no" title="statement not covered" >"Invalid</span> access",<span class="fstat-no" title="function not covered" >15</span>);i<span class="cstat-no" title="statement not covered" >.prototype=Error.prototype,n(re,i),o.pro<span class="cstat-no" title="statement not covered" >tot<span class="cstat-no" title="statement not covered" ></span>ype={length:0,item:fun<span class="cstat-no" title="statement not covered" >ction(e){return this[e]||null},toString:function(e,t){for(var<span class="cstat-no" title="statement not covered" > </span></span>n=[],r=0;r&lt;this.le</span>ngth;r+<span class="cstat-no" title="statement not covered" >+)M(this[r],n,e,t);r</span>e</span>turn n<span class="cstat-no" title="statement not covered" >.join("")}},a.prototype.item=fu</span>nc<span class="cstat-no" title="statement not covered" >tio</span>n(<span class="cstat-no" title="statement not covered" >e){return s(this)</span>,t<span class="cstat-no" title="statement not covered" >his[e]},r(a,o),u.pr</span>ot<span class="cstat-no" title="statement not covered" >otype={length:</span>0,<span class="cstat-no" title="statement not covered" >item:o.prototype.item,g</span>et<span class="cstat-no" title="statement not covered" >NamedItem:function(e){for(</span>va<span class="cstat-no" title="statement not covered" >r t=this.length;</span>t-<span class="cstat-no" title="statement not covered" >-;){var n=this[t];if(n.nodeName=</span>=e<span class="cstat-no" title="statement not covered" >)return n}},setNa</span>me<span class="cstat-no" title="statement not covered" >dItem:function(e){</span>var<span class="cstat-no" title="statement not covered" > t=e.ownerElement;if(t&amp;&amp;</span>t!=<span class="cstat-no" title="statement not covered" >this._ownerElement)throw new</span> i(<span class="cstat-no" title="statement not covered" >se);var n=this.getN</span>ame<span class="cstat-no" title="statement not covered" >dIt</span>em(<span class="cstat-no" title="statement not covered" >e.n</span>odeN<span class="cstat-no" title="statement not covered" >ame);return c(this._ownerElement,this,e,n),n},setNamedItemNS:function(e){var t,n=e.ownerElement;if(n&amp;&amp;n!=this._ownerElement)throw new i(se);return t=this.getNamedI</span>temNS<span class="cstat-no" title="statement not covered" >(e.namespaceURI,e.localName),c(this._ownerElement,this,e,t),t},removeNamedItem:function(e){var t=this.getNamedItem(e);return f(this._ownerElement,this,t),t},removeNamedItemNS:function(e,t){var n=this.getNamedItemNS(e,t);return f(this._ownerElement,this,n),n},ge</span>tName<span class="cstat-no" title="statement not covered" >dItemNS:function(e,t){for(var n=this.length;n--;){var r=this[n];if(r.localName==t&amp;&amp;r.namespaceURI==e)</span>r<span class="cstat-no" title="statement not covered" >eturn r}return null}},h.prototype={hasFeature:function(e,t){var n=this._features[e.toLowerCase()];return!(!n||t&amp;&amp;!(t in n))},createDocument:function(e,t,n){var r=new g;if(r.implementation=this,r.childNodes=new o,r.doctype=n,n&amp;&amp;r.appendChild(n),t){var i=<span class="cstat-no" title="statement not covered" >r</span>.createElementNS(e,t);r.appendChild(i)}return r},createDocumentType:function(e,t,n){var r=new j;<span class="fstat-no" title="function not covered" >retur</span>n r<span class="cstat-no" title="statement not covered" >.name=e,r.nodeName=e,r</span>.publicId=t,r.systemId=n,r}},d.prototype={fi<span class="fstat-no" title="function not covered" >rstChild:</span>null,<span class="cstat-no" title="statement not covered" >lastChild:null,previousSibling:null<span class="cstat-no" title="statement not covered" >,nextSibling:null<span class="cstat-no" title="statement not covered" >,</span></span>attributes:null,pa</span>rentNode:null,child<span class="fstat-no" title="function not covered" >No</span>des:null,o<span class="cstat-no" title="statement not covered" >wnerDocument:null,nodeVa</span>lue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(e,t){return x(this,e,t)<span class="fstat-no" title="function not covered" >},replaceChil</span>d:f<span class="cstat-no" title="statement not covered" >unction(e,t){this.insertBefore(e,t<span class="cstat-no" title="statement not covered" >),t&amp;&amp;thi<span class="cstat-no" title="statement not covered" ></span>s.removeChild(t)}<span class="cstat-no" title="statement not covered" >,removeChi</span></span>l</span>d:function(e){return w(this,e)},appendChild:func<span class="fstat-no" title="function not covered" >tion(e){retur</span>n this.in<span class="cstat-no" title="statement not covered" >sertBefore(e,nu<span class="cstat-no" title="statement not covered" ></span>ll)},hasChildNodes:function(<span class="cstat-no" title="statement not covered" >){return null!=th</span></span>is.fi<span class="cstat-no" title="statement not covered" >rstChild},cloneNode:function(e<span class="cstat-no" title="statement not covered" ></span>){return F(this.ownerDocument||this,this,</span>e)},normalize:function(){for(var e=this.firstChild<span class="fstat-no" title="function not covered" >;e;){var t=e.ne</span>xtSibling;t<span class="cstat-no" title="statement not covered" >&amp;&amp;t.nodeType==J<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;e.nodeType==J?(this.remove<span class="cstat-no" title="statement not covered" >Child(t),e.appen<span class="cstat-no" title="statement not covered" >d</span></span>Data(t.data)):(e.normalize(),e=t)}},isSupported:function(e,t){return this.ownerDocument.im</span>plementation.hasFeature(e,t)},hasAttributes:functio<span class="fstat-no" title="function not covered" >n(){return this.</span>attribute<span class="cstat-no" title="statement not covered" >s.length&gt;0},lookupPre<span class="cstat-no" title="statement not covered" ></span>fix:function(e){for(var t=this;t;){var </span>n=t._nsMap;if(n)for(var r in n)if(n[r]==e)return r;t=<span class="fstat-no" title="function not covered" >t.nodeType==X?t.ow</span>nerDocument<span class="cstat-no" title="statement not covered" >:t.parentNode}return null<span class="cstat-no" title="statement not covered" ></span>},lookupNamespaceURI:function(e){for(va</span>r t=this;t;){var n=t._nsMap;if(n&amp;&amp;e in n)return n[<span class="fstat-no" title="function not covered" >e];t=t.nodeType</span>==X?t<span class="cstat-no" title="statement not covered" >.ownerDocument:t.parentNode}return<span class="cstat-no" title="statement not covered" > null},i<span class="cstat-no" title="statement not covered" ></span>sDefaultNamespace:function(e){var t=t<span class="cstat-no" title="statement not covered" >his.lookup<span class="cstat-no" title="statement not covered" ></span></span>P</span>refix(e);ret</span>urn null==t}},n(V,d),n(V,d.prototype),g.prototype={nodeName:<span class="fstat-no" title="function not covered" >"#document"</span>,nodeType:Z<span class="cstat-no" title="statement not covered" >,doctype:null,documentElement:nu<span class="cstat-no" title="statement not covered" ></span>ll,_inc:1,insertBefore:func</span>tion(e,t){if(e.nodeType==te){for(var n=e.firstChil<span class="fstat-no" title="function not covered" >d;n;){var r=n.n</span>extSibling;th<span class="cstat-no" title="statement not covered" >is.inser<span class="cstat-no" title="statement not covered" ></span>tBefore(n,t),n=r}return e}return null==this.documentElement&amp;&amp;e.nodeType==W&amp;&amp;(this.docum<span class="cstat-no" title="statement not covered" >entElement=e),x(this,e,<span class="cstat-no" title="statement not covered" ></span>t),e.ownerDocument<span class="cstat-no" title="statement not covered" ></span>=</span>this,e},r</span>emoveChild:function(e){return this.documentElement==e&amp;<span class="fstat-no" title="function not covered" >&amp;(this.documentElem</span>ent=null),w(t<span class="cstat-no" title="statement not covered" >his,e)},<span class="cstat-no" title="statement not covered" ></span>importNode:function(e,t){return q(this,e,t)},getElementByI</span>d:function(e){var t=null;return v(this.documentElement,function(n){if(n.nodeType==W&amp;&amp;n.getAttribute("id")==e)return t=n,!0}),t},createElement:function(e){var t=new k;t.ownerDocument=this,t.nodeName=e,t.tagName=e,t.childNodes=new o;var n=t.attributes=new u;re<span class="fstat-no" title="function not covered" >turn n._owner</span>Eleme<span class="cstat-no" title="statement not covered" >nt=t,t},createDocume</span>ntFragment:function(){var e=new A;return e.owner<span class="fstat-no" title="function not covered" >Document=this</span>,e.ch<span class="cstat-no" title="statement not covered" >ildNodes=new o,e},createTextNode:function(e){va</span>r t=new S;return t.ownerDocument=this,t.appendD<span class="fstat-no" title="function not covered" >ata(e),t},cr</span>eat<span class="cstat-no" title="statement not covered" >eComment:function(</span>e){var t=new N;return t.ownerDocument=this,t.ap<span class="fstat-no" title="function not covered" >pendData(e),</span>t},<span class="cstat-no" title="statement not covered" >createCDATASection:function(e){var</span> t=new R;return t.ownerDocument=this,t.appendData<span class="fstat-no" title="function not covered" >(e),t},createP</span>ro<span class="cstat-no" title="statement not covered" >cessingInstruction:function(e,</span>t){var n=new L;return n.ownerDocument=this,n.<span class="fstat-no" title="function not covered" >tagName=n.</span>tar<span class="cstat-no" title="statement not covered" >get=e,n.nodeValue=n.data=t,n},createAttribu</span>te:function(e){var t=new T;return t.ownerDocu<span class="fstat-no" title="function not covered" >ment=this,</span>t.<span class="cstat-no" title="statement not covered" >name=e,t.nodeName=e,t.localName=e,t.<span class="cstat-no" title="statement not covered" >specified=!0,t<span class="cstat-no" title="statement not covered" ></span>},createEntityReference:function(e){var t=new C;return t.ownerDocument=this,t.nodeName=e,t},crea</span>t</span>eElementNS:function(e,t){var n=new k,r=t.split(<span class="fstat-no" title="function not covered" >":"),i=n.att</span>ribut<span class="cstat-no" title="statement not covered" >es=new u;return n.childNodes=new o,n.ownerDocument=this,n.</span>nodeName=t,n.tagName=t,n.namespaceURI=e,2==r.leng<span class="fstat-no" title="function not covered" >th?(n.prefix=r</span>[0<span class="cstat-no" title="statement not covered" >],n.localName=r[1]):n.localName=t</span>,i._ownerElement=n,n},createAttributeNS:function<span class="fstat-no" title="function not covered" >(e,t){var n=n</span>ew <span class="cstat-no" title="statement not covered" >T,r=t.split(":");return n<span class="cstat-no" title="statement not covered" >.ownerDoc<span class="cstat-no" title="statement not covered" ></span>ument<span class="cstat-no" title="statement not covered" >=this,n.nodeNam<span class="cstat-no" title="statement not covered" >e=t,n.name=<span class="cstat-no" title="statement not covered" >t,n.names<span class="cstat-no" title="statement not covered" >p</span></span></span></span>aceURI=e,n.specified=!0,2==r.length?(n.prefix<span class="cstat-no" title="statement not covered" ></span>=</span>r[0],n.local</span>Name=r[1]):n.localName=t,n}},r(g,d),k.prototype={nodeT<span class="fstat-no" title="function not covered" >ype:W,hasAttribute:</span>fun<span class="cstat-no" title="statement not covered" >ction(e){return null!=thi<span class="cstat-no" title="statement not covered" >s.getAttr<span class="cstat-no" title="statement not covered" ></span>ibuteNode(e)}<span class="cstat-no" title="statement not covered" >,getAttribut<span class="cstat-no" title="statement not covered" >e</span></span>:function(e){var t=this.getAttributeNode(e);r<span class="cstat-no" title="statement not covered" ></span>e</span>turn t&amp;&amp;t.va</span>lue||""},getAttributeNode:function(e){return this.attr<span class="fstat-no" title="function not covered" >ibutes.getNamedItem</span>(e)},setA<span class="cstat-no" title="statement not covered" >ttribute:function(e,t<span class="cstat-no" title="statement not covered" ></span>){var n=this.own</span>erDocument.createAttribute(e);n.value=n.nodeValue=""+t,this.setAttributeNode(n)},removeAttribute:function(e){var t=this.getAttributeNode(e);t&amp;&amp;this.removeAttri<span class="fstat-no" title="function not covered" >buteNode(t)},</span>appen<span class="cstat-no" title="statement not covered" >dChild:function(e){<span class="cstat-no" title="statement not covered" >return e.nodeType===te?this.inser<span class="cstat-no" title="statement not covered" >tBefore(e,null<span class="cstat-no" title="statement not covered" ></span>):_(this,e)},setAttributeNod<span class="cstat-no" title="statement not covered" ></span>e</span>:function<span class="cstat-no" title="statement not covered" ></span>(</span>e){return this.attributes.setNamedItem(e)},setAttributeNodeNS:function(e){return this.attributes.setNamedItemN</span>S(e)},removeAttributeNode:function(e){return th<span class="fstat-no" title="function not covered" >is.attribute</span>s.r<span class="cstat-no" title="statement not covered" >emoveNamedItem(e.nodeName)},removeAttributeNS:function(e,t){var n=this.</span>getAttributeNodeNS(e,t);n&amp;&amp;this.removeAttribut<span class="fstat-no" title="function not covered" >eNode(n)},h</span>asAtt<span class="cstat-no" title="statement not covered" >ributeNS:function(e,</span>t){return null!=this.getAttributeNodeNS(e,t)},getA<span class="fstat-no" title="function not covered" >ttributeNS:func</span>tion(e,t)<span class="cstat-no" title="statement not covered" >{var <span class="cstat-no" title="statement not covered" ></span>n=this.getAttributeNodeNS(e,t)<span class="fstat-no" title="function not covered" >;r</span>eturn n&amp;&amp;n<span class="cstat-no" title="statement not covered" >.value||""},setAttributeNS:function(e,t,n)<span class="cstat-no" title="statement not covered" >{var r=this.own</span></span>erDoc</span>ument.createAttributeNS(e,t);r.value=r.nodeValue=<span class="fstat-no" title="function not covered" >""+n,this.setA</span>ttributeN<span class="cstat-no" title="statement not covered" >ode(r)},<span class="cstat-no" title="statement not covered" ></span>getAttributeNodeNS:function(e,t){return this.attributes.getNamedItem</span>NS(e,<span class="cstat-no" title="statement not covered" >t)},getElementsByTagN<span class="cstat-no" title="statement not covered" ></span>ame:function(e){return new a</span>(this,function(t){var n=[];return v(t,function(r){r===t||r<span class="fstat-no" title="function not covered" >.nodeType!=W||"*"!==e&amp;&amp;</span>r.tagNam<span class="cstat-no" title="statement not covered" >e!=e||n.<span class="cstat-no" title="statement not covered" ></span>push(r)}),n})},getElementsByTagNameNS:function(e,t){</span>return new a(this,function(n){var r=[];return v(n,<span class="fstat-no" title="function not covered" >function(i){i==</span>=n||i.nod<span class="cstat-no" title="statement not covered" >eType!==<span class="cstat-no" title="statement not covered" ></span>W||"*"!==e&amp;&amp;i.namespaceURI!==e||"*"!==t&amp;&amp;i.loca</span>lName!=t||r.push(i)}),r})}},g.prototype.getElemen<span class="fstat-no" title="function not covered" >tsByTagName=k.</span>prototype<span class="cstat-no" title="statement not covered" >.getElem<span class="cstat-no" title="statement not covered" ></span>entsByTagName,g.prototype.getElementsByTagNameN</span>S=k.prototype.getElementsByTagNameNS,r(k,d),T.prototyp<span class="fstat-no" title="function not covered" >e.nodeType=X,r(T,d)</span>,E.protot<span class="cstat-no" title="statement not covered" >ype={dat<span class="cstat-no" title="statement not covered" ></span>a:"",substringData:function(e,t){return this.da</span>ta.substring(e,e+t)},appendData:function(e){e=this.data+e,this.<span class="fstat-no" title="function not covered" >nodeValue=this.data=e,this.l</span>ength=e.len<span class="cstat-no" title="statement not covered" >gth},ins<span class="cstat-no" title="statement not covered" ></span>ertData:function(e,t){this.replaceData(e,0,t)},appendChild:function(e){th</span>row new Error(ie[oe])},deleteData:function(e,t){thi<span class="fstat-no" title="function not covered" >s.replaceData(e,</span>t,"")},re<span class="cstat-no" title="statement not covered" >placeDat<span class="cstat-no" title="statement not covered" ></span>a:function(e,t,n){var r=this.data.substring(0,e),i=this.data.substring(e+t);n=r+n+</span>i,this.nodeValue=this.data=n,this.length=n.length}},r(E,d<span class="fstat-no" title="function not covered" >),S.prototype={nodeNam</span>e:"#text"<span class="cstat-no" title="statement not covered" >,nodeTyp<span class="cstat-no" title="statement not covered" ></span>e:J,splitText:function(e){var t=this.data,n=</span>t.substring(e);t=t.substring(0,e),this.data=this.no<span class="fstat-no" title="function not covered" >deValue=t,this.l</span>ength=t.len<span class="cstat-no" title="statement not covered" >gth;var </span>r=<span class="cstat-no" title="statement not covered" >this.ownerDoc</span>um<span class="cstat-no" title="statement not covered" >ent.createTextNode(n)<span class="cstat-no" title="statement not covered" ></span>;return this.parentNode&amp;&amp;this.parentNode.insertBefore(r,this.nextSibling),r}},r(S,E),N.prototype={nodeName:"#comment",nodeType:K},r(N,E),R.prototype={nodeName:"#cdata-sect</span>ion",nodeType:G},r(R,E),j.prototype.nodeType=ee,r(j,d<span class="fstat-no" title="function not covered" >),O.prototype.node</span>Type=ne,r(O<span class="cstat-no" title="statement not covered" >,d),I.pr</span>ot<span class="cstat-no" title="statement not covered" >otype.nodeTyp<span class="cstat-no" title="statement not covered" ></span>e=Y,r(I,d),C.prototype.nodeType=$,r(C,d),A.prototype.nodeName="#document-fragment",A.prototype.nodeType=te,r(A,d),L.prototype.nodeType=Q,r(L,d),</span>D.prototype.serializeToString=function(e,t,n){return P.call(e,t,n)},d.prototype.<span class="fstat-no" title="function not covered" >toString=P;tr</span>y{O<span class="cstat-no" title="statement not covered" >bject.defineProperty&amp;&amp;(Object.definePro</span>perty(a.prototype,"length",{get:function(){retur<span class="fstat-no" title="function not covered" >n s(this),thi</span>s.$$lengt<span class="cstat-no" title="statement not covered" >h}}),Object.definePropert<span class="cstat-no" title="statement not covered" ></span>y(d.prototype,"textCont</span>ent",{get:function(){return H(this)},set:function(e)<span class="fstat-no" title="function not covered" >{switch(this.node</span>Typ<span class="cstat-no" title="statement not covered" >e){case W:case te:for(;this.firstChild;)</span>this.removeChild(this.firstChild);(e||String(e))<span class="fstat-no" title="function not covered" >&amp;&amp;this.append</span>Child(this.<span class="cstat-no" title="statement not covered" >ownerDocument.createTextNode(e));break<span class="cstat-no" title="statement not covered" ></span>;default:this.data=e,this.value=e,this.nodeValue=e}</span>}}),B=function(e,t,n){e["$$"+t]=n})}catch(e){}t.DOM<span class="fstat-no" title="function not covered" >Implementation=h</span>,t.XMLSer<span class="cstat-no" title="statement not covered" >ializer=D},function(e,t){<span class="cstat-no" title="statement not covered" ></span>e.exports=XMLHttpRequest},functi</span>on(e,t,n){"use strict";function r(e,t){if(!(e i<span class="fstat-no" title="function not covered" >nstanceof t)</span>)th<span class="cstat-no" title="statement not covered" >row new TypeError("Cannot call a class as a function")}funct</span>ion i(e,t){if(!e)throw new ReferenceError("this hasn<span class="fstat-no" title="function not covered" >'t been initialis</span>ed <span class="cstat-no" title="statement not covered" >- super() hasn't been called");return!t|</span>|"object"!=typeof t&amp;&amp;"function"!=typeof t?e:t}function<span class="fstat-no" title="function not covered" > o(e,t){if("functio</span>n"!<span class="cstat-no" title="statement not covered" >=typeof t&amp;&amp;null!==t)throw new TypeError("S</span>uper expression must either be null or a function, not <span class="fstat-no" title="function not covered" >"+typeof t);e.protot</span>ype<span class="cstat-no" title="statement not covered" >=Object.create(t&amp;&amp;t.prototype,{constructor:{value:e,</span>enumerable:!1,writable:!0,configurable:!0}}),t&amp;&amp;(Obje<span class="fstat-no" title="function not covered" >ct.setPrototypeOf?</span>Object.setP<span class="cstat-no" title="statement not covered" >rototypeOf(e,t):e.__proto__=t<span class="cstat-no" title="statement not covered" ></span>)}var a=function(){function e(e,</span>t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumer<span class="fstat-no" title="function not covered" >able=r.enumerab</span>le||!<span class="cstat-no" title="statement not covered" >1,r.configurable=!0,"value"in r&amp;&amp;(r.writabl</span>e=!0),Object.defineProperty(e,r.key,r)}}return fun<span class="fstat-no" title="function not covered" >ction(t,n,r){re</span>turn n&amp;&amp;e(t<span class="cstat-no" title="statement not covered" >.prototype,n),r&amp;&amp;e(t,r),t}}()<span class="cstat-no" title="statement not covered" ></span>,s=n(12),u=n(9),l=n(11)</span>,c=n(13),f=n(15),h=n(8),d=n(10),p=n(21),v=n(71),g=<span class="fstat-no" title="function not covered" >n(72),y=functio</span>n(e){function<span class="cstat-no" title="statement not covered" > t(e,n,o,a){r(this,t);var s=i(this,Object.<span class="cstat-no" title="statement not covered" ></span>getPrototypeOf(t).call(this));return s.termType=t.t</span>ermType,s.statements=e||[],s.constraints=n||[],s.initB<span class="fstat-no" title="function not covered" >indings=o||[],s.opt</span>ional<span class="cstat-no" title="statement not covered" >=a||[],s}return o(t,e),a(t,[{key:"add",value</span>:function(e,t,n,r){return this.statements.push(new v(e,t<span class="fstat-no" title="function not covered" >,n,r))}},{key:"addSta</span>tem<span class="cstat-no" title="statement not covered" >ent",value:functio<span class="fstat-no" title="function not covered" >n(</span>e){return this.s<span class="cstat-no" title="statement not covered" >tat<span class="cstat-no" title="statement not covered" ></span>ements.push<span class="fstat-no" title="function not covered" >(e</span>)}},{key:"<span class="cstat-no" title="statement not covered" >bnode",value:function(e){return new s(e)}},{key:"bottomT</span>ypeUR</span>Is"</span>,value:function(e){var t,n,r,i,o,a,s,u,l;t=[];for(o in e)i<span class="fstat-no" title="function not covered" >f(e.hasOwnProperty(o)){</span>for(l<span class="cstat-no" title="statement not covered" >=e[o],u=this.each(<span class="fstat-no" title="function not covered" >vo</span>id 0,this.sym("h<span class="cstat-no" title="statement not covered" >ttp<span class="cstat-no" title="statement not covered" ></span>://www.w3.o<span class="fstat-no" title="function not covered" >rg</span>/2000/01/r<span class="cstat-no" title="statement not covered" >df-schema#subClassOf"),this.sym(o)),n=!0,i=0,a=u.length;i&lt;a;i++)if(r=u[i],s=r.uri,s in e</span>){n=!</span>1;b</span>reak}n&amp;&amp;(t[o]=l)}return t}},{key:"collection",value:function(){return new l}},{key:"each",value:function(e,t,n,r){var i,o,a,s,u,l,c,f,h,d=[],p=this.statementsMatching(e,t,n,r,!1);if(null==e)for(o=0,l=p.length;o&lt;l;o++)i=p[o],d.push(i.subject);el<span class="fstat-no" title="function not covered" >se if(null==t)</span>for(a<span class="cstat-no" title="statement not covered" >=0,c=p.length;a&lt;c;a++)i=p[a],d.push</span>(i.predicate);else if(null==n)for(s=0,f=p.leng<span class="fstat-no" title="function not covered" >th;s&lt;f;s++)</span>i=p<span class="cstat-no" title="statement not covered" >[s],d.push(i.object);else if(null==r)for(u=0,h=p.length;u&lt;h;u++</span>)i=p[u],d.push(i.why);return d}},{key:"equals"<span class="fstat-no" title="function not covered" >,value:func</span>tion(<span class="cstat-no" title="statement not covered" >e){return!!e&amp;&amp;this.hashSt</span>ring()===e.hashString()}},{key:"findMembersNT",<span class="fstat-no" title="function not covered" >value:functi</span>on(<span class="cstat-no" title="statement not covered" >e){var t,n,r,i,o,a,s,u,l,</span>c,f,h,d,p,v,g,y,m,b,w,x;m={},m[e.toNT()]=!0,l=<span class="fstat-no" title="function not covered" >{},h=this.t</span>ransi<span class="cstat-no" title="statement not covered" >tiveClosure(m,this.sym("ht</span>tp://www.w3.org/2000/01/rdf-schema#subClassOf")<span class="fstat-no" title="function not covered" >,!0);for(w i</span>n h)if(h.hasO<span class="cstat-no" title="statement not covered" >wnProperty(w)){for(d=this</span>.s<span class="cstat-no" title="statement not covered" >tatementsMatching(void 0,<span class="cstat-no" title="statement not covered" ></span>this.sym("http://www.w3.org/1999/02/22-rdf-syntax-ns#type</span>"),this.fromNT(w)),t=0,r=d.length;t&lt;r;t++)b=d[t],l[b.subject.toNT()]=b;for(p=this.each(void 0,<span class="fstat-no" title="function not covered" >this.sym("</span>http://ww<span class="cstat-no" title="statement not covered" >w.w3.org/2</span>00<span class="cstat-no" title="statement not covered" >0/01/rdf-schema<span class="cstat-no" title="statement not covered" ></span>#domain"),this.fromNT(w)),n=0,i=p.length;n&lt;i;n++)for(c=p[n],v=this.s</span>tatem<span class="cstat-no" title="statement not covered" >entsMatching(void 0,c),u=0,o=v.length<span class="cstat-no" title="statement not covered" ></span>;u&lt;o;u++)b=v[u],l[b.subject.toNT()]=b;for(g=this.each(void 0,this.sym("http:</span>//www.w3.org/2000/01/rdf-schema#range"),this.fromNT(w)),f=0,a=g.length;f&lt;a;f++)for(c=g[f],y=this.statementsMatching(void 0,c),x=0,s=y.length;x&lt;s;x++)b=y[x],l[b.object.toNT()]=b}return l}},{key:"findMemberURIs",value:function(e){return this.NTtoURI(this.findMembersNT(e))}},{key:"findSubClassesNT",value:function(e){var t={};return t[e.toNT()]=!0,this.transitiveClosure(t,thi<span class="fstat-no" title="function not covered" >s.</span>sym("http://ww<span class="cstat-no" title="statement not covered" >w.w3.org/2000/01/rdf-s</span>chema#subClassOf"),!0)}}<span class="cstat-no" title="statement not covered" >,</span>{ke<span class="cstat-no" title="statement not covered" >y:"findSuperClassesNT",value:function(e){var t={};return t[e.toNT()]=!0,this.transitiveClosure(t,this.sym(<span class="fstat-no" title="function not covered" >"htt</span>p:<span class="cstat-no" title="statement not covered" >//www.w3.org/2000/01/rdf-schem</span>a#subClassOf"),!1)}},{key:"findTypesNT",value:function(e){var t,n,r,i,o,a,s,u,l,c,f,h,d,p,<span class="fstat-no" title="function not covered" >v,g,</span>y;<span class="cstat-no" title="statement not covered" >for(f="http://ww</span>w.w3.org/1999/02/22-rdf-syntax-ns#type"<span class="fstat-no" title="function not covered" >,y=[</span>],h<span class="cstat-no" title="statement not covered" >=this.statementsMatching(e,void 0,voi<span class="cstat-no" title="statement not covered" >d 0),n=0,i=h.length;n&lt;<span class="cstat-no" title="statement not covered" >i;n++)if(g=h[n],g.predicate.uri===<span class="cstat-no" title="statement not covered" >f</span></span>)y[g.object.toNT()]=g;else for(d=this.each(g.predicate,this.sym("http:<span class="cstat-no" title="statement not covered" >/</span>/www.w</span>3.org/2<span class="cstat-no" title="statement not covered" >000/01/rdf-schema#domain")),r=0,o=d.length;</span>r</span>&lt;o;r++)c=d[r],y[c.toNT()]=g;for(p=this.<span class="fstat-no" title="function not covered" >st</span>atement<span class="cstat-no" title="statement not covered" >sMatching(voi</span>d 0</span>,void 0,e)<span class="cstat-no" title="statement not covered" >,</span>u=0,a=p.length;u&lt;a;u++)for(g=p[u],v=this</span>.<span class="fstat-no" title="function not covered" >ea</span>ch(g.predica<span class="cstat-no" title="statement not covered" >te,this.sym("http://www.w3</span>.<span class="fstat-no" title="function not covered" >or</span>g/2000/01/rdf-schema#range")),l=0,s=<span class="fstat-no" title="function not covered" >v.</span>lengt<span class="cstat-no" title="statement not covered" >h;l&lt;s;l++)t=v[l],y[t.<span class="cstat-no" title="statement not covered" >toNT()]=g;return this.transitiveClosure(y,this.sym("http:/</span></span>/www.w3.o<span class="fstat-no" title="function not covered" >rg</span>/2000<span class="cstat-no" title="statement not covered" >/01/rd<span class="cstat-no" title="statement not covered" >f-schema#subClassOf"),!1)}},{key:"findTypeURIs",value:function(e){return this.NTtoURI(<span class="cstat-no" title="statement not covered" >t</span></span>his.findTypesNT(e))}},{key:"connectedStatements",value:</span>function(<span class="fstat-no" title="function not covered" >e,</span>t,n){<span class="cstat-no" title="statement not covered" >n=n||[];for(var r=[e],i=[],o=[],a=<span class="cstat-no" title="statement not covered" >[],s=this,u=function(e){var u=function(e){"BlankNode"!==e.termType||i[e.value]||(i[e.valu<span class="cstat-no" title="statement not covered" >e</span></span>]=!0,r.push(e))},l=s.statementsMatching(null,null,e,t).concat(s.statementsMatching(e,null,null,t));l=l.filter(function(e){if(n[e.predicate.uri])return!1;var t=e.toNT();return!o</span>[t]&amp;&amp;(<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >o[</span>t]=!0,!0)}),l.forE<span class="fstat-no" title="function not covered" >ac</span>h(fun<span class="cstat-no" title="statement not covered" >ction(e,t){u(e.subject),u(e.object<span class="cstat-no" title="statement not covered" >)}),a<span class="cstat-no" title="statement not covered" ></span>=a.concat(l)};r.length;)u(r.shift());return a}},{key:"formula",value:function(){return new t}},{key:"fromNT",va</span>l<span class="cstat-no" title="statement not covered" ></span>ue:func<span class="fstat-no" title="function not covered" >ti</span>on(e){var t,n,<span class="cstat-no" title="statement not covered" >r,i;switch(e[0]){case"&lt;":return this.sym</span>(e</span>.sl</span>ic<span class="cstat-no" title="statement not covered" >e(1,-1</span>))<span class="cstat-no" title="statement not covered" >;case</span>'"<span class="cstat-no" title="statement not covered" >':if(r</span>=v<span class="cstat-no" title="statement not covered" >oid 0,</span>t=<span class="cstat-no" title="statement not covered" >void 0</span>,n<span class="cstat-no" title="statement not covered" >=e.la</span>st<span class="cstat-no" title="statement not covered" >IndexO</span>f(<span class="cstat-no" title="statement not covered" >'"'),n</span>&lt;e<span class="cstat-no" title="statement not covered" >.lengt</span>h-<span class="cstat-no" title="statement not covered" >1)if("</span>@"<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >==</span>=e[n+1])r=e.slice(n<span class="fstat-no" title="function not covered" >+2</span>);else{if<span class="cstat-no" title="statement not covered" >("^^"!==e.s</span>lice(<span class="cstat-no" title="statement not covered" >n+1,n+3))throw new Error("Can't convert stri<span class="cstat-no" title="statement not covered" ></span>ng from NT: "+e);t=this.fromNT(e.slice(n+3))}return e=e.slice(1,n),e=e.replace(/\\"/g,'"'),e=e.replace(/\\n/g<span class="cstat-no" title="statement not covered" ></span>,"\n"),e=e.replace(/\\\\/g,"\\"),this.literal(e,r,t);case"_":return i=<span class="fstat-no" title="function not covered" >new s,</span>i.id=pars<span class="cstat-no" title="statement not covered" >eInt(e.slice(3),10),s.nextId--,i;case"?":retu</span>rn new g(e.slice(1))}throw new Error("Can't convert from NT: "<span class="fstat-no" title="function not covered" >+e)}},</span>{ke<span class="cstat-no" title="statement not covered" >y:"holds",value:function(e,t,n,r</span>){var i;if(1===arguments.length){if(!e)return!0;if(e in<span class="fstat-no" title="function not covered" >stance</span>of <span class="cstat-no" title="statement not covered" >Array){for(i=0;i&lt;</span>e.length;i++)if(!this.holds(e[i]))return!1;<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return!0}i<span class="cstat-no" title="statement not covered" ></span>f(e instanceof v)r<span class="cstat-no" title="statement not covered" >eturn this.holds(e.subject,e.predicate,e.object,e.why);i<span class="cstat-no" title="statement not covered" >f</span></span>(e.statements)r<span class="cstat-no" title="statement not covered" >eturn this.holds(e.statements)}va</span></span>r o=th<span class="cstat-no" title="statement not covered" >is.anyStatementMatching(e,t,n,r);re<span class="cstat-no" title="statement not covered" ></span>turn null!=o}},{</span>key:"holdsStatement",value:function(e){return this.holds(e.subje<span class="fstat-no" title="function not covered" >ct,e.p</span>red<span class="cstat-no" title="statement not covered" >icate,e.object,e.why)}},{key:"list",value:function(e){var</span> t=new l;return e.forEach(function(e){t.append(e)}),t}<span class="fstat-no" title="function not covered" >},{key</span>:"literal<span class="cstat-no" title="statement not covered" >",value:<span class="cstat-no" title="statement not covered" ></span>function(e,t,n){r<span class="fstat-no" title="function not covered" >et</span>urn new c(<span class="cstat-no" title="statement not covered" >""+e,t,n)}},{</span>key:"</span>NTtoURI",value:function(e){var t,n,r={};for(t in e)e.hasO<span class="fstat-no" title="function not covered" >wnProp</span>erty(t)<span class="cstat-no" title="statement not covered" >&amp;&amp;(n=e[t],"&lt;"===t[0]&amp;&amp;(r</span>[t.slice(1,-1)]=n));return r}},{key:"serialize",value:fun<span class="fstat-no" title="function not covered" >ction(</span>e,t,n){var r,<span class="cstat-no" title="statement not covered" >i,o<span class="cstat-no" title="statement not covered" ></span>;switch(o=p<span class="cstat-no" title="statement not covered" >(this),o.suggestNamespaces(this.namespaces),o.setBase(e),i=n?th<span class="cstat-no" title="statement not covered" >i</span></span>s.stateme</span>ntsMatching(void 0,void 0,void 0,n):this.statements,null!=t<span class="fstat-no" title="function not covered" >?t:"te</span>xt/n3"){case"appl<span class="cstat-no" title="statement not covered" >ication/rdf+xml":r=o.statementsToXML(i);break;case"text/n3":case"text/turtle":r=o.statementsToN3(i);break;default:throw new Error("serialize: Content-type "+t+" not supported.")}retu<span class="cstat-no" title="statement not covered" >rn r}},{key:"substitute<span class="cstat-no" title="statement not covered" >"</span>,value</span>:function(e){var n=this.stateme<span class="cstat-no" title="statement not covered" >nts.map(function(t){re<span class="cstat-no" title="statement not covered" >t</span>urn t.</span>substit<span class="cstat-no" title="statement not covered" >ute(e)});console.log("formula subs statmnts:"+n);var r=new t;retu<span class="cstat-no" title="statement not covered" ></span>r</span>n r.add(n</span>),console.log("indexed-form subs formula:"+r),r}},{key:"sym"<span class="fstat-no" title="function not covered" >,value</span>:function<span class="cstat-no" title="statement not covered" >(e,t){if(t)throw new<span class="fstat-no" title="function not covered" > E</span>rror("This<span class="cstat-no" title="statement not covered" > feature (kb.sym with 2 </span>ar<span class="cstat-no" title="statement not covered" ></span>gs) is removed. Do not assume prefix mapp</span>ings.<span class="cstat-no" title="statement not covered" >");retur<span class="cstat-no" title="statement not covered" ></span>n new h(e)}},{key:"the",value:function(e,t,n,r){var i=this.any(</span>e,t,n,r);return null==i&amp;&amp;f.error("No value found for <span class="fstat-no" title="function not covered" >the() </span>{"+e+<span class="cstat-no" title="statement not covered" >" "+t<span class="cstat-no" title="statement not covered" >+" "+n+"}."),i}},{key:"transitiveClosure",value:function(e,t,n){var r,i,o,a,s,u,l={};Object.assi<span class="cstat-no" title="statement not covered" >g</span></span>n(l,e);for(var c</span>={};;){if(u=function(){for(var e in l)if(l.hasOwnProp<span class="fstat-no" title="function not covered" >erty(e</span>))return e}(),n<span class="cstat-no" title="statement not covered" >ull==u)return c;fo<span class="cstat-no" title="statement not covered" ></span>r(s=n?this.each(void 0,t,this.fromNT(u)):this.each(this.fromNT(u),t),i=0,o=s</span>.length;i&lt;o;i++)r=s[i],a=r.toNT(),a in c||a in l||(l[a]=l[u]);c[u]=<span class="fstat-no" title="function not covered" >l[u],d</span>elete l[u]}}},{key:"topTy<span class="cstat-no" title="statement not covered" >peU<span class="cstat-no" title="statement not covered" ></span>RIs",value:function<span class="cstat-no" title="statement not covered" >(</span>e){var t,n,r,i,<span class="cstat-no" title="statement not covered" >o,a,s<span class="fstat-no" title="function not covered" >,u</span>;s=[];for<span class="cstat-no" title="statement not covered" >(r in e)if(e.ha<span class="cstat-no" title="statement not covered" >sOwnProperty(r)){for(u=<span class="cstat-no" title="statement not covered" >e[r],o=0,a</span></span></span>=this.each(<span class="cstat-no" title="statement not covered" >this.sym(<span class="cstat-no" title="statement not covered" >r</span></span>),this.sym("http://www.w3.org/2000/01/rdf-schema#subClassOf")),t=0,i=a.length;t&lt;i;t++)if(n=a[<span class="cstat-no" title="statement not covered" >t],"http://www.w3.org/2000/01/rdf-schema#Resou<span class="cstat-no" title="statement not covered" >r</span></span>ce"!==n.uri){o++;break</span>}</span>o||(s[r]=u)}return s["http://www.w3.org/2000/01/rdf-schema#Re<span class="fstat-no" title="function not covered" >source</span>"]&amp;&amp;delete s["http://ww<span class="cstat-no" title="statement not covered" >w.w3.<span class="cstat-no" title="statement not covered" >o</span>rg/2000/01<span class="cstat-no" title="statement not covered" >/rdf-schema#Resource"],s<span class="cstat-no" title="statement not covered" >["http://www.w3.org/2002/07/owl#Thing"]&amp;&amp;delete s["http://www.w3.org/2002/07/owl#Thing"],s}},{key:"toString",value:function<span class="cstat-no" title="statement not covered" >(){return"{"+this.statements.join("\n")+"}"}},{key:"whether",value:<span class="cstat-no" title="statement not covered" >func<span class="cstat-no" title="statement not covered" >t</span>ion(e,<span class="cstat-no" title="statement not covered" ></span>t</span></span>,n,r){return<span class="cstat-no" title="statement not covered" ></span> </span></span>this.statementsMatching(e,t,n,r,!1).length}}]),t}(d);y.termType="formula",y.prototype.classOrder=u.Formula,y.prototype.isVar=0,y.prototype.ns=n(73),y.prototype.variable=function(e){return new g(e)},e.exports=y</span>},function(e,t,n){"use strict";function r(e,t,n,r,a){funct<span class="fstat-no" title="function not covered" >ion s(</span>e,<span class="cstat-no" title="statement not covered" >t){return a?void a(e,t):t}n=n||e.uri,r=r||</span>"text/turtle";var u=null;try{var l,c=o(t),f=t.statementsM<span class="fstat-no" title="function not covered" >atchin</span>g(void 0,<span class="cstat-no" title="statement not covered" >void 0,void 0,e);switch(c.suggestNamespaces(t.names</span>paces),c.se<span class="cstat-no" title="statement not covered" >tBase(n),r){case"application/rdf+xml":return u=c.statementsToXML(f),s(null,u);case"text/n3":case"application/n3":ret<span class="fstat-no" title="function not covered" >ur</span>n u=c.stat<span class="cstat-no" title="statement not covered" >ementsToN3(f),s(n</span>ull,u);case"te</span>x<span class="fstat-no" title="function not covered" >t/</span>turtle":case"application/x-turtle":r<span class="fstat-no" title="function not covered" >et</span>urn c.setFlags("si")<span class="fstat-no" title="function not covered" >,u</span>=c.st<span class="cstat-no" title="statement not covered" >atementsToN3(f),s(null,u<span class="cstat-no" title="statement not covered" ></span>);case"application/n-triples":r</span>eturn<span class="cstat-no" title="statement not covered" > c.se<span class="cstat-no" title="statement not covered" ></span>tFlags("dein<span class="cstat-no" title="statement not covered" >prstu</span>x"<span class="cstat-no" title="statement not covered" >),u=c.statementsToNTriples(f),s(null,u);case"<span class="cstat-no" title="statement not covered" ></span>application/ld+json":c.setFlags("deinprstux"),l=c.statementsToNTriples(f),i.convert<span class="cstat-no" title="statement not covered" >ToJson(l,a);break;case"application/n-quad</span>s":case"application/nquads":return<span class="cstat-no" title="statement not covered" > c.setFlags("deinprstux q"),u=c.statemen</span>tsToNTriples(f),s(null,u);default:throw new <span class="cstat-no" title="statement not covered" >Error("Serialize: Content-type "+r+" not supported for da</span>ta write.")}}catch(e){if(a)<span class="cstat-no" title="statement not covered" >return a(e);throw e}}e.exports=r;var i=n(22),o=n(70)},function(e,t,n){"</span>use strict";function r(e,<span class="cstat-no" title="statement not covered" >t){var n,r=s.Parser(),i=s.Writer({format:"N-Quads"});o.waterfall([function<span class="cstat-no" title="statement not covered" >(</span>t){r.p</span>arse(e,t)},function(e,t,n){null!==e&amp;&amp;i.addTriple(e<span class="cstat-no" title="statement not covered" >),"function"==typeof n&amp;&amp;i.end(n)},function(e,t){try{a.fromRDF(e,{format:"</span>applica<span class="cstat-no" title="statement not covered" >tion/nquads"},t)}catch(e){t(e)}},function(e,r){n=JSON.stringify(e),t(null,n)}],f</span>u</span>nction(e,<span class="cstat-no" title="statement not covered" >r){t(<span class="cstat-no" title="statement not covered" >e,n)})}funct<span class="cstat-no" title="statement not covered" >i</span></span>on i(e,t</span>)<span class="cstat-no" title="statement not covered" ></span>{var n,r=s.Pa</span>rser(<span class="cstat-no" title="statement not covered" >),i=s.</span>Wr<span class="cstat-no" title="statement not covered" >iter({</span>fo<span class="fstat-no" title="function not covered" >rm</span>at:"N-Quads"});o.waterfall([function<span class="fstat-no" title="function not covered" >(t</span>){r.parse(e,t<span class="cstat-no" title="statement not covered" >)},function</span>(e<span class="cstat-no" title="statement not covered" >,t,n){null!==e&amp;&amp;i.addTriple(e<span class="cstat-no" title="statement not covered" ></span>),"function"=<span class="fstat-no" title="function not covered" >=t</span>ypeof n&amp;&amp;i<span class="cstat-no" title="statement not covered" >.end(n)},funct</span>i<span class="fstat-no" title="function not covered" >on</span>(e,r){n=e,t(nu<span class="cstat-no" title="statement not covered" >ll,n)}],function(e,r){t(e,n)})}e.exports.convertToJson=r,</span>e<span class="fstat-no" title="function not covered" >.e</span>xports.conve<span class="cstat-no" title="statement not covered" >rtTo<span class="cstat-no" title="statement not covered" >NQuads=i;var o=n(23),a=n(27),s=n(33)},function</span>(e,t,n){v<span class="cstat-no" title="statement not covered" >ar r,i</span>;</span>(<span class="fstat-no" title="function not covered" >fu</span>nction(n,o){<span class="cstat-no" title="statement not covered" >/*!<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >a(</span>e){var t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(t)<span class="cstat-no" title="statement not covered" >throw new Error("Callback was already called.");<span class="cstat-no" title="statement not covered" >t</span></span>=!0,e.apply(s,arguments)}}</span>va</span>r s,u,l={}<span class="cstat-no" title="statement not covered" >;s=<span class="cstat-no" title="statement not covered" ></span>this,null!=s&amp;&amp;(u=s.async),l.noConflict=fu<span class="fstat-no" title="function not covered" >nc</span>tion(){re<span class="cstat-no" title="statement not covered" >turn s.async=u,l};va</span>r </span>c=Obj<span class="cstat-no" title="statement not covered" >ect.prototype.toString,f=A</span>rr<span class="cstat-no" title="statement not covered" >ay.isArray||fun<span class="fstat-no" title="function not covered" >ct</span>ion(e){ret<span class="cstat-no" title="statement not covered" >urn"[object Array]"===c.call(e)},h=f</span>u</span>nc<span class="cstat-no" title="statement not covered" >tion(e,t)<span class="fstat-no" title="function not covered" >{f</span>or(va<span class="cstat-no" title="statement not covered" >r n=0;n&lt;e.length;n+=1)t(e[n]<span class="cstat-no" title="statement not covered" >,n,e)},d=func</span></span>t</span>io<span class="cstat-no" title="statement not covered" >n(e,t){if<span class="fstat-no" title="function not covered" >(e</span>.map)<span class="cstat-no" title="statement not covered" >return e.<span class="cstat-no" title="statement not covered" >map(t);var n=[];r</span></span>eturn<span class="cstat-no" title="statement not covered" > h(<span class="cstat-no" title="statement not covered" ></span>e,function(<span class="fstat-no" title="function not covered" >e,</span>r,i){n.push(t(<span class="cstat-no" title="statement not covered" >e,r,i))}),n},p=fun</span>ction</span>(</span>e,<span class="cstat-no" title="statement not covered" >t,n){retu<span class="fstat-no" title="function not covered" >rn</span> e.redu<span class="cstat-no" title="statement not covered" >ce?e.reduce(t,n):(h(e,function(e,r,<span class="fstat-no" title="function not covered" >i)</span>{n=t(n,e,r,i)}<span class="cstat-no" title="statement not covered" >),n)},v=functi</span>on(e){</span>i</span>f(<span class="cstat-no" title="statement not covered" >Object.ke<span class="fstat-no" title="function not covered" >ys</span>)re<span class="cstat-no" title="statement not covered" >turn Object.key<span class="cstat-no" title="statement not covered" >s(e);var t=[];for(var n</span></span> in e<span class="cstat-no" title="statement not covered" >)e.<span class="cstat-no" title="statement not covered" ></span>hasOwnProperty(<span class="cstat-no" title="statement not covered" >n)&amp;&amp;t.push(n);return t};"undefi<span class="cstat-no" title="statement not covered" >n</span></span>ed"!=type</span>o<span class="cstat-no" title="statement not covered" ></span>f n&amp;&amp;n.nextTick?(l.nextTick=n.nextTick,"undefined"!=typeof o?l.setImmediate=function(e){o(e)}:<span class="fstat-no" title="function not covered" >l.</span>setImmedia<span class="cstat-no" title="statement not covered" >te=l.n</span>extTick):"function"==typeof o?(l.nextTick=function(e){o(e)},l<span class="fstat-no" title="function not covered" >.s</span>etImmediat<span class="cstat-no" title="statement not covered" >e=l.ne</span>xtTick):(l.nextTick=function(e){setTimeo<span class="fstat-no" title="function not covered" >ut</span>(e,0)},l.s<span class="cstat-no" title="statement not covered" >etImmediate=l.nex</span>tTick),l.each=function(e,t,n){funct<span class="fstat-no" title="function not covered" >io</span>n r(t){t?(n(t),n=functi<span class="fstat-no" title="function not covered" >on</span>(){<span class="cstat-no" title="statement not covered" >}):(i+=1,i&gt;=e.length&amp;&amp;n())}if(n=n||function(<span class="fstat-no" title="function not covered" >){</span>},!e.length)return n();var i=0<span class="cstat-no" title="statement not covered" ></span>;h(e,fun<span class="fstat-no" title="function not covered" >ct</span>ion(e){t(e,a(r))})},l<span class="cstat-no" title="statement not covered" >.forEach=l.e</span></span>ach,l<span class="cstat-no" title="statement not covered" >.e<span class="cstat-no" title="statement not covered" ></span>achS<span class="fstat-no" title="function not covered" >er</span>ies=functi<span class="cstat-no" title="statement not covered" >on(e,t,n){i</span>f(n</span>=n||function(){},!e.length)retu<span class="fstat-no" title="function not covered" >rn</span> n();var r=0,i<span class="cstat-no" title="statement not covered" >=functio<span class="fstat-no" title="function not covered" >n(</span>){t(e[r],function(t){<span class="cstat-no" title="statement not covered" >t?(n(t),n=fu</span></span>nctio<span class="cstat-no" title="statement not covered" >n(</span>){<span class="cstat-no" title="statement not covered" >}):(r+=1,<span class="fstat-no" title="function not covered" >r&gt;</span>=e<span class="cstat-no" title="statement not covered" >.length<span class="fstat-no" title="function not covered" >?n</span>():i())})}<span class="cstat-no" title="statement not covered" >;i()},l.forEachSeries=l.eachSeries,l.eachLim<span class="fstat-no" title="function not covered" >it</span>=function(e,t,n,r){var i=g(t);i.a</span>ppl</span>y<span class="cstat-no" title="statement not covered" ></span>(null</span>,[e,n,r])},l.forEachLimit=l.eachLimit;var <span class="fstat-no" title="function not covered" >g=</span>function(e){return fun<span class="cstat-no" title="statement not covered" >ction<span class="cstat-no" title="statement not covered" ></span>(t,n,r){if(r=r||functio</span>n(){},!t.length||e&lt;=0)return </span>r();v<span class="cstat-no" title="statement not covered" >ar i=0,o=<span class="fstat-no" title="function not covered" >0,</span>a=0<span class="cstat-no" title="statement not covered" >;!funct<span class="fstat-no" title="function not covered" >io</span>n s(){if(i&gt;=t.<span class="cstat-no" title="statement not covered" >length)r<span class="fstat-no" title="function not covered" >et</span>urn r();for(;a&lt;e&amp;&amp;o&lt;t.lengt<span class="cstat-no" title="statement not covered" >h;)o+=1,a+=1</span></span>,n(t[<span class="cstat-no" title="statement not covered" >o-</span>1]<span class="cstat-no" title="statement not covered" >,f</span>un<span class="cstat-no" title="statement not covered" >ct<span class="cstat-no" title="statement not covered" ></span>ion(e){e?(<span class="fstat-no" title="function not covered" >r(</span>e)<span class="cstat-no" title="statement not covered" >,r=function(){}<span class="cstat-no" title="statement not covered" >):(i+=1,a-=<span class="cstat-no" title="statement not covered" >1</span></span>,i&gt;=t.length?r():s())<span class="cstat-no" title="statement not covered" >})}()}},y=function(<span class="fstat-no" title="function not covered" >e)</span>{return fu<span class="cstat-no" title="statement not covered" >nction(){var t=Array.prototype.slice.call(ar<span class="fstat-no" title="function not covered" >gu</span>ments);return e.apply(null,[l.each].co</span>nca</span></span>t(t)</span>)}</span>}</span>,m<span class="cstat-no" title="statement not covered" >=function<span class="fstat-no" title="function not covered" >(e</span>,t)<span class="cstat-no" title="statement not covered" >{return<span class="fstat-no" title="function not covered" > f</span>unction(){var n<span class="cstat-no" title="statement not covered" >=Array.prototype.slice.call(arguments)<span class="cstat-no" title="statement not covered" ></span>;return t.apply(null,[g(e)].concat(n))}},</span>b=</span>f</span>un<span class="cstat-no" title="statement not covered" >ction(e){<span class="fstat-no" title="function not covered" >re</span>turn <span class="cstat-no" title="statement not covered" >functio<span class="fstat-no" title="function not covered" >n(</span>){var t=Array.p<span class="cstat-no" title="statement not covered" >rototype.slice.call(arguments);return <span class="cstat-no" title="statement not covered" ></span>e.apply(null,[l.eachSeries].concat(t))}</span>},</span>w</span>=f<span class="cstat-no" title="statement not covered" >unction(e<span class="fstat-no" title="function not covered" >,t</span>,n,<span class="cstat-no" title="statement not covered" >r){if(t<span class="fstat-no" title="function not covered" >=d</span>(t,function(e,t<span class="cstat-no" title="statement not covered" >){return{index:t,value:e}}),r){var i=[<span class="cstat-no" title="statement not covered" ></span>];e(t,function(e,t){n(e.value,function(n,r){i[e</span>.i</span>n</span>de<span class="cstat-no" title="statement not covered" >x]=r,t(n)<span class="fstat-no" title="function not covered" >})</span>},functio<span class="cstat-no" title="statement not covered" >n(e){r(e,<span class="fstat-no" title="function not covered" >i)</span>})}else e(t,<span class="cstat-no" title="statement not covered" >function(e,t){n(e.value,f</span>unction(e){<span class="cstat-no" title="statement not covered" >t(e<span class="cstat-no" title="statement not covered" ></span>)})}<span class="fstat-no" title="function not covered" >)}</span>;l.map=y(w),<span class="cstat-no" title="statement not covered" >l.mapSerie<span class="fstat-no" title="function not covered" >s=</span>b(w),l.mapLi<span class="cstat-no" title="statement not covered" >mit=function(e,t,n,</span>r){</span>r<span class="fstat-no" title="function not covered" >et</span>urn x(t)(e<span class="cstat-no" title="statement not covered" >,n,r)};v</span>ar </span>x=fun<span class="cstat-no" title="statement not covered" >ctio<span class="fstat-no" title="function not covered" >n(</span>e){return m(<span class="cstat-no" title="statement not covered" >e,w)};l.re<span class="fstat-no" title="function not covered" >du</span>ce=functio<span class="cstat-no" title="statement not covered" >n(e,t,</span>n,r</span>){l</span></span>.<span class="cstat-no" title="statement not covered" ></span>eachSeries(e,function(e,r){n(t,e,functi<span class="fstat-no" title="function not covered" >on</span>(e,n){t=n,r(e)})<span class="cstat-no" title="statement not covered" >},function(e){r(e,t)</span>})</span>},l.i<span class="cstat-no" title="statement not covered" >nject=l.r<span class="fstat-no" title="function not covered" >ed</span>uce<span class="cstat-no" title="statement not covered" >,l.foldl=l.redu</span>c<span class="cstat-no" title="statement not covered" ></span>e,l.reduc<span class="fstat-no" title="function not covered" >eR</span>ight=function(e,<span class="cstat-no" title="statement not covered" >t,n,r){var i=d(<span class="fstat-no" title="function not covered" >e,</span>function(e){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" > e</span>}).reverse()<span class="cstat-no" title="statement not covered" >;l.reduce(</span>i,t</span>,<span class="fstat-no" title="function not covered" >n,</span>r)},l.fold<span class="cstat-no" title="statement not covered" >r=l.redu</span>ceR</span>ight;var _=function(e,t,n,r){var i=[];t=d(t,functi<span class="fstat-no" title="function not covered" >on</span>(e,t){return{index:t,v<span class="cstat-no" title="statement not covered" >alue<span class="fstat-no" title="function not covered" >:e</span>}}),e(t,fu<span class="cstat-no" title="statement not covered" >nction(e,t</span>){n(e.value,<span class="cstat-no" title="statement not covered" ></span>function(n){n&amp;&amp;i.pu</span>sh(e),t()})},function(e)</span>{r(d(<span class="cstat-no" title="statement not covered" >i.sort(fu<span class="fstat-no" title="function not covered" >nc</span>tion(e,t){retur<span class="cstat-no" title="statement not covered" >n e<span class="cstat-no" title="statement not covered" ></span>.index<span class="fstat-no" title="function not covered" >-t</span>.index}),fun<span class="cstat-no" title="statement not covered" >ction(e){return e.value})</span>)})};l<span class="fstat-no" title="function not covered" >.f</span>ilter=y(_),l<span class="cstat-no" title="statement not covered" >.filterSer<span class="fstat-no" title="function not covered" >ie</span>s=b(_),l.s<span class="cstat-no" title="statement not covered" >elect=l.filter,l.s</span>ele</span>c<span class="fstat-no" title="function not covered" >tS</span>eries=l.fi<span class="cstat-no" title="statement not covered" >lterSeries;<span class="fstat-no" title="function not covered" >va</span>r k=function<span class="cstat-no" title="statement not covered" >(e,t,n,r){var i=[];t=d(t</span>,f<span class="fstat-no" title="function not covered" >un</span>ction(e,t)<span class="cstat-no" title="statement not covered" >{return{index:t,</span>valu</span>e:e</span>}<span class="cstat-no" title="statement not covered" ></span>}),e(t,function(e,t){n(e.value,function(n){n||i.push(e),t()})},function(e){r(d(i.so</span>rt(fu<span class="cstat-no" title="statement not covered" >nction(e,<span class="fstat-no" title="function not covered" >t)</span>{return e.index<span class="cstat-no" title="statement not covered" >-t.<span class="cstat-no" title="statement not covered" ></span>index}<span class="fstat-no" title="function not covered" >),</span>function(e){<span class="cstat-no" title="statement not covered" >return e.value}))})};l.re</span>ject=y<span class="fstat-no" title="function not covered" >(k</span>),l.rejectSe<span class="cstat-no" title="statement not covered" >ries=b(k);<span class="fstat-no" title="function not covered" >va</span>r T=functi<span class="cstat-no" title="statement not covered" >on(e,t,n,r){e(t,fu</span>nct</span>i<span class="fstat-no" title="function not covered" >on</span>(e,t){n(e,<span class="cstat-no" title="statement not covered" >function(n)<span class="fstat-no" title="function not covered" >{n</span>?(r(e),r=fun<span class="cstat-no" title="statement not covered" >ction(){}):t()})},functi</span>on<span class="fstat-no" title="function not covered" >(e</span>){r()})};l<span class="cstat-no" title="statement not covered" >.detect=y(T),l.d</span>etec</span>tSe</span>r<span class="cstat-no" title="statement not covered" ></span>ies=b(T),l.some=function(e,t,n){l.e</span>ach(e<span class="cstat-no" title="statement not covered" >,function<span class="fstat-no" title="function not covered" >(e</span>,r){t(e,f<span class="cstat-no" title="statement not covered" >unct<span class="fstat-no" title="function not covered" >io</span>n(e){e&amp;&amp;(n(!<span class="cstat-no" title="statement not covered" >0),n<span class="fstat-no" title="function not covered" >=f</span>unction(){<span class="cstat-no" title="statement not covered" >}),r()})},function(e){n(!1)})},l.any=l.some,<span class="fstat-no" title="function not covered" >l.</span>every=func</span>tio</span>n<span class="fstat-no" title="function not covered" >(e</span>,t,n){l.ea<span class="cstat-no" title="statement not covered" >ch(e,</span>fun</span>c<span class="cstat-no" title="statement not covered" ></span>tion(e,r){t(e,function(e){e||(n(!1),n=fun<span class="fstat-no" title="function not covered" >ct</span>ion(){}),r()})<span class="cstat-no" title="statement not covered" >},functio<span class="fstat-no" title="function not covered" >n(</span>e){n(!0)})},<span class="cstat-no" title="statement not covered" >l.al<span class="fstat-no" title="function not covered" >l=</span>l.every,l.<span class="cstat-no" title="statement not covered" >sortBy=function(e,t,n){l.map(e,function(e,n){t<span class="fstat-no" title="function not covered" >(e</span>,function(</span>t,r</span>)<span class="fstat-no" title="function not covered" >{t</span>?n(t):n(nu<span class="cstat-no" title="statement not covered" >ll,{val</span>ue:</span>e,criteria:r})})},func<span class="fstat-no" title="function not covered" >ti</span>on(e,t){if(e)r<span class="cstat-no" title="statement not covered" >eturn n(e<span class="fstat-no" title="function not covered" >);</span>var r=functi<span class="cstat-no" title="statement not covered" >on(e<span class="fstat-no" title="function not covered" >,t</span>){var n=e.<span class="cstat-no" title="statement not covered" >criteria,r=t.criteria;return n&lt;r?-1:n&gt;r?1:0};n<span class="fstat-no" title="function not covered" >(n</span>ull,d(t.so</span>rt(</span>r<span class="fstat-no" title="function not covered" >),</span>function(e<span class="cstat-no" title="statement not covered" >){retur</span>n e</span>.value}))})},l.auto=func<span class="fstat-no" title="function not covered" >ti</span>on(e,t){t=t||f<span class="cstat-no" title="statement not covered" >unction(<span class="fstat-no" title="function not covered" >){</span>};var n=v(e)<span class="cstat-no" title="statement not covered" >,r=n<span class="fstat-no" title="function not covered" >.l</span>ength;if(!r)<span class="cstat-no" title="statement not covered" >return t();var i={},o=[],a=function(e</span>){o</span>.<span class="fstat-no" title="function not covered" >un</span>shift(e)},s=<span class="cstat-no" title="statement not covered" >funct<span class="cstat-no" title="statement not covered" >ion(e){for(va</span></span>r t=0<span class="cstat-no" title="statement not covered" >;t&lt;o.length;t+=1)if(o[t]===e)retur<span class="fstat-no" title="function not covered" >n </span>void o.spli<span class="cstat-no" title="statement not covered" >ce(t,1)},u=</span>fu<span class="cstat-no" title="statement not covered" >nction(){r-<span class="cstat-no" title="statement not covered" ></span>-,h(o.slice(0),function</span>(<span class="cstat-no" title="statement not covered" ></span>e){e()})};a(functio<span class="fstat-no" title="function not covered" >n(</span>){if(!r){v<span class="cstat-no" title="statement not covered" >ar e=t;t=functio</span>n(){</span>},e</span>(null,i)<span class="fstat-no" title="function not covered" >}}</span>),h(n,functi<span class="cstat-no" title="statement not covered" >on(n)<span class="fstat-no" title="function not covered" >{v</span>ar r=f(e[n])</span>?e[n]<span class="cstat-no" title="statement not covered" >:[e[n</span>]]<span class="cstat-no" title="statement not covered" >,o=functi<span class="cstat-no" title="statement not covered" ></span>on(e){<span class="cstat-no" title="statement not covered" >var r=Array.</span></span>proto<span class="cstat-no" title="statement not covered" >typ</span>e.<span class="cstat-no" title="statement not covered" >sli</span>ce<span class="cstat-no" title="statement not covered" >.call(arg<span class="fstat-no" title="function not covered" >um</span>ent<span class="cstat-no" title="statement not covered" >s,1);if(r.leng</span>t</span>h&lt;<span class="cstat-no" title="statement not covered" >=1&amp;&amp;(r=r[<span class="fstat-no" title="function not covered" >0]</span>),e<span class="cstat-no" title="statement not covered" >){var o={};h(v(i),function(e<span class="cstat-no" title="statement not covered" >){o[e]=i[e]}<span class="cstat-no" title="statement not covered" >),o[n]=r,t(e,o),t=function(</span></span></span>)</span>{}<span class="cstat-no" title="statement not covered" >}else i[n<span class="fstat-no" title="function not covered" >]=</span>r,<span class="cstat-no" title="statement not covered" >l.setImmediate(u)<span class="fstat-no" title="function not covered" >},</span>c=r.slice(<span class="cstat-no" title="statement not covered" >0,Mat</span>h.a</span>b<span class="cstat-no" title="statement not covered" ></span>s(<span class="fstat-no" title="function not covered" >r.</span>length-1)<span class="cstat-no" title="statement not covered" >)||[],d=funct<span class="cstat-no" title="statement not covered" >io<span class="cstat-no" title="statement not covered" ></span>n(){return p(c,function(e,t){return <span class="fstat-no" title="function not covered" >e&amp;</span>&amp;i.hasOwnProper</span>t</span>y(t)},<span class="fstat-no" title="function not covered" >!0</span>)&amp;&amp;!i.hasOwnProp<span class="cstat-no" title="statement not covered" >erty(n)};if(d())r[r.</span>le<span class="cstat-no" title="statement not covered" >ngth-1](o,i);else{var g=function()<span class="fstat-no" title="function not covered" >{d</span>()&amp;&amp;(s(g)<span class="cstat-no" title="statement not covered" >,r[r.length-1](o,i))};a(g)}})},l.retry=f<span class="cstat-no" title="statement not covered" ></span>unction(e,t,n){var r=5,i=[];"funct<span class="cstat-no" title="statement not covered" >ion<span class="cstat-no" title="statement not covered" ></span>"==type<span class="fstat-no" title="function not covered" >of</span> e&amp;&amp;(n=t,t<span class="cstat-no" title="statement not covered" >=e,e=r),e=p</span>arseInt(e,10)||r;var o=function(r,o){for(var a=funct<span class="fstat-no" title="function not covered" >io</span>n(e,t</span>){ret<span class="cstat-no" title="statement not covered" >urn function(n){e(function</span></span>(</span>e,<span class="cstat-no" title="statement not covered" >r){n(!e||t,{err:e,result:r})},o)}};e</span>;)<span class="cstat-no" title="statement not covered" >i.push(a(<span class="fstat-no" title="function not covered" >t,</span>!(<span class="cstat-no" title="statement not covered" >e-=1)));l.s<span class="fstat-no" title="function not covered" >er</span>ies(i,functi<span class="cstat-no" title="statement not covered" >on(e,t){t=t[t.length-1],(r||n)(</span>t.err,t.result)})};return n?</span>o<span class="cstat-no" title="statement not covered" ></span>():o},l<span class="cstat-no" title="statement not covered" >.waterfall=function(</span>e,t){if(t=<span class="cstat-no" title="statement not covered" >t||functi<span class="fstat-no" title="function not covered" >on</span>()<span class="cstat-no" title="statement not covered" >{},!f(e)){var n=new Error("First</span> <span class="cstat-no" title="statement not covered" ></span>argume</span>n</span>t t</span>o waterfa<span class="fstat-no" title="function not covered" >ll</span> must be an array of<span class="cstat-no" title="statement not covered" > f</span>un<span class="cstat-no" title="statement not covered" >cti<span class="cstat-no" title="statement not covered" ></span>ons");return t(n)}if(!e.length)return t();var r=function(</span>e){re<span class="cstat-no" title="statement not covered" >turn function(n){if(n)t.apply(null<span class="fstat-no" title="function not covered" >,a</span>rgumen<span class="cstat-no" title="statement not covered" >ts),t=function(){};else{var i=Array.prototype.slice.call(arguments,1),o=e.next();o?i.push(r(o)):i.pu<span class="cstat-no" title="statement not covered" >sh(t),l.setImmediate(<span class="cstat-no" title="statement not covered" >f</span></span>unction(){<span class="fstat-no" title="function not covered" >e.</span>apply(null,i<span class="cstat-no" title="statement not covered" >)})}}};r(l.iterator(e))()};var E=functio</span>n(e</span>,<span class="cstat-no" title="statement not covered" ></span>t,n){if(n=n||fun</span>ction(){},f(t<span class="fstat-no" title="function not covered" >))</span>e.map(t,func<span class="cstat-no" title="statement not covered" >tion(e,t<span class="fstat-no" title="function not covered" >){</span>e&amp;&amp;e(function(e){var n=A<span class="cstat-no" title="statement not covered" >rray.prototype.slice.call(arguments,1);n.length&lt;=1&amp;&amp;(n=n[0]),t.call(nul<span class="cstat-no" title="statement not covered" ></span>l,e,n)})},n);<span class="cstat-no" title="statement not covered" ></span>e</span>lse{var r={}<span class="cstat-no" title="statement not covered" >;e.each(v(t)</span></span>,func<span class="cstat-no" title="statement not covered" >tion(e,n)<span class="fstat-no" title="function not covered" >{t</span>[e]<span class="cstat-no" title="statement not covered" >(functi<span class="fstat-no" title="function not covered" >on</span>(t){var i=<span class="cstat-no" title="statement not covered" >Array<span class="cstat-no" title="statement not covered" >.prototype.slice.call(arguments,1);i.length&lt;=1&amp;&amp;(i=i[0]),r[e<span class="fstat-no" title="function not covered" >]=</span>i,n(t</span>)})},funct<span class="cstat-no" title="statement not covered" >ion(e){n(e,r)})}};l.parallel=function(e,</span>t)<span class="cstat-no" title="statement not covered" >{E({map:l<span class="cstat-no" title="statement not covered" ></span>.map,each:l.each},e,t)},l.parallelLimit=<span class="fstat-no" title="function not covered" >fu</span>nction(e,<span class="cstat-no" title="statement not covered" >t,n){E({map:x(t),</span>eac</span>h</span>:g</span>(<span class="cstat-no" title="statement not covered" ></span>t)},e,n)},l.series=f</span>un</span>ction<span class="cstat-no" title="statement not covered" >(e,t){if(<span class="fstat-no" title="function not covered" >t=</span>t||func<span class="cstat-no" title="statement not covered" >tion(){}<span class="fstat-no" title="function not covered" >,f</span>(e))l.mapSeries(<span class="cstat-no" title="statement not covered" >e,functi<span class="fstat-no" title="function not covered" >on</span>(e,t){e&amp;&amp;e(f<span class="cstat-no" title="statement not covered" >uncti<span class="fstat-no" title="function not covered" >on</span>(e){var n=Array.<span class="cstat-no" title="statement not covered" >prototype.slice.call(arguments,1);n.leng<span class="cstat-no" title="statement not covered" ></span>th&lt;=1&amp;&amp;(n=n[0]),t.call(null,e,n)})},t);e</span>lse</span>{var </span>n={};l.eac<span class="cstat-no" title="statement not covered" >hSe<span class="cstat-no" title="statement not covered" ></span>ries(v(e),fu<span class="fstat-no" title="function not covered" >nc</span>tion(t,r){e[<span class="cstat-no" title="statement not covered" >t](fu<span class="fstat-no" title="function not covered" >nc</span>tion(e){var i=Ar<span class="cstat-no" title="statement not covered" >ray.prototype.slice.call(arguments,1);i.<span class="cstat-no" title="statement not covered" ></span>length&lt;=1&amp;&amp;(i=i[0]),n[t]=i,r(e)})},</span>fun</span>c<span class="fstat-no" title="function not covered" >ti</span>on(e){t(e,<span class="cstat-no" title="statement not covered" >n)})}},l</span>.it</span>e</span>r<span class="cstat-no" title="statement not covered" ></span>ator=functi<span class="fstat-no" title="function not covered" >on</span>(e){var t=fu<span class="cstat-no" title="statement not covered" >nction(n){var r=function(){retur</span>n e.length&amp;&amp;e[n].<span class="fstat-no" title="function not covered" >ap</span>ply(null,argum<span class="cstat-no" title="statement not covered" >ents),r.next()};return r.next</span>=function(<span class="fstat-no" title="function not covered" >){</span>return n&lt;e.l<span class="cstat-no" title="statement not covered" >ength-1?<span class="fstat-no" title="function not covered" >t(</span>n+1):null},r};re<span class="cstat-no" title="statement not covered" >turn t(0)},l.a<span class="fstat-no" title="function not covered" >pp</span>ly=function(<span class="cstat-no" title="statement not covered" >e){va<span class="fstat-no" title="function not covered" >r </span>t=Array.prototyp<span class="cstat-no" title="statement not covered" >e.slice.call(arguments,1);return functio<span class="cstat-no" title="statement not covered" ></span>n(){return e.apply(null,t.concat(Array.p</span>rot</span>otype</span>.slice.cal<span class="cstat-no" title="statement not covered" >l(a<span class="cstat-no" title="statement not covered" ></span>rguments)))}};var <span class="fstat-no" title="function not covered" >S=</span>function(e,t<span class="cstat-no" title="statement not covered" >,n,r)<span class="fstat-no" title="function not covered" >{v</span>ar i=[];e(t,func<span class="cstat-no" title="statement not covered" >tion(e,t){n(e,function(e,n){i=i.concat(n<span class="cstat-no" title="statement not covered" ></span>||[]),t(e)})},function(e){r(e,i)})}</span>;l.</span>c<span class="fstat-no" title="function not covered" >on</span>cat=y(S),l<span class="cstat-no" title="statement not covered" >.concatS</span>eri</span>e</span>s=b(S),l.whi<span class="fstat-no" title="function not covered" >ls</span>t=function(e,t,n<span class="cstat-no" title="statement not covered" >){e()?t(f<span class="fstat-no" title="function not covered" >un</span>ction(r){<span class="cstat-no" title="statement not covered" >return r?<span class="fstat-no" title="function not covered" >n(</span>r)<span class="cstat-no" title="statement not covered" >:void l.whilst(e,t,n)}):n()},l.doWhilst=function(e,t,n</span>)<span class="cstat-no" title="statement not covered" ></span>{e(function(r)<span class="fstat-no" title="function not covered" >{i</span>f(r)retur<span class="cstat-no" title="statement not covered" >n n(r);var i=Array.prototype.slic</span>e.ca</span>l<span class="cstat-no" title="statement not covered" ></span>l(arguments,1</span>);t.apply<span class="fstat-no" title="function not covered" >(n</span>ull,i)?l.doWhils<span class="cstat-no" title="statement not covered" >t(e,t,n):n()})},l.until=function(e,t,n){<span class="cstat-no" title="statement not covered" ></span>e()?n()<span class="fstat-no" title="function not covered" >:t</span>(function<span class="cstat-no" title="statement not covered" >(r){return r?n(r):void l.until(e,t,n)})},l.doUntil=function(e,t,n){e(f</span>un</span>ct</span>ion(r<span class="cstat-no" title="statement not covered" >){if(r)re<span class="fstat-no" title="function not covered" >tu</span>rn n(r);var i=A<span class="cstat-no" title="statement not covered" >rra<span class="cstat-no" title="statement not covered" ></span>y.pr<span class="fstat-no" title="function not covered" >ot</span>otype.slice.<span class="cstat-no" title="statement not covered" >call<span class="fstat-no" title="function not covered" >(a</span>rguments,1);<span class="cstat-no" title="statement not covered" >t.apply(null,i)?n():l.do</span>Unt</span>i<span class="fstat-no" title="function not covered" >l(</span>e,t,n)})},<span class="cstat-no" title="statement not covered" >l.queue=</span>fun</span>c<span class="cstat-no" title="statement not covered" ></span>tion(e,t){function n(e,t,n,r){return e.star<span class="fstat-no" title="function not covered" >te</span>d||(e.started=<span class="cstat-no" title="statement not covered" >!0),f(<span class="fstat-no" title="function not covered" >t)</span>||(t=[t]),<span class="cstat-no" title="statement not covered" >0==t.length?l.setImmediate(function(</span>){e.dra</span>in&amp;&amp;e.drain(<span class="fstat-no" title="function not covered" >)}</span>):void h(t,fun<span class="cstat-no" title="statement not covered" >ct<span class="fstat-no" title="function not covered" >io</span>n(t){var i<span class="cstat-no" title="statement not covered" >={dat<span class="cstat-no" title="statement not covered" >a:t,callback:</span></span>"func<span class="cstat-no" title="statement not covered" >tion"==typeof r?r:null};n?e.tasks.unshif<span class="cstat-no" title="statement not covered" ></span>t(i):e.tasks.push(i),e.saturated&amp;&amp;e.tas</span>ks.</span>length===<span class="fstat-no" title="function not covered" >e.</span>concurrency&amp;&amp;e<span class="cstat-no" title="statement not covered" >.saturated<span class="fstat-no" title="function not covered" >()</span>,l.setImme<span class="cstat-no" title="statement not covered" >diate(e.process)})}void 0===t&amp;&amp;(t=1</span>);v</span>ar r=0,i={t<span class="fstat-no" title="function not covered" >as</span>ks:[],concurre<span class="cstat-no" title="statement not covered" >nc<span class="fstat-no" title="function not covered" >y:</span>t,saturate<span class="cstat-no" title="statement not covered" >d:nul<span class="cstat-no" title="statement not covered" >l,empty:null,</span></span>drain<span class="cstat-no" title="statement not covered" >:null,started:!1,paused:!1,push:function<span class="cstat-no" title="statement not covered" ></span>(e,t){n(i,e,!1,t)},kill:function(){i.d</span>rai</span>n=null,i.<span class="fstat-no" title="function not covered" >ta</span>sks=[]},unshift:funct<span class="fstat-no" title="function not covered" >io</span>n(e,t){n(<span class="cstat-no" title="statement not covered" >i,e,!0,t)},process:function(){if(!i.paused&amp;&amp;r&lt;i.concurrency&amp;&amp;i.tasks.lengt<span class="fstat-no" title="function not covered" >h)</span>{var t=i.<span class="cstat-no" title="statement not covered" >tasks.shift();i.empt</span>y&amp;&amp;0===i.ta<span class="fstat-no" title="function not covered" >sk</span>s.length&amp;&amp;i.empt<span class="cstat-no" title="statement not covered" >y(),r+=1;var n=function(){r-=1,t.callback&amp;&amp;t.c<span class="cstat-no" title="statement not covered" ></span>allback.apply(t,arguments),i.drain&amp;&amp;i.tasks.length+r===0&amp;&amp;i.drain(),i.process()},o=a(n);e(t.data,o)}},length:function(){ret</span>urn<span class="cstat-no" title="statement not covered" ></span> i.tasks.length},ru</span>nning<span class="cstat-no" title="statement not covered" >:f</span>un<span class="cstat-no" title="statement not covered" >ction(){return r},idle:function(){return i.tasks.length+r===0},pause:function(){i.paused!==!0&amp;&amp;(i.paused=!0)},resume:func<span class="fstat-no" title="function not covered" >tion(</span>){if(<span class="cstat-no" title="statement not covered" >i.paused!==!1</span>){i.paused=!1;for(var e=1;e&lt;=i.concurren<span class="fstat-no" title="function not covered" >cy;e+</span>+)<span class="cstat-no" title="statement not covered" >l.setImmediate(i.process)</span>}}};return i},l.priorityQueue=function(e,t)<span class="fstat-no" title="function not covered" >{functio</span>n n(e<span class="cstat-no" title="statement not covered" >,t){return e.</span>priority-t.priority}function r(e,t,n){for(v<span class="fstat-no" title="function not covered" >ar r=-1,</span>i=<span class="cstat-no" title="statement not covered" >e.length-1;r&lt;i;){var o=r+(i-r+1&gt;&gt;&gt;1);n(t,e[o])&gt;=0?r=o<span class="cstat-no" title="statement not covered" >:i=o-1}return r}<span class="cstat-no" title="statement not covered" ></span>function i(e,t,i,o){return e.started||(e.star</span>ted=!<span class="cstat-no" title="statement not covered" >0),f(t)||<span class="fstat-no" title="function not covered" >(t</span>=[<span class="cstat-no" title="statement not covered" >t]),0==t.length?l.setImmediate(function(){e.drain&amp;&amp;e.drain()}):void h(t,function(t){var a={data:t,pri</span>o</span>ri<span class="cstat-no" title="statement not covered" >ty:i,<span class="cstat-no" title="statement not covered" ></span>callback:"fun</span>c</span>tion"==typeof o?o:null};e.tasks.splice(r(e<span class="fstat-no" title="function not covered" >.tasks,</span>a,<span class="cstat-no" title="statement not covered" >n)+1,0,a),e.saturated&amp;&amp;</span>e.tasks.length===e.concurrency&amp;&amp;e.saturated<span class="fstat-no" title="function not covered" >(),l.set</span>Im<span class="cstat-no" title="statement not covered" >mediate(e.</span>process)})}var o=l.queue(e,t);return o.p<span class="fstat-no" title="function not covered" >ush=f</span>un<span class="cstat-no" title="statement not covered" >ction(e,t,n){i(o,e,t,n)},dele</span>te o.unshift,o},l.cargo=function(e,t){var<span class="fstat-no" title="function not covered" > n=!1,</span>r=<span class="cstat-no" title="statement not covered" >[],i={tasks:r,payload:t,satura</span>ted:null,empty:null,drain:null,drained:!0,<span class="fstat-no" title="function not covered" >push:fu</span>nc<span class="cstat-no" title="statement not covered" >tion(e,n){f(e)||(e<span class="cstat-no" title="statement not covered" >=[e]),h(e,fu<span class="cstat-no" title="statement not covered" >n</span>ction(e){r.push({data:e,callback<span class="cstat-no" title="statement not covered" >:"function"==typeof n?n:nul</span></span>l</span>})<span class="cstat-no" title="statement not covered" ></span>,i.drained</span>=!1,i.saturated&amp;&amp;<span class="fstat-no" title="function not covered" >r.</span>length===t&amp;&amp;i.saturat<span class="fstat-no" title="function not covered" >ed</span>()}),<span class="cstat-no" title="statement not covered" >l.setImmediate(i.process)},pro</span>cess:func<span class="fstat-no" title="function not covered" >ti</span>on o(){<span class="cstat-no" title="statement not covered" >if(!n){if(0===r.length)return i.drain&amp;<span class="cstat-no" title="statement not covered" >&amp;!i.drained&amp;&amp;i<span class="cstat-no" title="statement not covered" ></span>.drain(),void(i.drained=<span class="cstat-no" title="statement not covered" ></span>!</span>0);var a=</span>"number"=<span class="fstat-no" title="function not covered" >=t</span>ypeof t?r<span class="cstat-no" title="statement not covered" >.splice(0,t):r.splice(0,r.length),s=d(a,function(e){return e.data});i.empt<span class="fstat-no" title="function not covered" >y&amp;</span>&amp;i.empty(<span class="cstat-no" title="statement not covered" >),n=!0,e(s,function(</span>){n=!1;var <span class="fstat-no" title="function not covered" >e=</span>arguments;h(a,fu<span class="cstat-no" title="statement not covered" >nction(t){t.callback&amp;&amp;t.callback.apply(null,e)}),o()})}},<span class="cstat-no" title="statement not covered" ></span>length:function(){return r.length},running:function(){return n}};return i};var N=function(e){return function(t){var n=Array</span>.pr</span>ototyp<span class="cstat-no" title="statement not covered" >e.slice.call(<span class="cstat-no" title="statement not covered" ></span>arguments,1);t<span class="fstat-no" title="function not covered" >.a</span>pply(null,n.co<span class="cstat-no" title="statement not covered" >ncat([functi</span>on(t){var n=Array.pro</span>totype.sl<span class="fstat-no" title="function not covered" >ic</span>e.call(arguments,1<span class="cstat-no" title="statement not covered" >);"</span>un<span class="cstat-no" title="statement not covered" >def</span>in<span class="cstat-no" title="statement not covered" >ed"!=typeof console&amp;&amp;(t?console.error&amp;&amp;console.error(t):console[e]&amp;&amp;h(n,function(t){console[e](t)}))}]))}}<span class="fstat-no" title="function not covered" >;l.lo</span>g=N("<span class="cstat-no" title="statement not covered" >log"),l.dir=N("dir<span class="fstat-no" title="function not covered" >")</span>,l.memoize<span class="cstat-no" title="statement not covered" >=function(e,t){var n={},r={};t=t||function(e){return e};var i=function(){var i=Array.prototype.slice.call(arg</span>uments),o=i.pop(),a=t.apply(n</span>ull,i);a in n?l.ne<span class="fstat-no" title="function not covered" >xt</span>Ti<span class="cstat-no" title="statement not covered" >ck(func<span class="cstat-no" title="statement not covered" >tion(){o.apply(n<span class="cstat-no" title="statement not covered" >ull,n[a])}):a in r?r[a].push(o):(r[a]=[o],e.apply(null,i.c</span></span>oncat<span class="cstat-no" title="statement not covered" >([function(){n[a]=arguments;var e=r[a];delete r[a];for</span>(v<span class="cstat-no" title="statement not covered" >ar t<span class="fstat-no" title="function not covered" >=0</span>,i=e.lengt<span class="cstat-no" title="statement not covered" >h;t&lt;i;t++)e[t].</span>ap<span class="cstat-no" title="statement not covered" ></span>ply(null,arguments)}])))};re<span class="fstat-no" title="function not covered" >tu</span>rn i.memo<span class="cstat-no" title="statement not covered" >=n,i.u</span>nmemo<span class="cstat-no" title="statement not covered" >ized=e,i},<span class="cstat-no" title="statement not covered" ></span>l.un<span class="fstat-no" title="function not covered" >me</span>moize=func<span class="cstat-no" title="statement not covered" >tion(e){return function(){return(e.unm</span>emoized</span>||e</span>)</span>.apply(null,arguments)}},l.times=function(<span class="fstat-no" title="function not covered" >e,t,n){</span>fo<span class="cstat-no" title="statement not covered" >r(var r=[],i=0;i&lt;</span>e;i++)r.push(i);return l.map(r,t,n)},l.time<span class="fstat-no" title="function not covered" >sSeries=</span>fu<span class="cstat-no" title="statement not covered" >nction(e,t</span>,n<span class="cstat-no" title="statement not covered" ></span>){for(var </span>r=</span>[],i=<span class="cstat-no" title="statement not covered" >0;i&lt;e;i++<span class="fstat-no" title="function not covered" >)r</span>.pu<span class="cstat-no" title="statement not covered" >sh(i);r<span class="fstat-no" title="function not covered" >et</span>urn l.mapSeries(<span class="cstat-no" title="statement not covered" >r,t,n)},l.seq=function(){var e=arguments<span class="cstat-no" title="statement not covered" ></span>;return function(){var <span class="fstat-no" title="function not covered" >t=</span>this,n=Array.pro<span class="cstat-no" title="statement not covered" >totype.slice.call(arguments),r=n.pop();l<span class="cstat-no" title="statement not covered" ></span>.reduce(e,n,function(e,n,r){n.apply(t,e.concat([function(){var e=arguments[0],t=<span class="fstat-no" title="function not covered" >Ar</span>ray.protot<span class="cstat-no" title="statement not covered" >ype.slice.call(</span>argu</span>ments</span>,1</span>)<span class="cstat-no" title="statement not covered" ></span>;r(e,t)}]))},function(e,n){r.apply(t,[e]<span class="fstat-no" title="function not covered" >.c</span>oncat(n))})}},l.co<span class="cstat-no" title="statement not covered" >mpo</span>se<span class="cstat-no" title="statement not covered" >=fu<span class="cstat-no" title="statement not covered" ></span>nctio<span class="fstat-no" title="function not covered" >n(</span>){return l<span class="cstat-no" title="statement not covered" >.seq.apply</span>(n</span>ull,A<span class="cstat-no" title="statement not covered" >rray.prototype.reverse.call(argume<span class="fstat-no" title="function not covered" >nt</span>s))};var<span class="cstat-no" title="statement not covered" > R=function(e,t){var n=function(){var </span>n=<span class="cstat-no" title="statement not covered" >this,r=A</span>rr<span class="cstat-no" title="statement not covered" >ay.prototype.sli<span class="cstat-no" title="statement not covered" ></span>ce.call(arguments)<span class="fstat-no" title="function not covered" >,i</span>=r.pop();<span class="cstat-no" title="statement not covered" >return e(t,function(</span>e,t){e.apply(n,r.concat([t]))},i)};if(arguments.length&gt;<span class="fstat-no" title="function not covered" >2)</span>{var r=Ar<span class="cstat-no" title="statement not covered" >ray.prototype.sl</span>ice.c<span class="cstat-no" title="statement not covered" >all(a<span class="cstat-no" title="statement not covered" ></span>rguments,2);<span class="cstat-no" title="statement not covered" >r</span>eturn n.apply(this,r)}return n<span class="cstat-no" title="statement not covered" >};l.applyEach=y(R),l.applyEa</span></span>chSeri</span>e<span class="cstat-no" title="statement not covered" ></span>s=b(R),l.forever=function(e,t){fun</span>ction n(r){if<span class="fstat-no" title="function not covered" >(r</span>){if(t)ret<span class="cstat-no" title="statement not covered" >urn t(r<span class="fstat-no" title="function not covered" >);</span>throw r}e<span class="cstat-no" title="statement not covered" >(n)}n()},"undefined"!=typeof e&amp;&amp;e.exports?e.exp</span>or</span>ts=l:(r=[<span class="fstat-no" title="function not covered" >],</span>i=function(){r<span class="cstat-no" title="statement not covered" >eturn l}.apply(t,r),!(voi<span class="cstat-no" title="statement not covered" >d 0!==i&amp;&amp;(<span class="cstat-no" title="statement not covered" >e</span></span>.exports=i)))}()}).c</span>all(t,n(24),n(2<span class="fstat-no" title="function not covered" >5)</span>.setImmediate)<span class="cstat-no" title="statement not covered" >},function(e,t){function <span class="cstat-no" title="statement not covered" >n(){throw <span class="cstat-no" title="statement not covered" >n</span></span>ew Error("setTimeout has n</span>ot been<span class="fstat-no" title="function not covered" > d</span>efined")}functi<span class="cstat-no" title="statement not covered" >on r(){thr<span class="cstat-no" title="statement not covered" ></span>ow new <span class="fstat-no" title="function not covered" >Er</span>ror("clearTimeo<span class="cstat-no" title="statement not covered" >ut ha</span>s <span class="cstat-no" title="statement not covered" >not been defined")}function i(e){if(c=</span>==<span class="cstat-no" title="statement not covered" >setTimeo<span class="cstat-no" title="statement not covered" ></span>ut)return set<span class="fstat-no" title="function not covered" >Ti</span>meout(e,0);if(<span class="cstat-no" title="statement not covered" >(c===n||!c)&amp;&amp;setTime<span class="fstat-no" title="function not covered" >ou</span>t)return c=setT<span class="cstat-no" title="statement not covered" >imeout,setTim</span>eo<span class="cstat-no" title="statement not covered" >ut(e,0);try{return c(e,0)}catch(t){try{r<span class="cstat-no" title="statement not covered" ></span>eturn c.</span>call(</span>n<span class="fstat-no" title="function not covered" >ul</span>l,e,0)}catch<span class="cstat-no" title="statement not covered" >(t){return c.call(this,e,0</span>)}}</span>}f</span>unction o(e<span class="fstat-no" title="function not covered" >){</span>if(f===cl<span class="cstat-no" title="statement not covered" >earTimeout)return clearTimeout(e);if((f===r||!f)&amp;&amp;clearTimeout)ret</span>ur</span>n f=c<span class="cstat-no" title="statement not covered" >learTimeo<span class="fstat-no" title="function not covered" >ut</span>,clearTimeo<span class="cstat-no" title="statement not covered" >ut(e);try{return f(e)}catch(t){try<span class="fstat-no" title="function not covered" >{r</span>eturn f.<span class="cstat-no" title="statement not covered" >call(</span>nu<span class="cstat-no" title="statement not covered" >ll,e)}catch(t){return f.call(this,e)}}</span>}f<span class="cstat-no" title="statement not covered" >unction <span class="cstat-no" title="statement not covered" ></span>a(){v&amp;&amp;d&amp;&amp;(<span class="fstat-no" title="function not covered" >v=</span>!1,d.length?<span class="cstat-no" title="statement not covered" >p=d.concat(p):g=-1,p.lengt</span>h&amp;&amp;s(</span>)<span class="cstat-no" title="statement not covered" ></span>)}function s(){if(!v){var e=i<span class="cstat-no" title="statement not covered" >(a);v=!0;for(var t=p.length;t;){for(d=p,<span class="cstat-no" title="statement not covered" ></span>p=[];++g&lt;t;)d&amp;&amp;d[g].run(<span class="cstat-no" title="statement not covered" ></span>)</span>;g=-1,t=p</span>.<span class="cstat-no" title="statement not covered" ></span>length}d=null,v=!1,o(e)}}function u(e,t){this.fun=<span class="fstat-no" title="function not covered" >e,</span>this.array=t}function<span class="fstat-no" title="function not covered" > l</span>(){<span class="cstat-no" title="statement not covered" >}var c<span class="cstat-no" title="statement not covered" >,f,h=<span class="cstat-no" title="statement not covered" >e.exports={}<span class="cstat-no" title="statement not covered" >;</span></span>!functio<span class="cstat-no" title="statement not covered" ></span>n</span>(){tr<span class="cstat-no" title="statement not covered" ></span>y{c="</span>function"==typeof setTimeout?setTimeout:n}catch(e){c=n<span class="fstat-no" title="function not covered" >}t</span>ry{f="fun<span class="cstat-no" title="statement not covered" >ction"==ty</span>peof clearTimeout?clearTimeout:r}catch(e){f</span>=r}}</span>();var d,p=[],v=!1,g=-1;h.nextTick=fu<span class="fstat-no" title="function not covered" >nc</span>tion(e){var t=new Arr<span class="fstat-no" title="function not covered" >ay</span>(a<span class="cstat-no" title="statement not covered" >rguments.length-1);if(arguments.length&gt;1)for(var n=1</span>;n&lt;argume<span class="fstat-no" title="function not covered" >nt</span>s.<span class="cstat-no" title="statement not covered" >length;n++)t[n-1]=arguments[n];p.push(new u(e,t)),1!==</span>p.length|<span class="fstat-no" title="function not covered" >|v</span>||i<span class="cstat-no" title="statement not covered" >(s)},u.prototype.r<span class="cstat-no" title="statement not covered" >un=function(){this.fun.<span class="cstat-no" title="statement not covered" >a</span></span>pply(null,this.array)},h.t<span class="cstat-no" title="statement not covered" >itle="browser",h.browser=!0,h.env={}<span class="cstat-no" title="statement not covered" >,</span></span>h.a<span class="cstat-no" title="statement not covered" >rgv=[],h.versio</span>n="",h.ve<span class="cstat-no" title="statement not covered" >rsio<span class="cstat-no" title="statement not covered" >ns={},h.on=l,h.addListene</span>r=l,h.onc<span class="cstat-no" title="statement not covered" >e=l,h.off=l,h.removeListe</span>n</span>e</span>r=l,h.rem<span class="fstat-no" title="function not covered" >ov</span>eAl<span class="cstat-no" title="statement not covered" >lListeners=l,h.emit=<span class="cstat-no" title="statement not covered" >l,h.binding=function(e)<span class="cstat-no" title="statement not covered" >{</span></span>throw new Error("process.bin<span class="cstat-no" title="statement not covered" >ding is not supported")},h.cwd=functio<span class="cstat-no" title="statement not covered" >n</span></span>(){<span class="cstat-no" title="statement not covered" >return"/"},h.</span>chdir=fun<span class="cstat-no" title="statement not covered" >ctio<span class="cstat-no" title="statement not covered" >n(e){throw new Error("p</span>rocess.ch<span class="cstat-no" title="statement not covered" >dir is not supported")}</span>,</span>h</span>.umask=fu<span class="fstat-no" title="function not covered" >nc</span>ti<span class="cstat-no" title="statement not covered" >on(){return 0}},function(e,t,n){function r(e,t){this._id</span>=e,this._<span class="fstat-no" title="function not covered" >cl</span>ea<span class="cstat-no" title="statement not covered" >rFn=t}var i=F<span class="cstat-no" title="statement not covered" >uncti<span class="cstat-no" title="statement not covered" ></span>on.pr<span class="cstat-no" title="statement not covered" >o</span>totype.apply;t.setTime<span class="cstat-no" title="statement not covered" >out=function(){retur<span class="cstat-no" title="statement not covered" >n new r(i.call<span class="cstat-no" title="statement not covered" >(</span></span>setTimeout,windo<span class="cstat-no" title="statement not covered" ></span>w</span>,arguments),clear</span>T</span>imeout)},<span class="fstat-no" title="function not covered" >t.</span>setIn<span class="cstat-no" title="statement not covered" >terval=function(){return </span>new r(i.c<span class="fstat-no" title="function not covered" >al</span>l(setInterval<span class="cstat-no" title="statement not covered" >,window,argum<span class="cstat-no" title="statement not covered" ></span>e<span class="fstat-no" title="function not covered" >nt</span>s),clearI<span class="cstat-no" title="statement not covered" >nter<span class="cstat-no" title="statement not covered" >val)},t.clearTimeout=t.clearInterval=function(</span>e){e&amp;&amp;e.c<span class="cstat-no" title="statement not covered" >lose(<span class="cstat-no" title="statement not covered" ></span>)</span>},r<span class="cstat-no" title="statement not covered" >.prototype.unref=r.prototype.ref=function(){},r.pr</span>ototype.c<span class="cstat-no" title="statement not covered" >lose=</span>f</span>unct</span>ion(){t<span class="cstat-no" title="statement not covered" >his</span>._<span class="cstat-no" title="statement not covered" >cle</span>ar<span class="cstat-no" title="statement not covered" >Fn.<span class="cstat-no" title="statement not covered" ></span>call(window<span class="fstat-no" title="function not covered" >,t</span>his._id)},t.enro<span class="cstat-no" title="statement not covered" >ll=function(e,t){clearTimeout(<span class="cstat-no" title="statement not covered" ></span>e._idleTimeoutId),e._i<span class="cstat-no" title="statement not covered" >dleTimeout=t},t.unenroll=function(e<span class="cstat-no" title="statement not covered" >){clearTimeout(e._id<span class="cstat-no" title="statement not covered" >l</span></span></span>eTimeoutId),e._idleTimeout=-1},t._unrefAc</span>tive=t.active=fun<span class="fstat-no" title="function not covered" >ct</span>ion(e){cl<span class="cstat-no" title="statement not covered" >earTimeout(e._idleTimeoutId);var </span>t=e._idleTimeout;t&gt;=0&amp;&amp;(e._idleTimeoutId=setTimeout(function(){e._onTimeout&amp;&amp;e._onTimeout()},t))},n(26),t.setImmediate=setImmediate,t.clearImmediate=clearImmediate},function(e,t,n<span class="fstat-no" title="function not covered" >){</span>(function(<span class="cstat-no" title="statement not covered" >e,t){!function(e,n){"use strict";function r(e){"funct</span>ion"!=t<span class="fstat-no" title="function not covered" >yp</span>eof e&amp;&amp;(e<span class="cstat-no" title="statement not covered" >=new Functi</span>on(""+e))<span class="fstat-no" title="function not covered" >;f</span>or(var t=n<span class="cstat-no" title="statement not covered" >ew Array(arguments.length-1),n=0;n&lt;t.length;n++)t[n</span>]=argumen<span class="fstat-no" title="function not covered" >ts</span>[n+1];var<span class="cstat-no" title="statement not covered" > r={callba</span>ck</span>:<span class="fstat-no" title="function not covered" >e,</span>args:t};return v[p]=r,d<span class="fstat-no" title="function not covered" >(p</span>),p++<span class="cstat-no" title="statement not covered" >}function i(e){delete v[e]}f</span>unctio<span class="cstat-no" title="statement not covered" >n o(e){var t=e.callback,r<span class="cstat-no" title="statement not covered" ></span>=e.args;switc<span class="fstat-no" title="function not covered" >h(</span>r.length)<span class="cstat-no" title="statement not covered" >{case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break</span>;case 3:t(r[0],<span class="fstat-no" title="function not covered" >r[</span>1],r[2]);<span class="cstat-no" title="statement not covered" >break;default:t.apply(n,r)}}function a(e){if(g)setTimeout(a,0,e);e</span>lse{var t=v[e];if(t){g=!0;try{o(<span class="fstat-no" title="function not covered" >t)</span>}finally{i<span class="cstat-no" title="statement not covered" >(e),g=!1}}}}fu</span>nction s(){d=function(e){t.nextTick<span class="fstat-no" title="function not covered" >(f</span>unction(){a(e)})}}function u(<span class="fstat-no" title="function not covered" >){</span>if(e.post<span class="cstat-no" title="statement not covered" >Message&amp;&amp;!e.importScripts){var t=!0,n</span>=e.onmessa<span class="fstat-no" title="function not covered" >ge</span>;return e.on<span class="cstat-no" title="statement not covered" >message=function(){t=!1},e.postMessage("","*"),e.</span>onmessage=n,<span class="fstat-no" title="function not covered" >t}</span>}function <span class="cstat-no" title="statement not covered" >l(){var t="setImmediate$"+Math.random()+"$",n=func</span>tion(n){n.source===e&amp;&amp;"st<span class="fstat-no" title="function not covered" >ri</span>ng"==typeo<span class="cstat-no" title="statement not covered" >f n.data&amp;&amp;0===n.data.indexOf(t)&amp;</span>&amp;a(+n<span class="cstat-no" title="statement not covered" >.data.slice(t.l<span class="cstat-no" title="statement not covered" ></span>ength))};e.addEventListener?e.addEv<span class="fstat-no" title="function not covered" >en</span>tListener<span class="cstat-no" title="statement not covered" >("message",n,!1):e.attachEvent</span>("onme</span>ssage",n),d=function(n){e.postMessage(t+n,"*")}}function c(){var e=n</span>e<span class="fstat-no" title="function not covered" >w </span>MessageChannel<span class="cstat-no" title="statement not covered" >;<span class="fstat-no" title="function not covered" >e.</span>port1.onmess<span class="cstat-no" title="statement not covered" >a<span class="fstat-no" title="function not covered" >ge</span>=function(e){var t=e.data;a(t)},d=<span class="fstat-no" title="function not covered" >fu</span>nct<span class="cstat-no" title="statement not covered" >ion(t){e.port2.postMessage(t)}}function f(){v<span class="cstat-no" title="statement not covered" >a</span>r e=y.documentElement;d=function(t){var n=y.createElement(<span class="cstat-no" title="statement not covered" >"script");n.onreadyst</span></span>atech<span class="cstat-no" title="statement not covered" >ange=function(){a(t)<span class="cstat-no" title="statement not covered" ></span>,n.onreadystatechange=nu</span>ll,e.remo<span class="fstat-no" title="function not covered" >ve</span>Chi<span class="cstat-no" title="statement not covered" >ld(n),n=null}</span>,e.append<span class="fstat-no" title="function not covered" >Ch</span>ild(n)}}f<span class="cstat-no" title="statement not covered" >unction h()</span>{d<span class="cstat-no" title="statement not covered" >=functi<span class="cstat-no" title="statement not covered" ></span>on(e){setTimeout(a,0,e)}<span class="cstat-no" title="statement not covered" >}if(<span class="cstat-no" title="statement not covered" >!</span>e.setI</span>mmedia<span class="cstat-no" title="statement not covered" >te){var <span class="cstat-no" title="statement not covered" >d</span>,p=1,v</span>={},g=<span class="cstat-no" title="statement not covered" >!1,y=e.docume<span class="cstat-no" title="statement not covered" >n</span>t,m=Ob</span>ject.g<span class="cstat-no" title="statement not covered" >etPrototypeOf&amp;&amp;Obj<span class="cstat-no" title="statement not covered" >e</span>ct.get</span>Prototy<span class="cstat-no" title="statement not covered" >peOf(e);m=m&amp;&amp;m</span>.</span>setTimeou<span class="fstat-no" title="function not covered" >t?</span>m:e<span class="cstat-no" title="statement not covered" >,"[ob<span class="cstat-no" title="statement not covered" >ject process]"==={}</span>.toString.<span class="cstat-no" title="statement not covered" >call(<span class="cstat-no" title="statement not covered" ></span>e.proc<span class="cstat-no" title="statement not covered" >ess)?<span class="cstat-no" title="statement not covered" >s</span>():<span class="cstat-no" title="statement not covered" >u()?l(</span>):e.Mess<span class="cstat-no" title="statement not covered" >ageChannel?</span>c</span>(</span>)</span>:y&amp;&amp;"onre<span class="fstat-no" title="function not covered" >ad</span>ys<span class="cstat-no" title="statement not covered" >tatechange"in y.createElement("scrip<span class="fstat-no" title="function not covered" >t"</span>)?f<span class="cstat-no" title="statement not covered" >():h(),m.se<span class="fstat-no" title="function not covered" >tI</span>mmediate=<span class="cstat-no" title="statement not covered" >r,m.cl</span>ear</span>Im</span>mediate=i<span class="fstat-no" title="function not covered" >}}</span>("<span class="cstat-no" title="statement not covered" >undefined"==typeof self?"undefined"==typeo<span class="cstat-no" title="statement not covered" >f e</span>?t<span class="cstat-no" title="statement not covered" >his:e:self)}<span class="cstat-no" title="statement not covered" ></span>).call(t,function()<span class="fstat-no" title="function not covered" >{r</span>eturn thi<span class="cstat-no" title="statement not covered" >s}(),n</span>(24))},function(e,t,n){var r,i;(function</span>(</span>o,a,s,u){<span class="fstat-no" title="function not covered" >/*</span>*<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
	 * A JavaScript implementation of the JSON-LD API.
	 *
	 * @author Dave Longley
	 *
	 * @license BSD 3-Clause License
	 * Copyright (c) 2011-2015 Digital Bazaar, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * Redistributions in binary form must reproduce the above copyright
	 * notice, this list of conditions and the following disclaimer in the
	 * documentation and/or other materials provided with the distribution.
	 *
	 * Neither the name of the Digital Bazaar, Inc. nor the names of its
	 * contributors may be used to endorse or promote products derived from
	 * this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
	 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
	 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
	 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(){var l=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof o&amp;&amp;o.versions&amp;&amp;o.versions.node,</span>c=<span class="cstat-no" title="statement not covered" >!l&amp;&amp;("undefined"!=typeof window||"undefined"!=typeof self);<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;"undefined"==typeof a&amp;&amp;("undefined"!=typeof window?a=window:"undefined"!=typeof self?a=self:"undefined"!=typeof $&amp;&amp;(a=$));v</span>ar f=<span class="cstat-no" title="statement not covered" >function(e){function t(){}function<span class="fstat-no" title="function not covered" > r</span>(e){for(var <span class="fstat-no" title="function not covered" >t=</span>[],n=Object.<span class="fstat-no" title="function not covered" >ke</span>ys(<span class="cstat-no" title="statement not covered" >e).sort(),r=0;r&lt;n.length;++r){var i=n[r],o=e[i];B(o)||(o=[o]);f<span class="cstat-no" title="statement not covered" >or(va</span>r <span class="cstat-no" title="statement not covered" >a=0;a<span class="cstat-no" title="statement not covered" ></span>&lt;o.length;++a)<span class="cstat-no" title="statement not covered" >{</span>var s=o[a];if(null!==s){if(!z(s))<span class="cstat-no" title="statement not covered" >throw<span class="cstat-no" title="statement not covered" ></span> new Ce("Inva<span class="cstat-no" title="statement not covered" >lid JSON-<span class="cstat-no" title="statement not covered" >LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:e});t.push({"@value":s,"@langua<span class="cstat-no" title="statement not covered" >g</span></span>e":i.toLowerCase()})}}}return t}function i(e,t){i</span>f</span>(<span class="cstat-no" title="statement not covered" ></span>B</span>(t))for(v</span>ar n=0;n&lt;<span class="fstat-no" title="function not covered" >t.</span>lengt<span class="cstat-no" title="statement not covered" >h;++n)t[<span class="cstat-no" title="statement not covered" >n]=i(e,t[n]);else if(K(t))t<span class="cstat-no" title="statement not covered" >["@list"]=i(e,t[</span></span>"@li<span class="cstat-no" title="statement not covered" >st"]);el<span class="cstat-no" title="statement not covered" >se if(q(t)){Z(t)&amp;&amp;(t["@id"]=</span>e.ge<span class="cstat-no" title="statement not covered" >tId(t["@i<span class="cstat-no" title="statement not covered" >d"]));for(var r=Object.keys(t).sort<span class="cstat-no" title="statement not covered" >(</span>),o=0;o&lt;r.length;++o){var a=r[o];"@id"!==a&amp;&amp;(t[a]=i(e,t[a<span class="cstat-no" title="statement not covered" >]))}}<span class="cstat-no" title="statement not covered" ></span>return t}function f(t,n,r){if</span>(<span class="cstat-no" title="statement not covered" ></span>n</span></span></span>ull===r||</span>void 0===<span class="fstat-no" title="function not covered" >r)</span>return <span class="cstat-no" title="statement not covered" >null;var i=L(t,n,{vocab:<span class="cstat-no" title="statement not covered" >!0});if("@id"</span></span>===i)<span class="cstat-no" title="statement not covered" >return L(t,r,{base<span class="cstat-no" title="statement not covered" ></span>:!0});if("@ty<span class="cstat-no" title="statement not covered" >pe"===i)return L(t,r,{vo<span class="cstat-no" title="statement not covered" >c</span></span>ab:!0,base:!0}<span class="cstat-no" title="statement not covered" >);var o=e.getContextValue(t,n,"@ty</span></span>pe");<span class="cstat-no" title="statement not covered" >if("@id"===o||"@graph"===i&amp;&amp;z(r<span class="cstat-no" title="statement not covered" ></span>))return{"@id":L(t,r,{base:!0})};<span class="cstat-no" title="statement not covered" >if("@vocab"===o)return{"@id":L(<span class="cstat-no" title="statement not covered" >t</span></span>,r,{vocab:!0,ba<span class="cstat-no" title="statement not covered" >se:!0})};if(M(i))return r;var a={};if(nu<span class="cstat-no" title="statement not covered" >l</span></span>l!==o)a<span class="cstat-no" title="statement not covered" >["@type"]=</span></span>o;els<span class="cstat-no" title="statement not covered" >e i<span class="cstat-no" title="statement not covered" ></span>f(z(r)){var <span class="cstat-no" title="statement not covered" >s=e.getContext</span>Valu<span class="cstat-no" title="statement not covered" >e(t,n,"@languag<span class="cstat-no" title="statement not covered" >e");null!==s&amp;&amp;(a["@language"]=s)}re<span class="cstat-no" title="statement not covered" ></span>turn["boolean","number","strin<span class="cstat-no" title="statement not covered" ></span>g</span></span>"].indexOf(typeof r)===-1&amp;&amp;(r=r.toString()),a["@value"]=r,a}function h(e,t,n){for(var r=[],i=</span>Object.ke<span class="fstat-no" title="function not covered" >ys</span>(e).sor<span class="cstat-no" title="statement not covered" >t(),o=0;o&lt;i.length;++o)for(var a=i[o],s=e[a],u=Object.ke<span class="cstat-no" title="statement not covered" >ys(s).sort(),l=0;l&lt;u.length;++l){var c=u[l],f=s[c];if("@type"===c)c=Ee;e<span class="cstat-no" title="statement not covered" >lse i</span>f(<span class="cstat-no" title="statement not covered" >M(c))<span class="cstat-no" title="statement not covered" ></span>continue;for(va<span class="cstat-no" title="statement not covered" >r h=0;</span>h&lt;f.<span class="cstat-no" title="statement not covered" >length;+<span class="cstat-no" title="statement not covered" >+h){var v<span class="cstat-no" title="statement not covered" >=</span></span></span>f[h],g={};if(g.type=0===a.indexOf<span class="cstat-no" title="statement not covered" >("_:"</span>)?<span class="cstat-no" title="statement not covered" >"bl<span class="cstat-no" title="statement not covered" ></span>ank node":"IRI",g.value=a,ee(a)){var y={};if(y.type=0===c.indexOf("_:")?<span class="cstat-no" title="statement not covered" >"bl<span class="cstat-no" title="statement not covered" ></span>ank node":"IRI",y.value=c,ee(c)&amp;&amp;("blank node"!==y.type||n.produceGeneralizedRdf))if(K(v))d(v["@list"],t,g,y,r);els<span class="cstat-no" title="statement not covered" >e{var m=<span class="cstat-no" title="statement not covered" >p(v);m&amp;&amp;r.push({subject</span>:g,predica<span class="cstat-no" title="statement not covered" >te:y,<span class="cstat-no" title="statement not covered" ></span>object:m})}}}}return r}function d(e,t,n,r,i){</span>f</span></span>o</span>r<span class="cstat-no" title="statement not covered" ></span>(</span></span>var o={ty</span>pe:"IRI",<span class="fstat-no" title="function not covered" >va</span>lue:_e},a={<span class="cstat-no" title="statement not covered" >type:"IRI",value:ke},s={type:"IRI",value:Te},u=0;u&lt;e.length;++u){var l=e[u],c={type:"blank node",value:t.g<span class="cstat-no" title="statement not covered" >etId(</span>)}<span class="cstat-no" title="statement not covered" >;i.push({subject:n,predicate:r,objec<span class="cstat-no" title="statement not covered" ></span>t:c}),n=c,r=o;var f=p(l);f&amp;&amp;i.push({subject:n,pred</span>icate<span class="cstat-no" title="statement not covered" >:r,ob<span class="cstat-no" title="statement not covered" ></span>ject:f}),r=a}i.push({subject:n,predicate:r,object<span class="cstat-no" title="statement not covered" ></span>:</span>s})}function p(e){var t={};if(Q(e)){t.typ</span>e="litera<span class="fstat-no" title="function not covered" >l"</span>;var n=e[<span class="cstat-no" title="statement not covered" >"@v<span class="cstat-no" title="statement not covered" ></span>alue"],r=<span class="cstat-no" title="statement not covered" >e["@type"]||null;J</span>(n)?(<span class="cstat-no" title="statement not covered" >t.value=n.to</span>St<span class="cstat-no" title="statement not covered" >ring(),t.datatype<span class="cstat-no" title="statement not covered" ></span>=r||ge):W(n)||r===ye?(W(n)||(n=parseFloat(n)),t.value=n.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),t.datatype=r||ye):V(n)?(t.value=n.toFixed(0),t.datatype=r||me):"@language"in e?(t.value=n,t.datatype=r||je,t.language=e["@language"]):(t.value=n,t.datatype=r||be)}else{var i=q(e)?e["@id"]:e;t.type=0===</span>i.indexOf("<span class="cstat-no" title="statement not covered" >_:")?"blank node<span class="cstat-no" title="statement not covered" ></span>":"IRI",t.value=i}return"IRI"!==t.type||ee(t.value)?t:nul<span class="cstat-no" title="statement not covered" ></span>l</span>}function v(e,t){if("IRI"===e.type||"blan</span>k node"==<span class="fstat-no" title="function not covered" >=e</span>.type<span class="cstat-no" title="statement not covered" >)return{"@id":e.value};var n={"@value":e.<span class="cstat-no" title="statement not covered" >value};if(e.language)n[</span></span>"@lan<span class="cstat-no" title="statement not covered" >guage"]=e.language;<span class="cstat-no" title="statement not covered" ></span>else{var r=e.d<span class="cstat-no" title="statement not covered" >atatype;if(r||(r=be),t){if(</span>r===ge)"tr<span class="cstat-no" title="statement not covered" >ue"===n["@v<span class="cstat-no" title="statement not covered" ></span>alue"]?n["@value<span class="cstat-no" title="statement not covered" >"]=!0:"fal<span class="cstat-no" title="statement not covered" >se"===n["@value"]&amp;&amp;(n["@value"]=!1);else if(X(n["@value"]))if(r===me){var i=p</span>arse<span class="cstat-no" title="statement not covered" >Int(n["@value"],10<span class="cstat-no" title="statement not covered" >);i.toFixed(0)===<span class="cstat-no" title="statement not covered" >n["@value"]&amp;&amp;(n["@value"]<span class="cstat-no" title="statement not covered" ></span>=i)}else r===ye&amp;&amp;(n["@value"]=parseFloat(n["@</span>value<span class="cstat-no" title="statement not covered" >"]));[ge,me,ye,be].indexOf(r)===-1&amp;&amp;(n["@type"<span class="cstat-no" title="statement not covered" >]</span></span></span></span>=r)}else r!==be&amp;&amp;(n["@type"]=r)}return n}funct</span>ion g<span class="cstat-no" title="statement not covered" >(e,t){for(var n=["subjec<span class="cstat-no" title="statement not covered" ></span></span>t</span>","predic</span>ate","obj<span class="fstat-no" title="function not covered" >ec</span>t"],r<span class="cstat-no" title="statement not covered" >=0;r&lt;n.length;++r){var i=n[r];if(e[i].type!==t[i].type||e[i].value!==<span class="cstat-no" title="statement not covered" >t[i].<span class="cstat-no" title="statement not covered" ></span>value)return!1}return e.object.language===t.object<span class="cstat-no" title="statement not covered" >.language&amp;<span class="cstat-no" title="statement not covered" ></span></span>&amp;</span>e.object.datatype===t.object.datatype}function y(t,n,r,i,o,a){if(B(t))for(var s=0;s&lt;</span>t.length;<span class="fstat-no" title="function not covered" >++</span>s)y(t[s],n,r,<span class="cstat-no" title="statement not covered" >i,void 0<span class="cstat-no" title="statement not covered" >,a);else{if(!q(t))return vo<span class="cstat-no" title="statement not covered" >id(a&amp;&amp;a.push(t));if(Q(t)</span></span>){if<span class="cstat-no" title="statement not covered" >("@type"i<span class="cstat-no" title="statement not covered" >n t){var u=t["@type"];0===<span class="cstat-no" title="statement not covered" >u</span></span>.indexOf<span class="cstat-no" title="statement not covered" >("_:")&amp;&amp;(t["@type"]=u=<span class="cstat-no" title="statement not covered" >i.getId(u))<span class="cstat-no" title="statement not covered" ></span>}return void(a&amp;&amp;a.push(t))}if("@type"in t)for(va<span class="cstat-no" title="statement not covered" ></span>r</span> l=t["@type"],s=0;s&lt;l.leng<span class="cstat-no" title="statement not covered" ></span>t</span>h;++s){var u=l<span class="cstat-no" title="statement not covered" >[s];0===u.indexOf("_:")&amp;&amp;i.getId(u)}G(o)&amp;&amp;(o=Z(<span class="cstat-no" title="statement not covered" >t)?i.<span class="cstat-no" title="statement not covered" ></span>getId(t["@id"]):t["@id"]),a&amp;&amp;a.pu<span class="cstat-no" title="statement not covered" ></span>s</span></span>h({"@id":o});var c=n[r],f=c[o]=c[o]||{};f["@id"]=o;for(var h=Ob</span>ject.<span class="cstat-no" title="statement not covered" >keys(</span>t)<span class="cstat-no" title="statement not covered" >.sort(),d=0;d&lt;<span class="cstat-no" title="statement not covered" ></span>h.length;++<span class="cstat-no" title="statement not covered" >d</span>){var p=h[d];if("@id"!==p)if("@reverse"!==p)if("@graph"!=<span class="cstat-no" title="statement not covered" >=p)if<span class="cstat-no" title="statement not covered" ></span>("@type"!==p&amp;<span class="cstat-no" title="statement not covered" >&amp;M(p)){if("@index"=<span class="cstat-no" title="statement not covered" >==p&amp;&amp;p in f&amp;&amp;(t[p<span class="cstat-no" title="statement not covered" >]!==f[p]||t[p]["@id"]!<span class="cstat-no" title="statement not covered" >==f[p]["@id"]))throw new Ce("Invalid JSON-LD syntax; conflicting @<span class="cstat-no" title="statement not covered" >index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:f});f[p]=t[p]}else{var v=t[p];if(0===p.indexOf("_:")&amp;&amp;(<span class="cstat-no" title="statement not covered" >p</span></span>=i.getId(p</span>)),0!==v.le<span class="cstat-no" title="statement not covered" >ngth)<span class="cstat-no" title="statement not covered" ></span>for(var g=0;g&lt;v.length;++g){var m=v[g];if("@type"===<span class="cstat-no" title="statement not covered" >p&amp;&amp;(m=0===m.indexOf("_:")?i.getId(<span class="cstat-no" title="statement not covered" >m):m)<span class="cstat-no" title="statement not covered" ></span>,$(m)||Y(m)){var b=Z(m)?i.getId(m["@id"]):m["@id"];e.addValue(f,p,{"@id<span class="cstat-no" title="statement not covered" >":b},{propertyIsArray:!0,allowDu<span class="cstat-no" title="statement not covered" ></span>plicate:!1}),y(m,n,r,i,b)}else if(K(m)){var w=[];y(m["@list"],n,r,i,o,w),m={"@l</span>ist":<span class="cstat-no" title="statement not covered" >w},e.addValue(f<span class="cstat-no" title="statement not covered" >,p,<span class="cstat-no" title="statement not covered" ></span>m,{propertyIsArray:!0,allowDuplicate:!1})}else y(m,n,r,i,o),e.addValue(f,p,m,{propertyIsArray:!0</span>,allo<span class="cstat-no" title="statement not covered" >wDuplicate:!1})}else e.addValue(f,p,[],{propertyIsArray:!0})}else{o in </span></span></span>n</span>||(n<span class="cstat-no" title="statement not covered" >[o]={});var x="@merged"===r?r:o;y(t[p],n,</span></span>x</span>,i)}e<span class="cstat-no" title="statement not covered" >lse{var _={"@id":o}</span>,k=t[<span class="cstat-no" title="statement not covered" >"@reverse"];for(va<span class="cstat-no" title="statement not covered" ></span>r T in k)for(va</span>r</span> E=k[T],S=0<span class="cstat-no" title="statement not covered" >;S&lt;E.lengt</span>h;<span class="cstat-no" title="statement not covered" >++S){var N=E[S<span class="cstat-no" title="statement not covered" ></span>],R=N["@id"];Z(<span class="cstat-no" title="statement not covered" >N)&amp;&amp;(R=i.getId(R)),y(N,n,r,i,R),e.addValu<span class="cstat-no" title="statement not covered" >e(c[R</span>],<span class="cstat-no" title="statement not covered" >T,_,{prop<span class="cstat-no" title="statement not covered" ></span>ertyIsArray:!0,allowDuplicate:!1})}}}}}function m(e){for(var t=e["@default"],n=Object.keys(e).s</span>o</span></span>r</span></span>t</span>(</span>),r=0;r&lt;n<span class="fstat-no" title="function not covered" >.l</span>eng<span class="cstat-no" title="statement not covered" >th;++r){var i=n[r];if("@default"!==i){var o=e[i],a=t[i];a?"@graph"in a||(a<span class="cstat-no" title="statement not covered" >["@gr<span class="cstat-no" title="statement not covered" ></span>aph"]=[]):t[i]=a={"@id":i<span class="cstat-no" title="statement not covered" >,"@gr</span>ap<span class="cstat-no" title="statement not covered" >h":[]<span class="cstat-no" title="statement not covered" ></span>};for(var s=a["@graph"],u=Object.keys(o).sort(),l=0;l&lt;u.length<span class="cstat-no" title="statement not covered" >;</span>++l){var c=o[u[l]];Y(c)||s.push(c)}}}return t}function b(e,t,n,r,i){k(n<span class="cstat-no" title="statement not covered" >),n=n[0]<span class="cstat-no" title="statement not covered" ></span>;for(var o=e.opti</span>o</span>n<span class="cstat-no" title="statement not covered" ></span>s</span>,a={embed</span>:_(n,o,"e<span class="fstat-no" title="function not covered" >mb</span>ed"),explic<span class="cstat-no" title="statement not covered" >it:_(n,o,"ex<span class="cstat-no" title="statement not covered" >p</span>licit"),requireAll:_(n,o,"requireAll")},s=T(e,t,n,a),u=Object.keys(s).sort(),l=0;l&lt;u.length;++l){var c=u[l],f=s[c];if("@link"===a.embed&amp;&amp;c in e.link)N(r,i,e.link[c])<span class="cstat-no" title="statement not covered" >;else</span>{n<span class="cstat-no" title="statement not covered" >ull==<span class="cstat-no" title="statement not covered" ></span>=i&amp;&amp;(e.uniqueEmbeds={});var h={};i<span class="cstat-no" title="statement not covered" >f(h["@id"]=c,e.lin</span>k[c]<span class="cstat-no" title="statement not covered" >=h,"@never"===a.embed||x(f,e.su</span>bject<span class="cstat-no" title="statement not covered" >Sta<span class="cstat-no" title="statement not covered" ></span>ck))N(r,i,h);else{"@last"===a.embed&amp;&amp;(c in e.uniqueEmbeds&amp;&amp;S(e,c),<span class="cstat-no" title="statement not covered" >e.uniqueEm</span>beds<span class="cstat-no" title="statement not covered" >[c]={parent:r,property:i}),e.subjectStack.push(f);for(var d=Object.keys(f).sort(),p=0;p&lt;d.length;p++){var v=d[p]<span class="cstat-no" title="statement not covered" >;</span>if(M(v))h[v]=te(f[v]);else if(!a.explicit||v in n)for(var<span class="cstat-no" title="statement not covered" > g=f[<span class="cstat-no" title="statement not covered" ></span>v],y=0;y<span class="cstat-no" title="statement not covered" >&lt;g.length;++y){</span>var <span class="cstat-no" title="statement not covered" >m=g[y];if(K(m)){var E={<span class="cstat-no" title="statement not covered" >"@list":[]};N(h,v,E);var R=m["@list"];for<span class="cstat-no" title="statement not covered" >(var <span class="cstat-no" title="statement not covered" ></span>j in R)if(m=R[j<span class="cstat-no" title="statement not covered" >],Y(m)){var O<span class="cstat-no" title="statement not covered" ></span>=v in n?n[</span>v][0]<span class="cstat-no" title="statement not covered" >["@list"]:w<span class="cstat-no" title="statement not covered" ></span>(a);b(e,[m["@id<span class="cstat-no" title="statement not covered" >"]],O,E,"@list")}else <span class="cstat-no" title="statement not covered" >N(E,"@list",te(m))}else if(Y(<span class="cstat-no" title="statement not covered" ></span>m)){var O=v in n?n[v]:w(a);b(</span>e,[m[<span class="cstat-no" title="statement not covered" >"@id"]],O,h,v)}else </span></span></span>N(h,v<span class="cstat-no" title="statement not covered" >,te(m))}}for(va<span class="cstat-no" title="statement not covered" >r d=Object.keys(n<span class="cstat-no" title="statement not covered" ></span>).sort(),p=0;p&lt;d.length</span>;++p)<span class="cstat-no" title="statement not covered" >{var v=d[p];if</span></span></span>(<span class="cstat-no" title="statement not covered" ></span></span></span>!</span>M(v)){var I=n[v][0],C=_(I,o,"omitDefault");if(!(C||v in h<span class="cstat-no" title="statement not covered" >)){va<span class="cstat-no" title="statement not covered" ></span>r A="@null";"@de<span class="cstat-no" title="statement not covered" >fault"in</span> I<span class="cstat-no" title="statement not covered" >&amp;&amp;(A=te(I["@default"]<span class="cstat-no" title="statement not covered" ></span>)),B(A)||(A=[A]),h[v]=[<span class="cstat-no" title="statement not covered" >{"@prese<span class="cstat-no" title="statement not covered" ></span>rve":A}]}}}N(r,i,h),e.subjectStack.pop()}}}}function w(e){var t={};for(var n</span> </span>i<span class="cstat-no" title="statement not covered" ></span>n</span> e)void 0!==e[n]&amp;&amp;(t["@"+n]=[e</span>[</span>n</span>]</span>]);return<span class="fstat-no" title="function not covered" >[t</span>]}functio<span class="cstat-no" title="statement not covered" >n x<span class="cstat-no" title="statement not covered" ></span>(e,t){for(var n<span class="cstat-no" title="statement not covered" >=t.length-1;n&gt;=0;--n)if(t[n]["@id<span class="cstat-no" title="statement not covered" >"</span></span>]===e["@id</span>"])return<span class="fstat-no" title="function not covered" >!0</span>;retu<span class="cstat-no" title="statement not covered" >rn!1}function _(e,t,n){var r="<span class="cstat-no" title="statement not covered" >@"+n,i=r in e?e[r][0]:t[n]<span class="cstat-no" title="statement not covered" >;return"e<span class="cstat-no" title="statement not covered" >m</span></span></span>bed"===n&amp;</span>&amp;(i===!0?<span class="fstat-no" title="function not covered" >i=</span>"@last":i===!<span class="cstat-no" title="statement not covered" >1?i="@</span>ne<span class="cstat-no" title="statement not covered" >ver":"@always"!==i&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>"@never"!==i&amp;&amp;"@link"!==i&amp;&amp;(i="@last")),i}function k(e){if(!B(e)||1!==e.length||!q(e[0]))throw new Ce("Invalid JS</span>ON-LD syn<span class="fstat-no" title="function not covered" >ta</span>x; <span class="cstat-no" title="statement not covered" >a JSON-LD frame must be a single <span class="cstat-no" title="statement not covered" >object.","jsonld.SyntaxError",{frame:e})}function T(e,t,n,r){for(var i={},o=0;o&lt;t.length;++o){var a=t[o],s=e.subj</span></span>ects[a];E<span class="fstat-no" title="function not covered" >(s</span>,n,r)&amp;&amp;(i<span class="cstat-no" title="statement not covered" >[a]=s)}return i}function E(t,n,r){if("@<span class="cstat-no" title="statement not covered" >type"</span>in<span class="cstat-no" title="statement not covered" > n&amp;&amp;(1!==n["@t<span class="cstat-no" title="statement not covered" ></span>ype"].length||!q(n["<span class="cstat-no" title="statement not covered" ></span>@</span>type"][0]</span>))){for(v<span class="fstat-no" title="function not covered" >ar</span> i=n["@<span class="cstat-no" title="statement not covered" >type"],o=0;o&lt;i.length;++o)if(e.hasValue(t,"@type",i[o]))retu<span class="cstat-no" title="statement not covered" >rn!0;return!1}var a=!0,s=!1;for(var u in<span class="cstat-no" title="statement not covered" > n){if(M(u)){if("@id"!==u&amp;&amp;"@t<span class="cstat-no" title="statement not covered" >ype"!==u)<span class="cstat-no" title="statement not covered" >c</span></span></span>ontinue;i</span>f</span>(a=!1<span class="cstat-no" title="statement not covered" >,"@</span>id<span class="cstat-no" title="statement not covered" >"==<span class="cstat-no" title="statement not covered" ></span>=u&amp;&amp;z(n[u])){if(<span class="cstat-no" title="statement not covered" >t[u]!==n[<span class="cstat-no" title="statement not covered" >u])return!1;s=!0;continue}<span class="cstat-no" title="statement not covered" >}if(a=!1,<span class="cstat-no" title="statement not covered" >u</span></span> in t){if(B(n[u])&amp;&amp;0===n[u]<span class="cstat-no" title="statement not covered" >.length&amp;&amp;void 0<span class="cstat-no" title="statement not covered" >!==t[u])r<span class="cstat-no" title="statement not covered" >e</span></span>turn<span class="cstat-no" title="statement not covered" >!</span>1;s=!0}el</span>s<span class="cstat-no" title="statement not covered" ></span>e</span>{var l=B(n[u])&amp;<span class="cstat-no" title="statement not covered" >&amp;q(n[u][0])&amp;&amp;"@default"in n[u][0];if(r.requ<span class="cstat-no" title="statement not covered" >ireAll&amp;&amp;!<span class="cstat-no" title="statement not covered" >l</span></span>)retu</span>rn!1}}retur<span class="cstat-no" title="statement not covered" >n a||s}function S(t,n){var r=t.uniqueEmbed<span class="cstat-no" title="statement not covered" ></span>s,i=r[n],o=i.parent,<span class="cstat-no" title="statement not covered" >a=i.proper</span></span>t<span class="cstat-no" title="statement not covered" ></span>y</span>,s={"@id":n}</span>;if(B(o))<span class="fstat-no" title="function not covered" >{f</span>or(var u=0;<span class="cstat-no" title="statement not covered" >u&lt;o.length;++u)</span>if<span class="cstat-no" title="statement not covered" >(e.co</span>mp<span class="cstat-no" title="statement not covered" >areValues</span>(o<span class="cstat-no" title="statement not covered" >[u],s)){o[u</span>]=<span class="cstat-no" title="statement not covered" >s;break}}e<span class="cstat-no" title="statement not covered" ></span>lse{var l<span class="cstat-no" title="statement not covered" >=B(o[a]);e.removeValue(o,a,<span class="cstat-no" title="statement not covered" >s,{propertyIsArray:l}),e.add<span class="cstat-no" title="statement not covered" >Value(o<span class="cstat-no" title="statement not covered" >,</span>a,s,{p</span>r</span></span>opertyIsArr<span class="cstat-no" title="statement not covered" >ay:l})}v<span class="cstat-no" title="statement not covered" ></span>ar c=function(e){for(var t=Object.keys(r),n=0;n&lt;t.length;++n){var i=t[n];i in r&amp;</span>&amp;</span>q(r[i<span class="cstat-no" title="statement not covered" >].parent)<span class="fstat-no" title="function not covered" >&amp;&amp;</span>r[i<span class="cstat-no" title="statement not covered" >].parent["@id"]===e&amp;&amp;(delete r[i],c(i))}};c(n)}func<span class="cstat-no" title="statement not covered" >tion <span class="cstat-no" title="statement not covered" ></span>N(t,n,r){q(t)?e.addValue(t,n,r,{propertyIsArray:!0}):t.push(r)}/**<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span>
	 * Removes the @preserve keywords as the last step of the framing algorithm.
	 *
	 * @param ctx the active context used to compact the input.
	 * @param input the framed, compacted output.
	 * @param options the compaction options used.
	 *
	 * @return the resulting output.
	 */
function <span class="fstat-no" title="function not covered" >R(</span>t,n,r){<span class="cstat-no" title="statement not covered" >if(B(n)){<span class="cstat-no" title="statement not covered" >for(var i=[],o=0;o&lt;n.length;++o){var a=<span class="cstat-no" title="statement not covered" >R(t,n[o],r);<span class="cstat-no" title="statement not covered" ></span>null!==a&amp;&amp;i.push(a)}n<span class="cstat-no" title="statement not covered" ></span>=</span>i}el</span>se if<span class="cstat-no" title="statement not covered" >(q(n)){</span></span>
// remove @preserve
<span class="cstat-no" title="statement not covered" >if("@preserve"in n)<span class="cstat-no" title="statement not covered" >return"@null"===n["@preserve"]?null:n["@preserve"];<span class="cstat-no" title="statement not covered" >i</span></span>f(Q(n))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f(K(n))<span class="cstat-no" title="statement not covered" >return n["@list"]=R(t,n["@list"],r),n;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >I(t,"@id");<span class="cstat-no" title="statement not covered" ></span>if(s in n){var u=<span class="cstat-no" title="statement not covered" >n[s];<span class="cstat-no" title="statement not covered" ></span>if(u in r.link){var l=<span class="cstat-no" title="statement not covered" >r.link[u].indexOf(n);<span class="cstat-no" title="statement not covered" ></span>if(l!==-1)<span class="cstat-no" title="statement not covered" >return r.link[u][l];<span class="cstat-no" title="statement not covered" >r</span></span>.link[u].push(n)}e</span>lse r<span class="cstat-no" title="statement not covered" >.link[u]=[n]}fo<span class="cstat-no" title="statement not covered" ></span></span>r</span>(var c in n){var a=R(<span class="cstat-no" title="statement not covered" >t,n[c],r),f=</span>e.<span class="cstat-no" title="statement not covered" >getContextValue(t,c,"@container");r.<span class="cstat-no" title="statement not covered" ></span>compactArrays&amp;&amp;B(a)&amp;&amp;1===a.length&amp;&amp;null===f&amp;&amp;(a=a[0]),n[c]=a}}re</span>t<span class="cstat-no" title="statement not covered" ></span>urn n}func</span>tion j(e,<span class="fstat-no" title="function not covered" >t)</span>{retu<span class="cstat-no" title="statement not covered" >rn e.length&lt;t.length?-1:t.length&lt;e.length?1:e===t?0:e&lt;t?-1:1}funct</span>ion O(e,t<span class="fstat-no" title="function not covered" >,n</span>,r,i,o){null=<span class="cstat-no" title="statement not covered" >==o&amp;&amp;(o="@null");var a=</span>[];if<span class="cstat-no" title="statement not covered" >("@<span class="cstat-no" title="statement not covered" ></span>id"!==o&amp;&amp;"@reverse"!==o||!Y(n))a.pus<span class="cstat-no" title="statement not covered" >h(o);else{"</span>@rev<span class="cstat-no" title="statement not covered" >erse"===o&amp;&amp;a.push("@reverse");var s=</span>I(e,n<span class="cstat-no" title="statement not covered" >["@id"],null,{vocab:!0});s in <span class="cstat-no" title="statement not covered" ></span>e.mappings&amp;&amp;e.mappings[s]&amp;&amp;e.mappings[s]["@id"]===n["@id"]?a.push.apply(a,["@vocab","@id"]):a.push.apply(a,["@id","@vocab"])}a.push<span class="cstat-no" title="statement not covered" ></span>(</span>"@none");for(va<span class="cstat-no" title="statement not covered" >r</span> u=e.inverse[t],l=0;l&lt;r.length;++l){var c=r[l];i<span class="cstat-no" title="statement not covered" >f(c i<span class="cstat-no" title="statement not covered" ></span>n u)for(va<span class="cstat-no" title="statement not covered" >r f=u[c][i],h=0;h&lt;a.length;++h){var d=a[h];i<span class="cstat-no" title="statement not covered" >f(d i<span class="cstat-no" title="statement not covered" ></span>n f)return<span class="cstat-no" title="statement not covered" > f[d]}}return</span></span> <span class="cstat-no" title="statement not covered" ></span></span>n</span>ull}function</span> I(e,t,n,<span class="fstat-no" title="function not covered" >r,</span>i){if(null=<span class="cstat-no" title="statement not covered" >==t)return t<span class="cstat-no" title="statement not covered" >;G(n)&amp;&amp;(n<span class="cstat-no" title="statement not covered" >=</span></span>null),G(i)&amp;&amp;(i=!1),r=r||{};var o=e.g</span>etInv<span class="cstat-no" title="statement not covered" >erse();if(M(t))<span class="cstat-no" title="statement not covered" ></span>return t<span class="cstat-no" title="statement not covered" > in o?o[t]["@none"]["@type"]["@none"]:t;if(r.voc<span class="cstat-no" title="statement not covered" >a</span></span>b&amp;&amp;t in o){var a=e["@lang<span class="cstat-no" title="statement not covered" >uage"]||"@none",s=[];q(n</span>)&amp;<span class="cstat-no" title="statement not covered" >&amp;"@<span class="cstat-no" title="statement not covered" ></span>index"in n&amp;&amp;s.push("@index");var u="@l</span>angua<span class="cstat-no" title="statement not covered" >ge",l="@null</span>";<span class="cstat-no" title="statement not covered" >if(i)u="<span class="cstat-no" title="statement not covered" ></span>@type<span class="cstat-no" title="statement not covered" >",l="@reverse",s.push("@set");else if(K</span>(n))<span class="cstat-no" title="statement not covered" >{"@index"<span class="cstat-no" title="statement not covered" >in n||s.push("@list");for(var <span class="cstat-no" title="statement not covered" >c</span>=n["@list"],f=0===c.length?a:null,h=null,d=0;d&lt;c.length;++d){var p=c[d],v="<span class="cstat-no" title="statement not covered" >@none</span>",<span class="cstat-no" title="statement not covered" >g="@none</span>";<span class="cstat-no" title="statement not covered" >if(Q(p)?<span class="cstat-no" title="statement not covered" ></span>"@language"in p?v=p["@language"]:"@type"in p?g=p["@type"]:v="@null":g="@id",null===f?f=v:v!==f&amp;&amp;Q(p)&amp;&amp;(f="@none"),null===h?h=g:g!==h&amp;&amp;(h="@none"),"@none"===f&amp;&amp;"@none"===h)break}f=<span class="cstat-no" title="statement not covered" >f||"@no<span class="cstat-no" title="statement not covered" ></span></span>n</span>e",h=h||"@none","@none"!==h?(u="@type",l=h):l=f}else Q(n)?</span>"@lan<span class="cstat-no" title="statement not covered" >guage"in n&amp;&amp;!("@index"in n)?(s.push("@language"),l=n["@language"]):"@type"in n&amp;&amp;(u="@type",l=n["@type"]):(u="@type",l="@id"),s.push("@set");s.push("@n<span class="cstat-no" title="statement not covered" >o</span></span></span>ne");var y=O(e,t</span>,n,s,<span class="cstat-no" title="statement not covered" >u,l);if(null!==<span class="cstat-no" title="statement not covered" ></span>y)return y}i<span class="cstat-no" title="statement not covered" >f(r.vocab&amp;<span class="cstat-no" title="statement not covered" ></span></span>&amp;</span>"@vocab"in e){var m=e["@vocab"]<span class="cstat-no" title="statement not covered" >;if(0===t.in<span class="cstat-no" title="statement not covered" ></span>dexOf(m)&amp;&amp;t!==m){var b=t.substr(m.<span class="cstat-no" title="statement not covered" >length);if(!(b in e<span class="cstat-no" title="statement not covered" ></span>.mappings))return b}}f<span class="cstat-no" title="statement not covered" >or(var w=n</span></span>u<span class="cstat-no" title="statement not covered" ></span>l</span>l,x=0,_=[],k=e.fastCurieMap,T=t.length-1;x&lt;T&amp;&amp;t[x]in k;++x)k=k[t[x]],""<span class="cstat-no" title="statement not covered" >in k&amp;&amp;_.push(k[""][0]);for(var d=_.<span class="cstat-no" title="statement not covered" >l</span></span>ength-1;d&gt;=0;--d)for(var E=_[<span class="cstat-no" title="statement not covered" >d],S=E.terms,N=0;N&lt;S.length;++N){var R=S[N]+":"+t.s<span class="cstat-no" title="statement not covered" >ubstr(E.iri.length),I=!(R in e.m</span>ap<span class="cstat-no" title="statement not covered" >pings)||null===n&amp;&amp;e.mappings[R]["@id"]===t;I&amp;&amp;(null===w<span class="cstat-no" title="statement not covered" ></span>||j(R,w)&lt;0)&amp;&amp;(w=R)}return null!=<span class="cstat-no" title="statement not covered" ></span>=</span></span>w?w:r.vocab?t:P(e["@base"],t)}function C(t,n</span>,r){if(Q(<span class="fstat-no" title="function not covered" >r)</span>){var i<span class="cstat-no" title="statement not covered" >=e.getContextVa<span class="cstat-no" title="statement not covered" >lue(t,n,"@type"),o=e.getContext</span>Va<span class="cstat-no" title="statement not covered" >lue(t,n,"@language"),a=e.getContext</span>Va<span class="cstat-no" title="statement not covered" >lue(t,n,"@container"),s="@index"in r</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >"@index"!==a;if(!s&amp;&amp;(r["@ty<span class="cstat-no" title="statement not covered" ></span>pe"]===i||r["@language"]===o))return r["@val<span class="cstat-no" title="statement not covered" >ue"];var u=Object.ke</span></span>ys(r)<span class="cstat-no" title="statement not covered" >.length,l=1===u||2===u</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >"@index"in r&amp;&amp;!s,c="@language"i</span>n <span class="cstat-no" title="statement not covered" >t,f=z(r["@value"</span>])<span class="cstat-no" title="statement not covered" >,h=t.mappings[n</span>]&amp;<span class="cstat-no" title="statement not covered" >&amp;null===t.mappings[n]["@language"];if(l&amp;&amp;(!c||!f|<span class="cstat-no" title="statement not covered" ></span>|h))return r["@val<span class="cstat-no" title="statement not covered" >ue"];var d={};return</span></span> s&amp;&amp;(<span class="cstat-no" title="statement not covered" >d[I<span class="cstat-no" title="statement not covered" ></span>(t,"@index")]=r["@index"]),"@type"in r?d[I(t,"@type")]=I(t,r["@type"],null,{vocab:!0}):"@language"in r&amp;&amp;(d[I(t,"@language")]=r["@language"]),d[I(t,"@value")]=r["@value"],d}var p=L(t,n,{vo</span>c</span>ab:!0<span class="cstat-no" title="statement not covered" >}),i=e.getContextV</span>al<span class="cstat-no" title="statement not covered" >ue(t,n,"@type"),v=I(t,r["@id"],</span>nu<span class="cstat-no" title="statement not covered" >ll,{vocab:"@vocab"===i});if("@id"===i||"<span class="cstat-no" title="statement not covered" ></span>@vocab"===i||"@graph"===p)return v;var d=<span class="cstat-no" title="statement not covered" >{};return </span></span>d[I(t<span class="cstat-no" title="statement not covered" >,"@<span class="cstat-no" title="statement not covered" ></span>id")]=v,d}function A(e,t,n</span>,r){if(n <span class="fstat-no" title="function not covered" >in</span> r){if(r[<span class="cstat-no" title="statement not covered" >n])return;t<span class="cstat-no" title="statement not covered" >hrow new<span class="cstat-no" title="statement not covered" > Ce("Cy<span class="cstat-no" title="statement not covered" >c</span></span>lical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:t,term:n})}if(r[n]=!1,M(n))t<span class="cstat-no" title="statement not covered" ></span>h</span>row new Ce("Inv<span class="cstat-no" title="statement not covered" >alid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:t,term:n});if(""===n)throw n<span class="cstat-no" title="statement not covered" >e</span></span>w Ce("Inv<span class="cstat-no" title="statement not covered" >alid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:t});e.mappings[n]&amp;&amp;de<span class="cstat-no" title="statement not covered" >l</span></span>ete e.mappings[n];var i=t[n];if(null</span>===i|<span class="cstat-no" title="statement not covered" >|q(i)<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;null===i["@id"])return e.mappings<span class="cstat-no" title="statement not covered" >[n]=null,void(r[n]=!0);if(z(i)&amp;&amp;(i={"@id<span class="cstat-no" title="statement not covered" >"</span></span>:i}),!q(i))throw new Ce("Inv<span class="cstat-no" title="statement not covered" >alid JSON-LD syntax; @context property values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:t});var o=e.mappings[n</span></span>]={};<span class="cstat-no" title="statement not covered" >if(o.reverse=!1,"<span class="cstat-no" title="statement not covered" ></span>@reverse"in i){if("@id"in i)thro<span class="cstat-no" title="statement not covered" >w new Ce("Inv<span class="cstat-no" title="statement not covered" >alid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});var a=i["@reverse"</span></span>];if(<span class="cstat-no" title="statement not covered" >!z(a))throw ne<span class="cstat-no" title="statement not covered" ></span>w Ce("Inv<span class="cstat-no" title="statement not covered" >alid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});var s=L(e,a,{vocab</span></span>:!0,b<span class="cstat-no" title="statement not covered" >ase:!1},t,r);if(!ee(s))throw n<span class="cstat-no" title="statement not covered" ></span>ew Ce("Inv<span class="cstat-no" title="statement not covered" >alid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});o["@id"]=s,o.reve<span class="cstat-no" title="statement not covered" >r</span></span>se=!0}else if("@id"in i)</span>{var <span class="cstat-no" title="statement not covered" >s=i["@id"];if(!z(s))<span class="cstat-no" title="statement not covered" >throw new<span class="cstat-no" title="statement not covered" ></span> Ce("Inva<span class="cstat-no" title="statement not covered" >lid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(s!==n){if(s=L(e<span class="cstat-no" title="statement not covered" >,</span></span>s,{vocab:<span class="cstat-no" title="statement not covered" >!0,base:!1},t,r),!ee(s)&amp;&amp;!M(s))throw new Ce("Inva<span class="cstat-no" title="statement not covered" >lid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});o["@id"]=s}}var u=<span class="cstat-no" title="statement not covered" >n</span></span>.indexOf(":</span>"</span>)</span></span>;if(o<span class="cstat-no" title="statement not covered" >._termHasColon=<span class="cstat-no" title="statement not covered" ></span>u!==-1,!("@id"in o))if(o._termHasColon)<span class="cstat-no" title="statement not covered" >{var l=n.substr(0,u);if(l <span class="cstat-no" title="statement not covered" >in t&amp;&amp;A(e,t,l,<span class="cstat-no" title="statement not covered" ></span>r),e.mappings[l]){var c=n.substr(u+1);o["@i<span class="cstat-no" title="statement not covered" >d"]=e.mappings<span class="cstat-no" title="statement not covered" ></span>[l]["@id"]+c}else o["@id"]=n}else</span>{if(!<span class="cstat-no" title="statement not covered" >("@vocab"in </span></span>e))th<span class="cstat-no" title="statement not covered" >row new Ce("Invalid<span class="cstat-no" title="statement not covered" > JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t,term:n});o["@id"]=e["@vocab"]+<span class="cstat-no" title="statement not covered" >n</span></span>}if(r[n]=!0,"@type"in i<span class="cstat-no" title="statement not covered" ></span>)</span></span>{var f=i["@type"];if(!z(f))th<span class="cstat-no" title="statement not covered" >row new Ce(<span class="cstat-no" title="statement not covered" ></span>"Invalid <span class="cstat-no" title="statement not covered" >JSON-LD syntax; an @context @type values must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:t});if("@id"!==f&amp;&amp;"@vocab"<span class="cstat-no" title="statement not covered" >!</span></span>==f){if(f=L(e,f,{vocab:!0,b<span class="cstat-no" title="statement not covered" >ase:!1},t,r),!ee(f))throw new Ce("Invalid <span class="cstat-no" title="statement not covered" >JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:t});if(0===f.indexOf("_:")<span class="cstat-no" title="statement not covered" >)</span></span>throw new Ce("Invalid <span class="cstat-no" title="statement not covered" >JSON-LD syntax; an @context @type values must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:t})}o["@type"]=f}if("@conta<span class="cstat-no" title="statement not covered" ></span></span>i</span>ner"in i){var<span class="cstat-no" title="statement not covered" ></span> </span>h=i["@container"];if("@lis<span class="cstat-no" title="statement not covered" >t"!==h&amp;&amp;"@set"!=<span class="cstat-no" title="statement not covered" ></span>=h&amp;&amp;"@index"!==h&amp;&amp;"@language"!==h)throw new Ce("Invalid JS<span class="cstat-no" title="statement not covered" >ON-LD syntax; @context @container value must be one of the following: @list, @set, @index, or @language.","jsonld.SyntaxError",{code:"invalid container mapping",context:t});if(o.reverse&amp;&amp;"@index"!=<span class="cstat-no" title="statement not covered" >=</span></span>h&amp;&amp;"@set"!==h&amp;&amp;null!==h)throw new Ce("Invalid JS<span class="cstat-no" title="statement not covered" >ON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});o["@container"]=h}if("@l<span class="cstat-no" title="statement not covered" >a</span></span>nguage"in i&amp;&amp;!("@t<span class="cstat-no" title="statement not covered" ></span>y</span>pe"in i)){var d=i["@language"];if(null!==<span class="cstat-no" title="statement not covered" >d&amp;&amp;!z(d))throw <span class="cstat-no" title="statement not covered" ></span>new Ce("Invalid JSO<span class="cstat-no" title="statement not covered" >N-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:t});null!==d&amp;&amp;(d=d.toLowerCas<span class="cstat-no" title="statement not covered" >e</span></span>()),o["@language"]=d}</span></span>
// disallow aliasing @context and @preserve
var s=<span class="cstat-no" title="statement not covered" >o["@id"];<span class="cstat-no" title="statement not covered" ></span>if("@context"===s||"@preserve"===s)<span class="cstat-no" title="statement not covered" >throw new Ce("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:t})}f</span></span>unction L<span class="fstat-no" title="function not covered" >(t</span>,n,r,i,o){i<span class="cstat-no" title="statement not covered" >f(null===n||M(n))r<span class="cstat-no" title="statement not covered" >eturn n;i<span class="cstat-no" title="statement not covered" >f</span></span>(n=String(n),i&amp;&amp;n in i&amp;&amp;o[n]!==!0&amp;&amp;A(t,i,n,o),r=r||{},r.vocab){var a=t<span class="cstat-no" title="statement not covered" >.mappings[n];i<span class="cstat-no" title="statement not covered" ></span>f(null===a)r<span class="cstat-no" title="statement not covered" >eturn null;i<span class="cstat-no" title="statement not covered" >f</span></span>(a)r<span class="cstat-no" title="statement not covered" >eturn a["@id"]}va</span></span>r</span> s=n.<span class="cstat-no" title="statement not covered" >indexOf(":");if<span class="cstat-no" title="statement not covered" ></span>(s!==-1){var u=n.<span class="cstat-no" title="statement not covered" >substr(0,s),l=</span>n.<span class="cstat-no" title="statement not covered" >substr(s+1);if<span class="cstat-no" title="statement not covered" ></span>("_"===u||0===l.indexOf("//"))re<span class="cstat-no" title="statement not covered" >turn n;i&amp;<span class="cstat-no" title="statement not covered" >&amp;</span></span>u in i&amp;&amp;A(t,i,u,o);var</span> a=t.<span class="cstat-no" title="statement not covered" >mappings[u];re<span class="cstat-no" title="statement not covered" ></span>turn a?a["@id"]+l:n}if(<span class="cstat-no" title="statement not covered" ></span>r</span>.vocab&amp;&amp;"@vocab"in t)ret<span class="cstat-no" title="statement not covered" >urn t["@vocab"]+n;var </span></span>c=n;r<span class="cstat-no" title="statement not covered" >et<span class="cstat-no" title="statement not covered" ></span>urn r.base&amp;&amp;(c=e.prependBase(t["@base"],c)),c}func</span>tion D(t,<span class="fstat-no" title="function not covered" >n)</span>{if(n<span class="cstat-no" title="statement not covered" >ull===t)retu<span class="cstat-no" title="statement not covered" >rn n;if(n<span class="cstat-no" title="statement not covered" >.</span></span>indexOf(":")!==-1)retu<span class="cstat-no" title="statement not covered" >rn n;z(t)<span class="cstat-no" title="statement not covered" >&amp;</span></span>&amp;(t=e.url.parse(t||""));var r</span>=e.ur<span class="cstat-no" title="statement not covered" >l.parse(n),i={p</span>ro<span class="cstat-no" title="statement not covered" >tocol:t.protocol||""};if(n<span class="cstat-no" title="statement not covered" ></span>ull!==r.authority)i.au<span class="cstat-no" title="statement not covered" >thority=r.authority,i.path=r.path,i.query=r.query;else </span>if(i<span class="cstat-no" title="statement not covered" >.authority=t.authority,""===r.path)i.pa<span class="cstat-no" title="statement not covered" >th=t.path,null!==r.query?i.query=r.query:i.query=t.query;else{</span>if(0<span class="cstat-no" title="statement not covered" >===r.path.indexOf("/"))i.pa<span class="cstat-no" title="statement not covered" >th=r.path;else{</span>var o=t.pa<span class="cstat-no" title="statement not covered" >th;""!=<span class="cstat-no" title="statement not covered" ></span>=r.path&amp;&amp;(o=o.substr(0,o.lastIndexOf("/")+1),o.length&gt;0&amp;&amp;"/"!==o.substr(-1)&amp;&amp;(o+="/"),o+=r.path),i.path=o}i.que<span class="cstat-no" title="statement not covered" ></span>r</span>y=r.query}i.path<span class="cstat-no" title="statement not covered" ></span>=</span></span>le(i.path,!!i.authority);var a=i</span>.prot<span class="cstat-no" title="statement not covered" >ocol;return<span class="cstat-no" title="statement not covered" ></span> null!==i.authority&amp;&amp;(a+="//"+i.authority),a+=i.path,null!==i.query&amp;&amp;(a+="?"+i.query),null!==r.fragment&amp;&amp;(a+="#"+r.fragment),""===a&amp;&amp;(a="./"),a}functio</span>n P(t,n){<span class="fstat-no" title="function not covered" >if</span>(null<span class="cstat-no" title="statement not covered" >===t)return <span class="cstat-no" title="statement not covered" >n;z(t)&amp;&amp;(<span class="cstat-no" title="statement not covered" >t</span></span>=e.url.parse(t||""));var r=""</span>;if("<span class="cstat-no" title="statement not covered" >"!=<span class="cstat-no" title="statement not covered" ></span>=t.href?r+=(t.protocol||"")+"//"+(t.authority||""):n.indexOf("//")&amp;&amp;(r+="//"),0!==n.indexOf(r))return <span class="cstat-no" title="statement not covered" >n;for(var<span class="cstat-no" title="statement not covered" > </span></span>i=e.url.parse(n.substr(r.length)),o=t.normalizedPath.split("/"),a=i.normalizedPath.split("/"),s=i.fragment||i.query?0:1;o.length&gt;0&amp;&amp;a.length&gt;s&amp;&amp;o[0]===a[0];)o.shift<span class="cstat-no" title="statement not covered" >(),a.shift();var u=""</span></span>;if(o<span class="cstat-no" title="statement not covered" >.le<span class="cstat-no" title="statement not covered" ></span>ngth&gt;0){o.pop()<span class="cstat-no" title="statement not covered" >;for(var<span class="cstat-no" title="statement not covered" > </span>l=0;l&lt;o.length;++l)u+="../<span class="cstat-no" title="statement not covered" >"}return u<span class="cstat-no" title="statement not covered" ></span></span>+</span>=a.join("/"),null!==i.query&amp;&amp;(u+="?"+i.query),null!==i.fragment&amp;&amp;(u+="#"+i.fragment),""===u&amp;&amp;(u="./"),u}function </span>U(t){func<span class="fstat-no" title="function not covered" >ti</span>on n(){var e<span class="fstat-no" title="function not covered" >=t</span>his;if(e<span class="cstat-no" title="statement not covered" >.inve<span class="cstat-no" title="statement not covered" ></span>rse)return e.<span class="cstat-no" title="statement not covered" >inverse;for(var t<span class="cstat-no" title="statement not covered" >=</span></span>e.inverse={},n=e.fastCurieMap={},o={},a=e["@language"]||"@none",s=e.mappings,u=Object.keys(s).sort(j),l=0;l&lt;u.length;++l){var c=u[l],f=s[<span class="cstat-no" title="statement not covered" >c];if</span>(n<span class="cstat-no" title="statement not covered" >ull!=<span class="cstat-no" title="statement not covered" ></span>=f){var h=f["@conta<span class="cstat-no" title="statement not covered" >iner"]||"@none",d=f["@id"</span>];<span class="cstat-no" title="statement not covered" >B(d)||(d=<span class="cstat-no" title="statement not covered" ></span>[d]);for(var p<span class="cstat-no" title="statement not covered" >=</span>0;p&lt;d.length;++p){var v=d[p],g=t[<span class="cstat-no" title="statement not covered" >v],y=</span>M(<span class="cstat-no" title="statement not covered" >v);if</span>(g<span class="cstat-no" title="statement not covered" >)y||f<span class="cstat-no" title="statement not covered" ></span>._ter<span class="cstat-no" title="statement not covered" >mHasColon||o[v].push(c);else if(t[</span>v]=g<span class="cstat-no" title="statement not covered" >={},!y&amp;&amp;!f._termHasColon){o[v]=[c];<span class="cstat-no" title="statement not covered" >var m={iri</span>:v,te<span class="cstat-no" title="statement not covered" >rms:o[v]};v[0]in n?<span class="cstat-no" title="statement not covered" ></span>n[v[0]].push(m):n[v[0]]=[m]}if(g[h]||(<span class="cstat-no" title="statement not covered" ></span>g</span></span>[h]={"@language":{},"@type":{}}),g=g[h],f.reverse)i(f,c,g["@<span class="cstat-no" title="statement not covered" >type"],"@reverse");else if("@t</span>ype"<span class="cstat-no" title="statement not covered" >in f)i(f,c,g["@<span class="cstat-no" title="statement not covered" >type"],f["@type"]);else if("@l</span>angu<span class="cstat-no" title="statement not covered" >age"in f){var b=f["@langua<span class="cstat-no" title="statement not covered" >ge"]||"@null";i(f,c,g["@<span class="cstat-no" title="statement not covered" ></span>language"],b)}else i(f,c,</span>g["@l<span class="cstat-no" title="statement not covered" >anguage"],a),i(f,c,g["@type"],"@none"),i(f,c,g["@language"],"@none")}}}for(var w </span></span></span></span>i</span>n<span class="cstat-no" title="statement not covered" ></span> </span>n)r(n,w,1);ret<span class="cstat-no" title="statement not covered" >urn t}fun<span class="cstat-no" title="statement not covered" >c</span></span>tion r(e,</span>t,n){for(<span class="fstat-no" title="function not covered" >va</span>r i,o,a<span class="cstat-no" title="statement not covered" >=e[t],s=e[t]={},u=0;u&lt;a.length;++u)i=a[u].iri,o=<span class="cstat-no" title="statement not covered" >n&gt;=i.length?"":i[n],o in s?s[o].push(a[u]):s[o]=[a[u]];for(var t in <span class="cstat-no" title="statement not covered" >s</span></span>)""!==t&amp;&amp;r(s,t<span class="cstat-no" title="statement not covered" >,n+1)}function i(e,t</span></span>,n,r){r i<span class="fstat-no" title="function not covered" >n </span>n||(n[r]=<span class="cstat-no" title="statement not covered" >t)}function o(){va</span>r e={};re<span class="fstat-no" title="function not covered" >tu</span>rn e["@b<span class="cstat-no" title="statement not covered" >ase<span class="cstat-no" title="statement not covered" ></span>"]=this["@base"],e.mappings=te(this.mappings),e.clone=this.clone,e.inverse=null,e.getInverse=this.getInverse,"@language"in this&amp;&amp;(e["@language"]=this["@language"]),"@vocab"in this&amp;&amp;(e["@vocab"]=this["@vocab"]),e}var a=e.url.pars</span>e(t.ba<span class="cstat-no" title="statement not covered" >se||"");return{"@base":a<span class="cstat-no" title="statement not covered" ></span>,mappings:{},inverse:null,getInverse:n,clone:o}}function M(e){if(</span>!z(e))ret<span class="fstat-no" title="function not covered" >ur</span>n!1<span class="cstat-no" title="statement not covered" >;switch(e<span class="cstat-no" title="statement not covered" >){case"@b<span class="cstat-no" title="statement not covered" >a</span></span>se":case"@context":case"@container":case"@default":case"@embed":case"@explicit":case"@graph":case"@id":case"@index":case"@language":case"@list":case"@omitDefault":case"@preserve":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@vocab":return!0}return!1<span class="cstat-no" title="statement not covered" >}function <span class="cstat-no" title="statement not covered" ></span>q</span>(e){retur</span>n"[object<span class="fstat-no" title="function not covered" > O</span>bje<span class="cstat-no" title="statement not covered" >ct]"===Object.prototype.toString.call(e)}function F(e){return</span> q(e)&amp;&amp;0=<span class="fstat-no" title="function not covered" >==</span>Obj<span class="cstat-no" title="statement not covered" >ect.keys(e).length}function B(e){return </span>Array.isA<span class="fstat-no" title="function not covered" >rr</span>ay(<span class="cstat-no" title="statement not covered" >e)}function H(e){if(!z(e)</span>&amp;&amp;!F(e)){<span class="fstat-no" title="function not covered" >va</span>r t<span class="cstat-no" title="statement not covered" >=!1;if(B(e)){t=!0;for(v<span class="cstat-no" title="statement not covered" >ar <span class="cstat-no" title="statement not covered" ></span>n=0;n&lt;e.l<span class="cstat-no" title="statement not covered" >ength<span class="cstat-no" title="statement not covered" >;</span>++n)if(!z(e[n])){t=!1;brea<span class="cstat-no" title="statement not covered" >k}}if(!t)thro<span class="cstat-no" title="statement not covered" >w new<span class="cstat-no" title="statement not covered" > </span>Ce('In</span>v<span class="cstat-no" title="statement not covered" ></span></span>a</span>lid J<span class="cstat-no" title="statement not covered" >SON-LD syntax; "@type" value must a string, an array of strings, or an empty object.',"jsonld.SyntaxError",{code:"invalid type value",value:e})}}function z(e){return"st</span></span>r</span>ing"==typ<span class="fstat-no" title="function not covered" >eo</span>f e<span class="cstat-no" title="statement not covered" >||"[object String]"===Object.prototype.toString.call(e)}function V(e){return"numb</span>er"==type<span class="fstat-no" title="function not covered" >of</span> e|<span class="cstat-no" title="statement not covered" >|"[object Number]"===Object.prototype.toString.call(e)}function W(e){return V(e)&amp;</span>&amp;String(e<span class="fstat-no" title="function not covered" >).</span>ind<span class="cstat-no" title="statement not covered" >exOf(".")!==-1}function X(e){return!isNaN(</span>parseFloa<span class="fstat-no" title="function not covered" >t(</span>e))<span class="cstat-no" title="statement not covered" >&amp;&amp;isFinite(e)}function J(e){return"boolean</span>"==typeof<span class="fstat-no" title="function not covered" > e</span>||"<span class="cstat-no" title="statement not covered" >[object Boolean]"===Object.prototype.toString.call(e)}function G(e){return"undefine</span>d"==typeo<span class="fstat-no" title="function not covered" >f </span>e}f<span class="cstat-no" title="statement not covered" >unction $(e){var t=!1;if(q(e)</span>&amp;&amp;!("@val<span class="fstat-no" title="function not covered" >ue</span>"in e||"@<span class="cstat-no" title="statement not covered" >set<span class="cstat-no" title="statement not covered" ></span>"in e||"@list"in e)){var n=Object.keys(e).length;t=n&gt;1||!<span class="cstat-no" title="statement not covered" >("@id"in e)}return t}f<span class="cstat-no" title="statement not covered" ></span>unction Y(e){return q<span class="cstat-no" title="statement not covered" ></span>(</span>e)&amp;&amp;1===O</span>bject.key<span class="fstat-no" title="function not covered" >s(</span>e).<span class="cstat-no" title="statement not covered" >length&amp;&amp;"@id"in e}function Q(e){return q(e)&amp;&amp;"@valu</span>e"in e}fu<span class="fstat-no" title="function not covered" >nc</span>tio<span class="cstat-no" title="statement not covered" >n K(e){return q(e)&amp;&amp;"@list"</span>in e}func<span class="fstat-no" title="function not covered" >ti</span>on <span class="cstat-no" title="statement not covered" >Z(e){var t=!1;return q(e)&amp;</span>&amp;(t="@id"<span class="fstat-no" title="function not covered" >in</span> e?0===e[<span class="cstat-no" title="statement not covered" >"@i<span class="cstat-no" title="statement not covered" ></span>d"].indexOf("_:"):0===Object.keys(e).length||!("@value"in e||"@set"in e||"@list"in e)),t}function ee(e){return z(e)&amp;&amp;e.indexO</span>f(":")!==<span class="fstat-no" title="function not covered" >-1}</span>fun<span class="cstat-no" title="statement not covered" >ction te(e){if(e&amp;&amp;"object"==typeof</span> e){var t<span class="fstat-no" title="function not covered" >;if</span>(B(<span class="cstat-no" title="statement not covered" >e)){t=[];for(var n=0;n&lt;e.length;<span class="cstat-no" title="statement not covered" >++n)t[n]=<span class="cstat-no" title="statement not covered" >te(e[<span class="cstat-no" title="statement not covered" >n</span>])}else if(q(e)){t={};for(<span class="cstat-no" title="statement not covered" >var r in e)t[r]</span></span>=te(e<span class="cstat-no" title="statement not covered" >[r])}else<span class="cstat-no" title="statement not covered" > t=e.<span class="cstat-no" title="statement not covered" >t</span>oString();retu<span class="cstat-no" title="statement not covered" >rn t}return e}f</span></span>uncti<span class="cstat-no" title="statement not covered" >on ne(t,n,r,i){<span class="cstat-no" title="statement not covered" >v</span></span></span>ar o=Obje<span class="cstat-no" title="statement not covered" ></span>c</span>t.keys(n)</span>.length;i<span class="fstat-no" title="function not covered" >f(B</span>(t)){for(var a=<span class="cstat-no" title="statement not covered" >0;a&lt;t.length;++a)ne(t[<span class="cstat-no" title="statement not covered" ></span>a],n,r,i)<span class="cstat-no" title="statement not covered" >;return o&lt;Object.keys(n).le<span class="cstat-no" title="statement not covered" >ngth}if(q(t)){f<span class="cstat-no" title="statement not covered" >o</span></span>r(var s in t)if("@context"===s)<span class="cstat-no" title="statement not covered" ></span>{</span>var u=t[<span class="cstat-no" title="statement not covered" >s];if(B(u))for(<span class="cstat-no" title="statement not covered" >var l=u.length,a=0;a&lt;l;++<span class="cstat-no" title="statement not covered" >a){va<span class="cstat-no" title="statement not covered" ></span>r c=u[a]<span class="cstat-no" title="statement not covered" >;z(c)&amp;&amp;(c=e.prependBase(i,c),r?(c=n[c]<span class="cstat-no" title="statement not covered" >,B(c)<span class="cstat-no" title="statement not covered" ></span>?(Array.prototype.splice.apply(u,[a,1].concat(c)),a+=c.length-1,l=u.length):u[a]=c):c in n||(n[c]=!1))}else z(u)&amp;&amp;(u=e.prependBase(i,u),r?t[s]=n[u</span>]</span>:u i<span class="cstat-no" title="statement not covered" >n n||(n[u]=!1))}else ne(t[s],n,r,i);return o&lt;Object.keys(n).</span></span>lengt<span class="cstat-no" title="statement not covered" >h}return!1}func<span class="cstat-no" title="statement not covered" >t</span></span></span>ion re(e,t,n){var r=null,i=t.do<span class="cstat-no" title="statement not covered" ></span>c</span>umentLoad</span>er,o=func<span class="fstat-no" title="function not covered" >tio</span>n(e,t,n,i,a){<span class="cstat-no" title="statement not covered" >if(Ob</span>je<span class="cstat-no" title="statement not covered" >ct.keys(t).length</span>&gt;I<span class="cstat-no" title="statement not covered" >e)return <span class="fstat-no" title="function not covered" >r=</span>new Ce("Max<span class="cstat-no" title="statement not covered" >imum number of @context URLs<span class="cstat-no" title="statement not covered" > exceeded.","jsonld.ContextUrlError",{code:"loading remote context failed",max:Ie}),a(r);var s={},u=function(){ne(e,s,!0,i),a(null,e)};ne(</span></span>e,s,!<span class="cstat-no" title="statement not covered" >1,i</span>)|<span class="cstat-no" title="statement not covered" >|u();var <span class="fstat-no" title="function not covered" >l=</span>[]<span class="cstat-no" title="statement not covered" >;for(var c in s)s[c]===!</span>1<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;l.push(c);for(var</span> f=l.<span class="cstat-no" title="statement not covered" >len<span class="cstat-no" title="statement not covered" ></span>gth,h=0;h&lt;l.len<span class="cstat-no" title="statement not covered" >gth;++h)!function(e){<span class="cstat-no" title="statement not covered" >i</span></span>f(e in t)return r=new Ce("Cyclical @c<span class="cstat-no" title="statement not covered" >o<span class="fstat-no" title="function not covered" >nt</span>ext URLs d<span class="cstat-no" title="statement not covered" >etected.",<span class="cstat-no" title="statement not covered" >"jsonld.ContextUrlError",{code:"recursive context inclusion",url:e}),a(r);var i=te(t);i[e]=!0;var l=function(t,l){if(!r){var c</span></span>=l?l.<span class="cstat-no" title="statement not covered" >docume<span class="cstat-no" title="statement not covered" ></span>nt:null;i</span>f(!t&amp;<span class="cstat-no" title="statement not covered" >&amp;z(c))try{c=JSON.parse(c)}catch(e)<span class="fstat-no" title="function not covered" >{t</span>=e}if(<span class="cstat-no" title="statement not covered" >t?t=new Ce("D<span class="cstat-no" title="statement not covered" >ereferencing a URL d<span class="cstat-no" title="statement not covered" ></span>id not resul<span class="cstat-no" title="statement not covered" >t in<span class="cstat-no" title="statement not covered" > a valid JSON-LD </span>object. P<span class="cstat-no" title="statement not covered" >ossib<span class="cstat-no" title="statement not covered" ></span>l</span></span>e causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.","jsonld.InvalidUrl",{code:"loading remote context failed",url:e,cause:t}):q(c)||(t=new Ce("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.","jsonld.InvalidUrl",{code:"invalid remote context",url:e,cause:t})),t)return r=t,a(r);c="@context"in c?{"@context":c["@context"]}:{"@context":{}},l.conte<span class="cstat-no" title="statement not covered" >xtUrl&amp;&amp;(B(c["@co<span class="cstat-no" title="statement not covered" >n</span></span>text"])||(c["@context"]=[c["@context"]]),c["@context"].push(l.contextUrl)),o(c,i,n,e,function(t,n){return t?a(t):(s[e]=n["@context"],f-=1,void(0===f&amp;&amp;u()))})}},c=n(e,l);c<span class="fstat-no" title="function not covered" >&amp;&amp;</span>"then"in c&amp;&amp;<span class="cstat-no" title="statement not covered" >c.then(l.bind(null,null),l)}(l[h])};o(e,{},i,t.base,n)}fun</span>cti</span>o</span>n</span> i<span class="cstat-no" title="statement not covered" >e(e){fo<span class="cstat-no" title="statement not covered" ></span>r(var t="(?:&lt;([^:]+:[^&gt;]*)&gt;)",n="(_:(?:[A-Za</span>-z0-9]+)</span></span>)<span class="cstat-no" title="statement not covered" ></span>",r='"([^"\\\\]*(?:\</span>\\\.[^"\\<span class="fstat-no" title="function not covered" >\\]</span>*)*<span class="cstat-no" title="statement not covered" >)"',i="(?:\\^\\^"+t+")",o="(?:@([a-z]+(?:-[a-z0-9]+)*))",a="(?:"+r+"(?:"+i+"|"+o+")?)",s="(?:#.*)?",u="[ \\t]+",l="[ \\t]*",c=/(?:\r\n)|(?:\n)|(?:\r)/g,f=new RegExp("^"+l+s+"$"),h="(?:"+t+"|"+n+")"+u,d=t+u,p="(?:"+t+"|"+n+"|"+a+")"+l,v="(?:\\.|(?:(?:"+t+"|"+n+")"+l+"\\.))",y=new RegExp("^"+l+h+d+p+v+l+s+"$"),m={},b=e.split(c),w=0,x=0;x&lt;b.length;++x){var _=b[x];if(w++,!f.test(_)){var k=_.match(y);if(null===k)throw new Ce("Error while parsing N-Q<span class="cstat-no" title="statement not covered" >uads;<span class="cstat-no" title="statement not covered" ></span> invalid quad.","jsonld.P<span class="cstat-no" title="statement not covered" >arseError",<span class="cstat-no" title="statement not covered" ></span>{line:w});va<span class="cstat-no" title="statement not covered" >r T={};if(G(k[1])?T.subject={type:"blank node",value:k[2]}:T.subject={type:"IRI",value:k[</span></span>1]},T<span class="cstat-no" title="statement not covered" >.pr<span class="cstat-no" title="statement not covered" ></span>edicate={type:"IRI",value:k[3]},G(k[4]))if(G(k[5])){T.object={type:"literal"},G(k[7])?G(k[8])?T.object.datatype=be:(T.object.dataty<span class="cstat-no" title="statement not covered" >pe=je,T.obje<span class="cstat-no" title="statement not covered" >ct.language=k[8]):T.object.datatype=k[7];var E=k[6].replace(/\\"/g,'"').replace(/\\t/g,"\t").replace(/\\n/g,"\n").replace(/\\r/g,"\r"</span>).rep<span class="cstat-no" title="statement not covered" >lace(/\\\\/g,"\\");T.object.value=E}else T.object={type:"blank node",value:k[5]};else T.object={type:"IRI",val<span class="cstat-no" title="statement not covered" ></span>ue:k[4]};var S="@d</span>efaul<span class="cstat-no" title="statement not covered" >t";if(G(k[9])?G(k[10])||(S=k[10]):S=k[9],</span></span>S in <span class="cstat-no" title="statement not covered" >m){for(var N=!0,R=m[S],j=0;N&amp;&amp;j&lt;R.</span></span>lengt<span class="cstat-no" title="statement not covered" >h;++j)g(R[j<span class="cstat-no" title="statement not covered" ></span>],T)&amp;&amp;(N=!1);N&amp;&amp;R.push(T)}else m[S]=[T]}}retur<span class="cstat-no" title="statement not covered" >n m}function oe(e){var t=[];for(var n in e<span class="cstat-no" title="statement not covered" >)for(var r=e[n],i=<span class="cstat-no" title="statement not covered" >0</span></span>;i&lt;r.length;+</span>+i){v<span class="cstat-no" title="statement not covered" >ar o=r[i];</span></span>"<span class="cstat-no" title="statement not covered" ></span>@</span>default"=</span>==n&amp;&amp;(n=n<span class="fstat-no" title="function not covered" >ull</span>),t.push(<span class="cstat-no" title="statement not covered" >ae(<span class="cstat-no" title="statement not covered" ></span>o,n))}return t.<span class="cstat-no" title="statement not covered" >sort().join("")}function ae(e,t){var n=e.<span class="cstat-no" title="statement not covered" >subje<span class="cstat-no" title="statement not covered" ></span>ct,r=e.predicate,i=e.object,o=t||null;"nam<span class="cstat-no" title="statement not covered" ></span>e</span></span>"in e&amp;&amp;e.name&amp;&amp;(o=e.name.</span>value);va<span class="fstat-no" title="function not covered" >r a</span>="";if(a+="<span class="cstat-no" title="statement not covered" >IRI"===n.t</span>yp<span class="cstat-no" title="statement not covered" >e?"&lt;"+n.valu</span>e+<span class="cstat-no" title="statement not covered" >"&gt;":n.val</span>ue<span class="cstat-no" title="statement not covered" >,a+=" ",<span class="cstat-no" title="statement not covered" ></span>a+="IRI"===r.type?"&lt;"+r.value+"&gt;":r.va</span>lue,a<span class="cstat-no" title="statement not covered" >+="<span class="cstat-no" title="statement not covered" ></span> ","IRI"===i.type)a+="&lt;"+i.value+"&gt;";else if("blank node"===i.type)a+=i.value;else{var s=i.value.replace(/\\/g,"\\\\<span class="cstat-no" title="statement not covered" >").replace(/\t/g,"\\</span>t").<span class="cstat-no" title="statement not covered" >replace(/\n/g,"\\n").repl<span class="cstat-no" title="statement not covered" >ace(/\r/g,"\</span>\r").repla<span class="cstat-no" title="statement not covered" >ce(/\"/g,'\\"');a+='"'+s+'"',i.datatype===je?i.language&amp;&amp;(a+="@"+i.language):i.datatype!==be&amp;&amp;(a+="^^&lt;"+i.datatype<span class="cstat-no" title="statement not covered" ></span>+"&gt;")}return null!==o&amp;&amp;void 0!==o&amp;&amp;(a+=0!==o.indexOf("_:")?" &lt;"+o+"&gt;":" "+o),a+=" .\n"}function se(e){var<span class="cstat-no" title="statement not covered" ></span> </span></span>t={};t["@default"]=[];for(var n=e.getSubjects(),r=0;r&lt;n.length;++r){var i=n[r];if</span>(null!==i<span class="fstat-no" title="function not covered" >){v</span>ar o=e.ge<span class="cstat-no" title="statement not covered" >tSu<span class="cstat-no" title="statement not covered" ></span>bjectTriples(i);i<span class="cstat-no" title="statement not covered" >f</span>(null!==o){var a=o.predicates;for(var s in a)for(va<span class="cstat-no" title="statement not covered" >r u=a<span class="cstat-no" title="statement not covered" ></span>[s].objects,l=0;l&lt;u<span class="cstat-no" title="statement not covered" >.length;++l){var c=u[l]<span class="cstat-no" title="statement not covered" ></span>,f={};0===i.indexOf<span class="cstat-no" title="statement not covered" >("_:")?f.subj<span class="cstat-no" title="statement not covered" ></span>ect={type:"blan<span class="cstat-no" title="statement not covered" >k node",value:i}:f.subject={type:"IRI",value:i},0<span class="cstat-no" title="statement not covered" >===s.</span>in<span class="cstat-no" title="statement not covered" >dex<span class="cstat-no" title="statement not covered" ></span>Of("_:")?f.predicate={type:"blank node",value:s}:f.predicate={type:"IRI",value:s};var h=c.value;if(c.type===Ne){pe||Me();var d=new pe;h="";for(var p=0;p&lt;c.value.length;p++)c.value[p].</span>nodeT<span class="cstat-no" title="statement not covered" >ype===ve<span class="cstat-no" title="statement not covered" ></span>.ELEMENT_NODE?h+<span class="cstat-no" title="statement not covered" >=d.seriali</span>zeToS<span class="cstat-no" title="statement not covered" >tring(c.v<span class="cstat-no" title="statement not covered" ></span>alue[<span class="cstat-no" title="statement not covered" >p</span>]):c.value[p].nodeType===ve.TEXT<span class="cstat-no" title="statement not covered" >_NODE&amp;&amp;(h+=c.value[p].nodeValue)}f.object={},c.type===Re?0===c.value.indexOf("_:")?f.object.type="blank node":f.object.type="IRI":(f.obj<span class="cstat-no" title="statement not covered" ></span></span>e</span>ct.type="literal",c.type===Se?c.language?(f.object.datatype=je,f.object.language=c.language):f.object.datatype=be:f.object.datatype=c.type),f.object.value=h,t["@default"].push(f)}}}}return t}function ue(e){this.prefix=e,this.counter=0,this.existing={}}function le(e,t){var n="";0===e</span>.</span></span>i</span>n<span class="cstat-no" title="statement not covered" ></span>d</span>exOf("/")</span>&amp;&amp;(n="/")<span class="fstat-no" title="function not covered" >;fo</span>r(v<span class="cstat-no" title="statement not covered" >ar r=e.split("/"),i=[];r.length&gt;0;)"."===r[0]||</span>""===r[0]<span class="fstat-no" title="function not covered" >&amp;&amp;r</span>.length&gt;1?r<span class="cstat-no" title="statement not covered" >.sh<span class="cstat-no" title="statement not covered" ></span>ift():".."!==r[0]?i.push(r.s<span class="cstat-no" title="statement not covered" >h</span>ift()):(r.shift(),t||i.length&gt;0&amp;&amp;".."!=<span class="cstat-no" title="statement not covered" >=i[i.length-1]?i.pop():i.push(".."));return n+i.join("/")}e.compact=function(t,n,r,i){function o(e,t,r,o){if(e)return i(e);o.compactArrays&amp;&amp;!o.<span class="cstat-no" title="statement not covered" >g</span></span>raph&amp;&amp;B(t)?1===t.leng<span class="cstat-no" title="statement not covered" ></span>th?t=t[0]:<span class="fstat-no" title="function not covered" >0=</span>==t.length&amp;&amp;(t={}):o.grap<span class="fstat-no" title="function not covered" >h&amp;</span>&amp;q(t)&amp;&amp;(t<span class="cstat-no" title="statement not covered" >=[t])<span class="cstat-no" title="statement not covered" >,q(n)&amp;&amp;"@con<span class="cstat-no" title="statement not covered" >t</span></span>ext"in n&amp;&amp;(n=n["@context"]),n=te(n),B(n)||(n=[n]);var a=n;n=[];for(var s=0;s&lt;a.length;++s)(!q(a[s])||Object.keys(a[s]).length&gt;0)&amp;&amp;n.push(a[s]);var u=n.length&gt;</span>0;if(<span class="cstat-no" title="statement not covered" >1=<span class="cstat-no" title="statement not covered" ></span>==n.l<span class="cstat-no" title="statement not covered" >e</span>ngth&amp;&amp;(n=n[0]),B(t)){var l<span class="cstat-no" title="statement not covered" >=I(r,"@graph"),c=t;t={},u&amp;&amp;(t["@context"]=n),t[l]=c}el</span></span>se if<span class="cstat-no" title="statement not covered" >(q(t)&amp;&amp;u){v<span class="cstat-no" title="statement not covered" ></span>ar c=t;t={"@context":n};for(var f in c<span class="cstat-no" title="statement not covered" >)t[f]=c[f]}i(n</span>ul<span class="cstat-no" title="statement not covered" >l,<span class="cstat-no" title="statement not covered" ></span>t,r)}if(arguments.length&lt;2)return </span>e.nex<span class="cstat-no" title="statement not covered" >tTick(function(){i<span class="cstat-no" title="statement not covered" >(n<span class="cstat-no" title="statement not covered" ></span>ew TypeError("Cou<span class="cstat-no" title="statement not covered" >l</span>d not compact,<span class="cstat-no" title="statement not covered" > too few ar<span class="cstat-no" title="statement not covered" ></span></span>g</span></span>uments."))})<span class="cstat-no" title="statement not covered" ></span>;if("function"==typeof<span class="cstat-no" title="statement not covered" > r&amp;&amp;(i=r,r={}),r=r<span class="fstat-no" title="function not covered" >||</span>{},null==<span class="cstat-no" title="statement not covered" >=n)return e.nextTick(function(){i(new Ce("The compaction co</span>nt<span class="cstat-no" title="statement not covered" >e</span></span>xt must not be null.","jsonld.CompactError",{code:"i<span class="cstat-no" title="statement not covered" >nvalid local conte<span class="fstat-no" title="function not covered" >xt</span>"}))});if<span class="cstat-no" title="statement not covered" >(null===t)return e.nextTick(function(){i(null,null)});"base"in r||(r.base="string"==typeof t?t:""),"compactA</span>rr<span class="cstat-no" title="statement not covered" >a</span></span>ys"in r||(r<span class="cstat-no" title="statement not covered" >.compactArrays=!0)<span class="fstat-no" title="function not covered" >,"</span>graph"in <span class="cstat-no" title="statement not covered" >r||(r.graph=!1</span>),<span class="cstat-no" title="statement not covered" >"</span></span>skipExpansion"in r||(r.skipExpansion=!1),"documentLoader"in r||(r.documentLoader=e.loadDocument),"link"in r||(r.link=!1),r.link&amp;&amp;(r.skipExpansion=!0);var a=function(t,n,r){return n.skipExpansion?e.nextTick(function(){r(null,t)}):void e.expand(t,n,r)};a(t,r,functio</span>n(t,a<span class="cstat-no" title="statement not covered" >){if(t)re<span class="fstat-no" title="function not covered" >tu</span>rn i(ne<span class="cstat-no" title="statement not covered" >w Ce("Could not expand input befor<span class="fstat-no" title="function not covered" >e </span>compactio<span class="cstat-no" title="statement not covered" >n.","jsonld</span>.CompactError",{cause:t}</span>)<span class="cstat-no" title="statement not covered" ></span>);var <span class="fstat-no" title="function not covered" >s=</span>U(r);e.proce<span class="cstat-no" title="statement not covered" >ssCon<span class="cstat-no" title="statement not covered" >text(s,n,r,function(e,t){if(e)return i(new Ce("Could not process context before compaction.","j</span></span>sonld<span class="cstat-no" title="statement not covered" >.Comp<span class="cstat-no" title="statement not covered" ></span>actError",{cause:e}));v<span class="fstat-no" title="function not covered" >ar</span> n;try{n=(ne<span class="cstat-no" title="statement not covered" >w Ae)<span class="cstat-no" title="statement not covered" >.compact(t,null,a,r)}catch(e){return i(e)}o(null,n,t,r)})})},e.expand=function(t,n,r){function i(e</span></span>){"ba<span class="cstat-no" title="statement not covered" >se"i<span class="cstat-no" title="statement not covered" >n n||(n.base=e.documentUrl||"");</span>var t={do<span class="cstat-no" title="statement not covered" >cument:te(e.d<span class="cstat-no" title="statement not covered" ></span>o</span>cument),remote</span>Con</span>tex</span>t:{"@conte<span class="fstat-no" title="function not covered" >xt</span>":e.contextUrl}};if("ex<span class="fstat-no" title="function not covered" >pa</span>ndC<span class="cstat-no" title="statement not covered" >ontext"in n){var i=te(n.expandContext);"</span>objec<span class="cstat-no" title="statement not covered" >t"==typeof i&amp;&amp;"@context"in i?t.expandContext=i:t.expandContext={"@<span class="cstat-no" title="statement not covered" ></span>context":i}}re(t,n,function(e,<span class="cstat-no" title="statement not covered" >t){if(e)return r(e);<span class="cstat-no" title="statement not covered" ></span>var i;try{var o=new Ae,a=U(n),s=t.document,u=t.remoteContext["@context"];t.expandCont<span class="cstat-no" title="statement not covered" ></span>e</span>xt&amp;&amp;(a<span class="fstat-no" title="function not covered" >=o</span>.processCont<span class="cstat-no" title="statement not covered" >ext(a<span class="cstat-no" title="statement not covered" >,t.expandCont</span></span>ext["<span class="cstat-no" title="statement not covered" >@context"]<span class="cstat-no" title="statement not covered" >,n)),u&amp;&amp;(</span>a=<span class="cstat-no" title="statement not covered" >o.pro</span>ce<span class="cstat-no" title="statement not covered" >ssContext(a</span>,u<span class="cstat-no" title="statement not covered" >,n)),i=o.expand(a,null,s,n,!<span class="cstat-no" title="statement not covered" ></span>1),q(i)&amp;&amp;"@graph"in i&amp;&amp;1===Object.keys(i).length?i=i["@graph"]:null===i&amp;&amp;(i=[]),B(i)||(i=[i])}catch(e){return r(e)}r(null,i)})}return arguments.length&lt;1?e.nextTick(function(){r(new TypeError("Could not expand, too few ar</span>guments."<span class="cstat-no" title="statement not covered" >))}):("functi<span class="cstat-no" title="statement not covered" ></span>o</span>n"==typeof</span> n&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(r=n,n={}),n=n||{},"documentLoader"i<span class="fstat-no" title="function not covered" >n </span>n||(n.doc<span class="cstat-no" title="statement not covered" >umentLoader=e.loadDocument),"keepFreeFloatingNodes"in n||(</span>n.keepFreeFloatingNodes=!1),void e.nextTick(function(){if("string"==typeof t){var e=function(e,t){if(e)return r(e);try{if(!t.document)throw new Ce("No remote document found a<span class="fstat-no" title="function not covered" >t </span>the given<span class="cstat-no" title="statement not covered" > URL.","jsonld.NullRemoteDocu<span class="cstat-no" title="statement not covered" >ment");"string"==typeof t.document<span class="fstat-no" title="function not covered" >&amp;&amp;</span>(t.docu<span class="cstat-no" title="statement not covered" >ment=JS<span class="cstat-no" title="statement not covered" >ON.parse(t.doc<span class="cstat-no" title="statement not covered" >u</span></span>men<span class="cstat-no" title="statement not covered" >t))}catch(e){re<span class="cstat-no" title="statement not covered" >turn r(new Ce("Could not retrieve a JSON-LD document from the URL. URL dereferencing no<span class="cstat-no" title="statement not covered" >t</span></span> implemented.","jsonld.LoadDocumentError",{code:"loading document</span> failed",<span class="cstat-no" title="statement not covered" >cause:e,remoteDoc:t}))}i(t)},o=n.documentLoader(t,e);return void(o&amp;&amp;"then"in o&amp;&amp;o.then(e.bind(null,null),e))}i({contextUrl:null,documentUrl:null,document:t})}))},e.flatten=function(t,n,r,i<span class="cstat-no" title="statement not covered" ></span>)</span>{retu</span>r</span>n <span class="cstat-no" title="statement not covered" >arguments.length&lt;1?e.n<span class="cstat-no" title="statement not covered" ></span>extTick(function(){i(new TypeError("Could not flatten, to<span class="cstat-no" title="statement not covered" ></span>o</span> few arguments."))}):("function"==typeof r?(i=r,r</span>={})</span>:"function"<span class="fstat-no" title="function not covered" >==</span>typeof n&amp;&amp;(i=n,n<span class="cstat-no" title="statement not covered" >=null,r={}),r=r||{},"base"in r||(r.ba<span class="fstat-no" title="function not covered" >se</span>="string"<span class="cstat-no" title="statement not covered" >==typeof t?t:""),"documentLoader"in r||(r.documentLoader=e.</span>loadDocument),void e.expand(t,r,function(t,o){if(t)return i(new Ce("Could not expand input before flattening.","jsonld.FlattenError",{cause:t}));var a;try{a=(new Ae).flatten(o)}catch(e){return i(e)}retu<span class="fstat-no" title="function not covered" >rn</span> null===n?i(<span class="cstat-no" title="statement not covered" >null,<span class="cstat-no" title="statement not covered" >a):(r.graph=!0,r.skipExpansion=!0,void e.compact(a,n,r,function(e,t){return e?i(new Ce("Could n</span></span>ot co<span class="cstat-no" title="statement not covered" >mpac<span class="cstat-no" title="statement not covered" >t flattened output.","j</span>sonld.Fla<span class="cstat-no" title="statement not covered" >ttenError",{c<span class="cstat-no" title="statement not covered" ></span>a</span>use:e})):void i(null,t)}))}))},e.frame=function(t,n,r,i){function o(n){var o,<span class="fstat-no" title="function not covered" >a=</span>n.document;a<span class="cstat-no" title="statement not covered" >?(o=a["@context"],n.contextUrl?(o?B(o)?o.push(n.contextUrl):o=[o,n.contextUrl]:o=n.contextUrl,a["@context"</span>]=o)</span>:o=o</span>||{}):o={<span class="fstat-no" title="function not covered" >},</span>e.expand(t,r,function(t,n<span class="fstat-no" title="function not covered" >){</span>if(t)return<span class="cstat-no" title="statement not covered" > i(new Ce("<span class="cstat-no" title="statement not covered" ></span>Could not expand input before framing.","jsonld.FrameError",{cause:t}));var s=te(r);s.isFrame=!0,s.keepFreeFloatingNodes=!0,e.expand(a,s,fu<span class="fstat-no" title="function not covered" >nc</span>tion(t,r){if<span class="cstat-no" title="statement not covered" >(t)re<span class="cstat-no" title="statement not covered" >turn i(new Ce("Could not expand frame before framing.","jsonld.FrameError",{cause:t}));var</span></span> a;tr<span class="cstat-no" title="statement not covered" >y{a=(n<span class="cstat-no" title="statement not covered" ></span>ew Ae).frame(n,r,s)}catch(e){return i(e)}s.graph=!0,s<span class="fstat-no" title="function not covered" >.s</span>kipExpansion<span class="cstat-no" title="statement not covered" >=!0,s<span class="cstat-no" title="statement not covered" >.link={},e.compact(a,o,s,function(e,t,n){if(e)return i(new Ce("Could not compact framed ou</span></span>tput.<span class="cstat-no" title="statement not covered" >","j<span class="cstat-no" title="statement not covered" >sonld.FrameError",{cause:</span>e}));var <span class="cstat-no" title="statement not covered" >r=I(n,"@graph<span class="cstat-no" title="statement not covered" ></span>"</span>);<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span>
// remove @preserve from results
<span class="cstat-no" title="statement not covered" >s.link={},t[r]=R(n,t[r],s),i(null,t)})</span>})})}retu<span class="cstat-no" title="statement not covered" >rn arguments.length&lt;2?e.nextTick(func<span class="fstat-no" title="function not covered" >ti</span>on(){i(ne<span class="cstat-no" title="statement not covered" >w TypeError("Could not frame, too few arguments."))}):("f</span>unction"==typeof r&amp;&amp;(i=r,r={}),r=r||{},"base"in r||(r.base="string"==typeof t?t:""),"documentLoader"in r||(r.documentLoader=e.loadDocument),"embed"in r||(r.embed="@last"),r.explicit=r.explicit||!1,"requireAll"in r||(r.requireAll=!0),r.omitDefault=r.omitDefault||!1,void e.nextTick(funct<span class="fstat-no" title="function not covered" >io</span>n(){if("s<span class="cstat-no" title="statement not covered" >tring"==typeof n){var e=funct<span class="cstat-no" title="statement not covered" >ion(e,t){if(e)return i(e);try{if(!<span class="fstat-no" title="function not covered" >t.</span>documen<span class="cstat-no" title="statement not covered" >t)throw<span class="cstat-no" title="statement not covered" > new Ce("No re<span class="cstat-no" title="statement not covered" >m</span></span>ote<span class="cstat-no" title="statement not covered" > document found<span class="cstat-no" title="statement not covered" > at the given URL.","jsonld.NullRemoteDocument");"string"==typeof t.document&amp;&amp;(t.docume<span class="cstat-no" title="statement not covered" >n</span></span>t=JSON.parse(t.document))}catch(e){return i(new Ce("Could not ret</span>rieve a J<span class="cstat-no" title="statement not covered" >SON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",cause:e,remoteDoc:t}))}o(t)},t=r.documentLoader(n,e);return voi<span class="cstat-no" title="statement not covered" ></span>d</span>(t&amp;&amp;"</span>t</span>he<span class="cstat-no" title="statement not covered" >n"in t&amp;&amp;t.then(e.bind(<span class="cstat-no" title="statement not covered" ></span>null,null),e))}o({contextUrl:null,documentUrl:null,docume<span class="cstat-no" title="statement not covered" ></span>n</span>t:n})}))},e.link=function(t,n,r,i){var o={};n&amp;&amp;(o</span>["@c</span>ontext"]<span class="fstat-no" title="function not covered" >=n</span>),o["@embed"]="@link",<span class="cstat-no" title="statement not covered" >e.f<span class="cstat-no" title="statement not covered" ></span>rame(t,o,r,i)},e.objectify=function(t,n,r,i){"function"==ty</span>peof r&amp;&amp;(i=r,<span class="fstat-no" title="function not covered" >r=</span>{}),r=r||{},"bas<span class="cstat-no" title="statement not covered" >e"in r||(r.base="string"==typeof t?t:""),"documentLoader"in r||(r.documentLoader=e.loadDocument),e.expand(t,r,function(t,o){if(t)return i(new Ce("Could not<span class="fstat-no" title="function not covered" > e</span>xpand input <span class="cstat-no" title="statement not covered" >befor<span class="cstat-no" title="statement not covered" >e linking.","jsonld.LinkError",{cause:t}));var a;try{a=(new Ae).flatten(o)}catch(e){retur</span></span>n i(e<span class="cstat-no" title="statement not covered" >)}r.<span class="cstat-no" title="statement not covered" >graph=!0,r.skipExpansio</span>n=!0,e.co<span class="cstat-no" title="statement not covered" >mpact(a,n,r,f<span class="cstat-no" title="statement not covered" ></span>u</span>nction(t,n,r){if(t)return i(new Ce("Could not<span class="fstat-no" title="function not covered" > c</span>ompact flatten<span class="cstat-no" title="statement not covered" >ed ou<span class="cstat-no" title="statement not covered" >tput before linking.","jsonld.LinkError",{cause:t}));var o=I(r,"@graph"),a=n[o][0],s=function(t){if(q</span></span>(t)||<span class="cstat-no" title="statement not covered" >B(t)){if(q(t))</span>{i<span class="cstat-no" title="statement not covered" >f(s.visi</span>te<span class="cstat-no" title="statement not covered" >d[t["@id"<span class="fstat-no" title="function not covered" >]]</span>)re<span class="cstat-no" title="statement not covered" >turn;s.visited[<span class="cstat-no" title="statement not covered" >t["@id"]]<span class="cstat-no" title="statement not covered" >=!0}for(var n in t){var<span class="cstat-no" title="statement not covered" > i=t[n]<span class="cstat-no" title="statement not covered" >,</span></span>o="@id"===e.getContextV<span class="cstat-no" title="statement not covered" ></span>a</span>lue(r,n,"@type");if(B<span class="cstat-no" title="statement not covered" >(i)||</span>q(<span class="cstat-no" title="statement not covered" >i)||o)if(z(i)&amp;&amp;o)t[n]=i=a[i],s(i);else <span class="cstat-no" title="statement not covered" ></span>if(B(i))for(var u<span class="cstat-no" title="statement not covered" >=0;u&lt;i.leng<span class="cstat-no" title="statement not covered" >th;++u)z(i[u])&amp;&amp;o?</span>i[u]<span class="cstat-no" title="statement not covered" >=a[i[u]]<span class="cstat-no" title="statement not covered" >:q(i[u])&amp;&amp;"@id"in i[u]&amp;&amp;(i[<span class="cstat-no" title="statement not covered" >u]=a[i[u]["@id"]]),s(i[u]);else if(q(i)){var l=i["@id"];t[n]=i=a[l],s(i)}}}};s</span></span>.vis<span class="cstat-no" title="statement not covered" >ited={},s(a),n.<span class="cstat-no" title="statement not covered" >of_type={<span class="cstat-no" title="statement not covered" ></span>};for(var u in a)i</span>f</span></span></span></span>(</span>"</span>@<span class="cstat-no" title="statement not covered" ></span>type"in a[u]){var l=a[u]["@type<span class="cstat-no" title="statement not covered" >"</span>];B(l)||(l=[l]<span class="cstat-no" title="statement not covered" >);for(var c=0;c&lt;l.length;<span class="cstat-no" title="statement not covered" >++c)l[c]in n.o<span class="cstat-no" title="statement not covered" ></span>f_type||(n.of_<span class="cstat-no" title="statement not covered" >t</span>ype[l[c]]=[]),n.of_type[l[<span class="cstat-no" title="statement not covered" >c]].push(a[u])}i(null,n)})})},e.normalize=function(t,n,r){if(argume<span class="cstat-no" title="statement not covered" ></span></span>n</span></span>ts.length&lt;</span>1)r</span>etu</span>rn e.nextTick<span class="fstat-no" title="function not covered" >(f</span>unction(){r(ne<span class="cstat-no" title="statement not covered" >w TypeError("Could not<span class="cstat-no" title="statement not covered" > normalize, too fe<span class="fstat-no" title="function not covered" >w </span>arguments<span class="cstat-no" title="statement not covered" >."))});if("function"==typeof n&amp;&amp;(r=n,n={}),n=n||{},"algorithm</span>"i<span class="cstat-no" title="statement not covered" >n</span></span> n||(n.algorithm="URGNA2012"),"base"in n||(n.base="string"==typeof t?t:""),"documentLoader"in n||(n.documentLoader=e.loadDocument),"inputFormat"in n){if("application/nquads"!==n.inputFormat)return r(new Ce(<span class="cstat-no" title="statement not covered" >"Unknown normalization input format.","j<span class="cstat-no" title="statement not covered" >sonld.NormalizeError"));var i=ie(t);(new Ae).normalize(i,n,r)}else{var o=te(n);de</span></span>lete <span class="cstat-no" title="statement not covered" >o.form<span class="cstat-no" title="statement not covered" ></span>at,o.produceGeneralizedRdf=</span>!1,e.toRDF(<span class="cstat-no" title="statement not covered" >t,o,fu<span class="cstat-no" title="statement not covered" ></span>nction(e,t){return e?r(new Ce("Could not convert input <span class="fstat-no" title="function not covered" >to</span> RDF dataset<span class="cstat-no" title="statement not covered" > before normalization.","jsonld.NormalizeError",{cause:e})):void(new Ae).normalize(t,n,r)})}},e.fromRDF=function(t,n,r){return arguments.length&lt;1?e.n</span>ext</span>T</span>ick(functio<span class="fstat-no" title="function not covered" >n(</span>){r(new TypeEr<span class="cstat-no" title="statement not covered" >ror("Could not convert from RDF, too <span class="fstat-no" title="function not covered" >fe</span>w argumen<span class="cstat-no" title="statement not covered" >ts."))}):("function"==typeof n&amp;&amp;(r=n,n={}),n=n||{},"useRdfType"in n|</span>|(n.useRdfType=!1),"useNativeTypes"in n||(n.useNativeTypes=!1),"format"in n||!z(t)||"format"in n||(n.format="application/nquads"),void e.nextTick(function(){function e(e,t,n){(new Ae).fromRDF(e,t,n)}var i;if<span class="fstat-no" title="function not covered" >(n</span>.format){if(i=n.rd<span class="fstat-no" title="function not covered" >fP</span>arser||<span class="cstat-no" title="statement not covered" >de[n.format],!i)return r(</span>new Ce<span class="cstat-no" title="statement not covered" >("Unknown inp<span class="cstat-no" title="statement not covered" >ut format.","jsonld.UnknownFormat"<span class="cstat-no" title="statement not covered" >,{format:n.format}))}else i=function(){return t};var o=!1;try{t=i(t,function(t,i){re</span></span>turn <span class="cstat-no" title="statement not covered" >o=!0,t?r(t):void e(i,n,r)})}catch(e)<span class="fstat-no" title="function not covered" >{i</span>f(<span class="cstat-no" title="statement not covered" >!o)return </span>r(</span></span>e);th<span class="cstat-no" title="statement not covered" >row<span class="cstat-no" title="statement not covered" ></span> e}i<span class="cstat-no" title="statement not covered" >f(t){i<span class="fstat-no" title="function not covered" >f(</span>"then"in t)r<span class="cstat-no" title="statement not covered" >eturn t.then(function(t){e(t,n,r)}</span>,r)</span>;e(t,n,r)<span class="cstat-no" title="statement not covered" >}}))},<span class="cstat-no" title="statement not covered" >e.toRDF=func<span class="cstat-no" title="statement not covered" >t</span></span>ion(t,n,<span class="cstat-no" title="statement not covered" ></span>r</span>){ret<span class="cstat-no" title="statement not covered" >urn arguments.<span class="cstat-no" title="statement not covered" >length&lt;1?e.nex<span class="fstat-no" title="function not covered" >tT</span>ick(functi<span class="cstat-no" title="statement not covered" >on(){r(new</span> Typ<span class="cstat-no" title="statement not covered" >e</span></span>Error("Co</span>u</span>ld n</span>ot conver<span class="fstat-no" title="function not covered" >t </span>to RDF, too fe<span class="cstat-no" title="statement not covered" >w arguments."))}):("function"==typeof<span class="fstat-no" title="function not covered" > n</span>&amp;&amp;(r=n,n=<span class="cstat-no" title="statement not covered" >{}),n=n||{},"base"in n||(n.base="string"==typeof t?t:""),"document</span>Loader"in n||(n.documentLoader=e.loadDocument),void e.expand(t,n,function(e,t){if(e)return r(new Ce("Could not expand input before serialization to RDF.","jsonld.R<span class="fstat-no" title="function not covered" >df</span>Error",{caus<span class="cstat-no" title="statement not covered" >e:e})<span class="cstat-no" title="statement not covered" >);var i;try{if(i=Ae.prototype.toRDF(t,n),n.format){if("application/nquads"===n.format)return r(null,o</span></span>e(i))<span class="cstat-no" title="statement not covered" >;thr<span class="cstat-no" title="statement not covered" >ow new Ce("Unknown output format.","jso<span class="cstat-no" title="statement not covered" >nld.UnknownFormat",{format:n.format<span class="cstat-no" title="statement not covered" >})}}catch(e){return r<span class="cstat-no" title="statement not covered" >(</span></span>e)}r(null,i)}))},e.createNodeMap=function(t,n,r){return arguments.length&lt;1?e.nex</span>t</span>Tick(func<span class="cstat-no" title="statement not covered" >tion(){r(new <span class="cstat-no" title="statement not covered" ></span>T</span>ypeError("</span>Coul</span>d not create node<span class="fstat-no" title="function not covered" > m</span>ap, too few ar<span class="cstat-no" title="statement not covered" >guments."))}):("function"==typeof n&amp;&amp;<span class="fstat-no" title="function not covered" >(r</span>=n,n={}),<span class="cstat-no" title="statement not covered" >n=n||{},"base"in n||(n.base="string"==typeof t?t:""),"documentLoade</span>r"in n||(n.documentLoader=e.loadDocument),void e.expand(t,n,function(e,t){if(e)return r(new Ce("Could not expand input before creating node map.","jsonld.CreateNod<span class="fstat-no" title="function not covered" >eM</span>apError",{ca<span class="cstat-no" title="statement not covered" >use:e<span class="cstat-no" title="statement not covered" >}));var i;try{i=(new Ae).createNodeMap(t,n)}catch(e){return r(e)}r(null,i)}))},e.merge=function(t,n,r,i){fun</span></span>ction<span class="cstat-no" title="statement not covered" > o(e<span class="cstat-no" title="statement not covered" >,t){if(!u){if(e)return u=e,i(ne</span>w Ce("Cou<span class="cstat-no" title="statement not covered" >ld not expand<span class="cstat-no" title="statement not covered" ></span> </span>input befo</span>re f</span>lattening<span class="fstat-no" title="function not covered" >."</span>,"jsonld.FlattenError",{c<span class="fstat-no" title="function not covered" >au</span>se:e}<span class="cstat-no" title="statement not covered" >));s.pu<span class="cstat-no" title="statement not covered" >sh(t)<span class="cstat-no" title="statement not covered" >,0===--l&amp;&amp;a(s)}}function a(t){var o=!0;"mergeNodes"in r&amp;&amp;(o=r.mergeNodes);var a,s=r.namer||r.issue<span class="cstat-no" title="statement not covered" >r</span></span>||new ue("_:b"),u={"@def</span>a</span>ult":{}};<span class="fstat-no" title="function not covered" >tr</span>y{for(var<span class="cstat-no" title="statement not covered" > l=<span class="cstat-no" title="statement not covered" ></span>0;l&lt;t.length;++l){var c=t[l];c=e.rel</span>abelBla<span class="cstat-no" title="statement not covered" >nkNodes(c,{issuer:new ue("_:b"+l+</span>"-<span class="cstat-no" title="statement not covered" >")});var f=o||0=<span class="cstat-no" title="statement not covered" ></span>==l?<span class="cstat-no" title="statement not covered" >u:{"@default":{}};if(y(c,f,"@defau<span class="cstat-no" title="statement not covered" >lt",s<span class="cstat-no" title="statement not covered" ></span>),f!==u)for(var h in f){var d=f[h];if(h in u){var p=u[h</span>];for<span class="cstat-no" title="statement not covered" >(var v in d)v in p||(p[v]=d<span class="cstat-no" title="statement not covered" ></span>[v])}else u[h]=d}}a=m(u)}catc<span class="cstat-no" title="statement not covered" >h(e){return i(e)}for(v<span class="cstat-no" title="statement not covered" >ar g=<span class="cstat-no" title="statement not covered" ></span>[],b=Object.keys(<span class="cstat-no" title="statement not covered" >a).so<span class="cstat-no" title="statement not covered" ></span>rt(),w=0;w&lt;b.le<span class="cstat-no" title="statement not covered" >ngth;++w){var x=a[b[w</span></span>]];Y(<span class="cstat-no" title="statement not covered" >x)||g.pu</span></span>s<span class="cstat-no" title="statement not covered" ></span></span>h</span>(x)}ret</span>urn null=<span class="cstat-no" title="statement not covered" >==n?i(null,g)<span class="cstat-no" title="statement not covered" ></span>:</span>(r.graph=!0,r.skipExpansion=!0,void e.compact(g,n,r,function(e<span class="cstat-no" title="statement not covered" >,t){retu<span class="cstat-no" title="statement not covered" ></span>rn e?i(new Ce("Co<span class="cstat-no" title="statement not covered" ></span>u</span>ld not compact merged output.","jsonld.MergeError",{cause:e})):void i(null,t)<span class="fstat-no" title="function not covered" >})</span>)}if(argumen<span class="cstat-no" title="statement not covered" >ts.length&lt;1)return e.nextTick(function(){i(new TypeError("Could not merge, too few arguments."))});if</span>(!B(<span class="cstat-no" title="statement not covered" ></span>t))return e.nextTick(f<span class="cstat-no" title="statement not covered" >unction(){i(new Ty<span class="fstat-no" title="function not covered" >pe</span>Error('Co<span class="cstat-no" title="statement not covered" >uld not merge, "docs" must be an array.'))});"function"==</span>ty<span class="cstat-no" title="statement not covered" >p</span></span>eof r?(i<span class="cstat-no" title="statement not covered" >=r,r={}):"function<span class="fstat-no" title="function not covered" >"=</span>=typeof n<span class="cstat-no" title="statement not covered" >&amp;&amp;(i=n,n=null,r={}),r=r||{};for(var s=[],u=null,l=t.length,c=0;</span>c&lt;<span class="cstat-no" title="statement not covered" >t</span></span>.length;++c){var f={};for(var h in r)f[h]=r[h];e.expand(t[c],f,o)}},e.relabelBl<span class="cstat-no" title="statement not covered" >a</span>nkNodes=function(e,t){t=t||{};var n=t.namer||t.issuer||n<span class="cstat-no" title="statement not covered" >ew <span class="cstat-no" title="statement not covered" ></span>ue("_:b");retur<span class="cstat-no" title="statement not covered" >n i(n,e)},<span class="cstat-no" title="statement not covered" >e</span></span>.prependBase=functi</span>o</span>n(e,t){return D(e,t)}<span class="fstat-no" title="function not covered" >,e</span>.documentLoa<span class="cstat-no" title="statement not covered" >der=funct</span>ion(t<span class="cstat-no" title="statement not covered" >,n){var r=new Ce("Could not retri<span class="cstat-no" title="statement not covered" ></span>eve a JSON-LD d</span>ocument from th<span class="fstat-no" title="function not covered" >e </span>URL. URL der<span class="cstat-no" title="statement not covered" >eferencing not </span>implemented.","jso<span class="fstat-no" title="function not covered" >nl</span>d.LoadDocumentErro<span class="cstat-no" title="statement not covered" >r",{code:"loading document failed"});return l?n(r,{contextUrl:null,documentUrl:t,document:null}):e.promisify(function(e){e(r)})},e.loadDocument=function(t,n)<span class="cstat-no" title="statement not covered" ></span>{var r=e.documentLoader(t,n);r&amp;&amp;"then"in r&amp;&amp;r.then(n.bind(null,null),n)}<span class="fstat-no" title="function not covered" >,e</span>.promises=<span class="cstat-no" title="statement not covered" >functi</span>on(</span>t){t=t||{};var r<span class="fstat-no" title="function not covered" >=A</span>rray.prototype.sli<span class="cstat-no" title="statement not covered" >ce,i=e.promisify,o=t.a<span class="cstat-no" title="statement not covered" ></span>pi||{},s=t.version||"jsonld.js";"string"==ty</span>peof t.api&amp;&amp;<span class="fstat-no" title="function not covered" >(t</span>.version||<span class="cstat-no" title="statement not covered" >(s=t.api)</span>,o={}<span class="cstat-no" title="statement not covered" >),o.expand=function(t)</span>{i<span class="cstat-no" title="statement not covered" >f(arguments.</span>le<span class="cstat-no" title="statement not covered" >ngth&lt;1)thr</span>ow<span class="cstat-no" title="statement not covered" > new TypeError("Could n<span class="cstat-no" title="statement not covered" ></span>ot expand, too few arguments.");return i.apply(null,[e.expand<span class="fstat-no" title="function not covered" >].</span>concat(r.c<span class="cstat-no" title="statement not covered" >all(arguments)))},o.co<span class="cstat-no" title="statement not covered" >mpact=function(t,n){if(arguments.length&lt;2)throw new TypeErro<span class="cstat-no" title="statement not covered" >r</span></span>("Could not compact, too few arguments.");var o=function(t</span>,n,r,i){e.c<span class="fstat-no" title="function not covered" >om</span>pact(t,n,r,f<span class="cstat-no" title="statement not covered" >unction(e,t){i(e,t)})}<span class="cstat-no" title="statement not covered" >;return i.apply(null,[o].concat(r.call(arguments)))},o.flatten</span></span>=func<span class="cstat-no" title="statement not covered" >tion(t){i<span class="fstat-no" title="function not covered" >f(</span>arguments<span class="cstat-no" title="statement not covered" >.length&lt;1)throw <span class="fstat-no" title="function not covered" >ne</span>w TypeError(<span class="cstat-no" title="statement not covered" >"Could n</span>ot </span>f<span class="cstat-no" title="statement not covered" ></span>latten, too few arguments.");return i.apply(null,[e.</span>flatten].co<span class="fstat-no" title="function not covered" >nc</span>at(r.call(<span class="cstat-no" title="statement not covered" >arguments)))},o.frame=<span class="cstat-no" title="statement not covered" >function(t,n){if(arguments.length&lt;2)throw new TypeError("Coul<span class="cstat-no" title="statement not covered" >d</span></span> not frame, too few arguments.");return i.apply(null,[e.fra</span>me].conca<span class="fstat-no" title="function not covered" >t(</span>r.call(argum<span class="cstat-no" title="statement not covered" >ents)))},o.fromRDF=fun<span class="cstat-no" title="statement not covered" >ction(t){if(arguments.length&lt;1)throw new TypeError("Could n<span class="cstat-no" title="statement not covered" >o</span></span>t convert from RDF, too few arguments.");return i.apply(n</span>ull,[e.from<span class="fstat-no" title="function not covered" >RD</span>F].concat(<span class="cstat-no" title="statement not covered" >r.call(arguments)))},o<span class="cstat-no" title="statement not covered" >.toRDF=function(t){if(arguments.length&lt;1)throw new TypeError("Could no<span class="cstat-no" title="statement not covered" >t</span></span> convert to RDF, too few arguments.");return i.apply(null,[</span>e.toRDF].<span class="fstat-no" title="function not covered" >co</span>ncat(r.cal<span class="cstat-no" title="statement not covered" >l(arguments)))},o.norm<span class="cstat-no" title="statement not covered" >alize=function(t){if(arguments.length&lt;1)throw new TypeError("Could n<span class="cstat-no" title="statement not covered" >o</span></span>t normalize, too few arguments.");return i.apply(null,[e.</span>normalize].co<span class="fstat-no" title="function not covered" >nc</span>at(r.call(<span class="cstat-no" title="statement not covered" >arguments)))},"jsonld.<span class="cstat-no" title="statement not covered" >js"===s&amp;&amp;(o.link=function(t,n){if(arguments.length&lt;2)throw new <span class="cstat-no" title="statement not covered" >T</span></span>ypeError("Could not link, too few arguments.");return i.apply</span>(null,[e.link].concat(r.ca<span class="fstat-no" title="function not covered" >ll</span>(arguments))<span class="cstat-no" title="statement not covered" >)},o.objectify=functio<span class="cstat-no" title="statement not covered" >n(t){return i.apply(null,[e.objectify].concat(r.call(argum<span class="cstat-no" title="statement not covered" >e</span></span>nts)))},o.createNodeMap=function(t){return i.apply(null,</span>[e.createNode<span class="fstat-no" title="function not covered" >Ma</span>p].concat(<span class="cstat-no" title="statement not covered" >r.call(arguments)))},o.merge=function(t){return i.apply(null,[</span>e.merge].concat(r<span class="fstat-no" title="function not covered" >.c</span>all(argume<span class="cstat-no" title="statement not covered" >nts)))});try{e.Promise=a.Promise||n(28).Promise}catch(e){var u=fun</span>ction(){t<span class="fstat-no" title="function not covered" >hr</span>ow new Err<span class="cstat-no" title="statement not covered" >or("Unable to find a Promise implementation.")};for(var l </span>in<span class="cstat-no" title="statement not covered" > </span>o)o<span class="cstat-no" title="statement not covered" >[l]=u}return o},e.promisify=function</span>(t){if(!e.Promi<span class="cstat-no" title="statement not covered" >se)try{e.<span class="fstat-no" title="function not covered" >Pr</span>om<span class="cstat-no" title="statement not covered" >ise=a.Promise||n(28).Promise}catch(e){throw new Error("Unable</span> <span class="cstat-no" title="statement not covered" ></span>to find a Promi<span class="cstat-no" title="statement not covered" >se imple<span class="cstat-no" title="statement not covered" ></span></span>m</span>entation.</span>")}var r=Arra<span class="fstat-no" title="function not covered" >y.</span>prototype.<span class="cstat-no" title="statement not covered" >slice.call(arg<span class="cstat-no" title="statement not covered" >umen<span class="cstat-no" title="statement not covered" >ts,1);return new e.Promise(function(</span>e,n){t.ap<span class="cstat-no" title="statement not covered" >ply(null,r.concat(function(t,r){t?n(t):e(r)}))})},e.promises(</span>{</span></span>api:e<span class="cstat-no" title="statement not covered" >.promises}),t.prototype=e.promises({vers<span class="cstat-no" title="statement not covered" ></span>ion:"json-ld-1.0"}),t<span class="fstat-no" title="function not covered" >.p</span>rototype.toS<span class="cstat-no" title="statement not covered" >tring=function(){retur<span class="fstat-no" title="function not covered" >n </span>this instanc<span class="cstat-no" title="statement not covered" >eof t?"[objec</span>t Js</span>onL</span>dProcessor]":"[object JsonLdProcessorPrototype]"},e.JsonLdProcessor=t;var ce=!!Object.definePropert<span class="fstat-no" title="function not covered" >y;</span>if(ce)try<span class="cstat-no" title="statement not covered" >{Object.defineProperty({},"x",{})}catch(e){ce=!1}ce&amp;&amp;(Object.defineProperty(t,"prototype"</span>,{writable:!1,enumerable:!1}<span class="cstat-no" title="statement not covered" >),Object.defineProperty(<span class="cstat-no" title="statement not covered" ></span>t.prot<span class="cstat-no" title="statement not covered" >otyp<span class="cstat-no" title="statement not covered" >e,"constructor",{writable:!0,enume</span>rable:!1,<span class="cstat-no" title="statement not covered" >configu<span class="cstat-no" title="statement not covered" ></span>r</span></span>able:!0,value:t})),c&amp;&amp;"undefined"==typeof a.JsonLdProcessor&amp;&amp;(ce?Object.defineProperty(a,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:t}):a.JsonLdProcessor=t);var fe="function"==typeof s&amp;&amp;s,he=fe?function(e){fe(e)}:function(e){setTimeout(e,0)};"object"==typeof o&amp;&amp;"function"==typeof o.nextTick?e.nextTick=o.nextT</span>ick:e.<span class="cstat-no" title="statement not covered" >nextTick=he,e.setImmedia</span>te=<span class="cstat-no" title="statement not covered" >fe?<span class="fstat-no" title="function not covered" >he</span>:e.nextTic<span class="cstat-no" title="statement not covered" >k,e.par</span>s<span class="fstat-no" title="function not covered" >eL</span>inkHeader=<span class="cstat-no" title="statement not covered" >function(e){for(v</span>a<span class="cstat-no" title="statement not covered" ></span>r t={},n=e.match(/(?:&lt;[^&gt;]*?&gt;|"[^"]*?"|[^,])+/g),r=/\s*&lt;([^&gt;]*?)&gt;\s*(?:;\s*(.*))?/,i=0;i&lt;n.length;++i){var o=n[i].match(r);if(o){for(var<span class="fstat-no" title="function not covered" > a</span>={target:o<span class="cstat-no" title="statement not covered" >[1]},s=o[2],u=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;o=u.exec(s);)a[o[1]]=void 0===o[2]?o[3]:o[2];va<span class="cstat-no" title="statement not covered" >r l=a.rel||"";<span class="cstat-no" title="statement not covered" ></span>B(t[l]<span class="cstat-no" title="statement not covered" >)?t[l].push(a):l in t?t[l]=[t[l],a]:t[l]=a}}return t},e.RequestQueue=function(){this._requests={}},e<span class="cstat-no" title="statement not covered" >.RequestQueue.prototype.wrapLoade</span></span>r=fun<span class="cstat-no" title="statement not covered" >ction(e){r<span class="cstat-no" title="statement not covered" ></span>eturn this._loader=e,this._usePromise=1===e.length</span>,<span class="cstat-no" title="statement not covered" ></span>t</span>his.add.b</span>ind(this)},e.Req<span class="fstat-no" title="function not covered" >ue</span>stQueue.p<span class="cstat-no" title="statement not covered" >rototype.add=functi</span>on(t,n){var r=this;if(!n&amp;&amp;!r._useProm<span class="fstat-no" title="function not covered" >is</span>e)throw ne<span class="cstat-no" title="statement not covered" >w Error("callback must be specified.");return r._usePromise?new e.Promise</span>(function(e,n){var i=r._reques<span class="fstat-no" title="function not covered" >ts</span>[t];i||(i=r._reque<span class="cstat-no" title="statement not covered" >sts[t<span class="cstat-no" title="statement not covered" ></span>]=r._loader(t).then(fu<span class="cstat-no" title="statement not covered" >nction(e){return delete r._requests[t],e}).catc<span class="cstat-no" title="statement not covered" >h</span></span>(function(e){throw delete r._reque<span class="fstat-no" title="function not covered" >st</span>s[t],e})),i.then(f<span class="cstat-no" title="statement not covered" >unction(t){e(t)<span class="cstat-no" title="statement not covered" ></span>}).catch(function(e){n(e)})}):void(t in<span class="fstat-no" title="function not covered" > r</span>._requests<span class="cstat-no" title="statement not covered" >?r._requests[t].push(n):(r._requ</span>ests[t]=<span class="fstat-no" title="function not covered" >[n</span>],r._loade<span class="cstat-no" title="statement not covered" >r(t,function(e,n){var i=r._requ</span>ests[t];de<span class="fstat-no" title="function not covered" >le</span>te r._requ<span class="cstat-no" title="statement not covered" >ests[t</span>];for(va<span class="fstat-no" title="function not covered" >r </span>o=0;o&lt;i.le<span class="cstat-no" title="statement not covered" >ngth;+</span>+o)</span>i[o](e,n)})))},e.DocumentCache=function(e){this.order=[],this.cache={},this.siz<span class="fstat-no" title="function not covered" >e=</span>e||50,this.expires<span class="cstat-no" title="statement not covered" >=3e4},e.Documen<span class="cstat-no" title="statement not covered" ></span>tCache.prototype.get=f<span class="cstat-no" title="statement not covered" >u</span>nction(e){if(e in this.cac<span class="cstat-no" title="statement not covered" >he){var t=t</span></span>his.c</span>ache[e];if(t.expi<span class="fstat-no" title="function not covered" >re</span>s&gt;=+new Da<span class="cstat-no" title="statement not covered" >te)return t.ctx;delete this.cache[e],this.order.splice(this.or</span>der.indexOf(e),1)}return null},<span class="fstat-no" title="function not covered" >e.</span>DocumentCa<span class="cstat-no" title="statement not covered" >che.prototype.set=function<span class="cstat-no" title="statement not covered" >(e,t){this.ord<span class="cstat-no" title="statement not covered" ></span>er.length===this.size&amp;&amp;del<span class="cstat-no" title="statement not covered" >ete this.cach<span class="cstat-no" title="statement not covered" >e</span></span>[this.order.shift()],this.order.push(e),this.cache[e]={ctx:t,exp<span class="cstat-no" title="statement not covered" ></span>i</span>res:+new Dat</span>e+this.expires}},e.ActiveContex<span class="fstat-no" title="function not covered" >tC</span>ache=functio<span class="cstat-no" title="statement not covered" >n(e){this.order=[],this.cache={},this.size=e||100},e.ActiveContextCache.prototype.get=function(e,t){var n=JSON.stringify(e),r=JSON.stringify(t),</span>i=this.cache[n];return<span class="fstat-no" title="function not covered" > i</span>&amp;&amp;r in i?i<span class="cstat-no" title="statement not covered" >[r]:null},e.ActiveContextCache.prototype.set=f</span>unction(e,t,n){if(this.order.length=<span class="fstat-no" title="function not covered" >==</span>this.size){var r=t<span class="cstat-no" title="statement not covered" >his.order.shift();</span>de<span class="cstat-no" title="statement not covered" >lete this.cache[r.</span>ac<span class="cstat-no" title="statement not covered" >tiveCtx][r.loc<span class="cstat-no" title="statement not covered" ></span>alCtx]}var i=JSON.stringify(</span>e),o=JSON.stringify(t);this.order.pu<span class="fstat-no" title="function not covered" >sh</span>({activeCtx:i,<span class="cstat-no" title="statement not covered" >localCtx:o}),i in this.cache||(this.cach<span class="cstat-no" title="statement not covered" >e[i]={}),this.cache<span class="cstat-no" title="statement not covered" ></span>[i][o]=te(n)},e.cache={activeCtx:new e.Activ</span>e</span>Conte<span class="cstat-no" title="statement not covered" >xtCache},e.documen</span>tL<span class="cstat-no" title="statement not covered" >oaders={},e.docume<span class="cstat-no" title="statement not covered" ></span>ntLoaders.jquery=function(t,n){function r(r,i){return 0!==r.indexOf("http:")&amp;&amp;0!==r.indexOf("https:")?</span>i(new Ce('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.<span class="fstat-no" title="function not covered" >In</span>validUrl",{code:"load<span class="fstat-no" title="function not covered" >in</span>g doc<span class="cstat-no" title="statement not covered" >ument failed",url:r}),{contextUrl:null,documentUrl:r,document:null}):n.secure&amp;&amp;0!==r.indexOf("https")?i(new Ce('URL could not be dereferenced; secure mode is enabled and the URL\'s scheme is not "https".',"jsonld.InvalidUrl",{code:"loading document failed",url:r}),{contextUrl:null,documentUrl:r,document:null}):void t.ajax({url:r,accepts:{json:"application/ld+json, application/json"},headers:{Accept:"application/ld+json, application/json"},dataType:"json",crossDomain:!0,success:function(t,n,o){var a={contextUrl:null,documentUrl:r,document:t},s=o.getResponseHeader("Content-Type"),u=o.getResponseHeader("Link");if(u&amp;&amp;"application/ld+json"!==s){if(u=e.parseLinkHeader(u)[Oe],B(u))return i(new<span class="fstat-no" title="function not covered" > Ce("URL</span> could not be<span class="cstat-no" title="statement not covered" > dereferenced, it has more than one associa</span>te<span class="cstat-no" title="statement not covered" >d HTTP Link Header.","jsonld.Invalid</span>Ur<span class="cstat-no" title="statement not covered" >l",{code:"multiple context l<span class="cstat-no" title="statement not covered" ></span>ink headers",url:r}),a);u&amp;&amp;(a.con<span class="cstat-no" title="statement not covered" >textUrl=u.target)}i(null,a)},error:<span class="cstat-no" title="statement not covered" >function(e,t,n){i(new Ce("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:r,cause:n}),{contextUrl:null<span class="cstat-no" title="statement not covered" >,</span></span>documentUrl:r,document:null<span class="cstat-no" title="statement not covered" ></span>}</span>)}})}n=n||</span>{};var i=new e.RequestQueue,o="usePromise<span class="fstat-no" title="function not covered" >"in n?</span>n.usePr<span class="cstat-no" title="statement not covered" >omise:"undefined"!=typeof Promise;return o?i.wrapLoader(function(t){return e.promisify(r,t)}):i.wrapLoader(r)},e.documentLoaders.node=function(t){function r(n,l,c){function f(t,i,a){if</span>(h={<span class="cstat-no" title="statement not covered" ></span>contextUr</span>l:nul<span class="cstat-no" title="statement not covered" >l,documentUrl:n,docum</span>en<span class="cstat-no" title="statement not covered" >t:a||null},t)return c(new Ce("URL could not be dereference<span class="cstat-no" title="statement not covered" ></span>d, an error occurred."<span class="fstat-no" title="function not covered" >,"</span>jsonld.Loa<span class="cstat-no" title="statement not covered" >dDocumentError",{code:"lo</span>ading document fail</span>ed",url:n,cause:t}),h);v<span class="fstat-no" title="function not covered" >ar</span> s=u.STATUS_CODES[i<span class="fstat-no" title="function not covered" >.s</span>tatusCode];if(i.<span class="fstat-no" title="function not covered" >st</span>atusCod<span class="cstat-no" title="statement not covered" >e&gt;=400)return c(new Ce("URL could not be dereferenced: "<span class="cstat-no" title="statement not covered" >+s,"jsonld.InvalidUrl",{code:"loading document failed",url:n,httpStatusCode:i.statusCode}),h);if(i.headers.link&amp;&amp;"application/ld+json"!==i.headers[</span></span>"cont<span class="cstat-no" title="statement not covered" >ent-type"]){var f=e.parseLink<span class="cstat-no" title="statement not covered" ></span>Header(i.headers.link<span class="cstat-no" title="statement not covered" >)[Oe];if(B(f))return c(new Ce("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"mul<span class="cstat-no" title="statement not covered" >t</span></span>iple context link headers",url:n}),h);f&amp;&amp;(h.contextUrl=f.target)}return i.s<span class="cstat-no" title="statement not covered" >tatusCode&gt;=300&amp;&amp;i.statusCode&lt;400&amp;&amp;i.he<span class="cstat-no" title="statement not covered" ></span>aders.lo<span class="cstat-no" title="statement not covered" >cation?l.length===o?c(new Ce("URL could not be dereferenced; there were too many redirects.","jsonld.TooManyRedirects",{code:"loading document failed",url:n,httpStatusC<span class="cstat-no" title="statement not covered" >o</span></span>de:i.statusCode,redirects:l<span class="cstat-no" title="statement not covered" ></span>}</span>),h):l.indexOf(n)!==-1?c(new Ce("URL could not be dereferenced; infinite redirection was detected.","jsonld.InfiniteRedirectDetected",{code:"recursive context inclusion",url:n,httpStatusCode:i.statusCode,redirects:l}),h):(l.push(n),r(i.headers.location,l,c)):(l.push(n),void c(t,h))}if(0!==n.indexOf("http:")&amp;&amp;0!==n.indexOf("https:"))return c(new Ce('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:n}),{contextUrl:null,documentUrl:n,document:null});if<span class="cstat-no" title="statement not covered" ></span>(t.secure&amp;&amp;0!==n.indexOf("https"))return c(new Ce('<span class="cstat-no" title="statement not covered" >URL could not be dereferenced; secure mode is enabled and the URL\'s scheme is not "https".',"jsonld.InvalidUrl",{code:"loading document failed",url:n}),{contextUrl:null,documentUrl:n,document:null});<span class="cstat-no" title="statement not covered" >v</span></span>ar h=null;if(null!==h)return c(null<span class="cstat-no" title="statement not covered" >,h);var d={Accept:s};for(var p in t.headers)d[p]=t.headers[p];a({url:n,headers:d,strictSSL:i,followRedirect:!1},f)}t=t||{};var i=!("strictSSL"in t)||t.strictSSL,o="maxRedirects"in t?t.maxRedirects:-1,a="request"in t?t.</span></span>reque<span class="cstat-no" title="statement not covered" >st:n(<span class="cstat-no" title="statement not covered" ></span>31),s="appli<span class="cstat-no" title="statement not covered" >cation/ld+json, ap</span></span>plica<span class="cstat-no" title="statement not covered" >tion/json",<span class="cstat-no" title="statement not covered" ></span>u=n(31),l=new e.Request<span class="cstat-no" title="statement not covered" >Queue;if(t.useProm<span class="cstat-no" title="statement not covered" >i</span></span>se)return l.wrapLoader(function(t){return e.promisify<span class="cstat-no" title="statement not covered" ></span>(r,t,[])}</span>);var<span class="cstat-no" title="statement not covered" > c=t.headers||{};if("Accept"in c</span>||<span class="cstat-no" title="statement not covered" >"accept"in c)throw new RangeError('Ac</span>ce<span class="cstat-no" title="statement not covered" >pt header may not be specified</span> a<span class="cstat-no" title="statement not covered" >s an option; only "'+s+'" is supported.'</span>);<span class="cstat-no" title="statement not covered" >return</span> l<span class="cstat-no" title="statement not covered" >.wrapLoader(function(<span class="cstat-no" title="statement not covered" ></span>e,t){r(e,[],t)})<span class="cstat-no" title="statement not covered" >},e.documentLoaders.<span class="fstat-no" title="function not covered" >xh</span>r=function<span class="cstat-no" title="statement not covered" >(t){function n(n,i){if(0!==n</span>.in</span></span>dexOf<span class="cstat-no" title="statement not covered" >("http:")&amp;&amp;0!=<span class="cstat-no" title="statement not covered" ></span>=n.indexOf("https:"))return i(<span class="cstat-no" title="statement not covered" >new Ce('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidU<span class="cstat-no" title="statement not covered" >r</span></span>l",{code:"loading d<span class="fstat-no" title="function not covered" >oc</span>ument failed<span class="cstat-no" title="statement not covered" >",url:n}),{</span>con</span>textUrl:null,documentUr<span class="fstat-no" title="function not covered" >l:</span>n,document:null});i<span class="fstat-no" title="function not covered" >f(</span>t.sec<span class="cstat-no" title="statement not covered" >ure&amp;&amp;0!==n.indexOf("https"))return i(new Ce('URL co<span class="cstat-no" title="statement not covered" >uld not be dereferenced; secure mode is enabled and the URL\'s scheme is not "https".',"jsonld.InvalidUrl",{code:"loading document failed",url:n}),{contextUrl:null,documentUrl:n,document:null});var o=<span class="cstat-no" title="statement not covered" >t</span></span>.xhr||XMLHttpRequest,a=new o;a.onlo<span class="cstat-no" title="statement not covered" >ad=function(){if(a.status&gt;=400)return i(new Ce("URL could not be dereferenced: "+a.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:n,httpStatusCode:a.status}),{contextUrl:null,documentUrl:n,do</span></span>cumen<span class="cstat-no" title="statement not covered" >t:null});var t,o={cont</span>ex<span class="cstat-no" title="statement not covered" >tUrl:nul<span class="cstat-no" title="statement not covered" ></span>l,documen<span class="fstat-no" title="function not covered" >tU</span>rl:n,docu<span class="cstat-no" title="statement not covered" >ment:a.response},<span class="cstat-no" title="statement not covered" >s=a.getResponseHeader("Content-Type");if(r.test(a.getAllResponseHeaders())&amp;&amp;(t=a.getResponseHeader("Link")),t&amp;&amp;"application/ld+json"!==s){if(t=e.parseLinkHeader(t)[Oe],B(t))return i(new Ce("URL could no</span></span>t be de<span class="cstat-no" title="statement not covered" >referenced, it has more than one associated HTTP Lin</span>k <span class="cstat-no" title="statement not covered" >Header.","jsonld.InvalidUrl",{code:"<span class="cstat-no" title="statement not covered" ></span>multiple context link headers",url:n}),o);t&amp;&amp;(o.contextUrl=t.target)}i(null,o)},a.onerror=function()<span class="cstat-no" title="statement not covered" >{i(new Ce("URL could not be derefer<span class="cstat-no" title="statement not covered" >enced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:n}),{contextUrl:null,documentUrl:n,document:null})},a.open("GET",n,!0),a.setRe<span class="cstat-no" title="statement not covered" >q</span></span>uestHeader("Accept","applic<span class="cstat-no" title="statement not covered" ></span>a</span>tion/ld+js</span>on, applica<span class="fstat-no" title="function not covered" >ti</span>on/json")<span class="cstat-no" title="statement not covered" >,a.send()}t=t||{};var r=/(^|(\r\n))link:/i,i=new e.RequestQueue,o="usePromise"in t?t.usePromise:"undefined"!=typeof Promise;return o?i.wrapLoader(function(t){return e.promisify</span>(n,t)}):i.wrapLoader(n)},e.useDocumentLoader=function(t){if(!(t in e.documentLoaders))throw new Ce(<span class="cstat-no" title="statement not covered" ></span>'Unknown </span>docum<span class="cstat-no" title="statement not covered" >ent loader type: "'</span>+t<span class="cstat-no" title="statement not covered" >+'"',"jsonld.UnknownD</span>oc<span class="cstat-no" title="statement not covered" >umentLoader",{type:t});e.documentLoader=e.documentLoaders[<span class="cstat-no" title="statement not covered" ></span>t].apply(e,Array.proto<span class="fstat-no" title="function not covered" >ty</span>pe.slice.c<span class="cstat-no" title="statement not covered" >all(arguments,1))},e.proc</span>essContext=function</span>(t,n){var r={},i=2;ar<span class="fstat-no" title="function not covered" >gu</span>ments.leng<span class="cstat-no" title="statement not covered" >th&gt;3&amp;&amp;(r=arguments[2]||{},i+=<span class="cstat-no" title="statement not covered" >1);var o=arguments[i];return"base"in r||(r.base=""),"documentLoader"in r||(r.documentLoader=e.<span class="cstat-no" title="statement not covered" >l</span></span>oadDocument),null===n?o(null,U(r)):(n=te(n),q(n)&amp;&amp;"@context"in n||(n={"@context":n}),vo</span>id re(n,r,function<span class="fstat-no" title="function not covered" >(e</span>,n){if(e)return o(<span class="cstat-no" title="statement not covered" >e);</span>tr<span class="cstat-no" title="statement not covered" >y{<span class="cstat-no" title="statement not covered" ></span>n=(new Ae).processContext(t,n,r)}catch(e){retur</span>n o(e<span class="cstat-no" title="statement not covered" >)}o(null,n)})<span class="cstat-no" title="statement not covered" ></span>)},e.hasProperty=function(e,t){var n=!1;if(t in e){var r=e[t];n=!B(r)||r.length&gt;0}return n},e.hasValue=function(t,n,r){var i=!1;if(e.hasProperty(t,n)){var o=t[n],a=K(o);i<span class="fstat-no" title="function not covered" >f(</span>B(o)||a){a&amp;&amp;<span class="cstat-no" title="statement not covered" >(o=o[<span class="cstat-no" title="statement not covered" >"@list"]);fo<span class="cstat-no" title="statement not covered" >r</span></span>(va<span class="cstat-no" title="statement not covered" >r s=0;s&lt;o.length;++s)if(e.compareV</span>alues(r,o<span class="cstat-no" title="statement not covered" >[s])){i=!0;br<span class="cstat-no" title="statement not covered" ></span>e</span>ak}}else B</span>(r)|</span>|(i=e.compareVa<span class="fstat-no" title="function not covered" >lu</span>es(r,o))}return i}<span class="cstat-no" title="statement not covered" >,e.<span class="cstat-no" title="statement not covered" ></span>addValue=function<span class="cstat-no" title="statement not covered" >(t,n,<span class="cstat-no" title="statement not covered" ></span>r,i){if(i=i||{},"prop<span class="cstat-no" title="statement not covered" ></span>e</span>rtyIsArra</span>y"in i||(i.p<span class="fstat-no" title="function not covered" >ro</span>pertyIsArray=!1),"al<span class="cstat-no" title="statement not covered" >low<span class="cstat-no" title="statement not covered" ></span>Duplicate"in i||(i.allowDupli<span class="cstat-no" title="statement not covered" >cate=</span>!0<span class="cstat-no" title="statement not covered" >),B(r<span class="cstat-no" title="statement not covered" ></span>)){0!==r.len<span class="cstat-no" title="statement not covered" >gth||!i.propertyIs<span class="cstat-no" title="statement not covered" >A</span>rray||n in t||(t[n]=[]);fo<span class="cstat-no" title="statement not covered" >r(var o=0;o&lt;r.length;++o)e.a<span class="cstat-no" title="statement not covered" >ddVal<span class="cstat-no" title="statement not covered" >u</span>e(t,n,</span>r</span></span>[o],i<span class="cstat-no" title="statement not covered" >)}else if(n in t){var a=!i.allow<span class="cstat-no" title="statement not covered" ></span></span>D</span>uplicate&amp;</span>&amp;e.hasValue(<span class="fstat-no" title="function not covered" >t,</span>n,r);B(t[n])||a&amp;<span class="cstat-no" title="statement not covered" >&amp;!i.propertyIsArray||(t[n]=[t[n]]),a||t[n].push(r)}else t[n]=i.propertyIsArray?[r]:r},e.getValues=function(<span class="cstat-no" title="statement not covered" >e,t){var n=e[t]||[];return B(n)||(n=[n]),n},e.remove<span class="cstat-no" title="statement not covered" >P</span>roperty=function(e,t){dele<span class="cstat-no" title="statement not covered" >te e[t]},e.removeValue=f</span></span>uncti<span class="cstat-no" title="statement not covered" >on(t,n,r,i){i=i||<span class="cstat-no" title="statement not covered" >{},"propertyIsArray"in i||(i.property<span class="cstat-no" title="statement not covered" ></span>IsArray=!1);var o=e.getValues(t,n).filter(function(t){return!e.</span>compa<span class="cstat-no" title="statement not covered" >reValues(t,r)});0===o.length?e</span></span></span>.removeProper<span class="fstat-no" title="function not covered" >ty</span>(t,n):1!==o.length<span class="cstat-no" title="statement not covered" >||i.prope<span class="cstat-no" title="statement not covered" ></span>rtyIsArray?t[n]=o:t[n]=o</span>[0]},e.compareValu<span class="fstat-no" title="function not covered" >es</span>=function(e,<span class="cstat-no" title="statement not covered" >t){return e==</span>=t||(!(!Q(e)||!<span class="fstat-no" title="function not covered" >Q(</span>t)||e["@value"]!<span class="cstat-no" title="statement not covered" >==t["@value"]||e["@type"]!==t["@type"]||e["@language"]!</span>==t["<span class="cstat-no" title="statement not covered" >@language"]||e["@index"]<span class="fstat-no" title="function not covered" >!=</span>=t["@index<span class="cstat-no" title="statement not covered" >"])||!!(q(e)&amp;&amp;"@id"in e&amp;&amp;q(t)</span>&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>"@id"in t)&amp;&amp;e["@id"]===t["@id"])},e.getContextValue=function(e,t,n){var r=null;if(nul</span>l===t)return r;if<span class="fstat-no" title="function not covered" >("</span>@language"==<span class="cstat-no" title="statement not covered" >=n&amp;&amp;n in e&amp;&amp;(r=e[n]),e.mappings[t]){var i=e.mappings[t];G(n)?r=i:n in i&amp;&amp;(r=i[n])}return r};var de={};if(e.registerRDFParser=function(e,t){de[e]=t},e.unregisterRDFParser=function(e){delete de[e]},l){if(</span>"undefined"==typeof<span class="fstat-no" title="function not covered" > p</span>e)var pe=null;if("un<span class="cstat-no" title="statement not covered" >defin<span class="cstat-no" title="statement not covered" ></span>ed"==typeof <span class="cstat-no" title="statement not covered" >ve)var ve<span class="cstat-no" title="statement not covered" >=</span></span>{ELEMENT_NODE:1,ATTRIBUTE_NODE:2,TEXT_NODE:3,CDATA_SECTIO<span class="cstat-no" title="statement not covered" >N_NODE:4,ENTIT<span class="cstat-no" title="statement not covered" ></span>Y_REFERENCE_NODE:5,ENTITY_N<span class="cstat-no" title="statement not covered" ></span>O</span>DE:6,PROC</span>ES</span>SING_I<span class="cstat-no" title="statement not covered" >NST<span class="cstat-no" title="statement not covered" ></span>RUCTION_NODE:7,COMMENT_<span class="fstat-no" title="function not covered" >NO</span>DE:8,DOCUMEN<span class="cstat-no" title="statement not covered" >T_NODE:9,</span>DOCUMENT_TYPE_NODE:10,D<span class="fstat-no" title="function not covered" >OC</span>UMENT_FRAG<span class="cstat-no" title="statement not covered" >MENT_NODE:11,N</span>OTAT<span class="cstat-no" title="statement not covered" >ION_NODE:12}}var ge="http://www.w<span class="cstat-no" title="statement not covered" >3.org<span class="cstat-no" title="statement not covered" ></span>/</span>2001/XMLSchema#boolean",ye="http<span class="cstat-no" title="statement not covered" >://www.w3.org/2001/XMLSchema#double",me="http://www.w3.org/2001/XMLSchema#integer",be="http://www.w3.org/2001/XMLSchema#string",we="http://www.w3.org/1999/02/22-rdf-syntax-ns#",xe=we+"List",_e=we+"first",ke=we+"rest",Te=we+"nil",Ee</span>=</span>w</span>e+"typ<span class="cstat-no" title="statement not covered" >e",Se=we+"PlainLiteral",Ne=we+"XMLLiteral",</span>Re=<span class="cstat-no" title="statement not covered" >we+"object",je=we+"langString",Oe="http://</span>www<span class="cstat-no" title="statement not covered" >.w3.org/ns/json-ld#context",Ie=10,Ce=functi</span>on(<span class="cstat-no" title="statement not covered" >e,t,n){l?(Error.call(this),Error.captureSt</span>ack<span class="cstat-no" title="statement not covered" >Trace(this,this.constructor)):"undefined"!=typ</span>eof<span class="cstat-no" title="statement not covered" > Error&amp;&amp;(t</span>his<span class="cstat-no" title="statement not covered" >.stack=(new</span> Er<span class="cstat-no" title="statement not covered" >ror).stack</span>),t<span class="cstat-no" title="statement not covered" >his.name=</span>t||<span class="cstat-no" title="statement not covered" >"jsonld.Er</span>ror<span class="cstat-no" title="statement not covered" >",this.message=e||</span>"An<span class="cstat-no" title="statement not covered" > unspecified JSO</span>N-L<span class="cstat-no" title="statement not covered" >D error occu</span>rre<span class="cstat-no" title="statement not covered" >d.",this.details</span>=n|<span class="cstat-no" title="statement not covered" >|{}};l?n(31).inherits(Ce,Error):"undefi</span>ned<span class="cstat-no" title="statement not covered" >"!=</span>typ<span class="cstat-no" title="statement not covered" >eof Error<span class="fstat-no" title="function not covered" >&amp;&amp;(</span>Ce.prot<span class="cstat-no" title="statement not covered" >otype=new Error);var Ae=function(){};Ae.prototype.compact=function(t,n,r,i){if(B(r)){for(var o=[],a=0;a&lt;r.length;++a){var s=this.compact(t,n,r[a],i);null!==s&amp;&amp;o.push(s)}if(i.compactArrays&amp;&amp;1===o.length){var u=e.getContextValue(t,n,</span>"<span class="cstat-no" title="statement not covered" ></span>@container");null===u&amp;&amp;(o=o[0])}return o}if(q(r)){if(i.link&amp;&amp;"@id"in r&amp;&amp;r["@id"]in</span> i.lin<span class="cstat-no" title="statement not covered" >k)for(var<span class="fstat-no" title="function not covered" > l=</span>i.li<span class="cstat-no" title="statement not covered" ></span>nk[r["@id"]],a=0;a&lt;l.<span class="fstat-no" title="function not covered" >le</span>ngth;++a)if(l[a]<span class="cstat-no" title="statement not covered" >.expanded<span class="cstat-no" title="statement not covered" >===r)return l[a].compacted;if(Q(r)||Y(r<span class="cstat-no" title="statement not covered" >)){var o=C(t,n,r);return <span class="cstat-no" title="statement not covered" ></span>i.link&amp;&amp;Y(r)&amp;&amp;(r["@id<span class="cstat-no" title="statement not covered" ></span>"</span>]in i.link||(i.link[r["@id"]]=[]),i.lin<span class="cstat-no" title="statement not covered" >k[r["@id"]].push({expanded:r,compact<span class="cstat-no" title="statement not covered" ></span>ed:o})),o}var c="@re<span class="cstat-no" title="statement not covered" ></span>v</span>erse"===n<span class="cstat-no" title="statement not covered" ></span>,</span>o={};i.l<span class="cstat-no" title="statement not covered" >ink&amp;&amp;"@id"in r&amp;&amp;(r["@id"]in i.link||(i.l<span class="cstat-no" title="statement not covered" >ink[r["@id"]]=[]),i.link[r["@id"]].push({expan<span class="cstat-no" title="statement not covered" >ded:r,compacted:o}));<span class="cstat-no" title="statement not covered" >for(var f=Object.keys(<span class="cstat-no" title="statement not covered" >r</span></span></span></span>).sort(),h=0;h&lt;f.len<span class="cstat-no" title="statement not covered" >gth;++h){<span class="cstat-no" title="statement not covered" ></span>var d=f[h],p=r[d];if("@id"!==d&amp;&amp;"@type"!==d)if("@reverse"!==d)if("@index"!==d)if("@graph"!==d&amp;&amp;"@list"!==d&amp;&amp;M(d)){v</span>a</span>r v=I<span class="cstat-no" title="statement not covered" >(t,d);e.addValu</span>e(<span class="cstat-no" title="statement not covered" >o,v<span class="cstat-no" title="statement not covered" ></span>,p)}else{if(0===p.length){var g=I(t,d,p,{vocab:!0},c);e.addValue(o,g,p,{propertyIsArray:!0})}for(var y=0;y&lt;p.l<span class="cstat-no" title="statement not covered" >e</span>ngth;++y){var m=p[y],g=I(t,d,m,{vocab:!0},c),u=e.getConte<span class="cstat-no" title="statement not covered" >xtVal</span>ue<span class="cstat-no" title="statement not covered" >(t,g,<span class="cstat-no" title="statement not covered" ></span>"@container"),b=K(m),w=null<span class="cstat-no" title="statement not covered" >;b&amp;&amp;(w=m["@list"]);<span class="cstat-no" title="statement not covered" >var x=this.compac<span class="cstat-no" title="statement not covered" >t(t,g,b?w:m,i);if(b)if(B(x)||(x=[x]),"@lis<span class="cstat-no" title="statement not covered" >t"!==u)<span class="cstat-no" title="statement not covered" ></span>{var _={};_[I(t,"@l</span>ist")<span class="cstat-no" title="statement not covered" >]=x,x=_,"@index"in m&amp;&amp;(<span class="cstat-no" title="statement not covered" >x[I(t,"@index")]=m["@i<span class="cstat-no" title="statement not covered" ></span>ndex"])}else if(g in o)throw new Ce('JSO<span class="cstat-no" title="statement not covered" ></span>N</span>-LD compact error; property has a<span class="cstat-no" title="statement not covered" > "@li</span>st<span class="cstat-no" title="statement not covered" >" @container rule but </span>th<span class="cstat-no" title="statement not covered" >ere is more than a single @list that</span> m<span class="cstat-no" title="statement not covered" >atche</span>s <span class="cstat-no" title="statement not covered" >the c<span class="cstat-no" title="statement not covered" ></span>ompacted term in th</span>e doc<span class="cstat-no" title="statement not covered" >ument. Compaction might mi<span class="cstat-no" title="statement not covered" ></span>x unw<span class="cstat-no" title="statement not covered" >anted items into the list.',"jsonld.<span class="cstat-no" title="statement not covered" >Syn<span class="cstat-no" title="statement not covered" ></span>taxError",{code:"compaction to list of lists"});if("@language"===u||</span>"@ind<span class="cstat-no" title="statement not covered" >ex"===u){v<span class="cstat-no" title="statement not covered" >ar k;g in o?k=o[g]:o[g]=k={},"@language"===u&amp;&amp;Q(x)&amp;&amp;(x=x["@value"]),e.addValue(k,m[u],x)}else{var T=!i.compactArrays||"@set"===u||"@list"===u||B(x)&amp;&amp;0===x.length||"@list"===d||"@graph"===d;e.addValue(o,g,x,{propertyIsArray:T})}}}else{var u=e.getContextValue(t,n,"@container"<span class="cstat-no" title="statement not covered" >)</span></span></span></span>;if("@index"===u)continue;var v=I(t,d);<span class="cstat-no" title="statement not covered" >e.addValue(o,v,p)}else{var E=this.compact(t,"@reverse",p,i);for(var S in E)if(t.mappi</span>ngs[S]&amp;&amp;t.m<span class="cstat-no" title="statement not covered" >appings[S].reverse){var N=E[S],u=e.getContextValue(t,S,"@container"),R="@set"===u||!i.com<span class="cstat-no" title="statement not covered" ></span>pactArrays;e.addValue(o,S,N,{propertyIs</span>A</span>r</span>r</span>ay:R}),dele<span class="cstat-no" title="statement not covered" >te E[S]}if(Object.keys(E).length&gt;0){<span class="cstat-no" title="statement not covered" ></span>var v=I(t,d);e.a<span class="cstat-no" title="statement not covered" >ddValue(o,</span></span>v,E)}<span class="cstat-no" title="statement not covered" >}else{v<span class="cstat-no" title="statement not covered" ></span>ar E;if(z(p))E=I(t,</span>p</span>,null,{voca<span class="cstat-no" title="statement not covered" >b:"@type"===d});else{E=[];for(v<span class="cstat-no" title="statement not covered" ></span>ar y=0;y&lt;p.leng<span class="cstat-no" title="statement not covered" >th;++y)E.push(I(t,p[y],null,{vocab:!0}))}var v=<span class="cstat-no" title="statement not covered" >I(t,d</span>),<span class="cstat-no" title="statement not covered" >T=B(E)&amp;&amp;0===p.length;e.addValue(o,v,</span>E,<span class="cstat-no" title="statement not covered" >{propertyIsArray:T})}}return <span class="cstat-no" title="statement not covered" ></span>o}return r},Ae.prototype.expand=function(t,n,i,o,a)<span class="cstat-no" title="statement not covered" ></span>{</span></span>var s=this;if(null===i||void 0===<span class="cstat-no" title="statement not covered" >i)retur<span class="cstat-no" title="statement not covered" ></span>n null;if(!B(i)&amp;&amp;!q</span>(</span>i</span>))return a|<span class="cstat-no" title="statement not covered" >|null!==<span class="cstat-no" title="statement not covered" >n&amp;&amp;"@graph"!==L(t,n,{vocab:!0})?f(t</span>,n,i<span class="cstat-no" title="statement not covered" >):nul<span class="cstat-no" title="statement not covered" >l</span>;if(B(i)){var u=[],l=e.get<span class="cstat-no" title="statement not covered" >ContextValue(t,n,"@container");a=a|</span></span>|</span>"@lis<span class="cstat-no" title="statement not covered" >t"===l;</span>fo<span class="cstat-no" title="statement not covered" >r(var c=0;c&lt;i.lengt<span class="cstat-no" title="statement not covered" ></span>h;++c){var h=s.expand(t,n,i[c],o);if(a&amp;</span>&amp;<span class="cstat-no" title="statement not covered" ></span>(</span>B(h)||K(h<span class="cstat-no" title="statement not covered" ></span>)</span>))throw n</span>ew Ce("Invalid JSON-L<span class="fstat-no" title="function not covered" >D </span>syntax; lists of lists a<span class="cstat-no" title="statement not covered" >re no<span class="cstat-no" title="statement not covered" ></span>t permitted.","jsonld.Sy<span class="cstat-no" title="statement not covered" >ntaxError",{<span class="cstat-no" title="statement not covered" >c</span></span>ode:"list of li<span class="cstat-no" title="statement not covered" >sts"});null!==h&amp;&amp;(B(h)?u=u.concat(h):u.push(h))}return u}"@cont<span class="cstat-no" title="statement not covered" >e</span></span>xt"in i&amp;&amp;(t=s.<span class="cstat-no" title="statement not covered" >pro</span>ce<span class="cstat-no" title="statement not covered" >ssContext(t,i["@context"],o));for(va<span class="cstat-no" title="statement not covered" ></span>r d=L(t,n,{vocab:<span class="cstat-no" title="statement not covered" >!</span>0}),u={},p=Object.keys(i).sort(),<span class="cstat-no" title="statement not covered" >v=0;v&lt;p.length;++v){v<span class="cstat-no" title="statement not covered" ></span>ar g,y=p[v],m=i[y];<span class="cstat-no" title="statement not covered" >if("@context"!==y){var b=L(t,y,{vocab:!0});if(null!==b&amp;&amp;(ee(b)||M(b))){if(M(b)){if("@reverse"===d)throw new Ce("Invali<span class="cstat-no" title="statement not covered" >d</span></span> JSON-LD syntax; a keyword cannot be used<span class="cstat-no" title="statement not covered" ></span> </span>as a @rev<span class="cstat-no" title="statement not covered" ></span>e</span>rse property.","jsonld.SyntaxError",{code:"invalid reve<span class="cstat-no" title="statement not covered" >r</span>se property map",value:m});if(b in u)throw new Ce("Invalid JSON-LD syntax; colliding<span class="cstat-no" title="statement not covered" > keyw</span>or<span class="cstat-no" title="statement not covered" >ds de<span class="cstat-no" title="statement not covered" ></span>tected.","jsonld.SyntaxEr<span class="cstat-no" title="statement not covered" >ror",{code:"collid<span class="cstat-no" title="statement not covered" ></span>ing keywords",keyword:b})}if<span class="cstat-no" title="statement not covered" >("@id"===<span class="cstat-no" title="statement not covered" >b&amp;&amp;!z(m)){if(!o.is<span class="cstat-no" title="statement not covered" >Frame)throw new Ce('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:m});if(!q(m))throw new Ce('Inva<span class="cstat-no" title="statement not covered" >l</span></span>id JSON-L<span class="cstat-no" title="statement not covered" >D syntax; "@id" value must be a string or an object.',"jsonld.SyntaxError",{code:"invalid @id value",value:m})}if("@type"===b&amp;&amp;H(<span class="cstat-no" title="statement not covered" ></span></span>m</span>),"@graph"===b&amp;&amp;!q(m<span class="cstat-no" title="statement not covered" >)&amp;&amp;!B(m))throw<span class="cstat-no" title="statement not covered" > new Ce('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @gr<span class="cstat-no" title="statement not covered" >a</span></span>ph value<span class="cstat-no" title="statement not covered" >",value:m});if("@value"===b&amp;&amp;(q(m)||B(m)))throw new Ce('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.S<span class="cstat-no" title="statement not covered" ></span></span>y</span>ntaxError",{code:"invalid value object value",v<span class="cstat-no" title="statement not covered" >alue:m});if("@language"===b){if(null===m)continue;if(!z(m))throw new Ce('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxE<span class="cstat-no" title="statement not covered" >r</span></span>ror",{code:"invalid language-<span class="cstat-no" title="statement not covered" >tagged string",value:m});m=m.toLowerCase()}if("@index"===b&amp;&amp;!z(m))throw new Ce('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxErr<span class="cstat-no" title="statement not covered" >o</span></span>r",{code:"invalid @<span class="cstat-no" title="statement not covered" >index value"<span class="cstat-no" title="statement not covered" >,value:m}<span class="cstat-no" title="statement not covered" >)</span></span>;if("@re<span class="cstat-no" title="statement not covered" >verse"!==b){var l=e.getContextValue(t,y,"@container");if("@language"===l&amp;&amp;q(m))g=r(m);else if("@index"===l&amp;&amp;q(m))g=function(e){for(var n=[],r=Obj<span class="cstat-no" title="statement not covered" >e</span></span>ct.keys(m).sort(),<span class="cstat-no" title="statement not covered" ></span>i</span>=0;i&lt;r.length;++i){var<span class="cstat-no" title="statement not covered" > a=r[i],u=m[a];B(u)||(u=[u]),u=s.expand(t,e,u,o,!1);for(var l=0;l&lt;u.length;++l){var c=u[l];"@index"in c||(c["@index"]=a),n.push(c)}}<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}(y);else{var w="<span class="cstat-no" title="statement not covered" >@list"===b;if(w||"@set"===b){var x=n<span class="cstat-no" title="statement not covered" ></span>;if(w&amp;&amp;"@graph"===d&amp;&amp;(x=n<span class="cstat-no" title="statement not covered" >ull),g=s</span>.exp<span class="cstat-no" title="statement not covered" >and(t,x,m,o,w),w&amp;&amp;K(g)<span class="cstat-no" title="statement not covered" >)t<span class="fstat-no" title="function not covered" >hr</span>ow new Ce(<span class="cstat-no" title="statement not covered" >"Invalid JSON-LD syntax; lists of lists are not permitted.","js<span class="cstat-no" title="statement not covered" >onld.</span>Sy<span class="cstat-no" title="statement not covered" >ntaxE<span class="cstat-no" title="statement not covered" ></span>rror",{code:"list of lists"})}else g=<span class="cstat-no" title="statement not covered" >s</span>.expand(t,y,m,o,!1)}if(null!==g||<span class="cstat-no" title="statement not covered" >"@val<span class="cstat-no" title="statement not covered" ></span>ue"===b)if("@list"===b||K(g)||"@list"!==l</span>|<span class="cstat-no" title="statement not covered" ></span>|</span>(g=B(g)?g</span>:[g],</span>g={"@list"<span class="cstat-no" title="statement not covered" >:g}),t.mappi<span class="cstat-no" title="statement not covered" ></span>ngs[y]&amp;&amp;t.mappings[y].re<span class="cstat-no" title="statement not covered" >ve<span class="cstat-no" title="statement not covered" ></span>rse){var _=u["@reverse"]=u["@reverse"]||{};B(g)||(g=[g]);fo<span class="cstat-no" title="statement not covered" >r(var k=0;k&lt;g.length;++k){var T=g[k];if(Q(T)||K(T))throw new Ce('Invalid JSON-LD syntax; "@reverse" value must not be a</span></span> @val<span class="cstat-no" title="statement not covered" >ue or an @list.',"jsonld<span class="cstat-no" title="statement not covered" ></span></span>.</span></span>SyntaxError",{code:"inval<span class="cstat-no" title="statement not covered" >id reverse property value",value:g});e.addValue(_,b,T,{propertyIsArray:!0})}}else{var E=["@index","@id","@ty<span class="cstat-no" title="statement not covered" >pe","@value","@language"].indexO<span class="cstat-no" title="statement not covered" ></span>f(b)===-1;e.ad<span class="cstat-no" title="statement not covered" >d</span>Value(u,b,g,{propertyIsArray:E})}<span class="cstat-no" title="statement not covered" >}else<span class="cstat-no" title="statement not covered" ></span>{if(!q(m))thro<span class="cstat-no" title="statement not covered" >w new Ce('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:m});if(g=s.expand(t,"@reverse",<span class="cstat-no" title="statement not covered" >m</span></span>,o),"@reverse"in g)for(var S in g["@rev</span>e</span>rse"])e.add<span class="cstat-no" title="statement not covered" >Value(u,S,g["@reverse"][S],{propertyIsArray:!0});var _=u["@rev<span class="cstat-no" title="statement not covered" ></span>erse"]||null;for(var S in g)if("@revers</span>e</span></span>"!==S<span class="cstat-no" title="statement not covered" >){null===<span class="cstat-no" title="statement not covered" >_&amp;&amp;(_=u["@reverse"]={}),e.addValue(_,S,[],{propertyIsArray:!0});for(var N=g[S],k=0;k&lt;N.length;++k){var T=N[k];if(Q(T)||K(T))throw new Ce(<span class="cstat-no" title="statement not covered" >'</span></span>Invalid JSON-LD syntax; "@reverse" value must <span class="cstat-no" title="statement not covered" >not be a @value or an @list<span class="cstat-no" title="statement not covered" >.',"jsonld.SyntaxError",{code:"invalid reverse property</span></span></span> valu<span class="cstat-no" title="statement not covered" >e",value:g});e.addVa<span class="cstat-no" title="statement not covered" ></span>lue(_,S,T,{prop<span class="cstat-no" title="statement not covered" >ertyIsArray:!0})}}}<span class="cstat-no" title="statement not covered" >}}}p=Object.keys(u);var R=p.length;if("@value"in u){if("@type"in u&amp;&amp;"@l<span class="cstat-no" title="statement not covered" >a</span>nguage"in u)throw new Ce('Invalid JSON-L<span class="cstat-no" title="statement not covered" >D syn<span class="cstat-no" title="statement not covered" ></span>tax; an elemen<span class="cstat-no" title="statement not covered" >t containing "@value" may not contain both "@type" and "@language".',"jsonld.SyntaxError",{code:"invalid value object",element:u});var j=R-1;if("@type"in u&amp;&amp;(j-<span class="cstat-no" title="statement not covered" >=</span></span>1),"@index"in u&amp;&amp;(j-=1),"@language"in u</span>&amp;</span>&amp;</span></span>(</span>j</span>-<span class="cstat-no" title="statement not covered" ></span>=</span>1),0!==j)throw ne</span>w Ce(<span class="cstat-no" title="statement not covered" >'Invalid <span class="cstat-no" title="statement not covered" ></span>JSON-LD syntax; a<span class="cstat-no" title="statement not covered" >n element containing "@value" ma<span class="cstat-no" title="statement not covered" >y only have an "@index" property and at most one other property which can be "@type" or "@language".',"jsonld.SyntaxError",{code:"invalid value object",element:u});if(null===u["@v</span></span>alue"<span class="cstat-no" title="statement not covered" >])u=<span class="cstat-no" title="statement not covered" ></span>null;else{if("@language"in u&amp;&amp;!z(u["@value"]))throw new Ce("Invalid JSON-L<span class="cstat-no" title="statement not covered" >D syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:u});if("@type"in u&amp;&amp;(!ee(u["@type"])||0===u["@type"].indexOf("_:")))throw new Ce('Invalid JSON-LD syntax; an element con<span class="cstat-no" title="statement not covered" >t</span></span>aining "@value" and "<span class="cstat-no" title="statement not covered" >@type" m</span>ust <span class="cstat-no" title="statement not covered" >have an absolute IRI for the value o<span class="cstat-no" title="statement not covered" >f "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:u})}}else if("@type"in u&amp;&amp;!B(u["@type"]))u["@type"]=[u["@type"]];else if("@set<span class="cstat-no" title="statement not covered" >"</span></span>in u||"@list"in u){if(R&gt;1&amp;&amp;!(2===R&amp;&amp;"@index"in u))throw new Ce(<span class="cstat-no" title="statement not covered" >'Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",el</span></span>e</span>ment:<span class="cstat-no" title="statement not covered" >u});"@set"in u&amp;&amp;(u=u["@set"],p=<span class="cstat-no" title="statement not covered" >Object.keys(u),R=p.length</span>)}el<span class="cstat-no" title="statement not covered" >se 1===R&amp;&amp;"@language"in u&amp;&amp;(<span class="cstat-no" title="statement not covered" >u=null);return!q(u)||o.keepFree<span class="cstat-no" title="statement not covered" >FloatingNodes||a||null!==n&amp;&amp;"@graph"!==d||(0===R||"@value"in u||"@list"in u||1===R&amp;&amp;"@id"in u)&amp;&amp;(u=null),u},Ae.prototype.createNodeMap=function(e,t){t=t||{};var n=t.namer||t.issuer||new ue("_:b"),r={"@default":{}};retur<span class="cstat-no" title="statement not covered" >n</span></span> y(e,r,"@default",n),m(r)},Ae.prototype.flatten=functi</span>on(e)<span class="cstat-no" title="statement not covered" >{for(var t=this.createNodeMap(e),<span class="cstat-no" title="statement not covered" >n</span></span></span></span>=[],r=Object.keys(t).sort(),i=0;i&lt;r.length;++i){var o=t[r[i]];Y(o)||n.push(o)}return n},Ae.prototype.frame=function(e,t,n){var r={</span>options:n,graphs:{"@default"<span class="fstat-no" title="function not covered" >:{</span>},"@merged":<span class="cstat-no" title="statement not covered" >{}},subje</span>ctSta<span class="cstat-no" title="statement not covered" >ck:[],link:{}},i=new ue("_:b");y(</span>e,<span class="cstat-no" title="statement not covered" >r.graphs,"@merge<span class="cstat-no" title="statement not covered" ></span>d",i),r.subjects=r.graphs["@merge</span>d"];var o=[];return b(<span class="fstat-no" title="function not covered" >r,</span>Object.key<span class="cstat-no" title="statement not covered" >s(r.subjects).sort(),t,o,null),o},Ae.prototype.normalize=function(e,t,n){return"URDNA20<span class="cstat-no" title="statement not covered" >15"===t.<span class="cstat-no" title="statement not covered" ></span>algorithm?new Le(<span class="cstat-no" title="statement not covered" ></span>t</span>).main(e,</span>n):"URGNA2012"===t.a<span class="fstat-no" title="function not covered" >lg</span>orithm?new De(t).mai<span class="cstat-no" title="statement not covered" >n(e,n):void n(new Error("Invalid RDF Dataset Normalization algorithm: "+</span>t.<span class="cstat-no" title="statement not covered" >algorithm))},A<span class="cstat-no" title="statement not covered" ></span>e.prototype.fromRDF=function(t,n,r){var i={},o={"@default"</span>:i},a<span class="cstat-no" title="statement not covered" >={}<span class="cstat-no" title="statement not covered" ></span>;for(var s in t){var u=t[s];s in o||(o[s]={}),"@default</span>"===s||s in i||(i[s]={"@<span class="fstat-no" title="function not covered" >id</span>":s});for(var <span class="cstat-no" title="statement not covered" >l=o[s],c=0;c&lt;u.length;++c){var f=u[c],h=f.subject.value,d=f.predicate.value,p=f.object;h in l||(l[h]={"@id":h});var g=l[h],y="IRI"===p.type||"blank node"===p.type;if(!y||p.value </span>in l||(l[p.value]={"@i<span class="fstat-no" title="function not covered" >d"</span>:p.value}),d!==Ee||n<span class="cstat-no" title="statement not covered" >.us</span>eR<span class="cstat-no" title="statement not covered" >dfType||!y){var</span> m<span class="cstat-no" title="statement not covered" >=v(<span class="cstat-no" title="statement not covered" ></span>p,n.useNativeTypes);if<span class="cstat-no" title="statement not covered" >(e.ad<span class="cstat-no" title="statement not covered" ></span>dValue(g,d,m,{propertyIsArray:!0}),y)if(p.value===Te){var b<span class="cstat-no" title="statement not covered" >=</span>l[p.value];"usages"in b||(b.usages=[]),b<span class="cstat-no" title="statement not covered" >.usag</span>es<span class="cstat-no" title="statement not covered" >.push({node:g,pr</span>op<span class="cstat-no" title="statement not covered" >erty:d,value:m})}e</span>ls<span class="cstat-no" title="statement not covered" >e p.value<span class="cstat-no" title="statement not covered" ></span> in a?a[p.value]=!1:a[p.va</span>lue]=<span class="cstat-no" title="statement not covered" >{node</span>:g<span class="cstat-no" title="statement not covered" >,property:d,value:m}}else e.addValue(g<span class="cstat-no" title="statement not covered" ></span>,"@type",p.value,{propertyIsArray:!0})}}for(var s in o){var w=o[s];if(Te in w){for<span class="cstat-no" title="statement not covered" >(var x=w[Te],_=0;_&lt;x.u<span class="cstat-no" title="statement not covered" ></span>sages.length;++_){for(var k=x.usages[_],g=k.<span class="cstat-no" title="statement not covered" >node,T=k.property,E=k.v<span class="cstat-no" title="statement not covered" >alue,S=[],N<span class="cstat-no" title="statement not covered" ></span>=[],R=Object.keys(g).length;T===ke&amp;&amp;q(a[g["@id"]])&amp;&amp;B(g[_e])&amp;&amp;1===g[_e].</span>lengt<span class="cstat-no" title="statement not covered" >h&amp;&amp;B(g[ke])&amp;&amp;1===g[ke].length&amp;&amp;(3===R||4===R&amp;&amp;B(g["@type"])&amp;&amp;1===g[</span></span></span>"@typ<span class="cstat-no" title="statement not covered" >e"].length&amp;&amp;g["@type"][0]===xe)&amp;&amp;(S.push(g[_e][0]),N</span></span>.<span class="cstat-no" title="statement not covered" ></span>p</span>ush(g["@id"]),k=a[g["<span class="cstat-no" title="statement not covered" >@id"]<span class="cstat-no" title="statement not covered" ></span>],g=k.node,T<span class="cstat-no" title="statement not covered" >=k.property,E=k.value,R=Object.keys(g).leng<span class="cstat-no" title="statement not covered" >th,0===g["@id"].indexOf("_:")););if(T===_e){if(g["@id"]===Te)continue;E=w[E["@id"]][ke][0],S.pop(),N.pop()}delete E["@id"],E["@list"]=S.reverse();for(var j=0;j&lt;N.length;++j)delete w[N[j]]}delete x.usages}}for(var O=[],I=Object.keys(i).sort(),_=0;_&lt;I.length;++_){var C=I[_],g=i[C];if(C in o)for(var u=g["@graph"]=[],w=o[C],A=Object.keys(w).sort(),L=0;L&lt;A.length;++L){var D=w[A[L<span class="cstat-no" title="statement not covered" >]</span>];Y(D)||u.<span class="cstat-no" title="statement not covered" >push(D)}Y(g)||O.p<span class="cstat-no" title="statement not covered" >ush(g)}r(<span class="cstat-no" title="statement not covered" >n</span></span>ull,O)},Ae.prototype.toRDF=function(e<span class="cstat-no" title="statement not covered" ></span>,</span>t){var n=new ue("_:b"),r={"@default":{<span class="cstat-no" title="statement not covered" >}</span>};y(e,r,"@default",n);for(<span class="cstat-no" title="statement not covered" >var i={},o=Objec<span class="cstat-no" title="statement not covered" ></span></span>t</span>.keys(r).sort(),</span>a<span class="cstat-no" title="statement not covered" ></span>=</span>0;a&lt;o.length;++a){var s=o[a];("@default"===s||ee(s))&amp;&amp;(i[s]=h(<span class="cstat-no" title="statement not covered" >r[s],</span>n,<span class="cstat-no" title="statement not covered" >t))}r<span class="cstat-no" title="statement not covered" ></span>eturn i},A<span class="cstat-no" title="statement not covered" >e.prototype.processContext=function(t,n,r){q(n)&amp;&amp;"@context"in n&amp;&amp;B(n["@context"])&amp;<span class="cstat-no" title="statement not covered" >&amp;(n=n["@<span class="cstat-no" title="statement not covered" ></span>context"]);var i=<span class="cstat-no" title="statement not covered" ></span>B</span></span>(n)?n:[n];if(0==<span class="cstat-no" title="statement not covered" ></span>=</span>i.length)r</span>eturn t.clone();for(<span class="fstat-no" title="function not covered" >va</span>r o=t,a=0;a&lt;i.leng<span class="cstat-no" title="statement not covered" >th;++a){var s=</span>i[<span class="cstat-no" title="statement not covered" >a];if(null!==s){<span class="cstat-no" title="statement not covered" ></span>if(q(s)&amp;&amp;"@context"i<span class="cstat-no" title="statement not covered" >n</span> s&amp;&amp;(s=s["@context"]),!q(s))throw new Ce("Invalid JSON-LD synt<span class="cstat-no" title="statement not covered" >ax; @<span class="cstat-no" title="statement not covered" ></span>context must be an object.","jsonld.SyntaxErr<span class="cstat-no" title="statement not covered" ></span>o</span>r",{code:</span>"invalid local context",conte<span class="fstat-no" title="function not covered" >xt</span>:s});if(e.cach<span class="cstat-no" title="statement not covered" >e.activeCtx){var u=e.cache.activeCtx.get(t,s);if(u){o=t=u;c</span>ontin<span class="cstat-no" title="statement not covered" >ue}}t=o,o=o<span class="cstat-no" title="statement not covered" ></span>.clone();var l={<span class="cstat-no" title="statement not covered" >};if("@base"in s)<span class="cstat-no" title="statement not covered" >{</span></span>var c=s["@base"];if(null===c)c=null;e<span class="cstat-no" title="statement not covered" >lse{i<span class="cstat-no" title="statement not covered" ></span>f(!z(c))throw<span class="cstat-no" title="statement not covered" > new Ce('Invalid JSON-LD syntax; the value of "@b<span class="cstat-no" title="statement not covered" >ase" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:s});if(""!==c&amp;&amp;!ee(c))throw ne<span class="cstat-no" title="statement not covered" >w</span></span> Ce('Invalid JSON-LD syntax<span class="cstat-no" title="statement not covered" >; the value of "@base" in a<span class="cstat-no" title="statement not covered" ></span> @cont<span class="cstat-no" title="statement not covered" >ext mu<span class="cstat-no" title="statement not covered" >s</span>t be an a</span>b<span class="cstat-no" title="statement not covered" ></span>s</span>olute IRI or the</span> empt<span class="cstat-no" title="statement not covered" >y s<span class="cstat-no" title="statement not covered" ></span>tring.',"jsonld.Syntax<span class="cstat-no" title="statement not covered" >Error",{<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ></span></span></span></span></span></span></span></span></span></span></span>
code:"invalid base IRI",context:s})}n<span class="cstat-no" title="statement not covered" >ull!==c&amp;&amp;(c=e.url.parse(c||"")),o["@base"]=c,l["@base"]=!0}if<span class="cstat-no" title="statement not covered" ></span>("@vocab"in s){var f=s[<span class="cstat-no" title="statement not covered" >"@vocab"];if<span class="cstat-no" title="statement not covered" ></span>(null===f)de<span class="cstat-no" title="statement not covered" >lete o["@vocab"];els</span>e{if<span class="cstat-no" title="statement not covered" >(!z(f))th<span class="cstat-no" title="statement not covered" >row new Ce('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:s});if<span class="cstat-no" title="statement not covered" >(</span></span>!ee(f))th<span class="cstat-no" title="statement not covered" >row new Ce('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:s});o[<span class="cstat-no" title="statement not covered" >"</span></span>@vocab"]=f}l["<span class="cstat-no" title="statement not covered" ></span>@</span>vocab"]=!0}if("<span class="cstat-no" title="statement not covered" ></span>@</span>language"in s){var f=s["@<span class="cstat-no" title="statement not covered" >language"];if(n<span class="cstat-no" title="statement not covered" ></span>ull===f)dele<span class="cstat-no" title="statement not covered" >te o["@language"];else{</span>if(!<span class="cstat-no" title="statement not covered" >z(f))thro<span class="cstat-no" title="statement not covered" >w new Ce('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:s});o["@<span class="cstat-no" title="statement not covered" >l</span></span>anguage"]=f.toLowerCase()}l["@l<span class="cstat-no" title="statement not covered" ></span>a</span>nguage"]=!0}for(va<span class="cstat-no" title="statement not covered" ></span>r</span> h in s)A(o,s,<span class="cstat-no" title="statement not covered" >h,l);e.cach<span class="cstat-no" title="statement not covered" >e</span></span>.activeCtx&amp;&amp;e.cache.activeCtx.set(t,s,o)}else o=</span>t=U(r<span class="cstat-no" title="statement not covered" >)}return o<span class="cstat-no" title="statement not covered" ></span>};var Le=f</span>unction(<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >){</span>var t={subject:<span class="cstat-no" title="statement not covered" >"s",object:"o",name:"g"},n=functio</span>n(<span class="cstat-no" title="statement not covered" >e){e=e||{<span class="fstat-no" title="function not covered" >},</span>thi<span class="cstat-no" title="statement not covered" >s.name="URDNA2015",this.options=e,this.blankNodeInfo={},this.hashToBlankNodes={},this.canonicalIssuer=new ue("_:c14n"),this.quads=[],this.schedule={},"maxCallStackDepth"in e?this.schedule.MAX_DEPTH=e.maxCallStackDepth:this.schedule.MAX_DEPTH=500,"maxTotalCallStackDepth"in e?this.schedule.MAX_TOTAL_DEPTH=e.maxCallStackDepth:this.schedule.MAX_TOTAL_DEPTH=4294967295,this.schedule.depth=0,this.schedule.totalDepth=0,"timeSlice"in e?this.schedule.timeSlice=e.timeSlice:this.schedule.timeSlice=10};return n.pr</span>o<span class="cstat-no" title="statement not covered" ></span>totype.doWork=function(t,n<span class="fstat-no" title="function not covered" >){</span>var r=this.schedul<span class="cstat-no" title="statement not covered" >e;return r.tot<span class="cstat-no" title="statement not covered" ></span>alDepth&gt;=r.MAX_TOTAL_DEPTH?n(new Error("Maximum total call stack depth exceeded; normalization aborting.")):void function i(){if(r.dep<span class="fstat-no" title="function not covered" >th</span>==<span class="cstat-no" title="statement not covered" >=r.MAX_DEPTH)return r.dep<span class="cstat-no" title="statement not covered" >th=0,r.running=!1,e.nextTick(i);var o=(new Da</span></span>te).g<span class="cstat-no" title="statement not covered" >etTime();return r.run<span class="cstat-no" title="statement not covered" ></span>ning||(r.start=(new Date).getTime(),r.deadline=r.start+r.timeSlice),o&lt;r.deadline?(r.running=!0,r.depth++,r.totalDepth++,t(function(e,t<span class="fstat-no" title="function not covered" >){</span>r.depth--,r.<span class="cstat-no" title="statement not covered" >totalDepth--,n(e,t)})):(r.depth=0</span>,r.running=!1,void e.setImmediate(i))}()},n.prototyp</span>e.fo</span>rEach=function(e,t,n)<span class="fstat-no" title="function not covered" >{v</span>ar r,i,o=this,a=0;if(B(e))<span class="cstat-no" title="statement not covered" >i=e.l</span>en<span class="cstat-no" title="statement not covered" >gt<span class="cstat-no" title="statement not covered" ></span>h,r=func<span class="cstat-no" title="statement not covered" >tion(){return a!==i&amp;&amp;(r.value=e[a++],r.key=a,!0)}<span class="fstat-no" title="function not covered" >;e</span>ls<span class="cstat-no" title="statement not covered" >e{var s=Object.keys(e);i=s.length,r=function(){</span>re</span>turn a!==i<span class="cstat-no" title="statement not covered" >&amp;&amp;(r.key=s[a++]<span class="cstat-no" title="statement not covered" ></span>,r.value=e[r.key],!0)}}!function e(i,a){return i?<span class="fstat-no" title="function not covered" >n(i</span>):<span class="cstat-no" title="statement not covered" >r()?o.doWork(function(){t(r.value,r.key,e)}):void n()}()</span>},<span class="cstat-no" title="statement not covered" ></span>n</span>.prototyp<span class="fstat-no" title="function not covered" >e.</span>water<span class="cstat-no" title="statement not covered" >fall=function(e,t){var n=this<span class="fstat-no" title="function not covered" >;n</span>.forEach(<span class="cstat-no" title="statement not covered" >e,function(e,t,r){n.doWo</span>rk(e,r)},t)}</span>,n.p</span>rototype.whilst=functio<span class="fstat-no" title="function not covered" >n(</span>e,t,n){var r=this;<span class="cstat-no" title="statement not covered" >!func<span class="cstat-no" title="statement not covered" ></span>tion i(o){re<span class="fstat-no" title="function not covered" >tu</span>rn o?n(o):e()?<span class="cstat-no" title="statement not covered" >void r.doWork(t</span>,i):n</span>()}()},n.prototype.m<span class="fstat-no" title="function not covered" >ai</span>n=function(e,t){var <span class="cstat-no" title="statement not covered" >n=thi<span class="cstat-no" title="statement not covered" ></span>s;n.schedu<span class="fstat-no" title="function not covered" >le</span>.st<span class="cstat-no" title="statement not covered" >art=(new Date).getTime();var r;if(n.option</span>s.fo</span>rmat&amp;&amp;"application<span class="fstat-no" title="function not covered" >/n</span>quads"!==n.options<span class="cstat-no" title="statement not covered" >.form<span class="cstat-no" title="statement not covered" ></span>at)return t(new Ce("Unknown output form</span>at.",<span class="cstat-no" title="statement not covered" >"jsonld.UnknownFormat",{format:n.options.format}));var i={};n<span class="cstat-no" title="statement not covered" >.waterfall([function(t){n.forEach(e,function(e,t,r){"@default"===t&amp;&amp;(t=null),n.forEach(e,func</span></span>tion(<span class="cstat-no" title="statement not covered" >e,r<span class="cstat-no" title="statement not covered" ></span>,o){null!==t&amp;<span class="fstat-no" title="function not covered" >&amp;(</span>0===t.inde<span class="cstat-no" title="statement not covered" >xOf("_:")?e.<span class="fstat-no" title="function not covered" >na</span>me={type:"blan<span class="cstat-no" title="statement not covered" >k node",value:t}:e.name={type:"IRI",v<span class="fstat-no" title="function not covered" >al</span>ue:t}),n.quads<span class="cstat-no" title="statement not covered" >.push(e),n.forEachComponent(e,function(t){if("blank node"===t.type){var r=t.value;r in n.blankNodeInfo?n.blankNodeInfo[r].quads.push<span class="fstat-no" title="function not covered" >(e</span>):(i[r]=!0<span class="cstat-no" title="statement not covered" >,n.blankNodeInfo[r]={quads:[e]})<span class="cstat-no" title="statement not covered" >}}),o()}<span class="cstat-no" title="statement not covered" ></span>,r)},t)},function(e){var t=!0;n.whilst(function(){return t},function(e){t=!1,n.hashToBlankNodes=</span>{</span>},n.wat</span>erfal</span>l([fu</span>n<span class="fstat-no" title="function not covered" >ct</span>ion(e){n.forEach<span class="cstat-no" title="statement not covered" >(i,<span class="cstat-no" title="statement not covered" ></span>function(<span class="fstat-no" title="function not covered" >e,</span>t,r){n.ha<span class="cstat-no" title="statement not covered" >shFirstDeg</span>r<span class="fstat-no" title="function not covered" >ee</span>Quads(t,fu<span class="cstat-no" title="statement not covered" >nction(e,i){return e?r(e):(i in n.hashTo<span class="fstat-no" title="function not covered" >Bl</span>ankNodes?n<span class="cstat-no" title="statement not covered" >.hashToBlank<span class="fstat-no" title="function not covered" >No</span>des[i].push(t)<span class="cstat-no" title="statement not covered" >:n.hashToBlankNodes[i]=[t<span class="fstat-no" title="function not covered" >],</span>void r())})}<span class="cstat-no" title="statement not covered" >,e)},function(e){var r=Object.keys(n.hashToBlankNodes).sort();n.forEach(r,function(e,r,o){var a=n.hashToBl</span>ank</span>Nodes</span>[<span class="fstat-no" title="function not covered" >e]</span>;if(a.length&gt;1)r<span class="cstat-no" title="statement not covered" >eturn o();var s=a[0];n.canonicalIssuer.<span class="cstat-no" title="statement not covered" ></span>getId(s),del<span class="fstat-no" title="function not covered" >et</span>e i[s],delete n.hash<span class="cstat-no" title="statement not covered" >ToBlankNodes[e],t=!0,o<span class="cstat-no" title="statement not covered" ></span>()},e)}],e)},e<span class="cstat-no" title="statement not covered" >)},function(</span></span>e){va<span class="cstat-no" title="statement not covered" >r t=O<span class="cstat-no" title="statement not covered" ></span>bject.keys(n.hashToBlankNodes).sort();n.forEach(t,function(e,t,r){var i=[],o=n</span>.hash</span>ToBlan</span>kNode</span>s<span class="fstat-no" title="function not covered" >[e</span>];n.waterfall([f<span class="cstat-no" title="statement not covered" >unction(e){n.forEach(o,function(e,t,r){<span class="cstat-no" title="statement not covered" ></span>if(n.canonic<span class="fstat-no" title="function not covered" >al</span>Issuer.hasId(e))retu<span class="cstat-no" title="statement not covered" >rn </span>r(<span class="cstat-no" title="statement not covered" >);var o=new ue("_:b");<span class="cstat-no" title="statement not covered" ></span>o.getId(e),n.<span class="fstat-no" title="function not covered" >ha</span>shNDegreeQ<span class="cstat-no" title="statement not covered" >uads(e,o,fun<span class="fstat-no" title="function not covered" >ct</span>ion(e,t){retur<span class="cstat-no" title="statement not covered" >n e?r(e):(i.push(t),void r())}<span class="cstat-no" title="statement not covered" >)},e)},funct</span></span>ion(e<span class="cstat-no" title="statement not covered" >){i.sort(funct<span class="cstat-no" title="statement not covered" ></span>ion(e,t){return e.hash&lt;t.hash?-1:e<span class="fstat-no" title="function not covered" >.h</span>ash&gt;t.hash?1<span class="cstat-no" title="statement not covered" >:0}),n.forEach(i,function(e,t,r){for</span>(va</span>r i i</span>n<span class="fstat-no" title="function not covered" > e</span>.issuer.ex<span class="cstat-no" title="statement not covered" >isting)<span class="fstat-no" title="function not covered" >n.</span>canonicalIss<span class="cstat-no" title="statement not covered" >uer.getId(i);r()},e)}],r)},e)},function(e){</span>var t=[];n.wat<span class="fstat-no" title="function not covered" >er</span>fall([function<span class="cstat-no" title="statement not covered" >(e){n.forEach(n.quads,function(<span class="cstat-no" title="statement not covered" >e,r,i){n.forEachComponent(e<span class="cstat-no" title="statement not covered" >,</span></span>func</span>tion(</span>e){"bl</span>ank n</span>o<span class="fstat-no" title="function not covered" >de</span>"===e.type&amp;&amp;0!==<span class="cstat-no" title="statement not covered" >e.v<span class="cstat-no" title="statement not covered" ></span>alue.indexOf(<span class="fstat-no" title="function not covered" >n.</span>canonicalI<span class="cstat-no" title="statement not covered" >ssuer.prefix)&amp;&amp;(e.<span class="fstat-no" title="function not covered" >va</span>lue=n.canonica<span class="cstat-no" title="statement not covered" >lIssuer.getId(e.value<span class="fstat-no" title="function not covered" >))</span>}),t.push(<span class="cstat-no" title="statement not covered" >ae(e)),i()},e)},function(e){return t.sort(),"application/nquads"===n.options.format?(r=t.join(""),e()):(r=ie(t.joi</span>n("")),void e())}],e)</span>}],fu</span>n<span class="fstat-no" title="function not covered" >ct</span>ion(e){t(e<span class="cstat-no" title="statement not covered" >,r)})},n.prototype.hashFirstDegreeQuads=function(e,t){var n=this,r=n.blankNodeInfo[e];if("hash"in r)retu</span>rn t(n</span>ul<span class="fstat-no" title="function not covered" >l,</span>r.hash);va<span class="cstat-no" title="statement not covered" >r i=[],o</span>=r.</span>quads;n.forEach(o,function(t,r,o){<span class="fstat-no" title="function not covered" >va</span>r a={predicate:t.p<span class="cstat-no" title="statement not covered" >redic</span>at<span class="cstat-no" title="statement not covered" >e};n.forEachCompone<span class="cstat-no" title="statement not covered" ></span>nt(t,function(<span class="cstat-no" title="statement not covered" >t,r){a[r]=n.modifyFirst</span></span>Degre<span class="cstat-no" title="statement not covered" >eCo</span>mp<span class="cstat-no" title="statement not covered" >onent(e,<span class="cstat-no" title="statement not covered" ></span>t,r)}),i.pus<span class="fstat-no" title="function not covered" >h(</span>ae(a)),o()},function<span class="cstat-no" title="statement not covered" >(e){return e?t(e):(i.sor<span class="cstat-no" title="statement not covered" ></span>t(),r.hash=Ue.hashNQu<span class="fstat-no" title="function not covered" >ad</span>s(n.name,i),<span class="cstat-no" title="statement not covered" >void t(null,r.hash))})},n.prototype.modify</span>FirstDegreeComponent=</span>f<span class="fstat-no" title="function not covered" >un</span>ction(e,t)<span class="cstat-no" title="statement not covered" >{return"blank node"!==t.type?t:(t=te(t),t.value=t.value===e?"_:a":"_:z",t)},n</span>.pr</span>ototype.hashRelatedBlankNode=function(e,<span class="fstat-no" title="function not covered" >t,</span>n,r,i){var o<span class="cstat-no" title="statement not covered" >,a=this;a.waterfall([function(t){return a.canonicalIssuer.hasId(e)?(o=a.can</span>onicalIssuer.getId(e),t()):n.hasId<span class="fstat-no" title="function not covered" >(e</span>)?(o=n.getId(e),t()):void <span class="cstat-no" title="statement not covered" >a.has<span class="cstat-no" title="statement not covered" ></span>hFirstDegreeQ<span class="fstat-no" title="function not covered" >ua</span>ds(e,funct<span class="cstat-no" title="statement not covered" >ion(e,n){return e?t(e):(o=n,void t())})}],function(e){if(e)return i(e);var n=new Ue(a.name);return n.update(r),"g"!==r&amp;&amp;n.update(<span class="fstat-no" title="function not covered" >a.</span>getRelatedPr<span class="cstat-no" title="statement not covered" >edicate(t)),n.update(o),i(null</span>,n.</span>di<span class="fstat-no" title="function not covered" >ge</span>st())})},n<span class="cstat-no" title="statement not covered" >.prot<span class="cstat-no" title="statement not covered" >otype.getRela</span></span>tedPr<span class="cstat-no" title="statement not covered" >edicate=functio<span class="cstat-no" title="statement not covered" ></span>n(e){return"&lt;"+e.predicate.value+"&gt;"},n.prototype.hashNDegreeQuads=function(e,t,n){var r,i=this</span>,o=</span>new Ue(i.name);i.waterfall([funct<span class="fstat-no" title="function not covered" >io</span>n(n){i.cre<span class="cstat-no" title="statement not covered" >ateHashToRelated(e,t,function(e,t</span>){return e?n(e):(r=t,void n())<span class="fstat-no" title="function not covered" >})</span>},function(e){var n=Ob<span class="cstat-no" title="statement not covered" >ject.</span>ke<span class="cstat-no" title="statement not covered" >ys(r).sort();i.<span class="cstat-no" title="statement not covered" ></span>forEach(n,fun<span class="fstat-no" title="function not covered" >ct</span>ion(e,n,a)<span class="cstat-no" title="statement not covered" >{o.update(e);var s,u="",l=<span class="fstat-no" title="function not covered" >ne</span>w Pe(r[e]);i<span class="cstat-no" title="statement not covered" >.whilst(function(){return l.ha</span>sNe</span>x<span class="fstat-no" title="function not covered" >t(</span>)},function(e){v<span class="cstat-no" title="statement not covered" >ar n=l.next(),r=t.clon<span class="cstat-no" title="statement not covered" ></span>e(),o="",a=[<span class="fstat-no" title="function not covered" >];</span>i.waterfall([f<span class="cstat-no" title="statement not covered" >unction(t){i.</span>forEach<span class="cstat-no" title="statement not covered" >(n,</span>fu<span class="cstat-no" title="statement not covered" >nction(t,n,s)<span class="cstat-no" title="statement not covered" ></span>{return i<span class="fstat-no" title="function not covered" >.c</span>anonicalI<span class="cstat-no" title="statement not covered" >ssuer.hasId(t)?o+=i.</span>c<span class="fstat-no" title="function not covered" >an</span>onicalIssuer.get<span class="cstat-no" title="statement not covered" >Id(t):(r.</span>ha<span class="cstat-no" title="statement not covered" >sId(t)||a.</span>pu<span class="cstat-no" title="statement not covered" >sh(</span>t)<span class="cstat-no" title="statement not covered" >,o+<span class="cstat-no" title="statement not covered" ></span>=r.getId(t)),<span class="fstat-no" title="function not covered" >0!</span>==u.length<span class="cstat-no" title="statement not covered" >&amp;&amp;o.length&gt;=<span class="fstat-no" title="function not covered" >u.</span>length&amp;&amp;o&gt;u?e(<span class="cstat-no" title="statement not covered" >):void s()},t)},function(t){i.forEach(a,function(t,n,a){i.hashNDegreeQuads(t,r,function(n,i){return n?a(n):(o+=r.getId(t),o+="&lt;"+i.hash+"&gt;",r=i.issuer,0!=</span>=u.le</span>n<span class="fstat-no" title="function not covered" >gt</span>h&amp;&amp;o.lengt<span class="cstat-no" title="statement not covered" >h&gt;=u.length&amp;<span class="fstat-no" title="function not covered" >&amp;o</span>&gt;u?e():void a(<span class="cstat-no" title="statement not covered" >))})},t)},function(e){(<span class="fstat-no" title="function not covered" >0=</span>==u.length||<span class="cstat-no" title="statement not covered" >o&lt;u)&amp;&amp;(u=o,s=r),e()}],e)},function(e){return e?a(e):(o.update(u),t=s,void a())})},e)}],function(e){n(e,{hash:o.</span>dig</span>est()</span>,<span class="fstat-no" title="function not covered" >is</span>suer:t})})<span class="cstat-no" title="statement not covered" >},n.prototype.createHashToRelated=fu</span>nction</span>(<span class="fstat-no" title="function not covered" >e,</span>n,r){var i<span class="cstat-no" title="statement not covered" >=this,o={},a=i.blankNodeInfo[e].quads;i.fo</span>rEa</span>ch(a,</span>fu<span class="fstat-no" title="function not covered" >nc</span>tion(r,a,s<span class="cstat-no" title="statement not covered" >){i.forEach(r,function(a,s,u){if(</span>"pr</span>edicate"===s||"blank node"!==a.ty<span class="fstat-no" title="function not covered" >pe</span>||a.value===e)return<span class="cstat-no" title="statement not covered" > u();</span>va<span class="cstat-no" title="statement not covered" >r l</span>=a<span class="cstat-no" title="statement not covered" >.value,c=t[s];i.hashRelat<span class="cstat-no" title="statement not covered" ></span>edBlankNode(<span class="fstat-no" title="function not covered" >l,</span>r,n,c,function<span class="cstat-no" title="statement not covered" >(e,t){return<span class="fstat-no" title="function not covered" > e</span>?u(e):(t in o?<span class="cstat-no" title="statement not covered" >o[t].push(l):o[t]=[l],void u())})},s)},function(e){r(e,<span class="cstat-no" title="statement not covered" >o)})},n.prot</span></span>otype<span class="cstat-no" title="statement not covered" >.forEach</span>Co<span class="cstat-no" title="statement not covered" >mpone<span class="cstat-no" title="statement not covered" ></span>nt=function(e,t){for(var n in e<span class="fstat-no" title="function not covered" >)"</span>predicate"!=<span class="cstat-no" title="statement not covered" >=n&amp;&amp;t(e[n],n,e)},n}(),De=function(){var e=function(e){L</span>e.c</span>all(t</span>h<span class="fstat-no" title="function not covered" >is</span>,e),this.n<span class="cstat-no" title="statement not covered" >ame="URG</span>NA2</span>012"};return e.prototype=new L<span class="fstat-no" title="function not covered" >e,</span>e.prototype.<span class="cstat-no" title="statement not covered" >modifyFirstDegr<span class="cstat-no" title="statement not covered" >eeComponent=function(e,t,n){re</span></span>turn</span>"bl</span>ank<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" > n</span>ode"!==t.type?t<span class="cstat-no" title="statement not covered" >:(t=te(t),"name"===n?t.value="_:g"<span class="fstat-no" title="function not covered" >:t</span>.valu<span class="cstat-no" title="statement not covered" >e=t.value===e?"_:a":"_:z",t)},e.prototype</span>.<span class="cstat-no" title="statement not covered" ></span>getRelatedPredicate=function(e){return e.predicate.value},e.prototy<span class="fstat-no" title="function not covered" >pe</span>.createHashToR<span class="cstat-no" title="statement not covered" >elated=function(e,t,n){var r=this,i={},o=r.blankNodeInfo[e].quads;r.forEach(o,function(n,o,a){var s,</span>u;if("blank node"===n.subject.typ<span class="fstat-no" title="function not covered" >e&amp;</span>&amp;n.subject<span class="cstat-no" title="statement not covered" >.value!==e)u=n.subject.val</span>ue,s="p";else{if("blank node"!==n<span class="fstat-no" title="function not covered" >.o</span>bject.type||n.object<span class="cstat-no" title="statement not covered" >.valu</span>e=<span class="cstat-no" title="statement not covered" >==e</span>)r<span class="cstat-no" title="statement not covered" >eturn a();u=n.object.valu<span class="cstat-no" title="statement not covered" ></span>e,s="r"}r.ha<span class="fstat-no" title="function not covered" >sh</span>RelatedBlankNode(u,n,t<span class="cstat-no" title="statement not covered" >,s,function(e,t){t in i?i[t].push(u):i[t]=[u],a()})},f<span class="cstat-no" title="statement not covered" >unction(e){n(e,i)})},e}()</span>;Obj<span class="cstat-no" title="statement not covered" >ect.keys||(Object.keys=function(e){if(e!==Object(e))<span class="cstat-no" title="statement not covered" >throw new T<span class="cstat-no" title="statement not covered" >y</span></span>peError("Object.keys ca<span class="cstat-no" title="statement not covered" ></span>l</span>led on non-object");var t=[];f<span class="fstat-no" title="function not covered" >or</span>(var n in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.ca</span>ll(</span>e<span class="fstat-no" title="function not covered" >,n</span>)&amp;&amp;t.push(<span class="cstat-no" title="statement not covered" >n);retur</span>n t</span>}),e</span>.re<span class="cstat-no" title="statement not covered" ></span>gisterRDFParser("applicati<span class="fstat-no" title="function not covered" >on</span>/nquads",i<span class="cstat-no" title="statement not covered" >e),e.registerRDFP<span class="cstat-no" title="statement not covered" >arser("rdfa-api",se),e.IdentifierIssuer=ue,e.UniqueNamer=</span></span>ue,ue<span class="cstat-no" title="statement not covered" >.pr<span class="cstat-no" title="statement not covered" ></span>ototype.clone=f<span class="cstat-no" title="statement not covered" >unction(){var e=new ue(this.prefix);return e.counter=<span class="cstat-no" title="statement not covered" >t</span></span>his.count</span>er,e.existing=te(this.existing),e},ue.prototype.getId=function(e){if(e&amp;&amp;e in this.existing)return this.existing[e];var t=this.prefix+this.co<span class="fstat-no" title="function not covered" >un</span>ter;return this<span class="cstat-no" title="statement not covered" >.counter+=1,e&amp;&amp;(this<span class="cstat-no" title="statement not covered" ></span>.existing[e]=t),t},ue.prototype.getName=ue.prototype.getName,u</span>e.prototype.hasId=fu<span class="fstat-no" title="function not covered" >nc</span>tion(e){re<span class="cstat-no" title="statement not covered" >turn e in this.existing},<span class="cstat-no" title="statement not covered" >ue.prototype.isNamed=ue.p</span></span>rotot<span class="cstat-no" title="statement not covered" >ype.hasId;var Pe=function<span class="cstat-no" title="statement not covered" ></span>(e){this.list=e.sort(),this.done=!1,this.left={};f</span>or(var t=0;t&lt;e.length;++t)this.left[e[t]]=!0};Pe.prototype.has<span class="fstat-no" title="function not covered" >Ne</span>xt=functio<span class="cstat-no" title="statement not covered" >n(){return!this.done},Pe.pr</span>ototype.next=function(){for(var e=this.lis</span>t.slic<span class="cstat-no" title="statement not covered" >e(),t=nul<span class="fstat-no" title="function not covered" >l,n</span>=0,<span class="cstat-no" title="statement not covered" >r=this.list.length,i=0;i&lt;r;++i){var o=this.li<span class="cstat-no" title="statement not covered" >s</span>t[i],a=this.left[o];(null=<span class="cstat-no" title="statement not covered" >==t||o&gt;t)&amp;&amp;(a&amp;&amp;i&gt;0&amp;&amp;</span></span>o<span class="cstat-no" title="statement not covered" ></span>&gt;this.list[i-1]||!a&amp;&amp;<span class="fstat-no" title="function not covered" >i&lt;</span>r-1&amp;&amp;o&gt;th<span class="cstat-no" title="statement not covered" >is.list[i+1])&amp;&amp;(t=</span>o,n=i)}if(null===t)<span class="fstat-no" title="function not covered" >th</span>is.done=!<span class="cstat-no" title="statement not covered" >0;else{var s=this.left[t]?n-1:n+1;this.list[n]=this.list[s],this.list[s]=t;fo<span class="cstat-no" title="statement not covered" >r(var i=0;i&lt;r</span>;+<span class="cstat-no" title="statement not covered" >+i)this.list[<span class="cstat-no" title="statement not covered" ></span>i]&gt;t&amp;&amp;(this.left[this.list[i]]=!this.left[this.list[i]])}return e};var Ue=function(e)<span class="cstat-no" title="statement not covered" ></span>{</span>if(!(this i<span class="cstat-no" title="statement not covered" >nstanceof Ue))</span>return new<span class="cstat-no" title="statement not covered" > Ue(e);if(["URDNA2015<span class="cstat-no" title="statement not covered" ></span>","URGNA2012"].indexOf(e)===-1)throw new <span class="cstat-no" title="statement not covered" >E</span>rror("Invalid RDF D<span class="cstat-no" title="statement not covered" >ataset Normalization algorithm: "+e);Ue._init.call(this,e)};if(Ue.ha<span class="cstat-no" title="statement not covered" ></span></span>s</span>hNQuads=f</span>un</span>ction(<span class="cstat-no" title="statement not covered" >e,t){for(<span class="fstat-no" title="function not covered" >var</span> n=<span class="cstat-no" title="statement not covered" >new Ue(e),r=0;r&lt;t.length;<span class="cstat-no" title="statement not covered" >++r)n.update(t[r]<span class="cstat-no" title="statement not covered" >)</span></span>;return n.digest()},function(e){if(e){var t=<span class="cstat-no" title="statement not covered" >n(31);return Ue._init=function(e){e="URDNA2015"===e?"sha256":"sha1"<span class="cstat-no" title="statement not covered" >,</span></span>this.md=t.createHash(e</span>)<span class="cstat-no" title="statement not covered" ></span>},Ue.prototype.up<span class="fstat-no" title="function not covered" >da</span>te=function(<span class="cstat-no" title="statement not covered" >e){return this.md.update(e,"utf8")},voi<span class="cstat-no" title="statement not covered" >d(Ue.prototype.<span class="cstat-no" title="statement not covered" >d</span></span>igest=function(){r</span>e<span class="fstat-no" title="function not covered" >tu</span>rn this.md<span class="cstat-no" title="statement not covered" >.digest("hex<span class="cstat-no" title="statement not covered" >")})}U<span class="cstat-no" title="statement not covered" ></span>e._init=function<span class="fstat-no" title="function not covered" >(e</span>){e="URDNA<span class="cstat-no" title="statement not covered" >2015"===e?new o.Algorithm:new i.Algorithm,this.md=new r(e)}</span>,Ue.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.md.update(e)},Ue.prot</span>otype.digest=function(){re<span class="fstat-no" title="function not covered" >tu</span>rn this.m<span class="cstat-no" title="statement not covered" >d.digest().toHex()};var r=func</span>tio<span class="cstat-no" title="statement not covered" ></span>n</span>(e){if(!<span class="fstat-no" title="function not covered" >(t</span>his instan<span class="cstat-no" title="statement not covered" >ceof r))return new r(e);if(this._algorithm=e,!r._padding||r._padding.len</span>gth&lt;this._algorithm.b<span class="fstat-no" title="function not covered" >lo</span>ckSize){r.<span class="cstat-no" title="statement not covered" >_padding=String.fromCharCo</span>de(128);for(var t=Str<span class="fstat-no" title="function not covered" >in</span>g.fromCha<span class="cstat-no" title="statement not covered" >rCode(0),n=64;n&gt;0;)1&amp;n&amp;&amp;(r._paddi</span>ng</span>+=t),<span class="cstat-no" title="statement not covered" >n&gt;&gt;&gt;=1,n&gt;<span class="fstat-no" title="function not covered" >0&amp;</span>&amp;(t<span class="cstat-no" title="statement not covered" >+=t)}this.start()};r.pro<span class="cstat-no" title="statement not covered" >totype.start=fun<span class="cstat-no" title="statement not covered" >c</span></span>tion(){this.messageLength=0,this.fullMessageLength=[];for(var e=this._algorith<span class="cstat-no" title="statement not covered" >m.messageLengthSize/4,t=0;t&lt;e;++t)th<span class="cstat-no" title="statement not covered" >i</span>s.fullMessageLength.push(0);return this._i<span class="cstat-no" title="statement not covered" >nput=new r.ByteBuffer,this.state=this._al<span class="cstat-no" title="statement not covered" ></span></span>g</span>orithm.start(</span>)<span class="cstat-no" title="statement not covered" ></span>,this},r.prototype<span class="fstat-no" title="function not covered" >.u</span>pdate=fun<span class="cstat-no" title="statement not covered" >ction(e){e=new r.ByteBuffer(unescape(encodeURIC<span class="cstat-no" title="statement not covered" >o</span>mponent(e))),this.messageLength+=e.length();var t=e.lengt<span class="cstat-no" title="statement not covered" >h();t=[t/4294967296&gt;&gt;&gt;0,t&gt;&gt;&gt;0];<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=this.fullMessageLength.length-1;n&gt;=0;--n)this.fullMessageLength[n]+=t</span>[1],t[1]=t[0]+(this.<span class="fstat-no" title="function not covered" >fu</span>llMessageL<span class="cstat-no" title="statement not covered" >ength[n]/4294967296&gt;&gt;&gt;0),this.fullMessageLength[n]=this.fullMessageLength[n]&gt;&gt;&gt;0,t[0</span>]=t[1<span class="cstat-no" title="statement not covered" >]/429496729<span class="cstat-no" title="statement not covered" ></span>6&gt;&gt;&gt;0;for(this._input.putBy<span class="cstat-no" title="statement not covered" >t</span>es(e.bytes());this._input.length()&gt;=this._algorith<span class="cstat-no" title="statement not covered" >m.blockSize;)this.state=this._algorithm.digest(this.state,this._input);return(this._input.read&gt;2048||0===this._input.length())&amp;&amp;this._input.compact(),this},r.prototyp<span class="cstat-no" title="statement not covered" >e</span></span>.digest=function(){var e=new r.ByteBuffer;e.putBytes(this._input.bytes());var t=this<span class="cstat-no" title="statement not covered" >.fullMessageLength[this.fullMessageLength.length-1]+this._<span class="cstat-no" title="statement not covered" >a</span></span>lgorithm.messageLengthSize,n=t&amp;this._algorithm.blockSize-1;e.putBytes(r._padding.sub</span>str(0,this._algorith<span class="fstat-no" title="function not covered" >m.</span>blockSize-n));f<span class="cstat-no" title="statement not covered" >or(var i=new r.Byte<span class="cstat-no" title="statement not covered" ></span>Buffer,o=0;o&lt;this.fullMessageLeng</span>th.le<span class="cstat-no" title="statement not covered" >ngth;++o)i.putInt32(this.fullMessageLength[o]&lt;&lt;3|this.fullMessageLength[o+1]&gt;&gt;&gt;28);this._a</span>lg<span class="cstat-no" title="statement not covered" >orithm.writeMessageLength(e,i)<span class="cstat-no" title="statement not covered" ></span>;var a=this._algorithm.digest(this.state.copy(),e),s=new r.By<span class="cstat-no" title="statement not covered" >t</span>eBuffer;return a.write(s),s},r.ByteBuffer=function(e){"string"==type<span class="cstat-no" title="statement not covered" >of e?this.data=e:this.data="",this.read=0},r.ByteBuffer.prototype.putInt32<span class="cstat-no" title="statement not covered" >=</span></span>function(e){this.data+=String.fromCharCo</span>de(e&gt;<span class="cstat-no" title="statement not covered" >&gt;24&amp;255)+String.fromCharCode(e&gt;&gt;16&amp;255)+Stri</span>ng<span class="cstat-no" title="statement not covered" >.fromCharCode(e&gt;&gt;8&amp;<span class="cstat-no" title="statement not covered" ></span>255)+String.fromCharC</span>ode(255&amp;e)},r.<span class="fstat-no" title="function not covered" >By</span>teBuffer.p<span class="cstat-no" title="statement not covered" >rototype.getInt32=function(){var e=this.data.charCodeAt(t</span>his.read)&lt;&lt;24^this.data.charCodeA<span class="fstat-no" title="function not covered" >t(</span>this.read+<span class="cstat-no" title="statement not covered" >1)&lt;&lt;16^this.data.charCodeAt(this.read+2)&lt;&lt;8^this.data.charCodeAt(this.read+3);return this.read+=4,e},r.ByteBuffer.prototype.putByte</span>s=function(e){this.data+=e},r.Byt<span class="fstat-no" title="function not covered" >eB</span>uffer.prototype<span class="cstat-no" title="statement not covered" >.bytes=function(){return this.data.slice(this.read)},r.ByteBuffer.prototype.length=function(){return this.data.length-this.read},r.ByteBuffer.pro<span class="cstat-no" title="statement not covered" ></span>totype.compact=function</span>(){this.data=this.data.slice(this<span class="fstat-no" title="function not covered" >.r</span>ead),this.<span class="cstat-no" title="statement not covered" >read=0},r.Byte</span>Buffer.prototype.toHex=functio<span class="fstat-no" title="function not covered" >n(</span>){for(var<span class="cstat-no" title="statement not covered" > e="",t=this.read;t&lt;this.data.lengt</span>h;++t){var n=this.data.charCode<span class="fstat-no" title="function not covered" >At</span>(t);n&lt;16&amp;<span class="cstat-no" title="statement not covered" >&amp;(e+="0"),e+=n.toString(16)}return </span>e};var i={_w:null};i.Algorithm=f<span class="fstat-no" title="function not covered" >un</span>ction(){t<span class="cstat-no" title="statement not covered" >his.name="sha1",this.blockSize=64,this.digestLengt</span>h=20,this.messageLengthSize=8}<span class="fstat-no" title="function not covered" >,i</span>.Algorith<span class="cstat-no" title="statement not covered" >m.prototype.start=function(){return i._w||(i._w=new Arr<span class="cstat-no" title="statement not covered" >ay(80)),i._createState()<span class="cstat-no" title="statement not covered" ></span>},i.Algorithm.prototype.writeMessa<span class="cstat-no" title="statement not covered" ></span>g</span>eLength=f</span>un</span>ction<span class="cstat-no" title="statement not covered" >(e,t){e.pu<span class="cstat-no" title="statement not covered" ></span>tBytes(t.byt<span class="fstat-no" title="function not covered" >es</span>())},i.Al<span class="cstat-no" title="statement not covered" >gorithm.prototype.digest=function(e,t){for(var n,r,o,a,s,u,l,c,f=t.length(),h=i._w</span>;f&gt;=64;){for(r=e.h0,o=e.h1,a=<span class="fstat-no" title="function not covered" >e.</span>h2,s=e.h3<span class="cstat-no" title="statement not covered" >,u=e.h4,c=0;c&lt;16;++c)n=t.getInt32(),h[c]=n,l=s^o&amp;(a^</span>s),n=(r&lt;&lt;5|r&gt;&gt;&gt;27)+l+u+1518500249+n,u=s,s=<span class="fstat-no" title="function not covered" >a,</span>a=o&lt;&lt;30|o&gt;&gt;&gt;<span class="cstat-no" title="statement not covered" >2,o=r,r=n;for(;c&lt;20;++c</span>)n=h[c-3]^h[c-8]^h[c-14]^h[c-1<span class="fstat-no" title="function not covered" >6]</span>,n=n&lt;&lt;1|n&gt;&gt;&gt;<span class="cstat-no" title="statement not covered" >31,h[c]=n,l=s^o&amp;(a^s),n=(r&lt;&lt;5|r&gt;&gt;&gt;27)+l+u+1518500249<span class="cstat-no" title="statement not covered" >+n,u=s,s=a,a=o&lt;&lt;30|o&gt;&gt;&gt;2,o=r,r=n;for(;c&lt;32;++c)n=h[c<span class="cstat-no" title="statement not covered" >-3]^h[c-8]^h[c-14]^h[c-16],n=n&lt;&lt;1|n&gt;&gt;&gt;31,h[c]=n,l=o^a^s,n=(r&lt;&lt;5|r&gt;&gt;&gt;27)+l+u+1859775393+n,u=s,s=a,<span class="cstat-no" title="statement not covered" >a</span></span>=o&lt;&lt;30|o&gt;&gt;&gt;2,<span class="cstat-no" title="statement not covered" >o=r,r=n;for(;c&lt;40;++c)n=h[c-6]^h[c-16]^h[c-28]^h[c-32],n=n&lt;&lt;2|n&gt;&gt;&gt;30,h[c]=n,l=o^a^s,n=(r&lt;&lt;5|r&gt;&gt;&gt;27)+l+u+1859775393+n,u=s,s=a,a=o<span class="cstat-no" title="statement not covered" >&lt;</span></span>&lt;30|o&gt;&gt;&gt;2,o=r<span class="cstat-no" title="statement not covered" >,r=n;for(;c&lt;60;++c)n=h[c-6]^h[c-16]^h[c-28]^h[c-32],n=n&lt;&lt;2|n&gt;&gt;&gt;30,h[c]=n,l=o&amp;a|s&amp;(o^a),n=(r&lt;&lt;5|r&gt;&gt;&gt;27)+l+u+2400959708+n,u=s,<span class="cstat-no" title="statement not covered" >s</span></span>=a,a=o&lt;&lt;30|o&gt;<span class="cstat-no" title="statement not covered" >&gt;&gt;2,o=r,r=n;for(;c&lt;80;++c)n=h[c-6]^h[c-16]^h[c-28]^h[c-32],n=n&lt;&lt;2|n&gt;&gt;&gt;30,h[c]=n,l=o^a^s,n=(r&lt;&lt;5|r&gt;&gt;&gt;27)+l+u+3395469782+n,u=s,<span class="cstat-no" title="statement not covered" >s</span></span>=a,a=o&lt;&lt;30|o&gt;<span class="cstat-no" title="statement not covered" >&gt;&gt;2,o=r,r=n;e.h0=e.h0+r|0,e.h1=e.h1+o|0,e.h2=e.h2+a|0,e.h3=e.h3+s|0,e.h4=e.h4+u|0,f-=64}return e},i._createState=function(){var e={<span class="cstat-no" title="statement not covered" >h</span></span>0:1732584193,<span class="cstat-no" title="statement not covered" >h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520};return e.copy=function(){var t=i._createState();return t.h0=e.h0,t.h1<span class="cstat-no" title="statement not covered" >=</span></span>e.h1,t.h2=e.h2,t.h3=e.h3,t.h4=e.h4,t},e.write=function(t){t.putInt32(e.h0),t<span class="cstat-no" title="statement not covered" ></span>.</span>putInt32(</span>e.h1),t.putInt32<span class="fstat-no" title="function not covered" >(e</span>.h2),t.putInt32<span class="cstat-no" title="statement not covered" >(e.h3),t.putInt32(e.h4)},e};var o={_k:null,_w:null};o.Algorithm=functio<span class="cstat-no" title="statement not covered" ></span>n(){this.name=<span class="fstat-no" title="function not covered" >"s</span>ha256",this.blo<span class="cstat-no" title="statement not covered" >ckSize=64,this.di<span class="cstat-no" title="statement not covered" ></span>gestLength=32,this.messageLengthSize=8},o.Algorithm.prototyp</span>e.start=f<span class="fstat-no" title="function not covered" >un</span>ction(){re<span class="cstat-no" title="statement not covered" >turn o._k||o._init(),o._createState()},o.Algorithm.prototype.writeMessageLength=functi</span>on(e</span>,t</span>){e.p<span class="cstat-no" title="statement not covered" >utBytes(t.bytes())<span class="cstat-no" title="statement not covered" ></span>},o.Algorith<span class="fstat-no" title="function not covered" >m.</span>prototype<span class="cstat-no" title="statement not covered" >.digest=function(e,t){for(var n,r,i,a,s,u,l,c,f,h,d,p,v,g,y,m=t.length(),b=o._k,w=o.</span>_w;m&gt;=64;){for(l=0;l&lt;16;++l)w<span class="fstat-no" title="function not covered" >[l</span>]=t.getIn<span class="cstat-no" title="statement not covered" >t32();for(;l&lt;64;++l)n=w[l-2],n=(n&gt;&gt;&gt;17|n&lt;</span>&lt;15)^(n&gt;&gt;&gt;19|n&lt;&lt;13)^n&gt;&gt;&gt;10,r=w[l-15],r=(r&gt;<span class="fstat-no" title="function not covered" >&gt;&gt;</span>7|r&lt;&lt;25)^(r&gt;<span class="cstat-no" title="statement not covered" >&gt;&gt;18|r&lt;&lt;14)^r&gt;&gt;&gt;3,w[l]=</span>n+w[l-7]+r+w[l-16]|0;for(c=e.h<span class="fstat-no" title="function not covered" >0,</span>f=e.h1,h=e.h<span class="cstat-no" title="statement not covered" >2,d=e.h3,p=e.h4,v=e.h5,g=e.h6,y=e.h7,l=0;l&lt;64;++l)a=(p&gt;&gt;&gt;6|p&lt;&lt;26)^(p&gt;&gt;&gt;11<span class="cstat-no" title="statement not covered" >|p&lt;&lt;21)^(p&gt;&gt;&gt;25|p<span class="cstat-no" title="statement not covered" >&lt;&lt;7),s=g^p&amp;(v^g),i<span class="cstat-no" title="statement not covered" >=</span></span>(c&gt;&gt;&gt;2|c&lt;&lt;30)<span class="cstat-no" title="statement not covered" >^(c&gt;&gt;&gt;13|c&lt;&lt;19)^(c&gt;&gt;&gt;22|c&lt;&lt;10),u=c&amp;f|h&amp;(c^f),n=y+a+s+b[l]+w[l],r=i+u,y=g,g=v,v=p,p=d+n|0,d=h,h=f,f=c,c=n+r|0;e.h0=e.h0+c|<span class="cstat-no" title="statement not covered" >0</span></span>,e.h1=e.h1+f|0,e.h2=e.h2+h|0,e.h3=e.h3+d|0,e.h4=e.h4+p|0,e.h5=e.h5+v|0,e<span class="cstat-no" title="statement not covered" >.h6=e.h6+g|0,e.h7=e.h7+y|0,m-=64}return e},o._createState=function(){var e={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:15414<span class="cstat-no" title="statement not covered" >5</span></span>9225};return e.copy=function(){var t=o._createState();return t.h0=e.h0,t.h1=e.h1,t.h2=e.h2,t.h3=e.h3,t.h4=e.h4,t.h5=e.<span class="cstat-no" title="statement not covered" ></span>h</span>5,t.h6=e.</span>h6,t.h7=e.h7,t},<span class="fstat-no" title="function not covered" >e.</span>write=function(<span class="cstat-no" title="statement not covered" >t){t.putInt32(e.h0),t.putInt32(e.h1),t.putInt32(e.h2),t.putInt32(e.h3),t.putInt32(e.h4),t.putInt32(e.h5),t.putInt<span class="cstat-no" title="statement not covered" ></span>32(e.h6),t.put<span class="fstat-no" title="function not covered" >In</span>t32(e.h7)},e},o<span class="cstat-no" title="statement not covered" >._init=function()<span class="cstat-no" title="statement not covered" ></span>{o._k=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763</span>221,36243<span class="fstat-no" title="function not covered" >81</span>080,310598<span class="cstat-no" title="statement not covered" >401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,15550</span>8169</span>2,1996064<span class="fstat-no" title="function not covered" >98</span>6,2554220<span class="cstat-no" title="statement not covered" >882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],o._w=new Array(64)}}(l),!pe)var Me=function(){pe=n(31).XMLSerializer};if(e.url={},e.url.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","author</span>it</span>y","auth","user<span class="cstat-no" title="statement not covered" >","passwo<span class="fstat-no" title="function not covered" >rd"</span>,"<span class="cstat-no" title="statement not covered" >hostname","port","path",</span>"<span class="cstat-no" title="statement not covered" ></span>d</span>irectory","file","query","fragment"],regex:/^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},e.url.parse=function(t,n){for(var r={},i=e.url.parsers[n||"full"],o=i.regex.exec(t),a=i.keys.length;a--;)r[i.keys[a]]=void 0===o[a]?null:o[a];return r.normalizedPath=le(r.path,!!r.authority),r},l?e.useDocumentLoader("node"):"undefined"!=typeof XMLHttpRequest&amp;&amp;e.useDocumentLoader("xhr"),l)<span class="fstat-no" title="function not covered" >{e</span>.use=functio<span class="cstat-no" title="statement not covered" >n(t){switch(t){case"request":e.request=n(31);break;default:throw new Ce("Unknow<span class="cstat-no" title="statement not covered" >n extension.","jsonld.UnknownExtensio<span class="cstat-no" title="statement not covered" >n</span></span>",{extension:t})}};var qe={exports:{},filename:u};n</span>(31)(qe,"version"),e.version=qe.exports.version}return e},h=function(){return f(function(){return<span class="cstat-no" title="statement not covered" > h()})<span class="fstat-no" title="function not covered" >};</span>return!l&amp;&amp;<span class="cstat-no" title="statement not covered" >n(32)?(r=[],i=function()<span class="cstat-no" title="statement not covered" >{return f(h),h}.<span class="cstat-no" title="statement not covered" >a</span>pply(t</span>,r),!(v<span class="cstat-no" title="statement not covered" >oid 0!==i&amp;&amp;(e.exports=i))):(f(h),"undefined"!=typeof e&amp;&amp;e.exports&amp;&amp;(e.export</span>s</span>=h</span>),c&amp;&amp;(<span class="cstat-no" title="statement not covered" >"undefined"==typeof json<span class="cstat-no" title="statement not covered" ></span>ld?jsonld=jsonldjs=h:jsonldjs=h)),h}()}).call(t,n(<span class="cstat-no" title="statement not covered" ></span>2</span>4),functi</span>on(<span class="cstat-no" title="statement not covered" >){return <span class="fstat-no" title="function not covered" >th</span>is<span class="cstat-no" title="statement not covered" >}(),n(25)<span class="fstat-no" title="function not covered" >.s</span>etImmedia<span class="cstat-no" title="statement not covered" >te,"/")},fun</span>cti</span>o<span class="cstat-no" title="statement not covered" ></span>n(e,t,n){var r;(function<span class="fstat-no" title="function not covered" >(e</span>,i,o,a){/<span class="cstat-no" title="statement not covered" >*!<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span>
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   2.3.0
	 */
<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){"use strict";function <span class="fstat-no" title="function not covered" >s(</span>e){<span class="cstat-no" title="statement not covered" >return"function"==typeof e||"object"==typeof e&amp;&amp;null!==e}f</span>unction u<span class="fstat-no" title="function not covered" >(e</span>){r<span class="cstat-no" title="statement not covered" >eturn"function"==typeof e}fu</span>nction l(<span class="fstat-no" title="function not covered" >e)</span>{re<span class="cstat-no" title="statement not covered" >turn"object"==typeof e&amp;&amp;null!==e}fun</span>ction c(e<span class="fstat-no" title="function not covered" >){</span>G=e<span class="cstat-no" title="statement not covered" >}func</span>tion f(e)<span class="fstat-no" title="function not covered" >{K</span>=e}<span class="cstat-no" title="statement not covered" >funct</span>ion h(){v<span class="fstat-no" title="function not covered" >ar</span> t=e.nex<span class="cstat-no" title="statement not covered" >tTick,n=e.v</span>er<span class="cstat-no" title="statement not covered" >sions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);retur<span class="cstat-no" title="statement not covered" ></span>n Array.isArray(n)&amp;&amp;"0"===n[1]&amp;&amp;"10"===n[2]&amp;&amp;(t=i),funct<span class="fstat-no" title="function not covered" >io</span>n(){t(y)}<span class="cstat-no" title="statement not covered" >}funct</span>io</span>n d(){ret<span class="fstat-no" title="function not covered" >ur</span>n <span class="cstat-no" title="statement not covered" >functio<span class="fstat-no" title="function not covered" >n(</span>){J(y)}}f<span class="cstat-no" title="statement not covered" >unctio</span>n </span>p(){var e<span class="fstat-no" title="function not covered" >=0</span>,t=new t<span class="cstat-no" title="statement not covered" >e(</span>y)<span class="cstat-no" title="statement not covered" >,n=documen</span>t.<span class="cstat-no" title="statement not covered" >createTextNode("");return t.<span class="cstat-no" title="statement not covered" ></span>observe(n,{characterData:!0}),function(<span class="fstat-no" title="function not covered" >){</span>n.data=e=<span class="cstat-no" title="statement not covered" >++e%2}}function </span>v(</span>){var e=n<span class="fstat-no" title="function not covered" >ew</span> Message<span class="cstat-no" title="statement not covered" >Channel;return e.port<span class="cstat-no" title="statement not covered" ></span>1.onmessage=y,function(){e.<span class="fstat-no" title="function not covered" >po</span>rt2.postM<span class="cstat-no" title="statement not covered" >essage(0)}}function g(){</span>re</span>turn func<span class="fstat-no" title="function not covered" >ti</span>on<span class="cstat-no" title="statement not covered" >(){setT<span class="fstat-no" title="function not covered" >im</span>eout(y,1)<span class="cstat-no" title="statement not covered" >}}function y(){fo</span>r(</span>var e=0;e<span class="fstat-no" title="function not covered" >&lt;Q</span>;e<span class="cstat-no" title="statement not covered" >+=2){var t=ie[e],n=ie[e+1];t<span class="cstat-no" title="statement not covered" >(n),ie</span>[e<span class="cstat-no" title="statement not covered" >]=void 0<span class="cstat-no" title="statement not covered" ></span>,ie[e+1]=void 0}Q=0}function m(){t<span class="cstat-no" title="statement not covered" ></span>r</span>y{va</span>r e=n(29)<span class="fstat-no" title="function not covered" >;r</span>et<span class="cstat-no" title="statement not covered" >urn J=e.ru<span class="cstat-no" title="statement not covered" >nOnLoo<span class="cstat-no" title="statement not covered" ></span>p||e.runOnContext,d()}catch(e){return g()}</span>}function<span class="cstat-no" title="statement not covered" > b(){}functi</span>o</span>n w(){ret<span class="fstat-no" title="function not covered" >ur</span>n new TypeEr<span class="fstat-no" title="function not covered" >ro</span>r(<span class="cstat-no" title="statement not covered" >"You cannot resolve a promise with itself")}function x(){return ne</span>w TypeErr<span class="fstat-no" title="function not covered" >or</span>("<span class="cstat-no" title="statement not covered" >A promises callback cannot return that same promise.")}function _(e){try{retur</span>n e.then}<span class="fstat-no" title="function not covered" >ca</span>tch<span class="cstat-no" title="statement not covered" >(e){<span class="cstat-no" title="statement not covered" >return ue.error</span>=e,ue}}fu<span class="cstat-no" title="statement not covered" >nction k(e,t,n,r){try{</span>e</span>.call(t,n<span class="fstat-no" title="function not covered" >,r</span>)}catch(e<span class="cstat-no" title="statement not covered" >){re<span class="cstat-no" title="statement not covered" >turn e}}functio</span>n T(e,t,n<span class="cstat-no" title="statement not covered" >){K(functi</span>o</span>n(e){var <span class="fstat-no" title="function not covered" >r=</span>!1,i=k(<span class="cstat-no" title="statement not covered" >n,<span class="fstat-no" title="function not covered" >t,</span>function(n){r||(<span class="cstat-no" title="statement not covered" >r=!</span>0,<span class="cstat-no" title="statement not covered" >t!==n?<span class="fstat-no" title="function not covered" >N(</span>e,n):j(e,n<span class="cstat-no" title="statement not covered" >))},function(t){r||(r=!0,O(e,t)</span>)<span class="fstat-no" title="function not covered" >},</span>"Settle: "<span class="cstat-no" title="statement not covered" >+(e._label||" unkn</span>own promise"));!r&amp;&amp;i&amp;&amp;(r=!0,O(e,i))},e)}func<span class="cstat-no" title="statement not covered" ></span>tion E(e,t){t._state==</span>=ae?j</span>(e,t._res<span class="fstat-no" title="function not covered" >ul</span>t):t.<span class="cstat-no" title="statement not covered" >_state===se?O(e,t._result):I(t,void 0,function(t){N(e,t)},function(t)<span class="fstat-no" title="function not covered" >{O</span>(e,t)})}fu<span class="cstat-no" title="statement not covered" >nction S</span>(<span class="fstat-no" title="function not covered" >e,</span>t){if(t.co<span class="cstat-no" title="statement not covered" >nstructo</span>r==</span>=e.constr<span class="fstat-no" title="function not covered" >uc</span>tor)E<span class="cstat-no" title="statement not covered" >(e,t);else{var n=_(t);n===ue?O(e,<span class="cstat-no" title="statement not covered" >ue.error</span>):void 0==<span class="cstat-no" title="statement not covered" >=n?j(<span class="cstat-no" title="statement not covered" ></span>e,t):u(n)?T(e,t,n):j(e,t)}}function N(e,t){e===t?O(e,w()):s(t</span>)</span>?S(e,t):j<span class="fstat-no" title="function not covered" >(e</span>,t)}f<span class="cstat-no" title="statement not covered" >unction R(e){e._onerror&amp;&amp;e._onerror</span>(e._resul<span class="fstat-no" title="function not covered" >t)</span>,C(<span class="cstat-no" title="statement not covered" >e)}function j(e,t){e._state===oe&amp;&amp;(e._re</span>sult=t,e.<span class="fstat-no" title="function not covered" >_s</span>tate=<span class="cstat-no" title="statement not covered" >ae,0!==e._subscribers.length&amp;&amp;K(C,e))}function O(e,t){e._state===oe&amp;&amp;(e._sta</span>te=se,e._<span class="fstat-no" title="function not covered" >re</span>sult=<span class="cstat-no" title="statement not covered" >t,K(R,e))}function I(e,t,n,r){var i=e._subscriber</span>s,o=i.len<span class="fstat-no" title="function not covered" >gt</span>h;e._onerror=nu<span class="cstat-no" title="statement not covered" >ll,i[o]=t,i[o+a</span>e]<span class="cstat-no" title="statement not covered" >=n,i[o+se<span class="cstat-no" title="statement not covered" ></span>]=r,0===o&amp;&amp;e._state&amp;&amp;K(C,e)}function C(e){var t=e._subscribers,n=e._</span>state;if(<span class="fstat-no" title="function not covered" >0!</span>==t.lengt<span class="cstat-no" title="statement not covered" >h){for(var r,i,</span>o=<span class="cstat-no" title="statement not covered" >e._result<span class="cstat-no" title="statement not covered" ></span>,a=0;a&lt;t.length;a<span class="cstat-no" title="statement not covered" >+=3)r=t[a],i=t[a+n],r?D(n,r,i,o):i(o);e._sub<span class="cstat-no" title="statement not covered" >scribers.length=0}}function A(){th<span class="cstat-no" title="statement not covered" >i</span></span>s.error=null}function L(</span>e</span>,t){try{r<span class="fstat-no" title="function not covered" >et</span>ur<span class="cstat-no" title="statement not covered" >n e(t)}catch(e){r</span>eturn le.<span class="fstat-no" title="function not covered" >er</span>ror=e<span class="cstat-no" title="statement not covered" >,le}<span class="cstat-no" title="statement not covered" >}function D(e</span>,t,n,r){v<span class="cstat-no" title="statement not covered" >ar i,o,a,s,l=u(n);if(l</span>)</span>{if(i=L(n<span class="fstat-no" title="function not covered" >,r</span>),i===le?(s=!0,o=i.erro<span class="cstat-no" title="statement not covered" >r,i=n<span class="cstat-no" title="statement not covered" ></span>ull):a<span class="cstat-no" title="statement not covered" >=!0,t===i)return void O(t,x())}else i=r,a=!0;t._state!<span class="cstat-no" title="statement not covered" >==oe||(l&amp;&amp;a?N(t,i):s?O</span></span>(t,o)<span class="cstat-no" title="statement not covered" >:e===ae?j<span class="cstat-no" title="statement not covered" >(</span></span>t,i):e===se&amp;&amp;O(t,i))}function P(e,t){try{t(function(t){N(e,t)},func</span>tion(t){O<span class="fstat-no" title="function not covered" >(e</span>,t)})<span class="cstat-no" title="statement not covered" >}cat<span class="cstat-no" title="statement not covered" >ch<span class="fstat-no" title="function not covered" >(t</span>){O(e,t)}}<span class="cstat-no" title="statement not covered" >function</span> <span class="fstat-no" title="function not covered" >U(</span>e,t){var n<span class="cstat-no" title="statement not covered" >=this;n.</span>_in</span>stanceCon<span class="cstat-no" title="statement not covered" >structor</span>=</span>e,n.promi<span class="fstat-no" title="function not covered" >se</span>=new e(b),n<span class="cstat-no" title="statement not covered" >._val<span class="cstat-no" title="statement not covered" ></span>idateInput(t)?(n._input=t,n.length=t.length,n._remaining=t.length,n._init(),0===n.length?j(n.promise,n._result):(n.length=n.length||0,n._enumerate(),0===n._remaining&amp;&amp;j(n.promise,n._result))):O(n.promise,n._validationError())}function M(e){return new ce(this,e).promise}functio</span>n q(e){fu<span class="fstat-no" title="function not covered" >nc</span>tio<span class="cstat-no" title="statement not covered" >n t(e){N(i,e)}function n(e){O(i</span>,e)}var r<span class="fstat-no" title="function not covered" >=t</span>his,i=new r(<span class="fstat-no" title="function not covered" >b)</span>;if<span class="cstat-no" title="statement not covered" >(!Y(e))r</span>eturn O(i<span class="fstat-no" title="function not covered" >,n</span>ew <span class="cstat-no" title="statement not covered" >TypeErro</span>r("You<span class="cstat-no" title="statement not covered" > must</span> p<span class="cstat-no" title="statement not covered" >ass an ar<span class="cstat-no" title="statement not covered" ></span>ray to ra<span class="cstat-no" title="statement not covered" >ce.")),i;for(var o=e.length,a=0;i._state===oe&amp;&amp;a&lt;o;a++)I(r.reso<span class="cstat-no" title="statement not covered" >l</span></span>ve(e[a]),void 0,t,n);return i}function F(e){v<span class="cstat-no" title="statement not covered" >ar t=this;if(e&amp;&amp;"object"==type<span class="cstat-no" title="statement not covered" >o</span></span>f e&amp;&amp;e.co</span>nstructor<span class="fstat-no" title="function not covered" >==</span>=t)return<span class="cstat-no" title="statement not covered" > e;va<span class="cstat-no" title="statement not covered" ></span>r n=new t(b);return N(n,e),n}function B(e){v<span class="cstat-no" title="statement not covered" >ar t=this,</span></span>n=new<span class="cstat-no" title="statement not covered" > t(b);ret<span class="cstat-no" title="statement not covered" ></span>urn O(n,e),n}func</span>tion H(){<span class="fstat-no" title="function not covered" >th</span>row new T<span class="cstat-no" title="statement not covered" >ypeEr</span>ro<span class="cstat-no" title="statement not covered" >r("You mu<span class="cstat-no" title="statement not covered" ></span>st pass a resolve</span>r functio<span class="fstat-no" title="function not covered" >n </span>as<span class="cstat-no" title="statement not covered" > the first argument to the promise constructor")}function z(){throw new TypeError("Failed to construct 'Pro</span>mise': Pl<span class="fstat-no" title="function not covered" >ea</span>se<span class="cstat-no" title="statement not covered" > use the 'new' operator, this object constructor cannot be called as a function.")}function V(e){this._id=ve++,this._state=void 0,this._result</span>=void 0,t<span class="fstat-no" title="function not covered" >hi</span>s._<span class="cstat-no" title="statement not covered" >subscribers=[],b!==e&amp;&amp;(u(e)||H(),this instanceof V||z(),P(this,e))}function W(){var e;if("undefined"!=typeof o)e=o;else if("und</span>efined"!=<span class="fstat-no" title="function not covered" >ty</span>peof sel<span class="cstat-no" title="statement not covered" >f)e=self;else try{e=Funct<span class="cstat-no" title="statement not covered" >ion("</span>retu<span class="cstat-no" title="statement not covered" >rn this")()}catch(e){throw n<span class="cstat-no" title="statement not covered" >ew Error</span>("po<span class="cstat-no" title="statement not covered" >lyfi<span class="cstat-no" title="statement not covered" >ll failed because global obje</span>ct is una<span class="cstat-no" title="statement not covered" >vailable in this environment")}var t=e.Promise;t&amp;&amp;"[object Promise]"===Object.prototype.toStr</span>i</span></span></span>ng.ca<span class="cstat-no" title="statement not covered" >ll(t.resol<span class="cstat-no" title="statement not covered" ></span>ve())&amp;&amp;!t.cast||(e.Promise=ge)}var X;X=Array.isArray?Array.isArray:function(e){return"[object </span>Array]<span class="cstat-no" title="statement not covered" >"===Object.prototype.toString.<span class="fstat-no" title="function not covered" >ca</span>ll(e)};var<span class="cstat-no" title="statement not covered" > J,G,$,Y=X,Q=0,K=({}.toString,function(e,t){ie[Q]=e,ie[Q+1]=</span>t,</span>Q+=2,2===Q&amp;<span class="cstat-no" title="statement not covered" >&amp;(</span>G?<span class="cstat-no" title="statement not covered" >G(</span>y):<span class="cstat-no" title="statement not covered" >$())}),Z="un<span class="fstat-no" title="function not covered" >de</span>fined"!=type<span class="cstat-no" title="statement not covered" >of window?window:void 0,ee=Z||{},te=ee.Mutat</span>i</span>onO<span class="cstat-no" title="statement not covered" >bserver||ee.WebKitMutationObserver,ne="un</span>def<span class="cstat-no" title="statement not covered" >ined"!</span>=ty<span class="cstat-no" title="statement not covered" >peof e&amp;&amp;"[object process]"==={}.toString.call(e</span>),r<span class="cstat-no" title="statement not covered" >e="undefined"!=typeof Uint8ClampedArray&amp;&amp;"undefined"!=typeof imp</span>ort<span class="cstat-no" title="statement not covered" >Scripts&amp;&amp;"undefined"!=typeof MessageChannel,ie=new Array(1e3);$=ne?h():te?p():re?v():void 0===Z?m():g();var o</span>e=v<span class="cstat-no" title="statement not covered" >oid 0,ae=1,se=2<span class="cstat-no" title="statement not covered" ></span>,ue=new A,le=new A;U.prototype._validateInp</span>ut=fun<span class="cstat-no" title="statement not covered" >ction(e</span>){r<span class="cstat-no" title="statement not covered" >et</span>urn<span class="cstat-no" title="statement not covered" > Y</span>(e)<span class="cstat-no" title="statement not covered" >},U.prot</span>oty<span class="cstat-no" title="statement not covered" >pe._vali<span class="cstat-no" title="statement not covered" ></span>dationError=function(){retu<span class="fstat-no" title="function not covered" >rn</span> new Error<span class="cstat-no" title="statement not covered" >("Array Metho</span>ds must be provided an Array")<span class="fstat-no" title="function not covered" >},</span>U.prototy<span class="cstat-no" title="statement not covered" >pe._init=function(){this._result=new Array(this.length)};var </span>ce=U;U.prototype._e<span class="fstat-no" title="function not covered" >nu</span>merate=fu<span class="cstat-no" title="statement not covered" >nction(){for(var e=this,t=e.length,n=</span>e.</span>promis<span class="cstat-no" title="statement not covered" >e,<span class="cstat-no" title="statement not covered" ></span>r=e._input,i=0;n._state<span class="fstat-no" title="function not covered" >==</span>=oe&amp;&amp;i&lt;t;<span class="cstat-no" title="statement not covered" >i++)e._eachEntry(r[i],i)},U.prototype._eachEntry=function(e,t){var n=this,r=<span class="cstat-no" title="statement not covered" >n._instanceConstructor</span></span>;l(e)?e.constructor===r&amp;<span class="fstat-no" title="function not covered" >&amp;e</span>._state!==oe?(e._o<span class="cstat-no" title="statement not covered" >nerro</span>r=<span class="cstat-no" title="statement not covered" >null,n._settledAt(e._st<span class="cstat-no" title="statement not covered" ></span>ate,t,e._result)):n._willSettleAt(r.resolve(e),t):(n._remaining--,n._result[t]=e)},U.prototype._settledAt=function(e,t,n){var r=this,i=r.promise;i._state===</span>oe&amp;&amp;(r._remaining--,e===<span class="fstat-no" title="function not covered" >se</span>?O(i,n):r._result[t]<span class="cstat-no" title="statement not covered" >=n),0</span>==<span class="cstat-no" title="statement not covered" >=r._remain<span class="cstat-no" title="statement not covered" ></span>ing&amp;&amp;j(i,r._result)},U.prototype._willSettleAt=function(e,t){var n=this;I(e,void 0,function(e){</span>n._settledAt(ae,t,e)},funct<span class="fstat-no" title="function not covered" >io</span>n(e){n._settledAt(<span class="cstat-no" title="statement not covered" >se,t,<span class="cstat-no" title="statement not covered" ></span>e)})};var f<span class="fstat-no" title="function not covered" >e=</span>M,he=q,de=<span class="cstat-no" title="statement not covered" >F,pe=B,ve=0,ge=V;V.all</span>=<span class="fstat-no" title="function not covered" >fe</span>,V.race=he<span class="cstat-no" title="statement not covered" >,V.resolve=de,V.reject</span>=pe</span>,V</span>._setS<span class="cstat-no" title="statement not covered" >ch</span>edu<span class="cstat-no" title="statement not covered" >le</span>r=c<span class="cstat-no" title="statement not covered" >,V</span>._s<span class="cstat-no" title="statement not covered" >et</span>Asa<span class="cstat-no" title="statement not covered" >p=</span>f,V<span class="cstat-no" title="statement not covered" >._<span class="cstat-no" title="statement not covered" ></span>asap=K,V.prototype={constructor:V,then:function(e,t){var n=this,r=n._state;if(r===ae&amp;&amp;!e||r===se&amp;&amp;!t)return this;var i=new this.constructor(b),o=n._res<span class="fstat-no" title="function not covered" >ult;i</span>f(r){var a=<span class="cstat-no" title="statement not covered" >argum</span>en<span class="cstat-no" title="statement not covered" >ts[r-1];K<span class="cstat-no" title="statement not covered" ></span>(function(){D(r,i,a,o)})}e<span class="cstat-no" title="statement not covered" >lse I(n,i,e,t</span></span>);ret<span class="cstat-no" title="statement not covered" >urn i},catch:function(e)</span>{r<span class="cstat-no" title="statement not covered" >eturn this<span class="cstat-no" title="statement not covered" ></span>.then(null,e<span class="cstat-no" title="statement not covered" >)}};var ye=W,me<span class="cstat-no" title="statement not covered" ></span>={<span class="fstat-no" title="function not covered" >Pr</span>omise:ge,<span class="cstat-no" title="statement not covered" >polyfill:ye}</span>;n(</span>30).a<span class="cstat-no" title="statement not covered" >md?(r=funct<span class="cstat-no" title="statement not covered" >i</span></span>on(){retu</span>rn me}.call(t,n,t,a),!(void 0!==r&amp;&amp;(a.exp<span class="fstat-no" title="function not covered" >orts=r)</span>)):<span class="cstat-no" title="statement not covered" >"undefined"!=typeof a&amp;&amp;a.e</span>xpo</span>rts?a.<span class="cstat-no" title="statement not covered" >ex</span>por<span class="cstat-no" title="statement not covered" >ts=me:"undefined"!=typeof<span class="cstat-no" title="statement not covered" ></span> this&amp;&amp;(this.<span class="fstat-no" title="function not covered" >ES</span>6Promise=<span class="cstat-no" title="statement not covered" >me),ye()}).</span>call(this)}).call(t,n(24),n(25).setImmediate,function(){return this}(),n(6)(e))},function(e,t){},function(e,t){e.exports=function(){throw new Er</span>ror("define ca</span>nnot be used indirect")}},function<span class="fstat-no" title="function not covered" >(e</span>,t){},fun<span class="cstat-no" title="statement not covered" >ction(e,t){(f</span>unction(t){e.e<span class="fstat-no" title="function not covered" >xp</span>orts=t}).call(<span class="fstat-no" title="function not covered" >t,</span>{})},functio<span class="cstat-no" title="statement not covered" >n(e,t,n){v<span class="fstat-no" title="function not covered" >ar</span> r,r;r=fu<span class="cstat-no" title="statement not covered" >nction(){};var t=e.exports={Lexer:r("./lib/N3Lexer"</span>),</span>P<span class="fstat-no" title="function not covered" >ar</span>ser:r("./lib/N<span class="fstat-no" title="function not covered" >3P</span>arser"),Writ<span class="cstat-no" title="statement not covered" >e<span class="fstat-no" title="function not covered" >r:</span>r("./lib/N<span class="cstat-no" title="statement not covered" >3Writer"),Sto</span>re:r("./lib/N3</span>S<span class="fstat-no" title="function not covered" >to</span>re"),StreamParser:r(".<span class="cstat-no" title="statement not covered" >/lib/N3StreamParser"),StreamWriter:r<span class="fstat-no" title="function not covered" >("</span>./lib</span>/N3St<span class="cstat-no" title="statement not covered" >reamWriter"),Util:r("./lib/N3Util")};Object.keys(t).forEach(function(e){Object.defineProperty(t,e,{configurable:!0,enumerable:!0,get:function(){return delete t[e],t[e]=n(34)("./N3"+e)}})})},function(e,t,n){function r(<span class="cstat-no" title="statement not covered" ></span>e){return n(i(e))}funct<span class="fstat-no" title="function not covered" >io</span>n i(e){ret<span class="cstat-no" title="statement not covered" >urn o[e]||function(){throw new Error("Cannot find module '"+e+"'.")}()}var o={"./N3Lexer":35,".<span class="fstat-no" title="function not covered" >/N3L</span>ex<span class="cstat-no" title="statement not covered" >er.js":35,"./N3Parser":36,"./N3Parser.js"</span>:36,</span>"./</span>N<span class="fstat-no" title="function not covered" >3S</span>tore":37,"./N3Store.js"<span class="fstat-no" title="function not covered" >:3</span>7,"<span class="cstat-no" title="statement not covered" >./N3StreamParser</span>":39,"./N<span class="fstat-no" title="function not covered" >3S</span>tre<span class="cstat-no" title="statement not covered" >amParser.js":<span class="fstat-no" title="function not covered" >39</span>,"./N3Str<span class="cstat-no" title="statement not covered" >eamWriter":68,"./N3StreamWriter.js":68,"./N3Util</span>":38</span>,"./N3<span class="cstat-no" title="statement not covered" >Util.js":38,"./N3Writer":69,"./N3Writer.js":69};r.keys=function(){return Object.keys(o)},r.resolve=i,e.exports=r,r.id=34},function(e,t,n){(function(t){function n(e){if(!(this instanceof n))return new n(e);if(e&amp;&amp;e.lineMode){this._tripleQuotedString=this._number=th<span class="cstat-no" title="statement not covered" ></span>is._boo<span class="fstat-no" title="function not covered" >le</span>an=/$0^/;<span class="cstat-no" title="statement not covered" >var t=this;this._tokeni</span>ze=this.tokenize,this.tokenize=fun</span>c<span class="fstat-no" title="function not covered" >ti</span>on(e,n){this._<span class="cstat-no" title="statement not covered" >t<span class="fstat-no" title="function not covered" >ok</span>enize(e,function(e,<span class="fstat-no" title="function not covered" >r)</span>{!e<span class="cstat-no" title="statement not covered" >&amp;&amp;/^(?:IRI|prefixed|lite<span class="cstat-no" title="statement not covered" >ral|langcode|typ<span class="cstat-no" title="statement not covered" >e</span></span>|\.|eof)$/.test(r<span class="cstat-no" title="statement not covered" >.type)?n&amp;&amp;n(e,r):n&amp;&amp;n(e||t._syntaxError(r.type,n=null))})}}</span>}var <span class="cstat-no" title="statement not covered" >r=Str<span class="cstat-no" title="statement not covered" ></span>ing.fromCharCode,i="function"==typeof t?t:f<span class="fstat-no" title="function not covered" >un</span>ction(e){set<span class="cstat-no" title="statement not covered" >Timeout(e,0)},o=/<span class="fstat-no" title="function not covered" >\\</span>u([a-fA-F0-9<span class="cstat-no" title="statement not covered" >]{4})|\\U([a-fA-F0-9]{8})|\\[uU]|\\(.)/g,a={"\\":"\\","'":"'",'"':'"',n:"\n",r:"\r",t:"\t",f:"\f",b:"\b",_:"_","~":"~</span>","</span>."</span>:</span>".","-<span class="cstat-no" title="statement not covered" >":"-","!":"!",$:"$",</span>"&amp;<span class="cstat-no" title="statement not covered" >":"&amp;","(":"(",")":")","<span class="fstat-no" title="function not covered" >*"</span>:"*","+":"<span class="cstat-no" title="statement not covered" >+",",":",",";":";</span>"</span>,"<span class="cstat-no" title="statement not covered" >=":"=","/":"/","?":"?","#":"#","@":"@","%":"%"},s=/[\x00</span>-\<span class="cstat-no" title="statement not covered" >x20&lt;&gt;\\"\{\}\|\^\`]/;n.prototype={_iri:/^&lt;((?:[^&gt;\\]|\\[uU])+)&gt;/,_unescapedIri:/^&lt;([^\x00-\x20&lt;&gt;\\"\{\}\|\^\`]*)&gt;/,_unescapedString:/^"[^"\\]+"(?=[^"\\])/,_singleQuotedString:/^"[^"\\]*(?:\\.[^"\\]*)*"(?=[^"\\])</span>|^<span class="cstat-no" title="statement not covered" >'[^'\\]*(?:\\.[^'\\]*)*'(?=[^<span class="cstat-no" title="statement not covered" ></span>'\\])/,_tripleQuotedString:/^""("[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*")""|^''('[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*')''/,_langcode:/^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i,_prefix:/^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s&lt;])/,_prefixed:/^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?=\.?[,;\s#()\[\]\{\}"'&lt;])/,_blank:/^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=\.?[,;:\s#()\[\]\{\}"'&lt;])/,_number:/^[\-+]?(?:\d+\.?\d*([eE](?:[\-\+])?\d+)|\d*\.?\d+)(?=[.,;:\s#()\[\]\{\}"'&lt;])/,_boolean:/^(?:true|false)(?=[.,;:\s#()\[\]\{\}"'&lt;])/,_keyword:/^@[a-z]+(?=[\s#&lt;:])/,_sparqlKeyword:/^(?:PREFIX|BASE|GRAPH)(?=[\s#&lt;:])/i,_shortPredicates:/^a(?=\s+|&lt;)/,_newline:/^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/,_whitespace:/^[ \t]+/,_endOfFile:/^(?:#[^\n\r]*)?$/,_tokenizeToEnd:function(e,t){function n(t){e(t._syntaxError(/^\S*/.exec(r)[0]))}for(var r=this._input;;){for(var i;i=this._newline.exec(r);)r=r.substr(i[0].length,r.length),this._line++;if((i=this._whitespace.exec(r))&amp;&amp;(r=r.substr(i[0].length,r.length)),this._endOfFile.<span class="fstat-no" title="function not covered" >test(r))return </span>t&amp;&amp;e(r=null,{l<span class="fstat-no" title="function not covered" >in</span>e:t<span class="cstat-no" title="statement not covered" >his._line,type:"eof",value:"",prefix:"<span class="cstat-no" title="statement not covered" ></span>"}),this._input=r;var o,a<span class="cstat-no" title="statement not covered" >=this._line,u="",l="",c="",f=r[0],h<span class="cstat-no" title="statement not covered" >=null,d=0,p=!1;switch(f){case"^":if(1===r.leng<span class="cstat-no" title="statement not covered" >t</span></span>h)break;if("^"!==r[1])return n(this);if(this._prevTokenType="^",r=r.substr(2),"&lt;"!==r[0]){p<span class="cstat-no" title="statement not covered" >=!0;break}case"&lt;":if(h=this._unescapedIri.exec(r))u="IRI",l=h[1];else if(h=this._ir</span></span>i.exec(<span class="cstat-no" title="statement not covered" >r)){if(o=th</span>is<span class="cstat-no" title="statement not covered" >._u</span>ne<span class="cstat-no" title="statement not covered" >sca</span>pe<span class="cstat-no" title="statement not covered" >(h[</span>1]<span class="cstat-no" title="statement not covered" >),nul</span>l=<span class="cstat-no" title="statement not covered" >==o||</span>s.<span class="cstat-no" title="statement not covered" >te</span>st<span class="cstat-no" title="statement not covered" >(o)<span class="cstat-no" title="statement not covered" ></span>)return n(this);u=<span class="cstat-no" title="statement not covered" >"IRI",l=o}break;<span class="cstat-no" title="statement not covered" >case"_<span class="cstat-no" title="statement not covered" >"</span></span>:((h=this._bl<span class="cstat-no" title="statement not covered" >ank.exec(r))||t<span class="cstat-no" title="statement not covered" >&amp;</span></span>&amp;(h=this._blank.exec(r+" ")))&amp;&amp;(u="prefixed",c="_",l<span class="cstat-no" title="statement not covered" >=h[1]<span class="cstat-no" title="statement not covered" >)</span>;break</span>;</span>case'"'<span class="cstat-no" title="statement not covered" >:case"'":if(h=this._unescapedStr<span class="cstat-no" title="statement not covered" >ing.exec(r))u="l</span>iter<span class="cstat-no" title="statement not covered" >al",l=h[0];else if(h=thi<span class="cstat-no" title="statement not covered" >s._singleQuotedString.exec(r)){if(o=this._unes<span class="cstat-no" title="statement not covered" >cape(h[0]),null<span class="cstat-no" title="statement not covered" >=</span></span>==o)return n<span class="cstat-no" title="statement not covered" ></span>(</span></span>this);</span>u="lite<span class="cstat-no" title="statement not covered" >ral",l=o.replace(/^'|'$/g,'"')}else if(h=this._tripleQuotedString.exec(r)){if(o=h[1]||h<span class="cstat-no" title="statement not covered" >[</span>2],thi</span>s._line+=o.spli<span class="cstat-no" title="statement not covered" >t(/\r\n|\r|\n/).length-1,o=this._un<span class="cstat-no" title="statement not covered" >escape(o),null===o)r</span>etur<span class="cstat-no" title="statement not covered" >n n(this);u="literal",l=o.replace(/^'|'<span class="cstat-no" title="statement not covered" >$/g,'"')}break;case"@":"literal"===<span class="cstat-no" title="statement not covered" >this._prevToken<span class="cstat-no" title="statement not covered" >T</span></span>ype&amp;&amp;(h=this._langcode.exec(r))?(u="la</span>ngcod<span class="cstat-no" title="statement not covered" >e",l=h[1]):(h=this._keyword.exec(r))&amp;&amp;(<span class="cstat-no" title="statement not covered" >u=h[0]);break;case".":if(1===r.length?t:r[1]&lt;"0"||r[1]&gt;"9"){u=".",d=1;break}case"0":case<span class="cstat-no" title="statement not covered" >"1":case"2":cas<span class="cstat-no" title="statement not covered" >e</span></span>"3":case"4":case"5":case"6":case"7":ca<span class="cstat-no" title="statement not covered" ></span>s</span></span></span>e"8":c</span>ase"9":<span class="cstat-no" title="statement not covered" >case"+":case"-":(h=this._number.exec(r))&amp;&amp;(u="literal",l='"'+h[0]+'"^^http://www.w3.org/2001/XMLSchema#'+(h[1]?"double<span class="cstat-no" title="statement not covered" >"</span>:/^[+\</span>-]?\d+$<span class="cstat-no" title="statement not covered" >/.test(h[0])?"integer":"decimal"));bre<span class="cstat-no" title="statement not covered" >ak;case"B"<span class="cstat-no" title="statement not covered" >:</span>case"b</span>"</span>:case"p":case"P":case"G":case"g":(h=this._sparqlKeyword.exec(r))?u=h[0].toUpperCase():p=!0;brea<span class="cstat-no" title="statement not covered" >k;case"f":case"t":(h=this._boolean.exec(r))?(u="literal",l='"'+h[0]+'"^^http://www.w3.org/2001/XMLSchema#boolean'):p=!0;break;case"a":(h=this._shortPre<span class="cstat-no" title="statement not covered" >d</span>icates</span>.exec(r))?(u="abbreviation",l="http://www.w3.or<span class="cstat-no" title="statement not covered" >g/1999/02/22-rdf-syntax-ns#type"):p=!0;break;case",":case"<span class="cstat-no" title="statement not covered" >;</span>":case</span>"[":case"]":cas<span class="cstat-no" title="statement not covered" >e"(":case")":case"{":case"}":d=1,u=f;break;default:p=!0}if(p&amp;&amp;("@prefix"!==this._prevTokenType&amp;&amp;"PREFI<span class="cstat-no" title="statement not covered" >X</span>"!==th</span>is._pre<span class="cstat-no" title="statement not covered" >vTokenType||!(h=this._prefix.exec(r))?((h=this._prefixed.exec(r))||t&amp;&amp;(h=this._prefixed.exec(r+" ")))&amp;&amp;(u="pre<span class="cstat-no" title="statement not covered" >f</span>ixed",</span>c=h[1]||"",l=this._unescape(h[2])):(u="prefix",l=h[1]||"")),"^"<span class="cstat-no" title="statement not covered" >===this.<span class="cstat-no" title="statement not covered" >_</span>prevTo</span>kenType<span class="cstat-no" title="statement not covered" >&amp;&amp;(u="<span class="cstat-no" title="statement not covered" ></span>I</span>RI"===u||"prefixed"===u?"type":""),!u)return t||!/^'''|^"""/.test(r)&amp;&amp;/\n|\r/.test(r)?n(this):this._input=r;e(null,{line:a,type:u,value:l,prefix:c}),this._prevTokenType=u,r=r.substr(d||h[0].length,r.length)}},_unescape:function(e){try{return e.replace(o,function(e,t,n,i){var o;if(t){if(o=parseInt(t,16),is<span class="cstat-no" title="statement not covered" >NaN(o))throw new Error;return r(o)}if(n){if(o=parseInt(n,16),isNaN(o))<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error;return o&lt;=65535?r(o):r(55296+(o-=65536)/1024,56320+(1023&amp;o))}var s=a[i];if(!s)throw </span>n</span>ew Error;return s})}catch(e){return null}},_s<span class="fstat-no" title="function not covered" >yntaxError</span>:fu<span class="cstat-no" title="statement not covered" >ncti<span class="cstat-no" title="statement not covered" >on(e){return this._<span class="fstat-no" title="function not covered" >in</span>put=null,new Error('Sy<span class="cstat-no" title="statement not covered" >ntax e<span class="cstat-no" title="statement not covered" >rror: unexpected "'+e+'" on l<span class="cstat-no" title="statement not covered" >ine '+this._line+"<span class="cstat-no" title="statement not covered" >.</span></span>")},tokenize<span class="cstat-no" title="statement not covered" ></span>:</span>funct<span class="cstat-no" title="statement not covered" >ion(e,t){function n(e){null!=<span class="cstat-no" title="statement not covered" >=o._input&amp;&amp;(o._inp<span class="cstat-no" title="statement not covered" >u</span></span>t+=e,o._tokenizeToEnd(t,!1))}function r(){null!==o._input&amp;&amp;o.</span>_</span>token<span class="cstat-no" title="statement not covered" >izeTo<span class="cstat-no" title="statement not covered" ></span>End(t,<span class="cstat-no" title="statement not covered" >!0)}var o=this;thi<span class="cstat-no" title="statement not covered" >s</span></span>._line=1,</span>"st</span>ring"==ty<span class="cstat-no" title="statement not covered" >peof e?(this.</span>_</span>input=e,i(function(){o._tokenizeToEnd(t,!0)})):(<span class="fstat-no" title="function not covered" >this._input="</span>",e<span class="cstat-no" title="statement not covered" >&amp;&amp;"function"!=typeof e?("function"==typeof e.setEncoding&amp;&amp;e.setEncoding("utf8"),e.on("data",n),</span>e.on("end",r)):(this.addChunk=n,this.end=r,t<span class="fstat-no" title="function not covered" >||(t=e)))</span>}},e.exports=n<span class="fstat-no" title="function not covered" >})</span>.ca<span class="cstat-no" title="statement not covered" >ll(t,n(25).setImmediate)},function(e,t,n){function r(e)</span>{if(!(thi<span class="fstat-no" title="function not covered" >s </span>in<span class="cstat-no" title="statement not covered" >stanceof r))return new r(e);this._tripleS</span>tack=[<span class="cstat-no" title="statement not covered" >],thi<span class="cstat-no" title="statement not covered" ></span>s._graph=null,e=e||{},this._setBase(e.documentIRI<span class="fstat-no" title="function not covered" >);</span>var t="st<span class="cstat-no" title="statement not covered" >ring"==typeof e.format&amp;&amp;</span>e.format.match(/\w*$/)[0].toLowerCase(),n="turtle"===t,a="trig"===t,s=/triple/.test(t),u=/quad/.test(t),l=s||u;(this._supportsNamedGraphs=!n)||(this._readPredicateOrNamed</span>Graph=this._rea</span>dPredicate),this._supportsQuad</span>s<span class="fstat-no" title="function not covered" >=!</span>(n||a||s),l&amp;&amp;(this._bas<span class="fstat-no" title="function not covered" >e=</span>"",<span class="cstat-no" title="statement not covered" >this._resolveIRI=functio<span class="cstat-no" title="statement not covered" >n(e){return this<span class="cstat-no" title="statement not covered" >.</span></span>_error("Disallowed relative IRI",e),this._callback=i,this._subject=null}),t</span>his._<span class="cstat-no" title="statement not covered" >blankNodePrefix="string"!=typeof e.blankNodePrefix?"":"_:"+e.blankN</span>od<span class="cstat-no" title="statement not covered" >ePrefix.repla</span>ce<span class="cstat-no" title="statement not covered" >(/^_:/,""),</span>th<span class="cstat-no" title="statement not covered" >is._lexer=e.lexer</span>||<span class="cstat-no" title="statement not covered" >new o({lineMode</span>:l<span class="cstat-no" title="statement not covered" >})}fu<span class="cstat-no" title="statement not covered" ></span>nction i(){}var o=n(35),a="http://www.w3.org/1999/02/22-rdf-syntax-ns#",s=a+"nil",u=a+"first",l=a+"rest",c=/^[a-z][a-z0-9+.-]*:/i,f=/^(?:([a-z][a-z0-9+.<span class="fstat-no" title="function not covered" >-]</span>*:))?(?:\/<span class="cstat-no" title="statement not covered" >\/[^\/]*)?/i,h=/(?:^|\/)\.\.?(?:$|[\/#?])/,d=0,p=0;r._resetBlankNodeIds=function(){d=</span>p=0},r.prototype={_setBase:function(e){if(e){if(e.indexOf("#")&gt;=0)throw new Error("Invalid base IRI "+e)}else e=null;(this._base=e)&amp;&amp;(this._baseP</span>ath=e.rep<span class="fstat-no" title="function not covered" >la</span>ce(/[^\/?<span class="cstat-no" title="statement not covered" >]*(?:\</span>?.<span class="cstat-no" title="statement not covered" >*)?$/,""),e=e.match(f),this._baseRoot=e[0],thi</span>s.<span class="cstat-no" title="statement not covered" >_baseSch</span>em<span class="cstat-no" title="statement not covered" >e=e[1])},_</span>re<span class="cstat-no" title="statement not covered" >adInTopCo</span>nt<span class="cstat-no" title="statement not covered" >ext:function(e){switch(</span>e.<span class="cstat-no" title="statement not covered" >type){case"eof":return null!==this._graph?thi</span>s.<span class="cstat-no" title="statement not covered" >_error("Unclosed graph",e):(</span>de<span class="cstat-no" title="statement not covered" >le</span>te<span class="cstat-no" title="statement not covered" > t<span class="cstat-no" title="statement not covered" ></span>his._prefixes._,this.<span class="fstat-no" title="function not covered" >_c</span>allback(n<span class="cstat-no" title="statement not covered" >ull,nul</span>l,this._prefixes));case"@prefix":return this._sparqlStyle<span class="fstat-no" title="function not covered" >=!1,this.</span>_re<span class="cstat-no" title="statement not covered" >adPref<span class="cstat-no" title="statement not covered" >ix;case"PREFIX":retur<span class="cstat-no" title="statement not covered" >n this._sparqlStyle=!0,this._readPrefix;</span></span>case"<span class="cstat-no" title="statement not covered" >@base":<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._sparqlStyle=!1,this._readBaseIRI;case"BASE":return this._sparqlStyle=!0,this._readBaseIRI;case"{":if(this._sup</span>portsNamedGraphs)return this._graph="",this._subject=<span class="fstat-no" title="function not covered" >null,this._readSub</span>jec<span class="cstat-no" title="statement not covered" >t;case"GRAPH":if(this._su<span class="cstat-no" title="statement not covered" >pportsNamedGraphs)return this._readNamedGraphLabel;default:return this._readSubject(e)}},_readSubject:function(e){switch(this.</span>_predicate=nu<span class="cstat-no" title="statement not covered" >ll,e.type){case"IRI":null===this._base||c.test</span>(e.value)?th<span class="cstat-no" title="statement not covered" >is._subject=e.value:this._subject=this._resolv</span>eIRI(e);bre<span class="cstat-no" title="statement not covered" >ak;case"prefixed":var t=this._prefixes[e.prefix</span>];if(void <span class="cstat-no" title="statement not covered" >0===t)return this._error('Undefined prefix "'+e</span>.prefix<span class="cstat-no" title="statement not covered" >+':"',e);this._subject=t+e.va<span class="cstat-no" title="statement not covered" >lue;break;case"[":return this._subject="_:b"+p++,this._tripl</span></span>eStack.push<span class="cstat-no" title="statement not covered" >({subject:this._subject,predi<span class="cstat-no" title="statement not covered" >cate:null,object:null,type:"blank"</span></span>}),this<span class="cstat-no" title="statement not covered" >._readBlankNodeHead;case"(":r</span>e</span>turn this._tripleStack.push({subject:s,predicate<span class="fstat-no" title="function not covered" >:null,object:</span>nul<span class="cstat-no" title="statement not covered" >l,type:"list"}),this._subject=null,this._readL<span class="cstat-no" title="statement not covered" >istItem;case"}":return this._readPunctuation(e);default:return this._error("Expected subjec<span class="cstat-no" title="statement not covered" >t</span> but g</span>ot "+e.type,e)}retur<span class="cstat-no" title="statement not covered" >n this._readPredicateOrNa<span class="cstat-no" title="statement not covered" ></span>medGraph},_rea<span class="cstat-no" title="statement not covered" >dPredicate:function(e){var t=e.type;switch(t){case"IRI":c<span class="cstat-no" title="statement not covered" >a</span></span>se"abbreviation":null==<span class="cstat-no" title="statement not covered" >=</span>this._</span>base||c<span class="cstat-no" title="statement not covered" >.test(e.value)?this._predicate=e.value:this._predicate=this._resolveIRI(e);break;case"prefixed":if("_"===e.prefix)return this._error("Disallowed</span> blank <span class="cstat-no" title="statement not covered" >node as predicate",e);var n=this._prefixes[e.prefix];if(void 0===n)return this._error('Undefined prefix "'+e.prefix+':"',</span>e);this<span class="cstat-no" title="statement not covered" >._predicate=n+e.value;break;case"</span>.":case<span class="cstat-no" title="statement not covered" >"]":case"}":return null===this._predicate?this._error("Une<span class="cstat-no" title="statement not covered" ></span>x</span>pected "+t,e):(this._subject=null,"]"==</span>=t?this._readBlankNodeTail(e):this._readPunctuatio<span class="fstat-no" title="function not covered" >n(e));case";":r</span>eturn thi<span class="cstat-no" title="statement not covered" >s._read<span class="cstat-no" title="statement not covered" ></span>Predicate;default:return this._error('E<span class="cstat-no" title="statement not covered" >xpected predicate to follow "'+this._subject+'"',e)}return this._readObject},_readObject:functi<span class="cstat-no" title="statement not covered" >o</span>n(e){s</span>witch(e.type){<span class="cstat-no" title="statement not covered" >case"IRI":null===t<span class="cstat-no" title="statement not covered" >his._base||c.test(e.value)?this._object=e.value:this._object</span></span>=this<span class="cstat-no" title="statement not covered" >._resolveIRI(e);break;cas<span class="cstat-no" title="statement not covered" ></span>e"prefixed":va<span class="cstat-no" title="statement not covered" >r t=this._prefixes[e.prefix];if(void 0===t)return this._e<span class="cstat-no" title="statement not covered" >r</span></span>ror('Undefined prefix "'+<span class="cstat-no" title="statement not covered" >e</span>.prefi</span>x+':"',e);this._object=<span class="cstat-no" title="statement not covered" >t+e.value;break;case"literal":return this._object=e.value,this._readDataTypeOrLang;case"[":var n="_:b"+p++;return this._tripleStack.push({subje</span>ct:this<span class="cstat-no" title="statement not covered" >._subject,predicate:this._pr</span>edicate<span class="cstat-no" title="statement not covered" >,object:n,type:"blank"}),this._subject=n,this._readBlankNodeHead;case"(":r<span class="cstat-no" title="statement not covered" ></span>e</span>turn this._tripleStack.p</span>ush({subject:this._subject,predicate:this._pred<span class="fstat-no" title="function not covered" >icate,object</span>:s,<span class="cstat-no" title="statement not covered" >type:"list"}),this._subje<span class="cstat-no" title="statement not covered" >ct=null,this._readListItem;default:return this._error('Expected object to follow "'+this.<span class="cstat-no" title="statement not covered" >_</span>predic</span>ate+'"',e)}return th<span class="cstat-no" title="statement not covered" >is._getTripleEndReader()}<span class="cstat-no" title="statement not covered" ></span>,_readPredicat<span class="cstat-no" title="statement not covered" >eOrNamedGraph:function(e){return"{"===e.type?this._readGr<span class="cstat-no" title="statement not covered" >a</span></span>ph(e):this._readPredic<span class="cstat-no" title="statement not covered" >a</span>te(e)}</span>,_readGraph:f<span class="cstat-no" title="statement not covered" >unction(e){return"{"!==e.type?this._error("Expected gr</span>aph but got "<span class="cstat-no" title="statement not covered" >+e.type,e)<span class="cstat-no" title="statement not covered" ></span>:(this._graph=this._subject,this._subject=null,this._readSubject)},_readBlankNodeHead:function(e){return"]"===e.type?(this._subject=null,this._r</span>eadBlan<span class="cstat-no" title="statement not covered" >kNodeTail(e)):(this._predicate=null,this._readPredicate(e))},_readBlankNodeTail:function(e){if("]"!==e.type)return this._readBlankNodePunctua</span>tion(e)<span class="cstat-no" title="statement not covered" >;null!==this._subject&amp;&amp;this._callback(null,{subject:this._subject,predica<span class="cstat-no" title="statement not covered" ></span>t</span>e:this._predicate,object:this._obj</span>ect,graph:this._graph||""});var t=this._tripleStack.pop();retu<span class="fstat-no" title="function not covered" >rn this._subject=t.subject,</span>nul<span class="cstat-no" title="statement not covered" >l!==t.object?(this._predicate=t.predicate,this._object=t.objec</span>t,this._getTripleEndReader()):null!==this._pre<span class="fstat-no" title="function not covered" >dicate?this</span>._r<span class="cstat-no" title="statement not covered" >eadPredicate:this._readPredicateOrNamedGraph},_readDataTypeOrLang:function(e){switch(e.type){case"type":var t;if(""===e.prefix)t=null</span>===this._base||c.test(e.value)?e.value:this._resolveIR<span class="fstat-no" title="function not covered" >I(e);else{var n=thi</span>s._<span class="cstat-no" title="statement not covered" >prefixes[e.prefix];if(void 0===n)return this._error('Undefined prefix "'+e.prefix+':"',e);t=n+e.value}return this.</span>_object+="^^"+t,this._getTripleEndReader();case"langco<span class="fstat-no" title="function not covered" >de":return this._ob</span>jec<span class="cstat-no" title="statement not covered" >t+="@"+e.value.t<span class="cstat-no" title="statement not covered" >oLowerCase(),this._getTripleEndReader();d<span class="cstat-no" title="statement not covered" >e</span></span>fault:return this._getTripleEndReader().call(this,e)}},_readListItem:function(e){var t=null,n=null,r=this._subject,i=this._tripleStack,</span>o=i[i<span class="cstat-no" title="statement not covered" >.length-1],a=this._readL<span class="cstat-no" title="statement not covered" ></span>istItem;switch(e.type){case"IRI":t=null===this._base||c.test(e.value)?e.value:this._resolveIRI(e);break;case"prefixed":var f=this._prefixes[e.prefix];if(void 0===f)return this._error('Undefined prefix "</span>'+e.prefix+':"',e);t=f+e.value;break;case"literal":t=e.<span class="fstat-no" title="function not covered" >value,a=this._readDa</span>taT<span class="cstat-no" title="statement not covered" >ypeOrLang;break;case"[":n="_:b"+<span class="cstat-no" title="statement not covered" >p++,t="_:b"+p++,i<span class="cstat-no" title="statement not covered" >.push({subject:n,predicate:u,object:t,type:"blank"}),this._subject</span>=t,a=this.<span class="cstat-no" title="statement not covered" >_readBlankNodeHead;break;<span class="cstat-no" title="statement not covered" ></span>case"(":n="_:b<span class="cstat-no" title="statement not covered" >"+p++,i.push({subject:n,predicate:u,object:s,type:"list"}<span class="cstat-no" title="statement not covered" >)</span></span>,this._subje<span class="cstat-no" title="statement not covered" ></span>c</span>t=null,a=this._readListItem;break;case")":if(i.pop(),0!</span>==i.length&amp;&amp;"l<span class="cstat-no" title="statement not covered" >ist"===i[i.length-1].type&amp;&amp;this._callback(null,{subject:o.subject,predicate</span>:o.pred<span class="cstat-no" title="statement not covered" >icate,object:o.object,graph:this._graph||""}),th</span>i</span>s._subject=o.subject,null===o.predicate){if(a=thi<span class="fstat-no" title="function not covered" >s._readPredica</span>te,o.subj<span class="cstat-no" title="statement not covered" >ect==</span>=s<span class="cstat-no" title="statement not covered" >)retu</span>rn<span class="cstat-no" title="statement not covered" > a}else if(thi</span>s.<span class="cstat-no" title="statement not covered" >_predicate=o.predi</span>ca<span class="cstat-no" title="statement not covered" >te,this._objec</span>t=<span class="cstat-no" title="statement not covered" >o.object,a=this._ge<span class="cstat-no" title="statement not covered" ></span>tTripleEndReader(),o.obje<span class="cstat-no" title="statement not covered" >ct===s)return a;n=s;break;default:return this._error('Expected li<span class="cstat-no" title="statement not covered" >s</span>t item</span> instead of "'+e.typ<span class="cstat-no" title="statement not covered" >e+'"',e)}return null===n&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(this._subjec<span class="cstat-no" title="statement not covered" >t=n="_:b"+p++),null===r?o.object===s?o.object=n:o.subject<span class="cstat-no" title="statement not covered" >=</span></span>n:this._cal<span class="cstat-no" title="statement not covered" >l</span>back(n</span>ull,{subject:<span class="cstat-no" title="statement not covered" >r,predicate:l,object:n,graph:this._gr<span class="cstat-no" title="statement not covered" >a</span>ph||""</span>}),null<span class="cstat-no" title="statement not covered" >!==t&amp;&amp;this._callback(null,{subject:n,predicate:u,object:t,graph:this._graph||""}),a},_readPunctuation:function(e){var t,<span class="cstat-no" title="statement not covered" >n</span>=this.</span>_subjec<span class="cstat-no" title="statement not covered" >t,r=this._graph;switch(e.type){case"}":if(null===this._graph)return this._error("Unexpected graph closing<span class="cstat-no" title="statement not covered" >"</span>,e);th</span>is._gra<span class="cstat-no" title="statement not covered" >ph=null;case".":this._subject=null,t=this._readInTopContext;break;case";":t=this._readPredicate;break;case",":t=this._readObject;break;case"IRI":if(this._supportsQuads&amp;&amp;null===this._graph){r=null===t<span class="cstat-no" title="statement not covered" >his._base||c.test(e.value)?e.value:this<span class="cstat-no" title="statement not covered" >._resolveI</span></span>RI(e)<span class="cstat-no" title="statement not covered" >,n=this._subject,t=this._readQuadPunctuation;break}case"prefixed":if(this._supportsQuads&amp;&amp;null=<span class="cstat-no" title="statement not covered" >==this._g<span class="cstat-no" title="statement not covered" >r</span></span></span>aph<span class="cstat-no" title="statement not covered" >)</span>{var i</span>=this._<span class="cstat-no" title="statement not covered" >prefixes[e.prefix];if(void 0===i)return this._error('Undefined prefi<span class="cstat-no" title="statement not covered" ></span>x</span> "'+e.prefix+':"',e);r=i+e.value,t=this._readQuadPunctuation;break}default:return this._error('Expected punctuation to follow "'+this._object+'"',e)}return null!==n&amp;&amp;this._callback(null,{subject:n,predicate:this._predicate,object:this._object,graph:r||""</span>}),t},_readBlankNodePunctuation:function(e){var t;sw<span class="fstat-no" title="function not covered" >itch(e.type){case</span>";":t=this.<span class="cstat-no" title="statement not covered" >_readPredicate</span>;b<span class="cstat-no" title="statement not covered" >reak;case","<span class="cstat-no" title="statement not covered" ></span>:t=this._readObject;bre<span class="cstat-no" title="statement not covered" >ak;default:return this<span class="cstat-no" title="statement not covered" >._error('Expected punctuation to follow "'+this._<span class="cstat-no" title="statement not covered" >o</span></span>bject+'"',e)}retu</span>rn this<span class="cstat-no" title="statement not covered" >._callback(null,{subject:this._subject,predi<span class="cstat-no" title="statement not covered" >c</span>ate:th</span>is._pre<span class="cstat-no" title="statement not covered" >dicate,object:this._ob<span class="cstat-no" title="statement not covered" >j</span>ect,gr</span>aph:thi<span class="cstat-no" title="statement not covered" >s._graph||""}),t},_<span class="cstat-no" title="statement not covered" >r</span>eadQua</span>dPunctuat<span class="cstat-no" title="statement not covered" >ion:function(e){return"."!==e.type?this._err<span class="cstat-no" title="statement not covered" >or("Expected dot to follow quad",e):this._readInTopContext},_readPrefix:function(e){return"prefix"!==e.type?t<span class="cstat-no" title="statement not covered" >h</span>is._er</span>r</span>or("Expected p<span class="cstat-no" title="statement not covered" >refix to follow @prefix",e):(this._prefix=e.value,<span class="cstat-no" title="statement not covered" >this._readPrefixIRI)},_re<span class="cstat-no" title="statement not covered" ></span>adPrefixIRI:fu<span class="cstat-no" title="statement not covered" >nction(e){if("IRI"!==e.type)return this._error('Expected <span class="cstat-no" title="statement not covered" >I</span></span>RI to follow prefix "'+this._prefix+':"<span class="cstat-no" title="statement not covered" >'</span>,e);va</span>r</span> t;retu<span class="cstat-no" title="statement not covered" >rn t=null===this._base||c.test(e.value)?e.value:this._resolveIRI(e),this._p<span class="cstat-no" title="statement not covered" ></span>r</span>efixes[this._prefix]=t,this._prefixCallback(this._prefix,t),this._readDeclarationPunctuation},_readBaseIRI:fun</span>ction(e){if("IRI"!==e.type)return this._error("Expected IRI t<span class="fstat-no" title="function not covered" >o follow base declaration"</span>,e);try{t<span class="cstat-no" title="statement not covered" >his._setBase(null===thi<span class="cstat-no" title="statement not covered" >s._base||c.test(e.valu<span class="cstat-no" title="statement not covered" >e</span>)?e.va</span>lue:thi<span class="cstat-no" title="statement not covered" >s._resolveIRI(e))}c<span class="cstat-no" title="statement not covered" >a</span>tch(t)</span>{this._<span class="cstat-no" title="statement not covered" >error(t.message,e)}return this._readDeclarationPunctuation},_readNamedGraph<span class="cstat-no" title="statement not covered" ></span>L</span>abel:function(e){switch(e.type){case"IRI":case"prefixed":return this._readSubject(e),this._readGraph;case"[":return this._</span>readNamedGraphBlankLabel;default:return this._error("Inv<span class="fstat-no" title="function not covered" >alid graph label",e)}</span>},_<span class="cstat-no" title="statement not covered" >readNamedGraphBlankLabel:function(e){return"]"!==e.type?this._error("Invalid graph label</span>",e):(this._subject="_:b"+p++,this._readGraph)}<span class="fstat-no" title="function not covered" >,_readDeclar</span>ati<span class="cstat-no" title="statement not covered" >onPunctuation:function(e){return this._sparqlStyle?this._readInTopContext(e):"."!==e.type?this._error("Expected declara</span>tion to end with a dot",e):this._readInTopContext}<span class="fstat-no" title="function not covered" >,_getTripleEndR</span>ead<span class="cstat-no" title="statement not covered" >er:function(){var <span class="cstat-no" title="statement not covered" >e=this._tripleStack;if(0===e.length)return this._readPunctuation;switch(e[e</span></span>.leng<span class="cstat-no" title="statement not covered" >th-1].type){case"blank":return this._readBlankNodeTail;case"list":return this._readListItem}},_error:function(e,t){this._callback(new Error(e+" at line "+t.line+"."))},_resol</span>veIRI:function(e){var t=e.value;switch(t[0]){cas<span class="fstat-no" title="function not covered" >e void 0:retu</span>rn <span class="cstat-no" title="statement not covered" >this._base;case"#"<span class="cstat-no" title="statement not covered" >:return this._base+t;case"?":return this._base.replace(/(?:\?.*)<span class="cstat-no" title="statement not covered" >?</span></span>$/,<span class="cstat-no" title="statement not covered" >t);case"/":return("/"===t[1]?this._baseScheme:this._baseRoot)+this._removeDotSe</span>gments(t)<span class="cstat-no" title="statement not covered" >;default:return this._remo<span class="cstat-no" title="statement not covered" ></span>v</span>eDotSegments(this._basePath+t)}},_remove</span>DotSegments:function(e){if(!h.test(e))return e;for(var t<span class="fstat-no" title="function not covered" >="",n=e.length,r=-1,i</span>=-1<span class="cstat-no" title="statement not covered" >,o=0,a="/";r&lt;n;){switch(a){case":":if(i&lt;<span class="cstat-no" title="statement not covered" >0&amp;&amp;"/"===e[++r]&amp;&amp;"/"===e[++r])for(;(i=r+1)&lt;n&amp;</span>&amp;"/"!==<span class="cstat-no" title="statement not covered" >e[i];)r=i;break;case"?":case"#":r=n;bre</span>ak;case<span class="cstat-no" title="statement not covered" >"/":if("."===e[r+1])switch(a=e[++r+1]){case"/</span>"</span>:t+=e.substring(o,r-1),o=r+1;break;case void 0:case"?":case"#<span class="fstat-no" title="function not covered" >":return t+e.substring(o,r</span>)+e<span class="cstat-no" title="statement not covered" >.substr(r+1);case".":if(a=e[++r+1],void 0===a||"/"===a||"?"===a||"#"===a){if(t+=e.substring(o,r-2),</span>(o=t.lastIndexOf("/"))&gt;=i&amp;&amp;(t=t.substr(0,o)),"/"!==a)return t+"<span class="fstat-no" title="function not covered" >/"+e.substr(r+1);o=r+1}}}a=e</span>[++<span class="cstat-no" title="statement not covered" >r]}return t+e.substring(o)},parse:function(e,t,n){this._readCallback=this._readInTopContext,this._prefixes=Object.create(null),this._prefixes._=</span>this._blankNodePrefix||"_:b"+d++ +"_","function"==typeo<span class="fstat-no" title="function not covered" >f e&amp;&amp;(n=t,t=e,e=null</span>),this._<span class="cstat-no" title="statement not covered" >callback=t||i,this<span class="cstat-no" title="statement not covered" ></span>._prefixCallback<span class="cstat-no" title="statement not covered" >=n||i;var r=this;this._lexer.<span class="cstat-no" title="statement not covered" >t</span></span>okenize(e,function(e,t){null!==e?(r._c<span class="cstat-no" title="statement not covered" >allback(e),r._callback=i):void 0</span>!==r._read<span class="cstat-no" title="statement not covered" >Callback&amp;&amp;(r._readCallback=</span>r</span>._readCallback(t))}),e||(this.addChunk=thi<span class="fstat-no" title="function not covered" >s._lexe</span>r.add<span class="cstat-no" title="statement not covered" >Chunk,this.end=this._lexer.end)}},e.exports=r},functi</span>on(e,t,n){function r(e,t){return this instanceo<span class="fstat-no" title="function not covered" >f r?(this._s</span>ize=0,thi<span class="cstat-no" title="statement not covered" >s._graph<span class="cstat-no" title="statement not covered" ></span>s=Object.create(null),thi<span class="cstat-no" title="statement not covered" >s._entities=Object.</span>create(<span class="cstat-no" title="statement not covered" >null),this._entities[</span>"&gt;&lt;"]=0<span class="cstat-no" title="statement not covered" >,this._entityCount=0,this._blankNodeIndex=0</span>,t||!e|<span class="cstat-no" title="statement not covered" >|e[0]||(t=e,e=null),this._prefixes=Object.create(null),t&amp;&amp;t.prefixes&amp;&amp;this.addP</span>refixes<span class="cstat-no" title="statement not covered" >(t.prefixes),void(e&amp;&amp;this.addTriples(e))):new r(e,</span>t</span>)}var i=n(38).expandPrefixedName;r.prototype={get size<span class="fstat-no" title="function not covered" >(){var e=this._size</span>;if<span class="cstat-no" title="statement not covered" >(null!==e)retu<span class="cstat-no" title="statement not covered" >rn e;var <span class="cstat-no" title="statement not covered" >t</span></span>,n,r=this._graphs;for(var i in r)for(var o in t=r<span class="cstat-no" title="statement not covered" >[i].subjects)for(v<span class="cstat-no" title="statement not covered" >ar a in n=t[o])e+=Object.keys(n[a])<span class="cstat-no" title="statement not covered" >.length;return this._size=e}<span class="cstat-no" title="statement not covered" >,_ad<span class="cstat-no" title="statement not covered" >d</span></span></span>ToInde</span>x:function(e,t,<span class="cstat-no" title="statement not covered" >n,r)<span class="cstat-no" title="statement not covered" >{</span>var i=</span>e[t]||(<span class="cstat-no" title="statement not covered" >e[t]={}),o=i[n]|<span class="cstat-no" title="statement not covered" >|(i[n]={});o[r]=null},_remo<span class="cstat-no" title="statement not covered" >veFromIndex:function(e,t,n,r<span class="cstat-no" title="statement not covered" >)</span>{var i</span>,o=e[t],a=o[n];delete a[r];<span class="cstat-no" title="statement not covered" >for(i in a)return;delete o[n];for(i in o)</span>return;<span class="cstat-no" title="statement not covered" >delete e[t]},_findInIndex:function(e,t,n,r,i,o,a,s){v<span class="cstat-no" title="statement not covered" >ar u,l,c,f=[],h=Object.keys(this._entities);t&amp;&amp;((u=e,e={})[t]=u[t]);for(var d <span class="cstat-no" title="statement not covered" >in e){var p=h[d];if(l=e[d])<span class="cstat-no" title="statement not covered" >{</span></span>n&amp;&amp;((u</span>=</span>l<span class="cstat-no" title="statement not covered" ></span></span>,</span>l={})[n]=<span class="cstat-no" title="statement not covered" ></span>u</span>[n]);for(var v in l){var</span> g=h[v];if(c=l[v])for(var y=(r?r in c?[r]<span class="fstat-no" title="function not covered" >:[]:Ob</span>ject.ke<span class="cstat-no" title="statement not covered" >ys(c)),m=y.length-1;m&gt;=0;m--){var b={subject:"",predicate:"",object:"",graph:s};b[i]=p,b[o]=g,b[a]=h[y[m]],f.push(b)}}}}return f},_countInIndex:function(e,t,n,r){var i,o,a,s=0;t&amp;&amp;((i=e,e={})[t]=i[t]);for(var u in e)if(</span>o=e[u<span class="cstat-no" title="statement not covered" >]){n&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;((i=o,o={})[n]=i[n]);f<span class="fstat-no" title="function not covered" >or</span>(var l in o)<span class="cstat-no" title="statement not covered" >(a=o[l])&amp;&amp;(r?r in a&amp;&amp;s++:s+=Object.keys(a).length)}return s},addTriple:function(e,t,n,r){t||(r=e.graph,n</span>=e.object,t=e.predicate,e=e.subject),r=r||"";var i=this._graphs[r];i</span>||(i=this._grap</span>h<span class="fstat-no" title="function not covered" >s[</span>r]={subjects:{},predica<span class="fstat-no" title="function not covered" >te</span>s:{},<span class="cstat-no" title="statement not covered" >objects:{}},Object.freeze(i));var o=this._entities;e=o[e]||(o[e]=++this._entityCount),t=o[t]||(o[t]=++this._entityCount),n=o[n]||(o[n]=++this._entityCount),this._addToIndex(i.subjects,e,t,n),this._addToIndex(i.predicates,t,n,e),this._addToIndex(i.objects,n,e,t),this._size=null},addTriples:function(e){for(var t=e.lengt</span>h-1;t&gt;<span class="cstat-no" title="statement not covered" >=0;t--)this.addTriple(e[t<span class="cstat-no" title="statement not covered" ></span>])},addPrefix:function(e,t){th<span class="cstat-no" title="statement not covered" >is._prefixe<span class="cstat-no" title="statement not covered" ></span>s[e]=t},addP<span class="cstat-no" title="statement not covered" >refixes:fu</span></span>nction(e)<span class="cstat-no" title="statement not covered" >{for(var t in<span class="cstat-no" title="statement not covered" ></span> e)this.addPref<span class="cstat-no" title="statement not covered" >ix(t,e[t])},removeTriple:func<span class="cstat-no" title="statement not covered" >tion(e,t,n,r){t||(r=<span class="cstat-no" title="statement not covered" >e.graph,n=e.object,t=e.predi<span class="cstat-no" title="statement not covered" >c</span></span></span></span>ate,e=e.subject),r=r</span>||"";var i,o=this._entities,a=this._graphs;if((<span class="fstat-no" title="function not covered" >e=o[e])&amp;&amp;(t=</span>o[t])&amp;&amp;(n=o[n])<span class="cstat-no" title="statement not covered" >&amp;&amp;(i=a[r])){var </span>s,<span class="cstat-no" title="statement not covered" >u;if((s=i.subjec<span class="cstat-no" title="statement not covered" ></span>ts[e])&amp;&amp;(u=</span>s[t])&amp;&amp;n in u){this._removeFromIndex(i.subjects,e,t,<span class="fstat-no" title="function not covered" >n),this._removeFr</span>omIndex(i.predica<span class="cstat-no" title="statement not covered" >tes,t</span>,n<span class="cstat-no" title="statement not covered" >,e),t<span class="cstat-no" title="statement not covered" ></span>his._removeF<span class="cstat-no" title="statement not covered" >r</span>omIndex(i.<span class="cstat-no" title="statement not covered" >objects<span class="cstat-no" title="statement not covered" >,</span></span>n,e,t),null<span class="cstat-no" title="statement not covered" >!</span>==this._si<span class="cstat-no" title="statement not covered" >ze&amp;&amp;thi<span class="cstat-no" title="statement not covered" >s</span></span>._size--;for</span>(e in i.subjects)return;delete a[r]}}},removeTri<span class="fstat-no" title="function not covered" >ples:function</span>(e){for(var t=e.length-1;t&gt;=0<span class="cstat-no" title="statement not covered" >;t-</span>-)<span class="cstat-no" title="statement not covered" >this.removeTriple(e[t])},fin<span class="cstat-no" title="statement not covered" ></span>d:function(e,t,n,r){var <span class="cstat-no" title="statement not covered" >o</span>=this._prefixes;retur<span class="cstat-no" title="statement not covered" >n thi<span class="cstat-no" title="statement not covered" ></span>s.findByIRI<span class="cstat-no" title="statement not covered" >(i(e,o),i(t,o),i(n,o),i(<span class="cstat-no" title="statement not covered" >r</span>,o))},findByIRI:funct<span class="cstat-no" title="statement not covered" >ion(e<span class="cstat-no" title="statement not covered" ></span>,t,n,r){r=<span class="cstat-no" title="statement not covered" >r||"";var i=this._graphs[r],o=this._entities;return i?e&amp;&amp;!(e=o[e])?[]:t&amp;<span class="cstat-no" title="statement not covered" >&amp;!(t=o[t])?[]:n&amp;&amp;!(n=o[n])?[]:e?n?this._find<span class="cstat-no" title="statement not covered" ></span>InIndex(i.objects,n,e,t,"object","subj</span>e</span></span>c</span>t<span class="cstat-no" title="statement not covered" ></span>"</span>,"predica</span>te",r):this._findInIndex(i.subjects,e,t,null,"sub<span class="fstat-no" title="function not covered" >ject","predica</span>te","object",r):t?thi<span class="cstat-no" title="statement not covered" >s.<span class="cstat-no" title="statement not covered" ></span>_findInIndex(i.predicate<span class="cstat-no" title="statement not covered" >s</span>,t,n,null,"pre<span class="cstat-no" title="statement not covered" >dicate","ob<span class="cstat-no" title="statement not covered" >ject","subject",r):n?thi<span class="cstat-no" title="statement not covered" >s</span>._findInIndex(<span class="cstat-no" title="statement not covered" >i.objects,n,null,null,"object","subject","predicate"<span class="cstat-no" title="statement not covered" ></span></span>,</span></span>r):this._</span>findInIndex(i.subjects,null,null,null,"subjec<span class="fstat-no" title="function not covered" >t","predic</span>ate","obj<span class="cstat-no" title="statement not covered" >ect",r):[]},count:function(e,t,n,r){var o=this._prefixes;retu</span>rn th<span class="cstat-no" title="statement not covered" >is.countByIRI(i(<span class="cstat-no" title="statement not covered" ></span>e,o),i(t,o),i(n,o),i(r,o))},countByIRI:function(e,t,n,r){r=r||"";var i=this._gra</span>phs[r<span class="cstat-no" title="statement not covered" >],o=this._entit<span class="cstat-no" title="statement not covered" ></span>ies;return i?e&amp;&amp;!(e=o[e])?0:t&amp;&amp;!(t=o[t])?0:n&amp;&amp;!(n=o[n])?0:e?n?this._countInIndex(i.objects,n,e,t):this._countInIndex(i.subjects,e,t,n):t?this._countInIndex(i.predicates,t,n,e):this._countInIndex(i.objects,n,e,t):0},createBlankNo</span>de:function(e){var t,n;if(e)for(t=e="_:"+e,n=1<span class="fstat-no" title="function not covered" >;this._enti</span>tie<span class="cstat-no" title="statement not covered" >s[t];)t=e+n++;else do t="_:b"+<span class="cstat-no" title="statement not covered" >this._blankNodeIndex++</span></span>;while(this._entities[t]);return this._entiti<span class="fstat-no" title="function not covered" >es[t]=++th</span>is._e<span class="cstat-no" title="statement not covered" >ntityCount,t}},e.expo</span>rts=r},function(e,t){function n(e,t){for(var n <span class="fstat-no" title="function not covered" >in c)t?e.pro</span>tot<span class="cstat-no" title="statement not covered" >ype[n]=r(c[n]):<span class="cstat-no" title="statement not covered" >e[n]=c[n];return e}funct</span></span>ion r(e){return function(t){return e(this,t)}}va<span class="fstat-no" title="function not covered" >r i="http://w</span>ww.w3.org<span class="cstat-no" title="statement not covered" >/2001/XMLSchema#",o=i+"string",a=i+"integer",s=i+"decimal",u=</span>i+"bool<span class="cstat-no" title="statement not covered" >ean",l="http://</span>ww<span class="cstat-no" title="statement not covered" >w.w3.org/1999<span class="cstat-no" title="statement not covered" ></span>/02/22-rdf-syntax-ns#langString",c={isIRI:function(<span class="cstat-no" title="statement not covered" >e){if(!e)return e;var t=e[0];return'"'!=<span class="cstat-no" title="statement not covered" >=t&amp;&amp;"_"!==t},isLiteral:function(e){return e&amp;&amp;'"'===e[0]},isBlank:function(e){return e&amp;&amp;"_:"===e.substr(0,2)},getLiteralValue:function(e){var t=/^"([^]*)"<span class="cstat-no" title="statement not covered" >/</span>.exec(e);if(!t)thro<span class="cstat-no" title="statement not covered" >w new E<span class="cstat-no" title="statement not covered" >r</span></span>ror(e+" is n</span>o</span>t</span> a literal");return t[1]},getLiteralType:function<span class="fstat-no" title="function not covered" >(e){var t=/^"[</span>^]*<span class="cstat-no" title="statement not covered" >"(?:\^\^([^"]+)|(@)[^@"]+)?$/.<span class="cstat-no" title="statement not covered" >exec(e);if(!t)throw new E</span></span>rror(e+" is not a literal");return t[1]|<span class="fstat-no" title="function not covered" >|(t[2</span>]?l:o)},getLite<span class="cstat-no" title="statement not covered" >ralLanguage:fun<span class="cstat-no" title="statement not covered" ></span>ction(e){var t=/^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.ex</span>ec(e);if(!t)throw new Error(e+" is not a lite<span class="fstat-no" title="function not covered" >ral");retu</span>rn t[1]?t<span class="cstat-no" title="statement not covered" >[1].toLow</span>erCas<span class="cstat-no" title="statement not covered" >e():""},isPrefix</span>ed<span class="cstat-no" title="statement not covered" >Name:function(e<span class="cstat-no" title="statement not covered" ></span>){return e&amp;&amp;/^[^:\/"']*:[^:\/"']+$/.test(e)},expandPrefixedName:function(e,t){var n,r,i,o=/(?:^|"\^\^)([^:\/#"'\^_]*):[^\/]*$/.exec(e);return o&amp;&amp;(n=o[1],r=t[n],i=o.index),void 0===r?e:0===i?r+e.substr(n.length+1):e.substr(0,i+3)+r+e.substr(i+n.length+4)},createIRI:function(e){return e&amp;&amp;'"'===e[0]?c.getLiteralValue(e):e},createLiteral:function(e,t){if(!t)switch(typeof e){case"boolean":t=u;break;case"number":if(isFinite(e)){t=e%1===0</span>?a:s;break}default:return'"'+e+'"'}return<span class="fstat-no" title="function not covered" >'"'+e+</span>(/^[a-z]+(-[a-z<span class="cstat-no" title="statement not covered" >0-9]+)*$/i.test<span class="cstat-no" title="statement not covered" ></span>(t)?'"@'+t.toLowerCase():'"^^'+t)}};e.exports=n(n)},f</span>unction(e,t,n){function r(e){if(!(this instanc<span class="fstat-no" title="function not covered" >eof r))retu</span>rn new r(<span class="cstat-no" title="statement not covered" >e);i.call</span>(this<span class="cstat-no" title="statement not covered" >,{decodeStrings:</span>!0<span class="cstat-no" title="statement not covered" >}),this._readab<span class="cstat-no" title="statement not covered" ></span>leState.objectMode=!0;var t=this,n=new a(e);n.parse(function(e,n){n&amp;&amp;t.push(n)||e&amp;&amp;t.emit("error",e)},this.emit.bind(this,"prefix")),this._transform=function(e,t,r){n.addChunk(e),r()},this._flush=function(e){n.e</span>nd(),e()}}var i=n(40).Transform,o=n(65),a=n(36);o.i<span class="fstat-no" title="function not covered" >nherits(r,i),e.e</span>xports=r},f<span class="cstat-no" title="statement not covered" >uncti<span class="cstat-no" title="statement not covered" >on(e,t,n){function r(){i.call(this)}e.<span class="cstat-no" title="statement not covered" >exports=r</span></span>;var<span class="cstat-no" title="statement not covered" > i=<span class="cstat-no" title="statement not covered" >n(41).EventEmitter,o=n(42);o(r,i</span>),r.Readable=n(43),r.Wri<span class="cstat-no" title="statement not covered" >t</span></span>able=n(61),r.Duplex=n(62),r.Transform=n(63),r.P</span>assThrough=n(64</span>)<span class="fstat-no" title="function not covered" >,r</span>.Stream=r,r.prototype<span class="fstat-no" title="function not covered" >.p</span>ipe=f<span class="cstat-no" title="statement not covered" >unction(e,t){fu<span class="cstat-no" title="statement not covered" >nction n(t){e.writable&amp;&amp;!1===e.writ<span class="cstat-no" title="statement not covered" >e</span></span>(t)&amp;&amp;l.pa</span>use&amp;&amp;l.pa<span class="fstat-no" title="function not covered" >us</span>e()<span class="cstat-no" title="statement not covered" >}functi<span class="fstat-no" title="function not covered" >on</span> r(){l.rea<span class="cstat-no" title="statement not covered" >dable&amp;&amp;l.resume&amp;&amp;l</span>.r</span>esume(<span class="cstat-no" title="statement not covered" >)}function o(){c||(c=!0,e.end())}fun</span>ct<span class="cstat-no" title="statement not covered" >ion a(){c||</span>(c<span class="cstat-no" title="statement not covered" >=!0,"functio</span>n"<span class="cstat-no" title="statement not covered" >==typeof e.d</span>es<span class="cstat-no" title="statement not covered" >troy&amp;&amp;e.dest</span>ro<span class="cstat-no" title="statement not covered" >y())}function s(e){if(u(),0===i.listenerCount(this,"erro</span>r"<span class="cstat-no" title="statement not covered" >))throw e}function u(){l.removeListener("<span class="fstat-no" title="function not covered" >data",</span>n),<span class="cstat-no" title="statement not covered" >e.remo<span class="cstat-no" title="statement not covered" >veListener</span></span>("dra<span class="cstat-no" title="statement not covered" >in",r<span class="cstat-no" title="statement not covered" ></span>),l.removeListener("end"</span>,o),l.removeListener("close",a),l.removeListe<span class="fstat-no" title="function not covered" >ner("error</span>",s<span class="cstat-no" title="statement not covered" >),e.removeListener("er</span>ror",s),l.removeListener("end",u),l.removeL<span class="fstat-no" title="function not covered" >istener(</span>"cl<span class="cstat-no" title="statement not covered" >ose",u),e.removeListener("close"</span>,u)}var l=this;l.on("data",n),e.on("drain",r),e._is<span class="fstat-no" title="function not covered" >Stdio||t&amp;&amp;t.end=</span>==!1||(l.<span class="cstat-no" title="statement not covered" >on("end",o),l.on("cl<span class="cstat-no" title="statement not covered" ></span>ose",a<span class="cstat-no" title="statement not covered" >));var c=!1;return l.on("error",s),e.on<span class="cstat-no" title="statement not covered" >(</span></span>"error",s),l</span>.on("end",u),l.on("close",u),e.on("close",u),e.emi<span class="fstat-no" title="function not covered" >t("pipe",l),e}}</span>,function<span class="cstat-no" title="statement not covered" >(e,t){function n(){this._events=this._events|<span class="cstat-no" title="statement not covered" ></span>|{},th<span class="cstat-no" title="statement not covered" >is._maxListeners=this._maxListeners||vo<span class="cstat-no" title="statement not covered" >i</span></span>d 0}function r(e){return</span>"function"==typeof e}function i(e){return"number"==typ<span class="fstat-no" title="function not covered" >eof e}function o(e)</span>{return"o<span class="cstat-no" title="statement not covered" >bject"==typeof e&amp;&amp;null!==e}function a(e){re<span class="cstat-no" title="statement not covered" ></span>turn v<span class="cstat-no" title="statement not covered" >oid 0===e}e.exports=n,n.EventEmitter=n,<span class="cstat-no" title="statement not covered" >n</span></span>.prototype._events=void 0,n.protot</span>ype._maxListeners=void 0,n.defaultMaxListeners=10,<span class="fstat-no" title="function not covered" >n.prototype.set</span>Max<span class="cstat-no" title="statement not covered" >Listeners=function(e){if(!i(e)||e&lt;0||isNaN(</span>e))throw TypeError("n must be a positive number");<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this._maxListeners=e,this},</span>n.prototype.emit=f<span class="fstat-no" title="function not covered" >un</span>ction(e){var t,n,i,s,u,l;i<span class="cstat-no" title="statement not covered" >f(this._events||(this._events={}),"error"===e&amp;&amp;(!this._events.error||o(this._events.error)&amp;&amp;!this._events.error.length)){i<span class="cstat-no" title="statement not covered" >f(t=arguments[1],t instanceof Error)t<span class="cstat-no" title="statement not covered" >hrow t;va</span></span>r c=n<span class="cstat-no" title="statement not covered" >ew Error('Uncaught, unspecified "error" event. ('+t+")");t<span class="cstat-no" title="statement not covered" ></span>hrow c.context=t,c}if<span class="cstat-no" title="statement not covered" ></span>(</span>n=this._events[e],a(n))re<span class="cstat-no" title="statement not covered" >turn!1;if<span class="cstat-no" title="statement not covered" >(</span></span>r(n))sw<span class="cstat-no" title="statement not covered" >itch(arguments.length){case 1:n.<span class="cstat-no" title="statement not covered" >call(this);br<span class="cstat-no" title="statement not covered" >e</span>ak;cas</span>e 2:n.<span class="cstat-no" title="statement not covered" >call(this,arguments[1]);br<span class="cstat-no" title="statement not covered" >e</span>ak;cas</span>e 3:n.<span class="cstat-no" title="statement not covered" >call(this,arguments[1],arguments[2]);br<span class="cstat-no" title="statement not covered" >e</span>ak;def</span>ault:s=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments,1),n.apply(this,s)}els</span>e</span> if(<span class="cstat-no" title="statement not covered" >o(n))for<span class="cstat-no" title="statement not covered" >(s=Array.prototype.slice.call(arguments,1),l=n.slice(),i=l.length,u=0;u&lt;i;u++)l[u<span class="cstat-no" title="statement not covered" >].apply(this,s);ret<span class="cstat-no" title="statement not covered" >u</span></span></span></span>rn!0},n.p</span>rototype.addListener=func<span class="fstat-no" title="function not covered" >ti</span>on(e,t){var i;if(!<span class="cstat-no" title="statement not covered" >r(t))thro<span class="cstat-no" title="statement not covered" >w TypeError("listener must be a function");retu<span class="cstat-no" title="statement not covered" >r</span></span>n this._events||(this._events={}),this._events.newListener&amp;&amp;this.emit("newListener",e,r(t.listener)?t.listener:t),this._events[e]?o(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,o(this._events[e])&amp;&amp;!this._events[e].warned&amp;&amp;(i=a(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,i&amp;&amp;i&gt;0&amp;&amp;this._events[e].length&gt;i&amp;&amp;(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&amp;&amp;console.trace())),this},n.pr</span>ototype.on=n.prototype.addListener,n.prototype.once=funct<span class="fstat-no" title="function not covered" >io</span>n(e,t){function n(){t<span class="fstat-no" title="function not covered" >hi</span>s.<span class="cstat-no" title="statement not covered" >removeListener(e,n),i||(i=!0,t.apply(this,arguments))}if(!r(<span class="cstat-no" title="statement not covered" ></span>t))throw <span class="cstat-no" title="statement not covered" >TypeError("listener must be a function");var i=!</span></span>1;ret<span class="cstat-no" title="statement not covered" >urn<span class="cstat-no" title="statement not covered" ></span> n.listener=t,this.on(e,n),this},n.prot</span>otype.removeListener=functio<span class="fstat-no" title="function not covered" >n(</span>e,t){var n,i,a,s;if(!r(t<span class="cstat-no" title="statement not covered" >))throw T<span class="cstat-no" title="statement not covered" >ypeError("listener must be a function");if(!thi<span class="cstat-no" title="statement not covered" >s</span></span>._events||!this._events[e])return <span class="cstat-no" title="statement not covered" >this;if(n=th<span class="cstat-no" title="statement not covered" >i</span></span>s._events[e],a=n.length,i=-1,n===t||r(n.listener)&amp;&amp;n.listener===t)delete <span class="cstat-no" title="statement not covered" >this._events[e],this._events.removeListener&amp;&amp;this.emit("removeListener",e,t);else if(</span>o(n)<span class="cstat-no" title="statement not covered" >){for(s=a<span class="cstat-no" title="statement not covered" >;s-- &gt;0;)if(n[s<span class="cstat-no" title="statement not covered" >]===t||n[s].listener&amp;&amp;n[s].listener===t){i=s;br<span class="cstat-no" title="statement not covered" >eak}<span class="cstat-no" title="statement not covered" >i</span>f(i&lt;0)<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn <span class="cstat-no" title="statement not covered" >this;1===n.l<span class="cstat-no" title="statement not covered" >e</span></span>ngth?(n.length=0,delete this._events[e]):n.splice(i,1),this._events.removeListener&amp;&amp;this.emit("removeListener",e,t)}return t<span class="cstat-no" title="statement not covered" ></span>h</span></span>is},n.protot</span>ype.removeAllListeners=function(<span class="fstat-no" title="function not covered" >e)</span>{var t,n;if(!this.<span class="cstat-no" title="statement not covered" >_events)return th<span class="cstat-no" title="statement not covered" >is;if(!this.<span class="cstat-no" title="statement not covered" >_</span></span>events.removeListener)return 0=<span class="cstat-no" title="statement not covered" >==arguments.length?this._events={}:this._events[e]&amp;&amp;delete this._events[e],this;if(0===ar<span class="cstat-no" title="statement not covered" >g</span></span>uments.length){for(t in <span class="cstat-no" title="statement not covered" >this._events)"removeLi<span class="cstat-no" title="statement not covered" >stener"!==t&amp;&amp;this.removeAllListeners(t);return th<span class="cstat-no" title="statement not covered" >i</span></span>s.removeAllListeners("removeListener"),this._events={},this}if(n=this.<span class="cstat-no" title="statement not covered" ></span>_</span>events[e],r(n))this.remov<span class="cstat-no" title="statement not covered" >eListener(e,n);else if(n)f</span>or(;<span class="cstat-no" title="statement not covered" >n.len<span class="cstat-no" title="statement not covered" >gth;)this.remov<span class="cstat-no" title="statement not covered" >eListener(e,n[n.length-1]);return del<span class="cstat-no" title="statement not covered" >e</span></span></span></span>te this._events[e],this},n.prototyp</span>e.listeners=function(e)<span class="fstat-no" title="function not covered" >{v</span>ar t;return t=th<span class="cstat-no" title="statement not covered" >is._events&amp;&amp;this._events[e]?r(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.prototype</span>.listenerCount=function(e){<span class="fstat-no" title="function not covered" >if</span>(this._eve<span class="cstat-no" title="statement not covered" >nts){var t=this._events<span class="cstat-no" title="statement not covered" >[e];if(r(t))retu<span class="cstat-no" title="statement not covered" ></span>rn 1;if(<span class="cstat-no" title="statement not covered" >t)return <span class="cstat-no" title="statement not covered" >t</span></span>.len<span class="cstat-no" title="statement not covered" >gth}return 0},n.l<span class="cstat-no" title="statement not covered" ></span></span>i</span>stenerCou</span>nt=function(e,t){<span class="fstat-no" title="function not covered" >re</span>turn e.liste<span class="cstat-no" title="statement not covered" >nerCount(t)}},function(e,t)</span>{"f<span class="fstat-no" title="function not covered" >un</span>ction"==type<span class="cstat-no" title="statement not covered" >of Object.create?e.exports=function(e,t){e.<span class="fstat-no" title="function not covered" >su</span>per_=t,e.pro<span class="cstat-no" title="statement not covered" >totype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=functi</span>on(e,t){e.s<span class="fstat-no" title="function not covered" >up</span>er_=t;var n=<span class="cstat-no" title="statement not covered" >function(){}</span>;n.pr<span class="cstat-no" title="statement not covered" >ototype=t<span class="fstat-no" title="function not covered" >.p</span>roto<span class="cstat-no" title="statement not covered" ></span>type,e.prototype=new n,e.prototype.constructor=e}},function(e,t,n){(fun</span>ct</span>i<span class="fstat-no" title="function not covered" >on</span>(r){var i=func<span class="cstat-no" title="statement not covered" >t<span class="fstat-no" title="function not covered" >io</span>n(){try{return n<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(4</span>0)}catch(<span class="cstat-no" title="statement not covered" >e){}<span class="cstat-no" title="statement not covered" >}();t=e.export</span>s=n(44),t.S</span>tre<span class="cstat-no" title="statement not covered" ></span>am=i||t,t.Readable=t,t.Writable=n(56),t.Duplex=n(55),t.Transform=n(59),t.PassThrough=n(60),!r.browser&amp;&amp;"disable"===r.env.READABLE_STREAM&amp;&amp;i&amp;&amp;(e.exports=i)}).call(t,n(24))},function</span>(e,t,n){(function</span>(<span class="fstat-no" title="function not covered" >t)</span>{"use strict";<span class="cstat-no" title="statement not covered" >f<span class="fstat-no" title="function not covered" >un</span>ction r(e,t,n){return"function"=<span class="fstat-no" title="function not covered" >=t</span>ypeof e<span class="cstat-no" title="statement not covered" >.prependListener?e.prependListener(t,n):void(e._events&amp;&amp;e._events[t]?I(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n))}function i(e,t){j=j||n(55),</span>e=e||{},t<span class="fstat-no" title="function not covered" >hi</span>s.obj<span class="cstat-no" title="statement not covered" >ectMode=!!e.objectMode,t instanceof j&amp;&amp;(this.objectMode=this.objectMode||!!e.readableObjectMode);var r=e.highWaterMark,i=this</span>.obje<span class="cstat-no" title="statement not covered" >ctMode?16:16384;</span>th<span class="cstat-no" title="statement not covered" >is.highWaterMark=r||0===r<span class="cstat-no" title="statement not covered" ></span>?r:i,this.highWaterMark=~~this.highWaterMark,this.buffer=new F,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.ranOut=!1,this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&amp;&amp;(q||(q=n(58).StringDecoder),this.decoder=new q(e.encoding),this.encoding=e.encoding)}function o(e){return j=j||n(55</span>),this in<span class="fstat-no" title="function not covered" >st</span>anc<span class="cstat-no" title="statement not covered" >eof o?(this._readableState=new i(e,this),this.readable=!0,e&amp;&amp;"function"==typeof e.read&amp;&amp;(this._read=e.read),void C.call(this)):new o(e)}function a(e,t,n,r,i){var o=c(t</span>,n);if(o)<span class="fstat-no" title="function not covered" >e.</span>emit("error",o);e<span class="cstat-no" title="statement not covered" >lse if(<span class="cstat-no" title="statement not covered" ></span>null=<span class="cstat-no" title="statement not covered" >==n)t.reading=!1,f(</span>e,t)<span class="cstat-no" title="statement not covered" >;else if(t.o<span class="cstat-no" title="statement not covered" >bjectMode||n&amp;&amp;n.lengt</span>h&gt;0)<span class="cstat-no" title="statement not covered" >if(t.ended&amp;&amp;!i){var a=new Error(<span class="cstat-no" title="statement not covered" >"stream.push() after E<span class="cstat-no" title="statement not covered" >OF");e.emit("error",a)}else if(t.endE<span class="cstat-no" title="statement not covered" ></span>mitted&amp;&amp;i){var u=ne</span>w Err<span class="cstat-no" title="statement not covered" >or("stream.unshift() after<span class="cstat-no" title="statement not covered" > end event");e.emit("error",u)}else{var l;!t.d<span class="cstat-no" title="statement not covered" ></span>ecoder||i||r||(n=t.</span>decoder.wri<span class="cstat-no" title="statement not covered" >te(n),l=!t.objectMode&amp;&amp;0===n.length),i||(t.reading=!1),l||(t.flowing&amp;&amp;0===t.length&amp;&amp;!t.sync?(e.emit("data",n),e.read(0)):(t.length+=t.objectMode?1:n.length,i?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&amp;&amp;h(e))),p(e,t)}else i||(t.reading=!1);return s(t)}</span>f</span></span>uncti<span class="cstat-no" title="statement not covered" >on s(e){return!e.e<span class="cstat-no" title="statement not covered" >n</span></span></span></span>ded&amp;&amp;(e.need</span>Readable|<span class="fstat-no" title="function not covered" >|e</span>.le<span class="cstat-no" title="statement not covered" >ngth&lt;e.highWaterMark||0===e.length)}function u(e){return e&gt;=B?e=B:(e--,e|=</span>e&gt;&gt;&gt;1,e|=<span class="fstat-no" title="function not covered" >e&gt;</span>&gt;&gt;2<span class="cstat-no" title="statement not covered" >,e|=e&gt;&gt;&gt;4,e|=e&gt;&gt;&gt;8,e|=e&gt;&gt;&gt;16,e++),e}function l(e,t){return e&lt;=0||0===t.leng</span>th&amp;&amp;t.end<span class="fstat-no" title="function not covered" >ed</span>?0:t.<span class="cstat-no" title="statement not covered" >objectMode?1:e!==e?t.flowing&amp;&amp;t.length?t.buffer.head.data.length:t.length:(e&gt;t.highWaterMark&amp;&amp;(t.highWaterMark=u(e)),e&lt;=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function c(e,t){var n=null;return L.isBu</span>ffer(t)||<span class="fstat-no" title="function not covered" >"s</span>tring"==typ<span class="cstat-no" title="statement not covered" >eof t<span class="cstat-no" title="statement not covered" ></span>||null===t||void 0===t||e.objectMode||(n=new TypeError("Invalid non-string/buffer chunk")),n}function f(e,t){if(!t.ended){if(t.decoder</span>){var n=t<span class="fstat-no" title="function not covered" >.d</span>ecode<span class="cstat-no" title="statement not covered" >r.end();n&amp;&amp;n.<span class="cstat-no" title="statement not covered" >length&amp;&amp;(t.buffer.pu<span class="cstat-no" title="statement not covered" >sh(n),t.length+=<span class="cstat-no" title="statement not covered" ></span>t.objectMode?1:n.length)}t.ended=!0,h(e)}}function h(e){var t=e._re<span class="cstat-no" title="statement not covered" ></span>a</span>dableState;t.nee</span>d</span>Readable=<span class="fstat-no" title="function not covered" >!1</span>,t.emitte<span class="cstat-no" title="statement not covered" >dReadable||(M("em<span class="cstat-no" title="statement not covered" ></span>itReadable",t.flowing),t.emittedReadable=!0,t.sync?O(d,e):d(e))}function d(e){M("emit readable"),e.emit("rea</span>dable"),w<span class="fstat-no" title="function not covered" >(e</span>)}f<span class="cstat-no" title="statement not covered" >unction p(e,t){t.readingMore||(t.readingMore</span>=!0,O(v,e<span class="fstat-no" title="function not covered" >,t</span>))}fu<span class="cstat-no" title="statement not covered" >nction v(e,t){for(var n=t.length;!t.reading&amp;</span>&amp;!t.flowi<span class="fstat-no" title="function not covered" >ng</span>&amp;&amp;!t.<span class="cstat-no" title="statement not covered" >ended&amp;&amp;t.length&lt;t.highWaterMark&amp;&amp;(M("maybeReadMore read 0"),e.read(0),n!==t.length);)n=t.length;t.readingMore=!1}function g(e){retu<span class="cstat-no" title="statement not covered" >rn function<span class="cstat-no" title="statement not covered" >(</span></span>){var t=e._readab</span>leState;M<span class="fstat-no" title="function not covered" >("</span>pip<span class="cstat-no" title="statement not covered" >eOnDrai<span class="fstat-no" title="function not covered" >n"</span>,t.awaitDrain),<span class="cstat-no" title="statement not covered" >t.awaitDrain&amp;&amp;t.a<span class="cstat-no" title="statement not covered" ></span>waitDrain--,0===t.awaitDrain&amp;&amp;A(e,"data")&amp;&amp;(t.flowing=!0,w(e))}}function y(e){M("readable nexttick read 0"),e.r</span>ea</span>d(0)}func<span class="fstat-no" title="function not covered" >ti</span>on <span class="cstat-no" title="statement not covered" >m(e,t){t.resumeScheduled||(t.resumeSchedu</span>led=!0,O(<span class="fstat-no" title="function not covered" >b,</span>e,t))<span class="cstat-no" title="statement not covered" >}function b(e,t){t.reading||(M("resume read 0"),e.re</span>ad(0)),t.<span class="fstat-no" title="function not covered" >re</span>sumeS<span class="cstat-no" title="statement not covered" >cheduled=!1,t.awaitDrain=0,e.emit("resume"),w(e),t.flowing&amp;&amp;!t.reading&amp;&amp;e.read(0)}function w(e){var t=e._readableState;for(M("flow",t.</span>flowing);<span class="fstat-no" title="function not covered" >t.</span>flowing&amp;&amp;<span class="cstat-no" title="statement not covered" >null!==e.read();)<span class="cstat-no" title="statement not covered" ></span>;}function x(e,t){if(0===t.length)return null;var n;re</span>turn t.ob<span class="fstat-no" title="function not covered" >je</span>ctMod<span class="cstat-no" title="statement not covered" >e?n=t.buffer.shi<span class="cstat-no" title="statement not covered" >ft():!e||e&gt;=t</span></span>.leng<span class="cstat-no" title="statement not covered" >th?(n=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):n=_(e,t.buffer,t.decoder),n}function _(e,t,n){var r;return e&lt;t.head.data.length?(</span>r=t.head.<span class="fstat-no" title="function not covered" >da</span>ta.slice(0,e)<span class="cstat-no" title="statement not covered" >,t.head.data=t.head.data.slice(e)):r=e===t.head.data.length?t.shift():n?k(e,t):T(e,t),r}function k(e,t){var n=t.head,r=1,i=n.data;for(e-=i.len</span>gth;n=n.n<span class="fstat-no" title="function not covered" >ex</span>t;){var o=n<span class="cstat-no" title="statement not covered" >.data,a</span>=e<span class="cstat-no" title="statement not covered" >&gt;o</span>.l<span class="cstat-no" title="statement not covered" >ength?o<span class="cstat-no" title="statement not covered" ></span>.length:e;if(i+=a===o.length?o:o.<span class="cstat-no" title="statement not covered" >slice(0</span>,e<span class="cstat-no" title="statement not covered" >),e-=a,0===e){a===o.le<span class="cstat-no" title="statement not covered" ></span>ngth?(++r,n.next?t.head=n.next:t.head=t.tail=n<span class="cstat-no" title="statement not covered" >ull):(t.head=n,n.data=o.slice(a));break}++r}return t.length-=r,i}function T(e,t){var n=D<span class="cstat-no" title="statement not covered" >.</span>allocU<span class="cstat-no" title="statement not covered" ></span>n</span>safe<span class="cstat-no" title="statement not covered" ></span>(</span>e),r=t.head,i=1;for(r</span>.data.cop<span class="fstat-no" title="function not covered" >y(</span>n),e-=r.dat<span class="cstat-no" title="statement not covered" >a.length;r=r.next</span>;)<span class="cstat-no" title="statement not covered" >{var o=</span>r.<span class="cstat-no" title="statement not covered" >da<span class="cstat-no" title="statement not covered" ></span>ta,a=e&gt;o.length?o.length:e;if(o.copy(n,n.length-e,0,a<span class="cstat-no" title="statement not covered" >),e-=a,</span>0=<span class="cstat-no" title="statement not covered" >==e){a===o.length?(++i<span class="cstat-no" title="statement not covered" ></span>,r.next?t.head=r.next:t.head=t.tail=null<span class="cstat-no" title="statement not covered" >):(t.head=r,r.data=o.slice(a));break}++i}return t.length-=i,n}function E(e){var t=e._rea<span class="cstat-no" title="statement not covered" >d</span>ableSt<span class="cstat-no" title="statement not covered" ></span>a</span>te;i<span class="cstat-no" title="statement not covered" ></span>f</span>(t.length&gt;0)throw new</span> Error('"<span class="fstat-no" title="function not covered" >en</span>dReadable<span class="cstat-no" title="statement not covered" >()" called on non<span class="cstat-no" title="statement not covered" ></span>-empty stream'<span class="cstat-no" title="statement not covered" >);t.endEmitted||(t.ended=!0,O(S,t,e))}function S(e,t){e.endEmi<span class="cstat-no" title="statement not covered" >t</span></span>ted||0!==e.length||(e.endEmitted=!0,</span>t.readabl<span class="fstat-no" title="function not covered" >e=</span>!1,t.<span class="cstat-no" title="statement not covered" >emit("end"))}function N(e,t){for(var n=0,r=e.length;n&lt;r;n++)t(e[n],n)}funct</span>ion R(e,t<span class="fstat-no" title="function not covered" >){</span>for(v<span class="cstat-no" title="statement not covered" >ar n=0,r=e.length;n&lt;r;n++)if(e[<span class="cstat-no" title="statement not covered" >n]===t)retu</span></span>rn n;retu<span class="fstat-no" title="function not covered" >rn</span>-1}e.<span class="cstat-no" title="statement not covered" >exports=o;var j,O=n(45),I=n(46)<span class="cstat-no" title="statement not covered" >;o.ReadableS<span class="cstat-no" title="statement not covered" >tate=i;va<span class="cstat-no" title="statement not covered" >r</span></span></span> C,A=(n(4<span class="cstat-no" title="statement not covered" ></span>1).EventEmitt</span>er,func<span class="cstat-no" title="statement not covered" >tion(e</span>,t<span class="cstat-no" title="statement not covered" >){retu<span class="cstat-no" title="statement not covered" ></span>rn e.listeners(t).l</span>ength});<span class="cstat-no" title="statement not covered" >!function(){try{C=n<span class="fstat-no" title="function not covered" >(4</span>0)}catch(e){<span class="cstat-no" title="statement not covered" >}finally{C||(C=n(41).EventEmit</span>t</span>e<span class="cstat-no" title="statement not covered" >r<span class="fstat-no" title="function not covered" >)}</span>}();var L<span class="cstat-no" title="statement not covered" >=n(4<span class="cstat-no" title="statement not covered" >7).Buffer</span>,D=n(51),P=n(52);P<span class="cstat-no" title="statement not covered" >.inherits=n(42);var U=n(53)</span>,</span>M=vo</span>id 0;<span class="cstat-no" title="statement not covered" >M=U&amp;&amp;U.debugl</span>og<span class="cstat-no" title="statement not covered" >?U.deb</span>ug<span class="cstat-no" title="statement not covered" >log("s<span class="cstat-no" title="statement not covered" ></span>tream"):function()</span>{};va<span class="cstat-no" title="statement not covered" >r q,F=</span>n(<span class="cstat-no" title="statement not covered" >54);P.i<span class="cstat-no" title="statement not covered" ></span>nherits(o,C),o.prototype.push=functio<span class="fstat-no" title="function not covered" >n(</span>e,t){var n=t</span>his._re<span class="cstat-no" title="statement not covered" >adable<span class="cstat-no" title="statement not covered" ></span>State;return n.objectMode||"strin<span class="fstat-no" title="function not covered" >g"</span>!=typeof e||(t=t||<span class="cstat-no" title="statement not covered" >n.defaultEncoding,t!<span class="cstat-no" title="statement not covered" ></span>==n.encoding&amp;&amp;(e=D.from(e,t),t="")),a(this,n,e,t,!1)},o.prototype.unshift=function(e){var t=this._readableState;return a(</span>this,t,e,"",!0)},o.pr<span class="fstat-no" title="function not covered" >ot</span>otype.isPaused=f<span class="cstat-no" title="statement not covered" >unction(){return thi<span class="cstat-no" title="statement not covered" ></span>s._readableState.flowing==</span>=!1},o.prototype.setEn<span class="fstat-no" title="function not covered" >co</span>ding=func<span class="cstat-no" title="statement not covered" >tion(e){return q||(q=n(58).StringDecoder)</span>,this._readableState.deco<span class="fstat-no" title="function not covered" >de</span>r=new q(e)<span class="cstat-no" title="statement not covered" >,this._readableState.encoding=e,this};var B=8388608;o.prototype.read=function(e){M("read",e),e=parseInt(e,10</span>);</span>var t<span class="cstat-no" title="statement not covered" >=this._r<span class="cstat-no" title="statement not covered" ></span>eadableState,n=e;<span class="fstat-no" title="function not covered" >if</span>(0!==e&amp;&amp;(t<span class="cstat-no" title="statement not covered" >.emittedReadable=!1),0===e&amp;&amp;t.</span>needR<span class="cstat-no" title="statement not covered" >eadable&amp;&amp;(t.length&gt;=</span>t.<span class="cstat-no" title="statement not covered" >hi<span class="cstat-no" title="statement not covered" ></span>ghWaterMark||t.ended))return M("read: emitReadable",t.length,t.ended),0===t.length&amp;&amp;t.ended?E<span class="cstat-no" title="statement not covered" >(this):h(this),null;if(e=l(e,t),0===e&amp;&amp;t.ended)return 0===t.length&amp;&amp;E(this),null;var r=t.ne<span class="cstat-no" title="statement not covered" >e</span></span>dReadable;M("need readable<span class="cstat-no" title="statement not covered" >",r),(0===t.length||t.length-e&lt;t.hi</span></span>ghWat<span class="cstat-no" title="statement not covered" >erMark)&amp;&amp;(r=!0,<span class="cstat-no" title="statement not covered" ></span>M("length less than watermark",r)),t.ended||t.reading?(r=!1,M("reading or ended",r)):r&amp;&amp;(M("do read"),t.reading=!0,t.sync=!0,0===t.length&amp;&amp;(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=l(n,t)));var i;return i=e&gt;0?x(e,t):null,null===i?(t.needReadable=!0,e=0):t.length</span>-=e,0<span class="cstat-no" title="statement not covered" >===t.length&amp;&amp;(t.ended||(t.needReadable=!0),n!==e&amp;&amp;t.ended&amp;&amp;E(this)),null!==i&amp;&amp;this.emit("data",i),i},o.prototype._read=function(e){this.emit("error",new Error("_read() is n</span>ot implemented"))},<span class="fstat-no" title="function not covered" >o.</span>prototype.<span class="cstat-no" title="statement not covered" >pipe=function(e,n){function i(e){M("onunpipe"),e===h&amp;&amp;a()}fu</span>nction o(){M("onen<span class="fstat-no" title="function not covered" >d"</span>),e.end()}function a(<span class="fstat-no" title="function not covered" >){</span>M("<span class="cstat-no" title="statement not covered" >cleanup"),e.removeListener</span>("close",<span class="fstat-no" title="function not covered" >l)</span>,e<span class="cstat-no" title="statement not covered" >.removeListener("fin</span>ish",c),e<span class="fstat-no" title="function not covered" >.r</span>em<span class="cstat-no" title="statement not covered" >oveListener("drain",y),e.removeListener("error",u),e.removeListener("unpipe",i),h.removeListener("end",o),h.removeListener("end",a),h.removeListener("data",s),m=!0,!d.awaitDrain||e._writableState&amp;&amp;!e._writableState.needDrain||y()}function s(t){M("ondata"),b=!1;var n=e.write(t);!1!==n||b||((1===d.pipesCoun</span>t&amp;&amp;d.pipe<span class="fstat-no" title="function not covered" >s=</span>==e<span class="cstat-no" title="statement not covered" >||d.pipesCount&gt;1&amp;&amp;</span>R(d.p<span class="cstat-no" title="statement not covered" >ipes,e)!==-<span class="cstat-no" title="statement not covered" ></span>1)&amp;&amp;!m&amp;&amp;(M("false write response, pause",h._readableState.awaitDrain),h._readableState.awaitDrain++,b=!0),h.pause())}function u(t){M("onerror",t),f(),e.removeListener("error",u),0===A(e,"error")</span>&amp;&amp;e.emit(<span class="fstat-no" title="function not covered" >"e</span>rro<span class="cstat-no" title="statement not covered" >r",t)}function l(){e.removeListener("finish",c),f()}function c(){M("onfinish"),e.rem</span>oveListen<span class="fstat-no" title="function not covered" >er</span>("<span class="cstat-no" title="statement not covered" >close",l),f()}function f(){M("unpi</span>pe"),h.un<span class="fstat-no" title="function not covered" >pi</span>pe<span class="cstat-no" title="statement not covered" >(e)}var h=this,d=this._readableState;switch(d.p</span>ipesCount<span class="fstat-no" title="function not covered" >){</span>ca<span class="cstat-no" title="statement not covered" >se 0:d.pipes=e;break;case</span> 1:d.p<span class="cstat-no" title="statement not covered" >ipes=</span>[d<span class="cstat-no" title="statement not covered" >.pipes,e];break;defa<span class="cstat-no" title="statement not covered" ></span>ult:d.pipes.push(e)}d.pipesC<span class="cstat-no" title="statement not covered" >ount+=1,M(<span class="cstat-no" title="statement not covered" >"</span>pipe c</span>ount=%<span class="cstat-no" title="statement not covered" >d opts=%j",d.pipesCo<span class="cstat-no" title="statement not covered" >u</span>nt,n);</span>var p=(<span class="cstat-no" title="statement not covered" >!n||n.end!==!1)&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>e</span>!==t.stdout&amp;&amp;e!==t.stderr,v=p?o:a;d.endEmitted?O(v):h.once</span>("end<span class="cstat-no" title="statement not covered" >",v),e.on("unpipe",i);var y=g(h);e.on("drain"</span>,y<span class="cstat-no" title="statement not covered" >);var <span class="cstat-no" title="statement not covered" ></span>m=!1,b=!1;return h.on("data",s),r(e,"error",u),e.onc</span>e("cl<span class="cstat-no" title="statement not covered" >ose",<span class="cstat-no" title="statement not covered" ></span>l),e.once("finish</span>",c),<span class="cstat-no" title="statement not covered" >e.e</span>mi<span class="cstat-no" title="statement not covered" >t("<span class="cstat-no" title="statement not covered" ></span>pipe",h),d.flowing||(M("pipe resume"),h.resume()),e},o.prototype.unpipe=function(e){var t=this._readableState;if(0===t.pipesCount)retur</span>n this;if(1===t.pipe<span class="fstat-no" title="function not covered" >sC</span>ount)return e&amp;&amp;e<span class="cstat-no" title="statement not covered" >!==t.pipes?this:(e||<span class="cstat-no" title="statement not covered" ></span>(e=t.pipes),t.pipes=<span class="cstat-no" title="statement not covered" >null,t.pipes<span class="cstat-no" title="statement not covered" >C</span></span>ount=0,t.flowing=!1<span class="cstat-no" title="statement not covered" >,e&amp;&amp;e.emit("unpipe",this),this);if(!e){var n=t.pipes,r=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(va<span class="cstat-no" title="statement not covered" >r</span></span> i=0;i&lt;r;i++<span class="cstat-no" title="statement not covered" >)n[i].em</span>it<span class="cstat-no" title="statement not covered" >("unpipe",thi<span class="cstat-no" title="statement not covered" ></span>s);return this}var o=R(t.pipes,e);return <span class="cstat-no" title="statement not covered" >o</span>===-1?this:(t.pipes<span class="cstat-no" title="statement not covered" >.splice(o,1),t.pipesCount<span class="cstat-no" title="statement not covered" >-</span></span>=1,1===t.pip</span>e</span>sCoun<span class="cstat-no" title="statement not covered" >t&amp;&amp;(t.pipes=t<span class="cstat-no" title="statement not covered" ></span>.pipes[0]),e.emit("unpipe",this),this)},o.prototype.on=function(e,t){var n=C.prototype.on.call(this,e,t);if("data"===e)this.</span>_readableState.f<span class="fstat-no" title="function not covered" >lo</span>wing!==!1&amp;&amp;this.re<span class="cstat-no" title="statement not covered" >sume();else if("readable"===e)<span class="cstat-no" title="statement not covered" ></span>{var r=this._r<span class="cstat-no" title="statement not covered" >eadableState;r.endEmitted||r.readableListening||(</span>r.re<span class="cstat-no" title="statement not covered" >adableListening=r.needRea<span class="cstat-no" title="statement not covered" >dable=!0,r.emittedRe<span class="cstat-no" title="statement not covered" ></span>adable=!1,r.reading?r.length&amp;&amp;h(this,r):O(y,this))}return n},o.prototype.addListener=o.prototype.on,o.prototype.resume=function(){var e=t<span class="cstat-no" title="statement not covered" ></span>h</span></span>is._reada</span>bleState;return e.flowing||(M("resume"),e.flowing=!0,m(this<span class="fstat-no" title="function not covered" >,e</span>)),this},o.prot<span class="cstat-no" title="statement not covered" >otype.pause=function<span class="cstat-no" title="statement not covered" ></span>(){return M("call pause flowing=%j",this._readableState.flowi</span>ng),!1!==this._read<span class="fstat-no" title="function not covered" >ab</span>leState.f<span class="cstat-no" title="statement not covered" >lowing&amp;&amp;(M("pause"),this._readableState.flowing=!1,this.emit("pause")),this},o.prototype.wrap=function(e){var t=this._readableState,n=!1,r=this;e.on("end",function()</span>{if(M("wrapped end<span class="fstat-no" title="function not covered" >")</span>,t.decoder&amp;&amp;!t.e<span class="cstat-no" title="statement not covered" >nded){var e=t.decode</span>r.<span class="cstat-no" title="statement not covered" >end</span>()<span class="cstat-no" title="statement not covered" >;e&amp;&amp;e<span class="cstat-no" title="statement not covered" ></span>.length&amp;&amp;r.<span class="fstat-no" title="function not covered" >pu</span>sh(e)}r.p<span class="cstat-no" title="statement not covered" >ush(null)}),e.on("data",function(i){if(M("wrapp<span class="cstat-no" title="statement not covered" >ed data"),t.deco<span class="cstat-no" title="statement not covered" ></span>der&amp;&amp;(i=t.decoder.write(<span class="cstat-no" title="statement not covered" ></span>i</span>)),(!t.object</span>Mode||null!==i<span class="fstat-no" title="function not covered" >&amp;&amp;</span>void 0!==i<span class="cstat-no" title="statement not covered" >)&amp;&amp;(t.objectMode||i&amp;&amp;i.length)){var o=r.push(i);o||(n=!0,e.pause())}});for(var i in e)void 0===this[i]&amp;&amp;"function"==typeof e[i]&amp;&amp;<span class="cstat-no" title="statement not covered" >(this[i]=f<span class="cstat-no" title="statement not covered" ></span>unction(t){return fun</span>c</span>ti<span class="cstat-no" title="statement not covered" >o</span>n(){return e[t<span class="cstat-no" title="statement not covered" >].apply(e,arguments)}}(i));var o=["error","close","d<span class="fstat-no" title="function not covered" >es</span>troy","pau<span class="cstat-no" title="statement not covered" >se","re<span class="fstat-no" title="function not covered" >su</span>me"];retu<span class="cstat-no" title="statement not covered" >rn N(o,function(t){e.on(t,r.emit</span>.b</span>ind(r,</span></span>t))})<span class="cstat-no" title="statement not covered" >,r._read=function(t){M("wrapped _read",t),n&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>(n=!1,e.res<span class="fstat-no" title="function not covered" >um</span>e())},r},o<span class="cstat-no" title="statement not covered" >._fromList=x}).call(t,n(24</span>))},functi<span class="fstat-no" title="function not covered" >on</span>(e,t,n){(f<span class="cstat-no" title="statement not covered" >unction(t){"use strict";function n(e,n,r,i)</span>{if(</span>"function"!=type</span>of e)throw new Ty</span>p<span class="fstat-no" title="function not covered" >eE</span>rror('"callbac<span class="cstat-no" title="statement not covered" >k<span class="fstat-no" title="function not covered" >" </span>argument must be a function');va<span class="fstat-no" title="function not covered" >r </span>o,a,s=arg<span class="cstat-no" title="statement not covered" >uments.length;switch(s){<span class="cstat-no" title="statement not covered" >case 0:case 1:return t.nextTick(e);case 2:return t.nextTick(fun</span></span>ction(){e<span class="cstat-no" title="statement not covered" >.call(null,n)});c<span class="cstat-no" title="statement not covered" ></span>ase 3:return t.nextTick(<span class="cstat-no" title="statement not covered" >function(){e.call(null</span>,n,r)}<span class="cstat-no" title="statement not covered" >);case 4:return t.<span class="fstat-no" title="function not covered" >ne</span>xtTick(fu<span class="cstat-no" title="statement not covered" >nction(){e.call(</span>nul</span>l,n,r,<span class="cstat-no" title="statement not covered" >i)});default:for(o<span class="fstat-no" title="function not covered" >=n</span>ew Array(<span class="cstat-no" title="statement not covered" >s-1),a=0;a&lt;o.lengt</span>h;)</span>o[a++]<span class="cstat-no" title="statement not covered" >=arguments[a];retu<span class="fstat-no" title="function not covered" >rn</span> t.nextTi<span class="cstat-no" title="statement not covered" >ck(function(){e.appl</span>y(n</span>ull,o)}<span class="cstat-no" title="statement not covered" >)}}!t.version||0===t.version.indexOf(<span class="cstat-no" title="statement not covered" >"v0.")||0===t.versio<span class="cstat-no" title="statement not covered" >n</span></span>.indexOf("v1.")&amp;&amp;<span class="fstat-no" title="function not covered" >0!</span>==t.versi<span class="cstat-no" title="statement not covered" >on.indexOf("v1.8.</span>")?</span>e<span class="cstat-no" title="statement not covered" ></span>.exports=n:e.exports=t.nextTick}).call(t,n(24))},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Arra</span>y]"==n.call(e)}},</span>f<span class="fstat-no" title="function not covered" >un</span>ction(e,t,n){(func<span class="cstat-no" title="statement not covered" >tion(e){/*!<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span>
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh &lt;feross@feross.org&gt; &lt;http://feross.org&gt;
	 * @license  MIT
	 */
"use strict";function <span class="fstat-no" title="function not covered" >r(</span>){<span class="cstat-no" title="statement not covered" >try{var e=<span class="cstat-no" title="statement not covered" >new Uint8Array(1);<span class="cstat-no" title="statement not covered" ></span>return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo(<span class="fstat-no" title="function not covered" >)&amp;&amp;"</span>fu<span class="cstat-no" title="statement not covered" >nction"==ty</span>peof e.subarray&amp;&amp;0===e.subarray(1,1).byteLength}catch(e){return!1}}function i()</span>{return a<span class="cstat-no" title="statement not covered" >.TYPED_ARR</span>A</span>Y_SUPPORT<span class="fstat-no" title="function not covered" >?2</span>14<span class="cstat-no" title="statement not covered" >7483647:1073741823}function o(e,t){if(i()&lt;t)throw ne</span>w RangeEr<span class="fstat-no" title="function not covered" >ro</span>r("In<span class="cstat-no" title="statement not covered" >valid typ<span class="cstat-no" title="statement not covered" >ed array length");return a.TYPED_ARRAY_SUPPORT?(e=n<span class="cstat-no" title="statement not covered" >e</span></span>w Uint8Array(t),e.__proto__=a.prototype):(null===e&amp;&amp;(e=new a(t)),e.length=t),e}function a(e,t,n){if(!(a.TYPED_ARR</span>AY_SUPPOR<span class="fstat-no" title="function not covered" >T|</span>|this i<span class="cstat-no" title="statement not covered" >nstanceof a))return new a(e,t,n);if("number"==t<span class="cstat-no" title="statement not covered" >ypeof e){if("string"<span class="cstat-no" title="statement not covered" >=</span></span>=typeof t)throw new Er<span class="cstat-no" title="statement not covered" >ror("If encoding is sp<span class="cstat-no" title="statement not covered" >ecified then the first argument must be a string");return c(this,e)}return s(this,e,t<span class="cstat-no" title="statement not covered" >,</span></span>n)}function s(e,t<span class="cstat-no" title="statement not covered" ></span>,</span>n,r){if("number"==typ</span>eof t)thr<span class="fstat-no" title="function not covered" >ow</span> new Type<span class="cstat-no" title="statement not covered" >Error('"value" argumen<span class="cstat-no" title="statement not covered" >t must not be a number');return"undefined"!=typeof ArrayBuffe<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;t instanceof ArrayBuffer?d(e,t,n,r):"string"==typeof t?f(e,t,n):p(e,t)}function u(e){if("number"!=typeof e)t</span>hrow new <span class="fstat-no" title="function not covered" >Ty</span>peE<span class="cstat-no" title="statement not covered" >rror('"size" argument <span class="cstat-no" title="statement not covered" >must be a number');if(e&lt;0)throw new RangeError('"size" a<span class="cstat-no" title="statement not covered" >r</span></span>gument<span class="cstat-no" title="statement not covered" > must not be negative')}function l(e,t,n,r){return u(t),t&lt;=0?o</span></span>(e,t):voi<span class="fstat-no" title="function not covered" >d </span>0!==n?"st<span class="cstat-no" title="statement not covered" >ring"==typeof r?o(e,t).fill(n,r):o(e,t).fill(n):o(e,t)}function c(e,t){if(u(t),e=o(e,t&lt;0?0:0|v</span>(t)),!a.T<span class="fstat-no" title="function not covered" >YP</span>ED_AR<span class="cstat-no" title="statement not covered" >RAY_SUPPORT)for(var n=0;n&lt;t;++n)e[n]=0;return e}fun<span class="cstat-no" title="statement not covered" >ction f(e,t,n){if("s<span class="cstat-no" title="statement not covered" >tring"=<span class="cstat-no" title="statement not covered" >=</span></span></span>typeof n&amp;</span>&amp;""!==n||<span class="fstat-no" title="function not covered" >(n</span>="utf8"<span class="cstat-no" title="statement not covered" >),!a.isEncoding(n))throw new TypeError('"encoding" must be <span class="cstat-no" title="statement not covered" >a valid string encoding');var r=0|y(t,n);e=o(e,r);var i=e.write(t,n</span></span>);ret<span class="cstat-no" title="statement not covered" >urn i!==r<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;(e=e.sli</span>ce(0,<span class="cstat-no" title="statement not covered" >i)),e}functio<span class="cstat-no" title="statement not covered" ></span>n h(e,t){var n=t.length&lt;0?0:0|v(t.</span>length);e<span class="fstat-no" title="function not covered" >=o</span>(e,n);for(v<span class="cstat-no" title="statement not covered" >ar r=0;r&lt;n;r+=1)e[r]=255&amp;t[<span class="cstat-no" title="statement not covered" ></span>r];return<span class="cstat-no" title="statement not covered" > </span>e}function d(e,t,n,r<span class="cstat-no" title="statement not covered" >){if(t.byteLen<span class="cstat-no" title="statement not covered" >g</span></span>th,n&lt;0||t</span>.byteLeng<span class="fstat-no" title="function not covered" >th</span>&lt;n)throw <span class="cstat-no" title="statement not covered" >new RangeError("'offset' is out of b<span class="cstat-no" title="statement not covered" >ounds");if(t.byteLength&lt;n+(r||0))throw new RangeEr<span class="cstat-no" title="statement not covered" >r</span></span>or("'length' is out of b<span class="cstat-no" title="statement not covered" >ounds");return t=void 0===n&amp;&amp;void 0===r?new Uint8A<span class="cstat-no" title="statement not covered" >r</span></span>ray(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r),a.TYPED_ARRAY_SUPPORT?(e=t,e.__proto__=a.prototype):e=h(e,t),e}function p(e,t){if(a.isBuffer(t)){var n=0|v</span>(t.length<span class="fstat-no" title="function not covered" >);</span>retur<span class="cstat-no" title="statement not covered" >n e=o(e,n),0===e.length?<span class="cstat-no" title="statement not covered" >e:(t.copy(e,0,<span class="cstat-no" title="statement not covered" ></span>0,n),e)}if(t){if("undefined"!=typeof ArrayBuffer&amp;&amp;t.<span class="cstat-no" title="statement not covered" ></span>b</span>uffer<span class="cstat-no" title="statement not covered" > instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||Y(t.length)<span class="cstat-no" title="statement not covered" >?o(e,0):h(e,t);if("Buffer"===t.type&amp;&amp;Z(t.data))return h(e,t<span class="cstat-no" title="statement not covered" >.</span></span>data)}throw new TypeError("Firs<span class="cstat-no" title="statement not covered" >t argument must be a<span class="cstat-no" title="statement not covered" ></span></span> </span>string, Buffer, ArrayBuffer, Array, or array-like object.")}function v(e){if(e&gt;=i())throw new RangeError("</span>Attempt t<span class="fstat-no" title="function not covered" >o </span>all<span class="cstat-no" title="statement not covered" >ocate Buff<span class="cstat-no" title="statement not covered" >er larger than maximum size: 0x"+i().toString(16)+" bytes");return 0|e}function g(e){return+e!=e&amp;&amp;(e=0),a.<span class="cstat-no" title="statement not covered" >a</span></span>lloc(+e)}fu</span>nction y(<span class="fstat-no" title="function not covered" >e,</span>t){<span class="cstat-no" title="statement not covered" >if(a.isBuffer(e))return e.length</span>;if("unde<span class="fstat-no" title="function not covered" >fi</span>ned"!<span class="cstat-no" title="statement not covered" >=typeof ArrayBuff<span class="cstat-no" title="statement not covered" >er&amp;&amp;"function"==<span class="cstat-no" title="statement not covered" >t</span></span>ypeof ArrayBuffer.isView&amp;&amp;(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&amp;&amp;(e=""+e)<span class="cstat-no" title="statement not covered" >;var n=e.length;if(0<span class="cstat-no" title="statement not covered" >=</span></span>==n)return 0;for(var r=!1;;)s</span>witch<span class="cstat-no" title="statement not covered" >(t){case"<span class="cstat-no" title="statement not covered" ></span>ascii":ca<span class="cstat-no" title="statement not covered" >se"latin1<span class="cstat-no" title="statement not covered" >"</span></span>:case"binary":<span class="cstat-no" title="statement not covered" >return n;case"utf8":case"utf-8":case void 0:retu<span class="cstat-no" title="statement not covered" >rn W(e).le</span>ngth;case"ucs2":case"ucs-2":case"u<span class="cstat-no" title="statement not covered" >tf16le":case"utf-16l</span>e":return 2*n;case"hex":return n&gt;&gt;&gt;1;case"base64":r<span class="cstat-no" title="statement not covered" >eturn G(e).l</span>ength;def<span class="cstat-no" title="statement not covered" >ault:if(r)retu</span>rn W(e).leng<span class="cstat-no" title="statement not covered" >th;t=(""+t).toLowerC</span>ase(),r<span class="cstat-no" title="statement not covered" >=!0}}<span class="cstat-no" title="statement not covered" >function m(e,t,n){v<span class="cstat-no" title="statement not covered" >a</span></span>r r=!1;if((void 0===t||t&lt;0)&amp;</span>&amp;</span></span>(t=0),t&gt;t<span class="fstat-no" title="function not covered" >hi</span>s.length)retu<span class="cstat-no" title="statement not covered" >rn"<span class="cstat-no" title="statement not covered" ></span>";if((void 0===n||n&gt;this.length)&amp;&amp;(n=this.<span class="cstat-no" title="statement not covered" >length),n<span class="cstat-no" title="statement not covered" >&lt;</span></span>=0)return"";if(n&gt;&gt;&gt;=0,t&gt;&gt;&gt;=0,n&lt;=t)return"";for(e||(e<span class="cstat-no" title="statement not covered" >="utf8");<span class="cstat-no" title="statement not covered" >;</span></span>)switch(e){case"hex":<span class="cstat-no" title="statement not covered" >return A(<span class="cstat-no" title="statement not covered" >t</span></span>his,t,n);case"utf8"<span class="cstat-no" title="statement not covered" >:case"utf-8":return <span class="cstat-no" title="statement not covered" >j(this,t,n);case"asc</span>ii":return I(this,t,n)<span class="cstat-no" title="statement not covered" >;case"latin1":case"b</span>inary":retu<span class="cstat-no" title="statement not covered" >rn C(this,t,n);case"</span>base64":return R(this,t,n<span class="cstat-no" title="statement not covered" >);case"ucs2":case"uc</span>s-2":case"ut<span class="cstat-no" title="statement not covered" >f16le":case"utf-16le</span>":return L(this,t,n);default:if(r)throw new TypeErr<span class="cstat-no" title="statement not covered" >or("Unknown encoding</span>: "+e);<span class="cstat-no" title="statement not covered" >e=(e+<span class="cstat-no" title="statement not covered" >"").toLowerCase(),r=!0}}function b(e,t,n){va<span class="cstat-no" title="statement not covered" >r</span></span> r=e[t];e[t]=e[n],e[n]=r}fun</span>c</span></span>tion w(e,<span class="fstat-no" title="function not covered" >t,</span>n,r,i){if(0==<span class="cstat-no" title="statement not covered" >=e.le<span class="cstat-no" title="statement not covered" ></span>ngth)return-1;if("</span>string"==<span class="fstat-no" title="function not covered" >ty</span>peof n?(r=n<span class="cstat-no" title="statement not covered" >,n=0):n&gt;21474836<span class="cstat-no" title="statement not covered" >47?n=2147<span class="cstat-no" title="statement not covered" >4</span></span>83647:n&lt;-2147483648&amp;&amp;(n=-2147483648),n=+n,isNaN(n)&amp;&amp;(n=i?0:e.length-1),n&lt;0&amp;&amp;(n=e.length+n),n&gt;=e.length){if(i)return-1;n=e.length-1}else if(n&lt;0){if(!i)retur<span class="cstat-no" title="statement not covered" >n-1;n<span class="cstat-no" title="statement not covered" >=0}if("st<span class="cstat-no" title="statement not covered" >r</span></span>ing"==typeof </span>t&amp;&amp;(t<span class="cstat-no" title="statement not covered" >=a.from(<span class="cstat-no" title="statement not covered" >t,r)),<span class="cstat-no" title="statement not covered" >a.isBuffe<span class="cstat-no" title="statement not covered" >r</span></span>(t))<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn 0===t.length?-1:x(e,t,n,r,i);if("number"==type<span class="cstat-no" title="statement not covered" >of t)return t&amp;=255,a.TYPED_ARRAY_SUP<span class="cstat-no" title="statement not covered" >P</span></span>ORT&amp;&amp;"function"==type<span class="cstat-no" title="statement not covered" >of Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):x(e,[t],n,r,i);throw new TypeError("val must be string, number or Bu<span class="cstat-no" title="statement not covered" >f</span></span>fer")}function x(e,t,n,r,i){function o(e,t){return 1===a?e[t</span>]:e.readU<span class="fstat-no" title="function not covered" >In</span>t16BE(t*a)}var a=1,s<span class="fstat-no" title="function not covered" >=e</span>.leng<span class="cstat-no" title="statement not covered" >th,u=t.length;if(void 0!==r&amp;&amp;(r=String(</span>r).toL<span class="cstat-no" title="statement not covered" >ow</span>er<span class="cstat-no" title="statement not covered" >Case(),"u</span>cs<span class="cstat-no" title="statement not covered" >2"===r||"<span class="cstat-no" title="statement not covered" ></span>ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length&lt;2||t.length&lt;2)return-1;a=2,s/=2,u/=2,n/=2}v<span class="cstat-no" title="statement not covered" >ar l;if(i){var c=-1;for(l=<span class="cstat-no" title="statement not covered" >n;l&lt;s;l++<span class="cstat-no" title="statement not covered" >)</span></span>if(o(e,l)===o(t,c==</span>=</span>-1?0:<span class="cstat-no" title="statement not covered" >l-c)){if(c==<span class="cstat-no" title="statement not covered" >=-1<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;(c=l),l-c+1===<span class="cstat-no" title="statement not covered" >u)return c*a}else c!==-1&amp;&amp;(l-=l<span class="cstat-no" title="statement not covered" >-c),c=-1}else for(n+u&gt;s&amp;&amp;(n<span class="cstat-no" title="statement not covered" >=s-u),l=n;l&gt;</span></span>=0;l-<span class="cstat-no" title="statement not covered" >-){for(var f=!0,h=0;h&lt;u</span></span></span>;h++)<span class="cstat-no" title="statement not covered" >if(o(e,l+h)!==o(t,h)){f=!1;break}<span class="cstat-no" title="statement not covered" >if(f)return l}return-1}fu<span class="cstat-no" title="statement not covered" >nction _(e,t,n,r){n=Nu<span class="cstat-no" title="statement not covered" >mber(<span class="cstat-no" title="statement not covered" >n</span>)||0;v<span class="cstat-no" title="statement not covered" ></span>a</span></span>r i=<span class="cstat-no" title="statement not covered" >e.length-n<span class="cstat-no" title="statement not covered" ></span></span>;</span></span>r?(r=Numb</span>er(r),r&gt;i<span class="fstat-no" title="function not covered" >&amp;&amp;</span>(r=i)):r=<span class="cstat-no" title="statement not covered" >i;var o=t.length</span>;if(o<span class="cstat-no" title="statement not covered" >%2!==0)thro<span class="cstat-no" title="statement not covered" ></span>w new TypeError("Invalid hex str</span>ing")<span class="cstat-no" title="statement not covered" >;r&gt;o/2&amp;&amp;(<span class="cstat-no" title="statement not covered" ></span>r=o/2);for(<span class="cstat-no" title="statement not covered" >var a=0;a&lt;r;++a){var s=parseInt(t.substr(2<span class="cstat-no" title="statement not covered" >*</span></span>a,2),16);if(is<span class="cstat-no" title="statement not covered" >N</span>aN(s))return a;e[n+a]=s}re<span class="cstat-no" title="statement not covered" >turn a}function k(e,t,n,r){re<span class="cstat-no" title="statement not covered" ></span>turn $(W(t,e<span class="cstat-no" title="statement not covered" >.length-n<span class="cstat-no" title="statement not covered" >)</span></span>,e,n,r)}f<span class="cstat-no" title="statement not covered" ></span>u</span>nction T(</span>e,t,n,r){<span class="fstat-no" title="function not covered" >re</span>turn $(X(<span class="cstat-no" title="statement not covered" >t),e,n,r)}function E(e,t,n,r){ret</span>urn T(e,t<span class="fstat-no" title="function not covered" >,n</span>,r)}funct<span class="cstat-no" title="statement not covered" >ion S(e,t,n,r){return </span>$(G(t),e,<span class="fstat-no" title="function not covered" >n,</span>r)}functi<span class="cstat-no" title="statement not covered" >on N(e,t,n,r){retur</span>n $(J(t,e<span class="fstat-no" title="function not covered" >.l</span>ength-n),<span class="cstat-no" title="statement not covered" >e,n,r)}function R(e,t,</span>n){return<span class="fstat-no" title="function not covered" > 0</span>===t&amp;&amp;n==<span class="cstat-no" title="statement not covered" >=e.length?Q.fromByteArray(e):Q.fr</span>omByteArr<span class="fstat-no" title="function not covered" >ay</span>(e.slic<span class="cstat-no" title="statement not covered" >e(t,n))}function j(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i&lt;n;){var o</span>=e[i],a=n<span class="fstat-no" title="function not covered" >ul</span>l,s=o&gt;2<span class="cstat-no" title="statement not covered" >39?4:o&gt;223?3:o&gt;191?2:1;<span class="cstat-no" title="statement not covered" >i</span>f(i+s&lt;=n){var u,l,c,f;switch<span class="cstat-no" title="statement not covered" >(s){c</span>as<span class="cstat-no" title="statement not covered" >e 1:o</span>&lt;1<span class="cstat-no" title="statement not covered" >28&amp;&amp;(a=o);break;case 2:u=e<span class="cstat-no" title="statement not covered" ></span>[i+1],128===(192&amp;u)&amp;&amp;(f<span class="cstat-no" title="statement not covered" >=(31&amp;o)&lt;&lt;6|63&amp;u,f<span class="cstat-no" title="statement not covered" >&gt;127&amp;&amp;(a=f));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >u=e[i+1],l=e[i+2],128===(192&amp;u)&amp;&amp;128===(192&amp;l)&amp;&amp;(f=(15&amp;o<span class="cstat-no" title="statement not covered" >)</span>&lt;&lt;12|(</span>63&amp;u)&lt;<span class="cstat-no" title="statement not covered" >&lt;6|63&amp;l,f&gt;2047&amp;&amp;(f&lt;55296||f&gt;57343)&amp;&amp;(a=f));break;case 4:u=e[i+1],l=e[i+2],c=e[i+3],128===(192&amp;u)&amp;&amp;128===(192&amp;l)&amp;<span class="cstat-no" title="statement not covered" >&amp;</span>128===</span>(192&amp;c<span class="cstat-no" title="statement not covered" >)&amp;&amp;(f=(15&amp;o)&lt;&lt;18|(63&amp;u)&lt;&lt;12|(63&amp;l)&lt;&lt;6|63&amp;c,f&gt;65535&amp;&amp;f&lt;1114112&amp;&amp;(a=f))}}null===a?(a=65533,s=1):a&gt;65535&amp;&amp;(a-=65536,r.push(a&gt;&gt;&gt;10&amp;1023|55296),a</span>=<span class="cstat-no" title="statement not covered" ></span>5</span>6320|1023&amp;a),r.push(a),i+=s}return O(r)}function O(e){var t=e.length;if(t&lt;=ee)return String.fromCha<span class="cstat-no" title="statement not covered" ></span>r</span>Code.apply(S</span>tring,e);<span class="fstat-no" title="function not covered" >fo</span>r(var n="<span class="cstat-no" title="statement not covered" >",r=0;r&lt;t<span class="cstat-no" title="statement not covered" ></span>;)n+=Stri<span class="cstat-no" title="statement not covered" >ng.fromCharCode.apply(String,e.slice(r,r+=e<span class="cstat-no" title="statement not covered" >e</span></span>));return n}function <span class="cstat-no" title="statement not covered" >I(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<span class="cstat-no" title="statement not covered" >&lt;</span></span>n;++i)r+=</span>String.fr<span class="fstat-no" title="function not covered" >om</span>CharCode(127&amp;<span class="cstat-no" title="statement not covered" >e[i<span class="cstat-no" title="statement not covered" ></span>]);return r}function C(<span class="cstat-no" title="statement not covered" >e</span>,t,n){var r="";n=Ma<span class="cstat-no" title="statement not covered" >th.min(e.length,n);for(var i=t;i&lt;<span class="cstat-no" title="statement not covered" >n</span></span>;++i)r+=S</span>tring.fro<span class="fstat-no" title="function not covered" >mC</span>harCode(e[i])<span class="cstat-no" title="statement not covered" >;re<span class="cstat-no" title="statement not covered" ></span>turn r}function A(e,t,n<span class="cstat-no" title="statement not covered" >)</span>{var r=e.length;(!t<span class="cstat-no" title="statement not covered" >||t&lt;0)&amp;&amp;(t=0),(!n||n&lt;0||n&gt;r)&amp;<span class="cstat-no" title="statement not covered" >&amp;</span></span>(n=r);for</span>(var i=""<span class="fstat-no" title="function not covered" >,o</span>=t;o&lt;n;++o)i+<span class="cstat-no" title="statement not covered" >=V(e[o]);<span class="cstat-no" title="statement not covered" ></span>return i}function L(e,t,n){for(var r=e.<span class="cstat-no" title="statement not covered" >s</span>lice(t,n),i="",o=0;o&lt;r.l<span class="cstat-no" title="statement not covered" >ength;o+=2)<span class="cstat-no" title="statement not covered" >i</span></span>+=String.</span>fromCharC<span class="fstat-no" title="function not covered" >od</span>e(r[o]+<span class="cstat-no" title="statement not covered" >256*r[o+1]);return i}function D(e,t,n){if(e%1!==<span class="cstat-no" title="statement not covered" >0||e&lt;0)throw new RangeError("offset is n<span class="cstat-no" title="statement not covered" >o</span></span>t uint");</span>if(e+t&gt;n)<span class="fstat-no" title="function not covered" >th</span>row new<span class="cstat-no" title="statement not covered" > RangeError("Try<span class="cstat-no" title="statement not covered" >ing to access beyond buffer length")}functi<span class="cstat-no" title="statement not covered" >o</span></span>n P(e,t,<span class="cstat-no" title="statement not covered" >n,r,i,o){if(!a.isBuffer(e))throw new TypeError('"buffer" argume</span></span>nt must b<span class="fstat-no" title="function not covered" >e </span>a Buffer inst<span class="cstat-no" title="statement not covered" >ance');if(t&gt;i||t&lt;o<span class="cstat-no" title="statement not covered" >)throw new RangeError('"value" argument is out of bounds');if(n+r&gt;e<span class="cstat-no" title="statement not covered" >.</span></span>length)thro<span class="cstat-no" title="statement not covered" >w new RangeError("Index out of range")}function U(e,t,n,r)<span class="cstat-no" title="statement not covered" >{</span></span>t&lt;0&amp;&amp;(t=65535+t<span class="cstat-no" title="statement not covered" >+1);for(var i=0,o=Math.min(e.length-n,2);i&lt;o</span></span>;++i)e[n+<span class="fstat-no" title="function not covered" >i]</span>=(t&amp;255&lt;&lt;<span class="cstat-no" title="statement not covered" >8*(r?i:1-i))&gt;&gt;&gt;8*(r<span class="cstat-no" title="statement not covered" >?</span>i:1-i)}function M(e,t,n,r){t&lt;0&amp;&amp;(t=429496729<span class="cstat-no" title="statement not covered" >5+t+1);for(var i=0,o=Math.min(e.length-n,4)</span></span>;i&lt;o;++i)<span class="fstat-no" title="function not covered" >e[</span>n+i]=t&gt;&gt;&gt;<span class="cstat-no" title="statement not covered" >8*(r?i:3-i)&amp;255}function<span class="cstat-no" title="statement not covered" > </span>q(e,t,n,r,i,o){if(n+r&gt;e.length)throw new Ran<span class="cstat-no" title="statement not covered" >geError("Index out of range"</span></span>);if(n&lt;0)<span class="fstat-no" title="function not covered" >th</span>row new Range<span class="cstat-no" title="statement not covered" >Error("Index out<span class="cstat-no" title="statement not covered" > of range")}function F(e,t,n,r,i){return i|<span class="cstat-no" title="statement not covered" >|</span></span>q(e,t,<span class="cstat-no" title="statement not covered" >n,4,3.4028234663852886e38,-3.402823466385288</span></span>6e38),K.w<span class="fstat-no" title="function not covered" >ri</span>te(e,t,n,r,<span class="cstat-no" title="statement not covered" >23,4),n+4}function B(e,t,n,r,i){return i||q(e,t,n,8,1.7976931348623157e308,-1.797693134862315</span>7e308),K.<span class="fstat-no" title="function not covered" >wr</span>ite(e,t,n,r<span class="cstat-no" title="statement not covered" >,52,8),n+8}function H(e){if(e=z(e).replace(te,""),e.length&lt;2)return"";for(;e.length%4!==0;)e+="</span>=";return<span class="fstat-no" title="function not covered" > e</span>}fu<span class="cstat-no" title="statement not covered" >nction z(e){return e.trim?e.trim():e<span class="cstat-no" title="statement not covered" >.replace(<span class="cstat-no" title="statement not covered" >/</span></span>^\s+|\s+$/g,"")}func<span class="cstat-no" title="statement not covered" >tion V(<span class="cstat-no" title="statement not covered" >e</span></span>){return </span>e&lt;16?"0"+<span class="fstat-no" title="function not covered" >e.</span>toS<span class="cstat-no" title="statement not covered" >tring(16):e.toString(16)}function W(e,t){t=t||1/0;f</span>or(var n,<span class="fstat-no" title="function not covered" >r=</span>e.l<span class="cstat-no" title="statement not covered" >ength,i=null,o=[],a=0;a&lt;r;++a){if(n=e.charCodeA</span>t(a),n&gt;55<span class="fstat-no" title="function not covered" >29</span>5&amp;&amp;n&lt;<span class="cstat-no" title="statement not covered" >57344){if<span class="cstat-no" title="statement not covered" >(</span>!i){if(n&gt;56319){(t-=3)&gt;-1&amp;&amp;o.push(239,191,189<span class="cstat-no" title="statement not covered" >);continue}if(a+1===r){(t-=3)&gt;-1&amp;&amp;o.pus<span class="cstat-no" title="statement not covered" >h(239,1<span class="cstat-no" title="statement not covered" >91,189);cont<span class="cstat-no" title="statement not covered" >inue}i=n;continue}if(n&lt;56320){(<span class="cstat-no" title="statement not covered" >t</span>-=3)&gt;-1&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>o</span>.push(239,1<span class="cstat-no" title="statement not covered" >91,189),i=n;continue}n=(i-55296<span class="cstat-no" title="statement not covered" >&lt;</span>&lt;10|n-563<span class="cstat-no" title="statement not covered" ></span>2</span>0)+<span class="cstat-no" title="statement not covered" >6</span>5536}else<span class="cstat-no" title="statement not covered" ></span> </span>i&amp;&amp;(t-=3)&gt;-<span class="cstat-no" title="statement not covered" >1&amp;&amp;o.push(239,191,189);if(i=null,n&lt;<span class="cstat-no" title="statement not covered" >1</span>28){if((t<span class="cstat-no" title="statement not covered" ></span>-</span>=1)&lt;0)break;o.push(n)}else if(</span>n&lt;204<span class="cstat-no" title="statement not covered" >8){if((t-=2)&lt;0)break;o.push(n&gt;&gt;6|1<span class="cstat-no" title="statement not covered" >9</span></span>2,63&amp;n|128)}else<span class="cstat-no" title="statement not covered" > if(n&lt;65536)<span class="cstat-no" title="statement not covered" >{if((t<span class="cstat-no" title="statement not covered" >-</span></span>=3)&lt;0)brea</span>k;o.p<span class="cstat-no" title="statement not covered" >ush(n&gt;&gt;12|2<span class="cstat-no" title="statement not covered" >24,n&gt;&gt;6&amp;63|1<span class="cstat-no" title="statement not covered" >28,63&amp;<span class="cstat-no" title="statement not covered" >n</span></span>|128)}else{if(!(n&lt;1114112)</span>)thro<span class="cstat-no" title="statement not covered" >w new Error(<span class="cstat-no" title="statement not covered" >"Invalid cod<span class="cstat-no" title="statement not covered" >e poin<span class="cstat-no" title="statement not covered" >t</span></span>");if((t-=4)&lt;0)break;o.push(n&gt;&gt;18|240,n</span>&gt;&gt;12&amp;<span class="cstat-no" title="statement not covered" >63|128,n&gt;&gt;6&amp;63|1<span class="cstat-no" title="statement not covered" >28,63&amp;n|128)}}return o}function X(e){f<span class="cstat-no" title="statement not covered" >o</span></span>r(var t=[],<span class="cstat-no" title="statement not covered" >n=0;n&lt;<span class="cstat-no" title="statement not covered" >e</span></span>.length;++n)t.push(255&amp;e.charCodeAt(n));return t}fun</span>c<span class="cstat-no" title="statement not covered" ></span></span></span>t</span>ion J(e,t</span>){for(var<span class="fstat-no" title="function not covered" > n</span>,r,<span class="cstat-no" title="statement not covered" >i,o=[],a=0;a&lt;e.length&amp;&amp;!((t-=2)&lt;<span class="cstat-no" title="statement not covered" >0);++a)n=e.charCodeAt(a),r=n<span class="cstat-no" title="statement not covered" >&gt;</span></span>&gt;8,i=n%25</span>6,o.push(<span class="fstat-no" title="function not covered" >i)</span>,o.pu<span class="cstat-no" title="statement not covered" >sh(r);return o}function G(e){return Q.toByteArray(H<span class="cstat-no" title="statement not covered" >(e))}function $(e,t,n,r){for(var i=0;i&lt;r&amp;&amp;!(i+n&gt;=t.le<span class="cstat-no" title="statement not covered" >n</span></span>gth||i&gt;=e</span>.length);<span class="fstat-no" title="function not covered" >++</span>i)t<span class="cstat-no" title="statement not covered" >[i+n]=e[i];return i}function</span> Y(e){ret<span class="fstat-no" title="function not covered" >ur</span>n e!==e}v<span class="cstat-no" title="statement not covered" >ar Q=n(48),K=n(49),Z=n(50);t.Buffer=a,t.SlowBuffer=<span class="cstat-no" title="statement not covered" >g,t.INSPECT_<span class="cstat-no" title="statement not covered" >M</span></span>AX_BYTES=</span>50,a.TYPE<span class="fstat-no" title="function not covered" >D_</span>ARR<span class="cstat-no" title="statement not covered" >AY_SUPPORT=voi</span>d 0!==<span class="cstat-no" title="statement not covered" >e.TYPE</span>D_<span class="cstat-no" title="statement not covered" >ARRAY_</span>SU<span class="cstat-no" title="statement not covered" >PPORT?<span class="cstat-no" title="statement not covered" ></span>e.TYPED_ARRAY_SUPPORT:r(),t.kMaxLength=i(),a.poolSize=8192,a._augment=function(e){return e.__proto__=a.prototype,e},a.from=function(e,t,n){return s(null,e,t,n)},a.TYPED_ARR<span class="fstat-no" title="function not covered" >AY</span>_SUPPORT&amp;&amp;<span class="cstat-no" title="statement not covered" >(a.prototype.__proto__=Uint8Array.</span>prototyp<span class="fstat-no" title="function not covered" >e,</span>a.__proto__=Ui<span class="cstat-no" title="statement not covered" >nt8Array,"undefined"!=</span>typeof Symbol&amp;&amp;Symbol.species&amp;&amp;a[Symbol.species]===a&amp;&amp;Object.defineProperty(a,Symbol.species,{value:null,configurable:!0})),a.alloc=function(e,t,n){return l(null,e,t,n)},a.allocUnsafe=function(e){return c(null,e)},a.allocUnsafeSlow=func<span class="fstat-no" title="function not covered" >ti</span>on(e){return c<span class="cstat-no" title="statement not covered" >(null,e)},a.isBuffer=f</span>unction(e){retu<span class="fstat-no" title="function not covered" >rn</span>!(null==e|<span class="cstat-no" title="statement not covered" >|!e._isBuffer)},a.</span>compare=function(e,<span class="fstat-no" title="function not covered" >t)</span>{if(!a.isB<span class="cstat-no" title="statement not covered" >uffer(e)||!a.isBuf</span>fer(t))throw<span class="fstat-no" title="function not covered" > n</span>ew TypeErr<span class="cstat-no" title="statement not covered" >or("Arguments must be Buffers");</span>if(e===t)re<span class="fstat-no" title="function not covered" >tu</span>rn 0;for(var<span class="cstat-no" title="statement not covered" > n=e.length,r=t.length,i=0,o=Math.<span class="cstat-no" title="statement not covered" >min(n,r);i&lt;o;++i)if(e[i]!==t[i]){n=e[i],r=t[i];br<span class="cstat-no" title="statement not covered" >e</span></span>ak}retur<span class="cstat-no" title="statement not covered" >n n&lt;r?-1:<span class="cstat-no" title="statement not covered" >r</span></span>&lt;n?1:0},a.isEncoding=function(e){switch(String(e).toLower<span class="cstat-no" title="statement not covered" >Case()){case"hex<span class="cstat-no" title="statement not covered" >":case"utf8":c<span class="cstat-no" title="statement not covered" >a</span>se"utf<span class="cstat-no" title="statement not covered" ></span>-</span></span>8":case"ascii":case"la</span>tin1":case"bin<span class="fstat-no" title="function not covered" >ar</span>y":case"ba<span class="cstat-no" title="statement not covered" >se64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(e,t){if(!Z(e))throw new TypeError('"list" argument must be an Ar<span class="cstat-no" title="statement not covered" >ray of Buf</span>fers');<span class="cstat-no" title="statement not covered" >if(0===e.l</span>e</span>ngth)retur<span class="fstat-no" title="function not covered" >n </span>a.alloc(0);v<span class="cstat-no" title="statement not covered" >ar n;if(v<span class="cstat-no" title="statement not covered" >oid 0===t)for(t=0,n=0;n&lt;e.length;++n)t+=e[n].length;var r=a.allocUn<span class="cstat-no" title="statement not covered" >s</span></span>afe(t),i=0;for(<span class="cstat-no" title="statement not covered" >n=0;n&lt;e.length;++n)</span></span>{var <span class="cstat-no" title="statement not covered" >o=e[n];if(!a.i<span class="cstat-no" title="statement not covered" >sBuffer(o))throw new TypeEr<span class="cstat-no" title="statement not covered" >ror('"list" argu</span></span></span>ment <span class="cstat-no" title="statement not covered" >must be an Array </span>of<span class="cstat-no" title="statement not covered" > B<span class="cstat-no" title="statement not covered" ></span>uffers');o.copy(r,i),i+=o.leng<span class="cstat-no" title="statement not covered" >th}re<span class="cstat-no" title="statement not covered" ></span>turn r},a.byteLeng<span class="cstat-no" title="statement not covered" >th=y,a.prototype._isBuffer=!0,a.prototype.swap16=function(){var e=t<span class="cstat-no" title="statement not covered" >h</span></span>is.length;if(e%2!==0)thr<span class="cstat-no" title="statement not covered" ></span>o</span>w new Ran</span>geError("Buffer size must be a multiple of 16-bits");for(var<span class="fstat-no" title="function not covered" > t</span>=0;t&lt;e;t+=2)b(t<span class="cstat-no" title="statement not covered" >his,t,t+1);r<span class="cstat-no" title="statement not covered" ></span>eturn this}<span class="cstat-no" title="statement not covered" >,a.prototype.swap32=function(){var e=this.length;if(e%4!==0)throw <span class="cstat-no" title="statement not covered" >n</span></span>ew RangeError("Buffe<span class="cstat-no" title="statement not covered" >r size must be<span class="cstat-no" title="statement not covered" > </span></span>a multiple o</span>f 32-bits");for(var <span class="fstat-no" title="function not covered" >t=</span>0;t&lt;e;t+=4)b(th<span class="cstat-no" title="statement not covered" >is,t,t+3),b(<span class="cstat-no" title="statement not covered" ></span>this,t+1,t+<span class="cstat-no" title="statement not covered" >2);return this},a.prototype.swap64=function(){var e=this.length;if<span class="cstat-no" title="statement not covered" >(</span></span>e%8!==0)throw new Ra<span class="cstat-no" title="statement not covered" >ngeError("Buffer size must be <span class="cstat-no" title="statement not covered" >a</span></span> multiple of</span> 64-bits");for(var t<span class="fstat-no" title="function not covered" >=0</span>;t&lt;e;t+=8)b(thi<span class="cstat-no" title="statement not covered" >s,t,t+7),b(t<span class="cstat-no" title="statement not covered" ></span>his,t+1,t+6<span class="cstat-no" title="statement not covered" >),b(this,t+2,t+5),b(this,t+3,t+4);return this},a.prototype.toStrin<span class="cstat-no" title="statement not covered" >g</span></span>=function(){var e=0|<span class="cstat-no" title="statement not covered" >this.length;return 0===e?"":0===arguments.length?j(this,0,e):m<span class="cstat-no" title="statement not covered" >.</span></span>apply(this,a</span>rguments)},a.prototype<span class="fstat-no" title="function not covered" >.e</span>quals=function(<span class="cstat-no" title="statement not covered" >e){if(!a.isBuf<span class="cstat-no" title="statement not covered" ></span>fer(e))throw new TypeError("Argument must be a Buffer");return this===e||0</span>===a.compare(this,e)<span class="fstat-no" title="function not covered" >},</span>a.prototyp<span class="cstat-no" title="statement not covered" >e.inspect=function<span class="cstat-no" title="statement not covered" >(){var e="",n=t.INSPECT_MAX_BYTES;return this.len<span class="cstat-no" title="statement not covered" >g</span></span>th&gt;0&amp;&amp;(e=this.toString("hex",0,n).match</span>(/.{2}/g).join(" "),t<span class="fstat-no" title="function not covered" >hi</span>s.length&gt;n&amp;&amp;(e+<span class="cstat-no" title="statement not covered" >=" </span>..<span class="cstat-no" title="statement not covered" >. ")),"&lt;Buffer "+e+"<span class="cstat-no" title="statement not covered" ></span>&gt;"},a.prototype.compare=function(e,t,n,r,i){if(!a.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0==</span>=t&amp;&amp;(t=0),void 0===n&amp;<span class="fstat-no" title="function not covered" >&amp;(</span>n=e?e.length:0),vo<span class="cstat-no" title="statement not covered" >id 0===r&amp;&amp;(r=0),vo<span class="cstat-no" title="statement not covered" >id 0===i&amp;&amp;(i=this.length),t&lt;0||n&gt;e.length||r&lt;0||i<span class="cstat-no" title="statement not covered" >&gt;</span></span>this.length)throw new RangeError("out of range index");if(r&gt;=i&amp;&amp;t&gt;=n)return 0;if(r&gt;=i)return-1;if(t&gt;=n)return 1;if(t&gt;&gt;&gt;=0,n&gt;&gt;&gt;=0,r&gt;<span class="cstat-no" title="statement not covered" >&gt;&gt;=0,i&gt;&gt;&gt;=0,this===e)return 0;for(var o=i-r<span class="cstat-no" title="statement not covered" >,</span></span>s=n-t,u=Math.<span class="cstat-no" title="statement not covered" >min(o,s),<span class="cstat-no" title="statement not covered" >l</span></span>=this.s<span class="cstat-no" title="statement not covered" >lice(r,i)<span class="cstat-no" title="statement not covered" >,</span></span>c=e.sli<span class="cstat-no" title="statement not covered" >ce(t,n),f<span class="cstat-no" title="statement not covered" >=</span></span>0;f&lt;u;++f)if(l[f]!==c[f]){o=l[f],s=c[f]<span class="cstat-no" title="statement not covered" >;break}re<span class="cstat-no" title="statement not covered" >t</span></span>urn o&lt;s?-1:s&lt;o?1:0},a.prototype.includes=function(e,t,n){return this.indexOf(e,t<span class="cstat-no" title="statement not covered" >,n)!==-1},a.prot<span class="cstat-no" title="statement not covered" >otype.indexOf=<span class="cstat-no" title="statement not covered" >f</span>unctio<span class="cstat-no" title="statement not covered" ></span>n</span></span>(e,t,n){return w(this,</span>e,t,n,!0)},a.prototype<span class="fstat-no" title="function not covered" >.l</span>astIndexOf=fun<span class="cstat-no" title="statement not covered" >ction(e,t,n){return w(this,e,t,n,</span>!1)},a.prototype.writ<span class="fstat-no" title="function not covered" >e=</span>function(e,t,n<span class="cstat-no" title="statement not covered" >,r){if(void 0===t)r="utf8</span>",n=this.length,t=0;else <span class="fstat-no" title="function not covered" >if</span>(void 0===n&amp;&amp;"<span class="cstat-no" title="statement not covered" >string"==typeof t)r=t,n=t</span>his.length,t=0;else<span class="fstat-no" title="function not covered" >{i</span>f(!isFinite(t))t<span class="cstat-no" title="statement not covered" >hrow new Error<span class="cstat-no" title="statement not covered" >("Buffer.write(string, encod</span>ing,<span class="cstat-no" title="statement not covered" > offset[, length]) is no longer su<span class="cstat-no" title="statement not covered" >pported");t|=0,isFinite</span>(n)?<span class="cstat-no" title="statement not covered" >(n|=0,void 0===r<span class="cstat-no" title="statement not covered" >&amp;&amp;(r="utf8")):(r=n,n=void 0)}var i=this.length-t;if((void 0===n||n&gt;i)&amp;&amp;(n=i),e.length&gt;0&amp;&amp;(n<span class="cstat-no" title="statement not covered" >&lt;</span></span>0||t&lt;0)||t&gt;this.length)throw new RangeError("Attempt to write </span>o</span></span>utsid<span class="cstat-no" title="statement not covered" >e buffer bound<span class="cstat-no" title="statement not covered" ></span>s");r||(r="utf8");for(var o=!1;;)switch(r){case"hex":return _(this<span class="cstat-no" title="statement not covered" >,e,t,n);case"utf8":case"utf-8":return k(this,e,t,n);case"ascii"<span class="cstat-no" title="statement not covered" >:</span></span>return T(this<span class="cstat-no" title="statement not covered" >,</span>e,t,n);case"la<span class="cstat-no" title="statement not covered" >tin1":case"binary":r<span class="cstat-no" title="statement not covered" >eturn E(this,e,t,n);ca</span>se"base64":return S(th<span class="cstat-no" title="statement not covered" >is,e,t,n);case"ucs2":c</span>ase"ucs-2":<span class="cstat-no" title="statement not covered" >case"utf16le":case"utf</span>-16le":return N(this,e,t,<span class="cstat-no" title="statement not covered" >n);default:if(o)throw </span>new TypeErro<span class="cstat-no" title="statement not covered" >r("Unknown encoding: "</span>+r);r=(""+r).toLowerCase(),o=!0}},a.prototype.toJSO<span class="cstat-no" title="statement not covered" >N=function(){return{ty</span>pe:"Buf<span class="cstat-no" title="statement not covered" >fer",<span class="cstat-no" title="statement not covered" >data:Array.prototype.slice.call(this._arr||t<span class="cstat-no" title="statement not covered" >h</span></span>is,0)}};var ee=4096;a.protot</span>y</span></span>pe.slice=function(e,<span class="fstat-no" title="function not covered" >t)</span>{var n=th<span class="cstat-no" title="statement not covered" >is.length;e=~~e,t=void 0===t?n:~~t,e&lt;0?(e+=n,e&lt;0&amp;&amp;(e=0)):e&gt;n&amp;&amp;(e=n),t&lt;0?(t</span>+=</span>n,t&lt;0&amp;<span class="cstat-no" title="statement not covered" >&amp;(t=0<span class="cstat-no" title="statement not covered" ></span>)):t&gt;n&amp;&amp;(t=n),t&lt;e&amp;<span class="fstat-no" title="function not covered" >&amp;(</span>t=e);var r;if(a.TY<span class="cstat-no" title="statement not covered" >PED_ARRAY_SU<span class="cstat-no" title="statement not covered" ></span>PPORT)r=this.subarray(e,t),r.__proto__=a.prototype;else{var i=t-e;r=new a(i,void 0);for(var o=0;o&lt;i;++o</span>)r[o]<span class="cstat-no" title="statement not covered" >=this[o+e]}return r},a.pr<span class="cstat-no" title="statement not covered" >ototype.readUIntLE=function(e,t,n){e|=0,t|=0,n</span>||D(e,t,th<span class="cstat-no" title="statement not covered" >is.l<span class="cstat-no" title="statement not covered" ></span>ength);for(var r=t<span class="cstat-no" title="statement not covered" >h</span>is[e],i=1,o=0;++o&lt;t<span class="cstat-no" title="statement not covered" >&amp;&amp;(i*=256);)r+=t<span class="cstat-no" title="statement not covered" ></span></span>h</span>is[e+o]*i</span>;return r},a.prototype.r<span class="fstat-no" title="function not covered" >ea</span>dUIntBE=functi<span class="cstat-no" title="statement not covered" >on(e,t,n){e|=0,t|=0,n||D(e,t,thi<span class="cstat-no" title="statement not covered" >s</span>.length);for(var r=this[e+--t],i=1;t&gt;0&amp;&amp;(i<span class="cstat-no" title="statement not covered" >*=256);)r+=this<span class="cstat-no" title="statement not covered" >[</span></span>e+--t]*i;</span>return r},a.prototype.re<span class="fstat-no" title="function not covered" >ad</span>UInt8=function<span class="cstat-no" title="statement not covered" >(e,t){return t||D(e,1,this.lengt<span class="cstat-no" title="statement not covered" >h</span>),this[e]},a.prototype.readUInt16LE=func<span class="cstat-no" title="statement not covered" >tion(e,t){return <span class="cstat-no" title="statement not covered" >t</span></span>||D(e,2,t</span>his.length),this[e]|thi<span class="fstat-no" title="function not covered" >s[</span>e+1]&lt;&lt;8},a.p<span class="cstat-no" title="statement not covered" >rototype.readUInt16BE=function(e,t){re</span>turn t||D(e,2,this.length)<span class="fstat-no" title="function not covered" >,t</span>his[e]&lt;&lt;8|th<span class="cstat-no" title="statement not covered" >is[e+1]},a.prototype.readUInt32LE=function(e,t){ret</span>urn t||D(e,4,this.length),<span class="fstat-no" title="function not covered" >(t</span>his[e]|this[<span class="cstat-no" title="statement not covered" >e+1]&lt;&lt;8|this[e+2]&lt;&lt;16)+16777216*this[e+3]},a.protot</span>ype.readUInt32BE=function(<span class="fstat-no" title="function not covered" >e,</span>t){return t|<span class="cstat-no" title="statement not covered" >|D(e,4,this.length),16777216*this[e]+(this[e+1]&lt;&lt;16|this[e+2]&lt;&lt;8|this[e+3])},a.prototy</span>pe.readIntLE=function(e,t,<span class="fstat-no" title="function not covered" >n)</span>{e|=0,t|=0,n<span class="cstat-no" title="statement not covered" >||D(e,t,this.length);for(var r=this[e],i=1,o=0;++o&lt;t&amp;&amp;(i*=256);)r+=this[e+o]*i;return </span>i*=128,r&gt;=i&amp;&amp;(r-=Math.p<span class="fstat-no" title="function not covered" >ow</span>(2,8*t)),r},a.<span class="cstat-no" title="statement not covered" >prototype.readIntBE=function(e,t<span class="cstat-no" title="statement not covered" >,</span>n){e|=0,t|=0,n||D(e,t,this.length);for(var<span class="cstat-no" title="statement not covered" > r=t,i=1,o=this<span class="cstat-no" title="statement not covered" >[</span></span>e+--r];r&gt;0&amp;&amp;(i*=256);)o+=this[e+--r]*i;retu</span>rn i*=128,o&gt;=i&amp;&amp;(o-=Mat<span class="fstat-no" title="function not covered" >h.</span>pow(2,8*t)),o}<span class="cstat-no" title="statement not covered" >,a.prototype.readInt8=function(e<span class="cstat-no" title="statement not covered" >,</span>t){return t||D(e,1,this.length),128&amp;this[e]?<span class="cstat-no" title="statement not covered" >(255-this[e]+1)*-<span class="cstat-no" title="statement not covered" >1</span></span>:this[e]},a.prototype.readInt16LE=function(</span>e,t){t||D(e,2,this.len<span class="fstat-no" title="function not covered" >gt</span>h);var n=thi<span class="cstat-no" title="statement not covered" >s[e]|this[e+1]&lt;&lt;8;return 32768&amp;n?4294901760|n:n},a.prototype.readInt1</span>6BE=function(e,t){t||D(e,<span class="fstat-no" title="function not covered" >2,</span>this.length)<span class="cstat-no" title="statement not covered" >;var n=this[e+1]|this[e</span>]&lt;&lt;8;<span class="cstat-no" title="statement not covered" >return 32768&amp;n?429490<span class="cstat-no" title="statement not covered" ></span>1760|n:n},a.prototype.readInt32</span>LE=function(e,t){return t<span class="fstat-no" title="function not covered" >||</span>D(e,4,this.l<span class="cstat-no" title="statement not covered" >ength),this[e]|this[e+1</span>]&lt;&lt;8|<span class="cstat-no" title="statement not covered" >this[e+2]&lt;&lt;16|this[e+<span class="cstat-no" title="statement not covered" ></span>3]&lt;&lt;24},a.prototype.readInt32BE</span>=function(e,t){return t||<span class="fstat-no" title="function not covered" >D(</span>e,4,this.len<span class="cstat-no" title="statement not covered" >gth),this[e]&lt;&lt;24|this[e+1]&lt;&lt;16|this[e+2]&lt;&lt;8|this[e+3]},a.prototype.readFloatLE=</span>function(e,t){return t||D<span class="fstat-no" title="function not covered" >(e</span>,4,this.leng<span class="cstat-no" title="statement not covered" >th),K.read(this,e,!0,23,4)},a.prototype.readFloatBE=function(e,t){return t||D(e</span>,4,this.length),K.read(th<span class="fstat-no" title="function not covered" >is</span>,e,!1,23,4)}<span class="cstat-no" title="statement not covered" >,a.prototype.readDoubleLE=function(e,t){return t||D(e</span>,8,this.length),K.read(th<span class="fstat-no" title="function not covered" >is</span>,e,!0,52,8)}<span class="cstat-no" title="statement not covered" >,a.prototype.readDoubleBE=function(e,t){return t||D(e</span>,8,this.length),K.read(thi<span class="fstat-no" title="function not covered" >s,</span>e,!1,52,8)},<span class="cstat-no" title="statement not covered" >a.prototype.writeUIntLE=function(e,t,n,r){if(e=+e,t|=</span>0,n|=0,!r){var i=Math.pow(<span class="fstat-no" title="function not covered" >2,</span>8*n)-1;P(thi<span class="cstat-no" title="statement not covered" >s,e,t,n,i,0)}var o=1,a=0;for(this[t]=255&amp;e;++a&lt;n&amp;&amp;(o*</span>=256);)this[t+a]=e/o&amp;255;<span class="fstat-no" title="function not covered" >re</span>turn t+n},a.prot<span class="cstat-no" title="statement not covered" >otype.writeUIntBE=function(e<span class="cstat-no" title="statement not covered" >,t,n,r){if(e=+e,t|<span class="cstat-no" title="statement not covered" ></span>=0,n|=0,!r){var i=M</span>a</span>th.po<span class="cstat-no" title="statement not covered" >w(</span>2,<span class="cstat-no" title="statement not covered" >8*<span class="cstat-no" title="statement not covered" ></span>n)-1;P(this,e,t,n,i,0)}var o=n-1,a=<span class="cstat-no" title="statement not covered" >1;for(this[t+o]=25<span class="cstat-no" title="statement not covered" >5</span></span>&amp;e;--o&gt;=0&amp;&amp;</span>(a*=256);)this[t+o]=e/a&amp;2<span class="fstat-no" title="function not covered" >55</span>;return t+n},a.p<span class="cstat-no" title="statement not covered" >rototype.writeUInt8=function<span class="cstat-no" title="statement not covered" >(e,t,n){return e=+<span class="cstat-no" title="statement not covered" ></span>e,t|=0,n||P(this,e,</span>t</span>,1,25<span class="cstat-no" title="statement not covered" >5,0)</span>,a<span class="cstat-no" title="statement not covered" >.T<span class="cstat-no" title="statement not covered" ></span>YPED_ARRAY_SUPPORT||(e=Math.floor(e)),<span class="cstat-no" title="statement not covered" >this[t]=255&amp;e,t+1}<span class="cstat-no" title="statement not covered" >,</span></span>a.prototype</span>.writeUInt16LE=function(<span class="fstat-no" title="function not covered" >e,</span>t,n){return e=<span class="cstat-no" title="statement not covered" >+e,t|=0,n||P(this,e,t,2,65535,0),a.TYPED_ARRAY_SUPPORT?(this[t]=255&amp;e,this[t+1]=e&gt;&gt;&gt;8):U(this,e,t,!0</span>),t+2},a.prototype.writeUIn<span class="fstat-no" title="function not covered" >t1</span>6BE=function(e<span class="cstat-no" title="statement not covered" >,t,n){return e=+e,t|=0,n||P(this,e,t,2,65535,0),a.TYPED_ARRAY_SUPPORT?(this[t]=e&gt;&gt;&gt;8,this[t+1]=255&amp;e):U(this,e,t,!1)</span>,t+2},a.prototype.writeUInt<span class="fstat-no" title="function not covered" >32</span>LE=function(e,<span class="cstat-no" title="statement not covered" >t,n){return e=+e,t|=0,n||P(this,e,t,4,4294967295,0),a.TYPED_ARRAY_SUPPORT?(this[t+3]=e&gt;&gt;&gt;24,this[t+2]=e&gt;&gt;&gt;16,this[t+</span>1]=e&gt;&gt;&gt;8,this[t]=255&amp;e):M(t<span class="fstat-no" title="function not covered" >hi</span>s,e,t,!0),t+4}<span class="cstat-no" title="statement not covered" >,a.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||P(this,e,t,4,4294967295,0),a.TYPED_ARRAY_SUPPORT?(this[t]=e&gt;&gt;&gt;24,this[t+1]=e&gt;&gt;&gt;16,this[t+2]=</span>e&gt;&gt;&gt;8,this[t+3]=255&amp;e):M(th<span class="fstat-no" title="function not covered" >is</span>,e,t,!1),t+4},<span class="cstat-no" title="statement not covered" >a.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);P(this,e,t,n,i-1,-i)}var o=0,a=1,s=0;for(this[t]=255&amp;e;++o&lt;n&amp;&amp;(a*=256);)e</span>&lt;0&amp;&amp;0===s&amp;&amp;0!==this[t+o-<span class="fstat-no" title="function not covered" >1]</span>&amp;&amp;(s=1),this[t+o<span class="cstat-no" title="statement not covered" >]=(e/a&gt;&gt;0)-s&amp;255;return<span class="cstat-no" title="statement not covered" > t+n},a.prototype.<span class="cstat-no" title="statement not covered" ></span>writeIntBE=function(e,</span>t</span>,n,r)<span class="cstat-no" title="statement not covered" >{i</span>f(<span class="cstat-no" title="statement not covered" >e=</span>+e<span class="cstat-no" title="statement not covered" >,t<span class="cstat-no" title="statement not covered" ></span>|=0,!r){var i=Math.pow(2,8*n-1);P(t<span class="cstat-no" title="statement not covered" >his,e,t,n,i-1,-i)}var o=n-1,a=1,s=0;for(this[t+o]=255&amp;e;--o&gt;<span class="cstat-no" title="statement not covered" >=</span></span>0&amp;&amp;(a*=256)</span>;)e&lt;0&amp;&amp;0===s&amp;&amp;0!==this[t<span class="fstat-no" title="function not covered" >+o</span>+1]&amp;&amp;(s=1),this[<span class="cstat-no" title="statement not covered" >t+o]=(e/a&gt;&gt;0)-s&amp;255;ret<span class="cstat-no" title="statement not covered" >urn t+n},a.prototy<span class="cstat-no" title="statement not covered" ></span>pe.writeInt8=function(</span>e</span>,t,n)<span class="cstat-no" title="statement not covered" >{ret</span>ur<span class="cstat-no" title="statement not covered" >n </span>e=<span class="cstat-no" title="statement not covered" >+e<span class="cstat-no" title="statement not covered" ></span>,t|=0,n||P(this,e,t,1,127,-128),a.TYPE<span class="cstat-no" title="statement not covered" >D_ARRAY_SUPPORT||(e=Math.floor(e)),e&lt;0&amp;&amp;(e=255+e+1),this[t]=<span class="cstat-no" title="statement not covered" >2</span></span>55&amp;e,t+1},a</span>.prototype.writeInt16LE<span class="fstat-no" title="function not covered" >=f</span>unction(e,t,n)<span class="cstat-no" title="statement not covered" >{return e=+e,t|=0,n||P(this,e,t,2,32767,-32768),a.TYPED_ARRAY_SUPPORT?(this[t]=255&amp;e,this[t+1]=e&gt;&gt;&gt;8):U(this,e,t,!0),t+2</span>},a.prototype.writeInt16BE<span class="fstat-no" title="function not covered" >=f</span>unction(e,t,n)<span class="cstat-no" title="statement not covered" >{return e=+e,t|=0,n||P(this,e,t,2,32767,-32768),a.TYPED_ARRAY_SUPPORT?(this[t]=e&gt;&gt;&gt;8,this[t+1]=255&amp;e):U(this,e,t,!1),t+2}</span>,a.prototype.writeInt32LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return e=+e,t|=0,n||P(this,e,t,4,2147483647,-2147483648),a.TYPED_ARRAY_SUPPORT?(this[t]=255&amp;e,this[t+1]=e&gt;&gt;&gt;8,this[t+2]=e</span>&gt;&gt;&gt;16,this[t+3]=e&gt;&gt;&gt;24):M(<span class="fstat-no" title="function not covered" >th</span>is,e,t,!0),t+4<span class="cstat-no" title="statement not covered" >},a.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||P(this,e,t,4,2147483647,-2147483648),e&lt;0&amp;&amp;(e=4294967295+e+1),a.TYPED_ARRAY_SUPPORT?(this[t]=e&gt;&gt;&gt;24,thi</span>s[t+1]=e&gt;&gt;&gt;16,this[t+2]=e&gt;<span class="fstat-no" title="function not covered" >&gt;&gt;</span>8,this[t+3]=25<span class="cstat-no" title="statement not covered" >5&amp;e):M(this,e,t,!1),t+4},a.prototype.writeFloatLE=function(e,t,n){return F(this,e,t,!0,n)},a.prototype.writeFloatBE=function(e,t,n){return F(this,e,t,!1,n)},a.prototype.writeDoubleLE=functi</span>on(e,t,n){return B(this,e,<span class="fstat-no" title="function not covered" >t,</span>!0,n)},a.proto<span class="cstat-no" title="statement not covered" >type.writeDoubleBE=functi</span>on(e,t,n){return B(this,e,<span class="fstat-no" title="function not covered" >t,</span>!1,n)},a.proto<span class="cstat-no" title="statement not covered" >type.copy=function(e,t,n,</span>r){if(n||(n=0),r||0===r||(r<span class="fstat-no" title="function not covered" >=t</span>his.length),t&gt;<span class="cstat-no" title="statement not covered" >=e.length&amp;&amp;(t=e.length),t</span>||(t=0),r&gt;0&amp;&amp;r&lt;n&amp;&amp;(r=n),r==<span class="fstat-no" title="function not covered" >=n</span>)return 0;if(0<span class="cstat-no" title="statement not covered" >===e.length||0===this.len</span>gth)return 0;if(t&lt;<span class="fstat-no" title="function not covered" >0)</span>throw new RangeE<span class="cstat-no" title="statement not covered" >rror("targetStart out of bounds");if(n&lt;0||n&gt;=this.length)throw new RangeError("sourceStart out <span class="cstat-no" title="statement not covered" >of bounds<span class="cstat-no" title="statement not covered" >"</span></span>);if(r&lt;0)throw new RangeError("s<span class="cstat-no" title="statement not covered" >ourceEnd <span class="cstat-no" title="statement not covered" >o</span></span>ut of <span class="cstat-no" title="statement not covered" >bounds");r&gt;this.length&amp;&amp;(r=this.length),e.length-t<span class="cstat-no" title="statement not covered" >&lt;</span></span>r-n&amp;&amp;(r=e.length-t+n);<span class="cstat-no" title="statement not covered" >var i,o=r-n;if(this===e&amp;&amp;n&lt;t&amp;&amp;t&lt;r)for(i=o-1;i&gt;=0;-<span class="cstat-no" title="statement not covered" >-</span></span>i)e[i+<span class="cstat-no" title="statement not covered" >t]=this[i+n];else if(o&lt;1e3||!a.TYPED_ARRAY_SUPPO<span class="cstat-no" title="statement not covered" >R</span></span>T)for(i=0;i&lt;o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set</span>.call(e<span class="cstat-no" title="statement not covered" >,thi<span class="cstat-no" title="statement not covered" ></span>s.subarray(n,n+o),t);r<span class="cstat-no" title="statement not covered" >eturn o},a.prototyp<span class="cstat-no" title="statement not covered" >e.fill=function(e,</span></span>t,n,<span class="cstat-no" title="statement not covered" >r){if("string"==typeof e){if("str<span class="cstat-no" title="statement not covered" >ing"==typeof t?(<span class="cstat-no" title="statement not covered" >r=t,t=0,n=this.len</span></span>gth)<span class="cstat-no" title="statement not covered" >:"string"==typeof n&amp;&amp;(r=n,n=this.length),1===e.length){v<span class="cstat-no" title="statement not covered" >a</span></span></span>r i=e.cha</span>rCodeAt(0);i&lt;256&amp;&amp;<span class="fstat-no" title="function not covered" >(e</span>=i)}if(void 0!==<span class="cstat-no" title="statement not covered" >r&amp;&amp;"string"!=typeof r)t<span class="cstat-no" title="statement not covered" >hrow new TypeError("encoding must be a string");if("string"==typeof r&amp;&amp;!a.isEncoding(r))throw new TypeErro<span class="cstat-no" title="statement not covered" >r("Unknown encod<span class="cstat-no" title="statement not covered" ></span>ing: "+r)}else<span class="cstat-no" title="statement not covered" ></span>"</span>number"==typeof e&amp;&amp;(e&amp;=255);if(t&lt;<span class="cstat-no" title="statement not covered" >0||this.length&lt;t||this.length&lt;n)throw new RangeEr<span class="cstat-no" title="statement not covered" >r</span></span>or("Out of range index");if(n&lt;=t)return<span class="cstat-no" title="statement not covered" > this;t&gt;&gt;&gt;=0,n=void 0===n?this.length:n&gt;&gt;&gt;0,e</span></span>||(e<span class="cstat-no" title="statement not covered" >=0);var o;if("number"==typeof<span class="cstat-no" title="statement not covered" > </span></span>e)for(o=t;o&lt;n;++o)this[o]=e;else{var<span class="cstat-no" title="statement not covered" > s=a.isBuffer(e)?e:W(new a(e,r).toString())<span class="cstat-no" title="statement not covered" >,</span></span>u=s.len<span class="cstat-no" title="statement not covered" >gth;for(o=0;<span class="cstat-no" title="statement not covered" >o</span></span>&lt;n-t;++o)this[o+t]=s[o%u]}return this};var te=/</span>[^+\/<span class="cstat-no" title="statement not covered" >0-9A-Za-z-_]/g}).call(<span class="cstat-no" title="statement not covered" >t,function(){ret<span class="cstat-no" title="statement not covered" >urn this}()</span></span>)},functio<span class="cstat-no" title="statement not covered" >n(e,t){"use strict";function n(e){var t=e</span>.l<span class="cstat-no" title="statement not covered" >ength;if(<span class="cstat-no" title="statement not covered" ></span>t%4&gt;0)throw new Er<span class="cstat-no" title="statement not covered" >ror("Invalid strin<span class="cstat-no" title="statement not covered" ></span></span>g</span>. Length mus</span>t </span>be a m<span class="cstat-no" title="statement not covered" >ultiple of 4");return</span>"="===e[t-<span class="fstat-no" title="function not covered" >2]</span>?2:"="===<span class="cstat-no" title="statement not covered" >e[t-1]?1:0}fu</span>nction<span class="fstat-no" title="function not covered" > r</span>(e){return 3*e.length/4-n(e)}funct<span class="fstat-no" title="function not covered" >io</span>n i(e){va<span class="cstat-no" title="statement not covered" >r t,r,i,o<span class="cstat-no" title="statement not covered" ></span>,a,s,u=e.<span class="cstat-no" title="statement not covered" >length;a=n(e),s=new c(3*u/4-a),i=a&gt;0?u-4:u;var f=0;for(t=0,r=0;t&lt;i<span class="cstat-no" title="statement not covered" >;</span></span>t+=4,r+=3)o=l[e.charCodeAt(t)]&lt;&lt;18|l[e</span>.charCode<span class="fstat-no" title="function not covered" >At</span>(t+<span class="cstat-no" title="statement not covered" >1)]&lt;&lt;12|l[e.charCodeAt(t+2</span>)]&lt;&lt;6|l[e<span class="fstat-no" title="function not covered" >.c</span>harCodeAt(t+3)],s[f++<span class="cstat-no" title="statement not covered" >]=o&gt;&gt;16&amp;2<span class="cstat-no" title="statement not covered" ></span>55,s[f++]=o&gt;&gt;8&amp;255,s[f++]=255&amp;o;retur</span>n 2==<span class="cstat-no" title="statement not covered" >=a<span class="cstat-no" title="statement not covered" ></span>?(o=l[e.charCodeAt(t)]&lt;&lt;2|<span class="cstat-no" title="statement not covered" >l[e.charCodeAt(t+1)]&gt;&gt;4,s[f++]=255&amp;o):1===a&amp;&amp;(o=l[e.charCodeAt(t)]&lt;&lt;10|l[e.charCodeAt(t+1)]&lt;&lt;4|l[e.charCodeAt(t+2)]&gt;&gt;2,s[f++]=o&gt;&gt;8&amp;255,s[f++]<span class="cstat-no" title="statement not covered" >=</span></span>255&amp;o),s}function o(e){return u[e&gt;&gt;18&amp;63]+u[e&gt;&gt;12&amp;63]+u[e&gt;&gt;6&amp;63]+u[63&amp;e]}function a(e,t,n){for(var r,i=[],a=t;a&lt;n;a+=3)r=(e[a]&lt;&lt;16)+(e[a+1]&lt;&lt;8)+e[a+2],i.push(o(r));return i.join("")}functio</span>n s(e){fo<span class="fstat-no" title="function not covered" >r(</span>var<span class="cstat-no" title="statement not covered" > t,n=e.length,r=n%3,i="",o=[],s=16383,l=0,c=n-r;l&lt;c</span>;l+=s)o.p<span class="fstat-no" title="function not covered" >us</span>h(a(e,l<span class="cstat-no" title="statement not covered" >,l+s&gt;c?c:l+s));return 1===r?<span class="cstat-no" title="statement not covered" >(t=e[n-1],i+=u[t&gt;&gt;2],i+=u[t&lt;&lt;4&amp;63],i+="=="):2<span class="cstat-no" title="statement not covered" >=</span></span>==r&amp;&amp;(t=(e[n-2]&lt;&lt;8</span>)+e[n-1],<span class="fstat-no" title="function not covered" >i+</span>=u[<span class="cstat-no" title="statement not covered" >t&gt;&gt;10],i+=u[t&gt;&gt;4&amp;63],i+=u[t&lt;&lt;2&amp;63],i+="="),o.push(i),o.join("")}<span class="cstat-no" title="statement not covered" >t.byteLength=r,t.toByteArra<span class="cstat-no" title="statement not covered" >y</span></span>=i,t.fromByteArray=s;for(var u=[],l=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+<span class="cstat-no" title="statement not covered" ></span>/",h=0,d=f.length;h&lt;d;++h)u[h]=f[h],l[f.charCodeA<span class="cstat-no" title="statement not covered" >t</span>(h)]=h;l["-".charCodeAt(0)]=62,l["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,r,i){var o,a,s=8*i-r-1,u=(1&lt;&lt;s)-1,l=u&gt;&gt;1,c=-7,f=n?i-1:0,h=n?-1:1,d=<span class="cstat-no" title="statement not covered" >e[t+f];for(f+=h,o=d&amp;(1&lt;&lt;-c)-1,d<span class="cstat-no" title="statement not covered" >&gt;</span></span>&gt;=-c,c+=s;c&gt;0;o=256*o+e[t+f],f+=h,c-=8);for(a=o&amp;</span>(<span class="fstat-no" title="function not covered" >1&lt;</span>&lt;-c)-1,o&gt;&gt;=-<span class="cstat-no" title="statement not covered" >c,c+=r;<span class="fstat-no" title="function not covered" >c&gt;</span>0;a=256*a+e[t+f],f+=h,c-=8);<span class="cstat-no" title="statement not covered" >if(0===o</span>)o<span class="cstat-no" title="statement not covered" >=1-l;else</span>{i<span class="cstat-no" title="statement not covered" >f(o==</span>=u<span class="cstat-no" title="statement not covered" >)re</span>tu<span class="cstat-no" title="statement not covered" >rn a?NaN</span>:(<span class="cstat-no" title="statement not covered" >d?-1:1)</span>*(<span class="cstat-no" title="statement not covered" >1/0);a+<span class="cstat-no" title="statement not covered" ></span>=Math.pow(2,r),o-=l}return(d?-1:1)*a*Math.pow(2,o-r)},t.write=fun<span class="cstat-no" title="statement not covered" >c</span>tion(e,t,n,r,i,o){var a,s,u,l=8*o-i-1,c=(1&lt;&lt;l)-1,f=c&gt;&gt;1,h=2<span class="cstat-no" title="statement not covered" >3</span>===i?Mat<span class="cstat-no" title="statement not covered" >h.pow(2</span>,-24<span class="cstat-no" title="statement not covered" >)-Math.po<span class="cstat-no" title="statement not covered" >w(2,-77):0,d=r?0:o-1,p=r?1:-<span class="cstat-no" title="statement not covered" >1</span></span>,v=t&lt;0||0===t&amp;&amp;1/t&lt;0?1<span class="cstat-no" title="statement not covered" ></span>:</span>0;for(t=Math.abs(t),isNaN(t)||t==</span>=1/0?(s=i<span class="fstat-no" title="function not covered" >sN</span>aN(t)?1:0,a=c):(a=Math.floor(Mat<span class="cstat-no" title="statement not covered" >h.log(t)</span>/M<span class="cstat-no" title="statement not covered" >ath.LN2),</span>t*<span class="cstat-no" title="statement not covered" >(u=Ma</span>th<span class="cstat-no" title="statement not covered" >.pow(2,-a))&lt;1&amp;&amp;(a--,u*=2),t+=a+f&gt;=1?h/u:h</span>*M<span class="cstat-no" title="statement not covered" >ath.pow(</span>2,<span class="cstat-no" title="statement not covered" >1-f),t*</span>u&gt;<span class="cstat-no" title="statement not covered" >=2&amp;&amp;(a++,u/=2),a+f&gt;=c?<span class="cstat-no" title="statement not covered" ></span>(s=0,a=c):a+f&gt;=1?(s=(t*u-1)*Math.pow(2,i),a+=f):(s=t*Math.pow(2,f-1)*Math.pow(2,i),a=0));i&gt;=8;e[n+d]=255&amp;s,d+=p,s/=256,i-=8);for(a=a&lt;&lt;i|s,l+=i;l&gt;0;e[n+d]=255&amp;a,d+=p,a/=256,l-=8);e[n+d-p]|=128*v}},46,function(e,t,n){(function(e){"use strict";var r=n(47),i=r.Buffer,o=r.SlowBuffer,a=r.kMaxLength||2147483647;t.all<span class="cstat-no" title="statement not covered" >o</span>c=function(e,t,n){if("function"==typeof i.alloc)retu<span class="cstat-no" title="statement not covered" >r</span>n i.alloc(e,t,n)</span>;i</span>f("n<span class="fstat-no" title="function not covered" >um</span>ber"==typeof n<span class="cstat-no" title="statement not covered" >)<span class="fstat-no" title="function not covered" >th</span>row new TypeError("encoding m<span class="cstat-no" title="statement not covered" >ust no</span>t <span class="cstat-no" title="statement not covered" >be number</span>")<span class="cstat-no" title="statement not covered" >;if("number"!</span>=t<span class="cstat-no" title="statement not covered" >ypeof e)throw new TypeErr<span class="cstat-no" title="statement not covered" ></span>or("size<span class="fstat-no" title="function not covered" > m</span>ust be a numbe<span class="cstat-no" title="statement not covered" >r");if(e&gt;a)throw new RangeErro<span class="cstat-no" title="statement not covered" >r("size is too large")<span class="cstat-no" title="statement not covered" >;</span></span>var r=n,o=t;void 0===<span class="cstat-no" title="statement not covered" >o&amp;&amp;(r=void 0,o=0);var s=new i(e);if("string"==typeo<span class="cstat-no" title="statement not covered" >f</span></span> o)for(var u=new i(o,<span class="cstat-no" title="statement not covered" >r),l=u.length,c=-1;++c&lt;e;)s[c]=u[c%l];else s.<span class="cstat-no" title="statement not covered" >f</span></span>ill(o)<span class="cstat-no" title="statement not covered" >;return s},t.allocUnsafe=function(e){if("fu</span></span>nctio<span class="cstat-no" title="statement not covered" >n"</span>==<span class="cstat-no" title="statement not covered" >ty<span class="cstat-no" title="statement not covered" ></span>peof i.allocUnsafe)return i.</span>alloc<span class="cstat-no" title="statement not covered" >Unsafe(e)<span class="cstat-no" title="statement not covered" ></span>;if("number"!=typeof e<span class="cstat-no" title="statement not covered" >)throw new TypeError("size must be a number"<span class="cstat-no" title="statement not covered" >);if(e&gt;a)thro</span></span>w ne<span class="cstat-no" title="statement not covered" >w RangeErr<span class="cstat-no" title="statement not covered" >o</span></span>r("size i</span>s too large");r<span class="fstat-no" title="function not covered" >et</span>urn new i(<span class="cstat-no" title="statement not covered" >e)},t.from=function(t,n,r){if("funct<span class="cstat-no" title="statement not covered" >ion"==typeof i.from&amp;&amp;(!e<span class="cstat-no" title="statement not covered" >.</span></span>Uint8Array||Uint8Arra<span class="cstat-no" title="statement not covered" >y.from!==i.from))return i.from(t,n,r);if("num<span class="cstat-no" title="statement not covered" >b</span></span>er"==t<span class="cstat-no" title="statement not covered" >ypeof t)throw new TypeError('"value" argum<span class="cstat-no" title="statement not covered" >e</span></span>nt must not be a</span> number'<span class="fstat-no" title="function not covered" >);</span>if("string"==t<span class="cstat-no" title="statement not covered" >ypeof t)return new i(t,n);if("undefined"!=typeof ArrayBuffer&amp;&amp;t instance<span class="cstat-no" title="statement not covered" >of ArrayBuffer){var o<span class="cstat-no" title="statement not covered" >=</span></span>n;if(1===arguments.le<span class="cstat-no" title="statement not covered" >ngth)return new i(t);"undefined"==typeof o&amp;&amp;(o=0);var a=r;if(<span class="cstat-no" title="statement not covered" >"</span></span>undefined"==typeof a&amp;<span class="cstat-no" title="statement not covered" >&amp;(a=t.byteLength-o<span class="cstat-no" title="statement not covered" >)</span></span>,o&gt;=t.byteLength)throw new RangeError("'offset' is out of bounds");<span class="cstat-no" title="statement not covered" >if<span class="cstat-no" title="statement not covered" ></span>(a&gt;t.byteLength-o)throw <span class="cstat-no" title="statement not covered" >new RangeError("<span class="cstat-no" title="statement not covered" >'</span></span>length' is out of bounds");re</span>turn <span class="cstat-no" title="statement not covered" >ne<span class="cstat-no" title="statement not covered" ></span>w i(t.slice(o,o+a))}if(i.isBuffer(t)){var s=new i(t.length);r<span class="cstat-no" title="statement not covered" >eturn t.copy(s,0,0,t.length),s}if(t){if(Array.isAr<span class="cstat-no" title="statement not covered" >r</span></span>ay(t)||"undefined"!<span class="cstat-no" title="statement not covered" >=typeof ArrayBuffer&amp;&amp;t.buffer instanceof ArrayBuff<span class="cstat-no" title="statement not covered" >e</span></span>r||"length"in t)return new i(<span class="cstat-no" title="statement not covered" ></span>t</span>);if("Buffer"===t.type&amp;<span class="cstat-no" title="statement not covered" >&amp;Array.isArray(t<span class="cstat-no" title="statement not covered" ></span>.data))return new i(t.data)}throw<span class="cstat-no" title="statement not covered" ></span> </span>new T<span class="cstat-no" title="statement not covered" >ypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")},t.al<span class="cstat-no" title="statement not covered" >locUnsafeSlow=fu<span class="cstat-no" title="statement not covered" >n</span></span>ction(e){if("function"==typeof i.allocUnsaf<span class="cstat-no" title="statement not covered" >eSlow)return i.allocUn<span class="cstat-no" title="statement not covered" ></span></span>s</span>afeSlow(e);if("number"!=typeof e)throw new TypeError("size must be a number");if(e&gt;=a)throw new RangeError</span>("size is too large<span class="fstat-no" title="function not covered" >")</span>;return ne<span class="cstat-no" title="statement not covered" >w o(e)}}).call(t,function(){return this}<span class="cstat-no" title="statement not covered" >())},function(e,t,n){(functi<span class="cstat-no" title="statement not covered" >o</span></span>n(e){function n(e){re<span class="cstat-no" title="statement not covered" >turn Array.isArray?Array.isArray(e):"[object <span class="cstat-no" title="statement not covered" >A</span></span>rray]"=<span class="cstat-no" title="statement not covered" >==g(e)}function r(e){return"boolean"==type<span class="cstat-no" title="statement not covered" >o</span></span>f e}function i(e</span>){</span>return nu<span class="fstat-no" title="function not covered" >ll</span>===e}func<span class="cstat-no" title="statement not covered" >tion o(e){ret</span>urn n</span>u<span class="fstat-no" title="function not covered" >ll</span>==e}function a<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >e)</span>{return"number"==ty<span class="fstat-no" title="function not covered" >pe</span>of <span class="cstat-no" title="statement not covered" >e}function s(e){return"string"==typeof e}function u(e){return"s</span>ymbol"==t<span class="fstat-no" title="function not covered" >yp</span>eof<span class="cstat-no" title="statement not covered" > e}function l(e){return voi</span>d 0===e}f<span class="fstat-no" title="function not covered" >un</span>cti<span class="cstat-no" title="statement not covered" >on c(e){return"[o</span>bject Reg<span class="fstat-no" title="function not covered" >Ex</span>p]"<span class="cstat-no" title="statement not covered" >===g(e)}function</span> f(e){ret<span class="fstat-no" title="function not covered" >ur</span>n"o<span class="cstat-no" title="statement not covered" >bject"==typeof e&amp;&amp;null!==e</span>}function<span class="fstat-no" title="function not covered" > h</span>(e)<span class="cstat-no" title="statement not covered" >{return"[object Date]"===g</span>(e)}funct<span class="fstat-no" title="function not covered" >io</span>n d<span class="cstat-no" title="statement not covered" >(e){return"[object Error]"</span>===g(e)||<span class="fstat-no" title="function not covered" >e </span>ins<span class="cstat-no" title="statement not covered" >tanceof Error}funct</span>ion p(e){<span class="fstat-no" title="function not covered" >re</span>tur<span class="cstat-no" title="statement not covered" >n"function"==typeof e}function v</span>(e){retur<span class="fstat-no" title="function not covered" >n </span>nul<span class="cstat-no" title="statement not covered" >l===e||"boolean"==typeof e||"number"</span>==typeof <span class="fstat-no" title="function not covered" >e|</span>|"s<span class="cstat-no" title="statement not covered" >tring"==typeof e||"symbol"==ty</span>peof e||"<span class="fstat-no" title="function not covered" >un</span>def<span class="cstat-no" title="statement not covered" >ined"==typeof e}function g(e){return Object.prototy</span>pe.toStri<span class="fstat-no" title="function not covered" >ng</span>.ca<span class="cstat-no" title="statement not covered" >ll(e)}t.isArray=n,t.isBoolea</span>n=r,t.isN<span class="fstat-no" title="function not covered" >ul</span>l=i<span class="cstat-no" title="statement not covered" >,t.isNullOrUndefined=o,t.isNumber=a,t.isString=s,t.isSymbol=u,t.isUndefined=l,t.isRegExp=c,t.isObject=f,t.isDate=h,t.isEr</span>ror=d,t.i<span class="fstat-no" title="function not covered" >sF</span>unc<span class="cstat-no" title="statement not covered" >tion=p,t.isPrimitive=v,t.isBuffer=e.isBuff<span class="cstat-no" title="statement not covered" ></span>er}).call(t,n(47).Buffer)},29,function(e,t,n){"use strict";function r(){this.head=null,this.tail=null,this.length=0}var i=(n(47).Buffer,n(51));e.exports=r,r.prototype.push=function(e){var t={data:e,next:null};this.len</span>gth&gt;0?this.tail.next=t:t</span>his.<span class="fstat-no" title="function not covered" >he</span>ad=t,this.tail=t,++this.length},r.pr<span class="fstat-no" title="function not covered" >ot</span>ot<span class="cstat-no" title="statement not covered" >ype.unshift=function(e){var t={data:e,next:th</span>is.head<span class="cstat-no" title="statement not covered" >};0===this.length&amp;&amp;</span>(<span class="cstat-no" title="statement not covered" >this.tail=t),this.head=t,++th<span class="fstat-no" title="function not covered" >is</span>.length},r.proto<span class="cstat-no" title="statement not covered" >type.shift=function<span class="cstat-no" title="statement not covered" ></span>(){if(0!==this.length){var e=this.head.data;return 1===this.length?thi</span>s.head=this.tail=null<span class="fstat-no" title="function not covered" >:t</span>his.head=this.he<span class="cstat-no" title="statement not covered" >ad.next,--this.length,e}<span class="cstat-no" title="statement not covered" ></span>},r.prototype.clear=function(){this.head=this.tail=null,th</span>is.length=0},r.prot<span class="fstat-no" title="function not covered" >ot</span>ype.join=<span class="cstat-no" title="statement not covered" >function(e){if(0===this.le<span class="cstat-no" title="statement not covered" >ngth)return"";f<span class="cstat-no" title="statement not covered" ></span>or(var t=this.head,n=""+t.data;t=t.next;)n+=e+t.data;return n},r.prototype.concat=function</span>(</span>e){if(0===this.leng<span class="fstat-no" title="function not covered" >th</span>)return i<span class="cstat-no" title="statement not covered" >.alloc(0);if(1===this.length)return this</span>.head.data;for(var<span class="fstat-no" title="function not covered" > t</span>=i.allocUn<span class="cstat-no" title="statement not covered" >safe(e&gt;&gt;&gt;0),n=this.<span class="cstat-no" title="statement not covered" >head,r=0;<span class="cstat-no" title="statement not covered" >n</span></span>;)n.data.copy(t,r),r+=n.data.length,n=n.n<span class="cstat-no" title="statement not covered" >ext;return t<span class="cstat-no" title="statement not covered" >}</span></span>},functio</span>n(e,t,n){"use strict<span class="fstat-no" title="function not covered" >";</span>function r<span class="cstat-no" title="statement not covered" >(e){return this ins<span class="cstat-no" title="statement not covered" >tanceof r?(l.call(<span class="cstat-no" title="statement not covered" >t</span></span>his,e),c.call(this<span class="cstat-no" title="statement not covered" >,e),e&amp;&amp;e.readable===!1<span class="cstat-no" title="statement not covered" >&amp;</span></span>&amp;(this.readable=!1),e&amp;&amp;e.writable===!1&amp;&amp;(this.wri<span class="cstat-no" title="statement not covered" >table=!1),this.allowHalfOpen=!0,e&amp;&amp;e.allowH<span class="cstat-no" title="statement not covered" >a</span></span>lfOpen===</span>!1</span>&amp;<span class="fstat-no" title="function not covered" >&amp;(</span>this.allowHalfOpen=!1),void this.onc<span class="fstat-no" title="function not covered" >e(</span>"en<span class="cstat-no" title="statement not covered" >d",i)):new r(e)}function i(){this.allowHalfOpen||this._writableState.ended||s(o,this)}function o(e){e.end()}var a=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};e.exports=r;var s=n(45),u=n(52);u.inherits=n(42);var l=n(</span>44),c=n(5<span class="fstat-no" title="function not covered" >6)</span>;u<span class="cstat-no" title="statement not covered" >.inherits(r,l);for(var f=a(c.prototype),h=0;h&lt;f.length;h++</span>){var d=f<span class="fstat-no" title="function not covered" >[h</span>];r<span class="cstat-no" title="statement not covered" >.prototyp</span>e[d]||<span class="cstat-no" title="statement not covered" >(r.prototype[<span class="fstat-no" title="function not covered" >d]</span>=c.prototype[d])<span class="cstat-no" title="statement not covered" >}},<span class="cstat-no" title="statement not covered" ></span>function(e,t,n)<span class="cstat-no" title="statement not covered" >{(function<span class="cstat-no" title="statement not covered" >(</span></span>t,r){"use</span> <span class="cstat-no" title="statement not covered" ></span>strict";funct</span>ion i<span class="cstat-no" title="statement not covered" >(){}fu</span>nc<span class="cstat-no" title="statement not covered" >tion o<span class="cstat-no" title="statement not covered" ></span>(e,t,n){this.chunk</span>=e,th<span class="cstat-no" title="statement not covered" >is.enc</span>od<span class="cstat-no" title="statement not covered" >ing=t,<span class="cstat-no" title="statement not covered" ></span>this.callback=n,<span class="cstat-no" title="statement not covered" >t</span>his.next=null}function a(e,t){T=T||n(55),e=e||{},t<span class="cstat-no" title="statement not covered" >his.o<span class="cstat-no" title="statement not covered" ></span>bjectMode=!!e.objectMode,t instanceof T&amp;&amp;(this.ob</span>j</span>e<span class="fstat-no" title="function not covered" >ct</span>Mode=this.obje<span class="cstat-no" title="statement not covered" >c<span class="fstat-no" title="function not covered" >tM</span>ode||!!e.writableObjectMode);var r<span class="fstat-no" title="function not covered" >=e</span>.highWaterMa<span class="fstat-no" title="function not covered" >rk</span>,i=this<span class="cstat-no" title="statement not covered" >.objectMode?16:16384;this.highWaterMark=r||0===r?r:i,this.hig</span>hWaterMar<span class="fstat-no" title="function not covered" >k=</span>~~thi<span class="cstat-no" title="statement not covered" >s.highWaterMark,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var o=e.decodeStrings===!1;this.decodeStrings</span>=!o,t<span class="cstat-no" title="statement not covered" >his.defaultEncod</span>in<span class="cstat-no" title="statement not covered" >g=e.defaultEncoding||"utf<span class="cstat-no" title="statement not covered" ></span>8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){v(t,e)},this.writecb=null,t</span>his.w<span class="cstat-no" title="statement not covered" >ritelen=0,this.buffer<span class="cstat-no" title="statement not covered" ></span>edRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new k(thi<span class="fstat-no" title="function not covered" >s)</span>}function <span class="cstat-no" title="statement not covered" >s(e){ret</span>urn T=T||n(55),C.call(s,this)||this instanceof T?(this._writableState=new a(e,this),this.writable=!0,e&amp;&amp;("function"==typeof e.write&amp;&amp;(this._write=e.write),"function"==typeof e.writev&amp;&amp;(this._writev=e.writev)),void </span>R.call(th<span class="fstat-no" title="function not covered" >is</span>)):<span class="cstat-no" title="statement not covered" >new s(e)}function u(e,t){var n=new Error("write after end");e.emit("error",n),E(t,n)}function l(e,t,n,r){var i=!0,o=!1;return null===n?o=new TypeError("May not write null values to stream"):O.isBuffer(n)||"string"==typeof n||void 0===n||t.ob</span>jectMode|<span class="fstat-no" title="function not covered" >|(</span>o=new TypeE<span class="cstat-no" title="statement not covered" >rror("Invalid non-string/buff<span class="cstat-no" title="statement not covered" ></span>er chunk")),o&amp;&amp;(e.emit("er</span>ror",o),E<span class="fstat-no" title="function not covered" >(r</span>,o),i=!1),i}fun<span class="cstat-no" title="statement not covered" >cti</span>on<span class="cstat-no" title="statement not covered" > c(<span class="cstat-no" title="statement not covered" ></span>e,t,n){return e.objectMode||e.decodeStrings===!1||"string"!=typeof t||(t=I.from(t,n)),t}function f(e,t,n,r,i){n=c(t,n,r),O.isBuffer(n)&amp;&amp;(r="buffer");var a=t.objectMode?1:n.length;t.length+=a;var s=t.length&lt;t.highWaterMark;i</span>f(s||(t.n<span class="fstat-no" title="function not covered" >ee</span>dDrain=<span class="cstat-no" title="statement not covered" >!0),t.writing||t.corked){var u=t.lastBufferedRequest;t.lastBufferedRequest=new o(n</span>,r,i),u?u<span class="fstat-no" title="function not covered" >.n</span>ext=t.lastB<span class="cstat-no" title="statement not covered" >ufferedRequest:t.bufferedRequest=t.lastB</span>uffer<span class="cstat-no" title="statement not covered" >edRequest,t.bufferedRequ<span class="cstat-no" title="statement not covered" ></span>estCount+=1}e</span>lse h<span class="cstat-no" title="statement not covered" >(e,t,!1,a,n,r,i);return s<span class="cstat-no" title="statement not covered" ></span>}function h(e,t,n,r,i,o,a){t.writelen=r,t.writecb=<span class="cstat-no" title="statement not covered" >a,t.writing=!0,t.sync=<span class="cstat-no" title="statement not covered" ></span>!0,n?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1}function d(e,t,n,r,i){--t.pendingcb,n?E(i,r):i(r),e._writableState.erro</span>rEmit<span class="cstat-no" title="statement not covered" >ted=!0,e.emit("err<span class="cstat-no" title="statement not covered" >o</span></span>r",r)}fun</span>ction p(e<span class="fstat-no" title="function not covered" >){</span>e.writing=!1,e.<span class="cstat-no" title="statement not covered" >writecb=null,e.length-=e.writelen,e.writelen=0}function v(e,t){var n=e._writableState,r=n.sync,i=n.writecb;i</span>f(p(n),t)<span class="fstat-no" title="function not covered" >d(</span>e,n,r,t,i);<span class="cstat-no" title="statement not covered" >else{var o=b(n);o||n.corked||n.bufferProcessing||!n.bufferedRequest||m(e,n),r?S(</span>g,e,n,o,i<span class="fstat-no" title="function not covered" >):</span>g(e<span class="cstat-no" title="statement not covered" >,n,o,i)}}function g(e,t,n,r){n||y(e,t),t.pendingcb--,r(),x(e,t)</span>}function<span class="fstat-no" title="function not covered" > y</span>(e,t){0===t<span class="cstat-no" title="statement not covered" >.length&amp;&amp;t.needDr</span>ai<span class="cstat-no" title="statement not covered" >n&amp;&amp;(t.n</span>ee<span class="cstat-no" title="statement not covered" >dDrain=!1,<span class="cstat-no" title="statement not covered" ></span>e.emit("dr<span class="cstat-no" title="statement not covered" >ain"))}functio</span>n m(e,t){t<span class="cstat-no" title="statement not covered" >.buff<span class="cstat-no" title="statement not covered" ></span>erProcessing=!0;var n=t.bufferedRequest;if(e._writev&amp;&amp;n&amp;&amp;n.next){var r=t.bufferedReques</span>t</span>Count,i=n<span class="fstat-no" title="function not covered" >ew</span> Array(r)<span class="cstat-no" title="statement not covered" >,o=t.corkedRequestsFree;o.entry=n;fo</span>r(var a=0<span class="fstat-no" title="function not covered" >;n</span>;)i[a<span class="cstat-no" title="statement not covered" >]=n,n=n.next,a+=1;h(e,t,!0,t.length,i,"",o.finish),t.pendingc</span>b++,t.las<span class="fstat-no" title="function not covered" >tB</span>uffer<span class="cstat-no" title="statement not covered" >edRequest=null,o.next?(</span>t.cor<span class="cstat-no" title="statement not covered" >kedRequestsFree=o.<span class="cstat-no" title="statement not covered" ></span>next,o.next=null):t.corkedReque<span class="cstat-no" title="statement not covered" >stsFree=new k(t)}else{f</span>or<span class="cstat-no" title="statement not covered" >(;n;){var s=n</span>.c<span class="cstat-no" title="statement not covered" >hunk,u=n.encoding,l=n<span class="cstat-no" title="statement not covered" ></span>.callback,<span class="cstat-no" title="statement not covered" >c</span>=t.objectMode?<span class="cstat-no" title="statement not covered" >1:s.length;if(h(e,t,!<span class="cstat-no" title="statement not covered" >1</span></span>,c,s,u,l),n=n.next,t.writing)break}null===n&amp;&amp;(t.lastBufferedRequest=null)}t.bufferedRequestCount=0,t.bufferedRequest=n,t.bufferProcessing=!1}function b(e</span>){ret<span class="cstat-no" title="statement not covered" >urn e.ending&amp;&amp;0<span class="cstat-no" title="statement not covered" >===e.len</span>gt<span class="cstat-no" title="statement not covered" >h&amp;&amp;null===e</span>.b<span class="cstat-no" title="statement not covered" >ufferedRequ</span>es<span class="cstat-no" title="statement not covered" >t&amp;&amp;!e.finished&amp;&amp;!e.writi<span class="cstat-no" title="statement not covered" ></span>ng}function w(e,t){t.prefinished||(t.pre<span class="cstat-no" title="statement not covered" >finishe<span class="cstat-no" title="statement not covered" ></span></span>d</span>=!0,e.emit("prefinish"))}function x(e,t<span class="cstat-no" title="statement not covered" ></span>)</span>{var n=b(t);return n&amp;&amp;(0===t.pendingcb?(w(e,t),t.finished=!0,e.emit</span>("finish"<span class="fstat-no" title="function not covered" >))</span>:w(<span class="cstat-no" title="statement not covered" >e,t)),n}function _(e,t,n){t.ending=!0,x(e,t),n&amp;&amp;(t.finished?E(n):e.once("finish",n</span>)),t.ende<span class="fstat-no" title="function not covered" >d=</span>!0,e.<span class="cstat-no" title="statement not covered" >writable=!1}function k(e){var t=this;this.next=null,thi</span>s.entry=n<span class="fstat-no" title="function not covered" >ul</span>l,this.fini<span class="cstat-no" title="statement not covered" >sh=fu<span class="cstat-no" title="statement not covered" ></span>nction(n){var r=t.entry;for(t.entry=null;r;){var i=r.callback;e.pendingcb--,i(</span>n),r=r.ne<span class="fstat-no" title="function not covered" >xt</span>}e.cork<span class="cstat-no" title="statement not covered" >edRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}}e.exports=s;var T,</span>E=n(45),S<span class="fstat-no" title="function not covered" >=!</span>t.browser<span class="cstat-no" title="statement not covered" >&amp;&amp;["v<span class="cstat-no" title="statement not covered" ></span>0.10","v0.9."].indexOf(t.version.slice(0,5)<span class="fstat-no" title="function not covered" >)&gt;</span>-1?r:E;s.Writabl<span class="cstat-no" title="statement not covered" >eState=a<span class="cstat-no" title="statement not covered" ></span>;var N=n(52);N.inherits=n(4<span class="cstat-no" title="statement not covered" >2);var R,j=<span class="cstat-no" title="statement not covered" ></span>{deprecate:n(57)};!function()<span class="cstat-no" title="statement not covered" ></span>{</span>try{R=n(40)}catch(e){}finally{R||(R=n(41).EventEmitter)}}();var O=n(47).</span>Bu<span class="cstat-no" title="statement not covered" ></span>ffer,I=n(51);</span>N.inher<span class="cstat-no" title="statement not covered" >its(s,</span>R)<span class="cstat-no" title="statement not covered" >,a.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=<span class="cstat-no" title="statement not covered" ></span>[];e;)t.push(e),e=e</span>.next<span class="cstat-no" title="statement not covered" >;retur<span class="cstat-no" title="statement not covered" ></span>n t},function(){tr</span>y{Objec<span class="cstat-no" title="statement not covered" >t.defineProperty(a<span class="cstat-no" title="statement not covered" ></span>.<span class="fstat-no" title="function not covered" >pr</span>ototype,"<span class="cstat-no" title="statement not covered" >buff<span class="cstat-no" title="statement not covered" >er",{get:</span>j.deprecate(functi<span class="cstat-no" title="statement not covered" >on(){return this.getBuffer(</span>)</span>},"_</span>writa<span class="cstat-no" title="statement not covered" >bleState.buff</span>er<span class="cstat-no" title="statement not covered" > is de<span class="cstat-no" title="statement not covered" ></span>precated. Use _writableState.getBuffer<span class="fstat-no" title="function not covered" > i</span>nstead.")<span class="cstat-no" title="statement not covered" >})}catch(e){}}();var C;"function"==type<span class="cstat-no" title="statement not covered" >of Symbol&amp;&amp;Symbol.h<span class="cstat-no" title="statement not covered" >a</span></span>sInstance</span>&amp;<span class="fstat-no" title="function not covered" >&amp;"</span>function"<span class="cstat-no" title="statement not covered" >==ty<span class="cstat-no" title="statement not covered" >peof Function.prototype[Symbol.hasInstance]?(C=Function.prot<span class="fstat-no" title="function not covered" >ot</span>ype[Symbo<span class="cstat-no" title="statement not covered" >l.hasInstance],Object.def</span>ineProperty(s,Symbol.hasInstance,{value:function(e){return!!C.call(this,e)||e&amp;&amp;e._</span>writableSta</span>te i</span>nstan<span class="cstat-no" title="statement not covered" >ceof a}})):C=function(e){return e instanceof this},s.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},s.prototype.write=function(e,t,n){var r=this._writableState,o=!1;return"function"==typeof t&amp;&amp;<span class="fstat-no" title="function not covered" >(n=t,t</span>=nu<span class="cstat-no" title="statement not covered" >ll),O.isBuffer(e)?t="buffer":t||(t=r.defaultEncoding),"fun</span>ction"!=typeof n&amp;&amp;(n=i),r.ended?u(this,n<span class="fstat-no" title="function not covered" >):</span>l(t<span class="cstat-no" title="statement not covered" >his,r,e,n)&amp;&amp;(r.pendingcb++</span>,o=f(this,r,e,t,n)<span class="fstat-no" title="function not covered" >),</span>o},s.prot<span class="cstat-no" title="statement not covered" >otype.cork=function(){var e=this._writableState;e.corked++}</span>,s.prototype.uncork<span class="fstat-no" title="function not covered" >=f</span>unction(){var e=this<span class="cstat-no" title="statement not covered" >._writableState;e.co</span>rk<span class="cstat-no" title="statement not covered" >ed&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||m(this,e))},s.prototype.setDefaultEncoding=function(e){<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >if("string"==typeof e&amp;&amp;(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())&gt;-1))<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._writableState.defaultEncoding=e,this},</span>s.prototype._write=f<span class="fstat-no" title="function not covered" >un</span>ction(e,t,n){n<span class="cstat-no" title="statement not covered" >(new Error("_write() is not implemented"))},s</span>.prototype._writev=null,s.prototype.end=fu<span class="fstat-no" title="function not covered" >nc</span>tion(e,t,n){var r=th<span class="cstat-no" title="statement not covered" >is._writableState;"f<span class="cstat-no" title="statement not covered" ></span>unction"==typeof e?(n=e,e=null,t=null):"function"==typeof t&amp;&amp;(n=t,t=null),null!==e&amp;&amp;void 0!==e&amp;&amp;this.write(e,t),r.corked&amp;&amp;(r.corked=1,this.uncork()),r.ending||r.finished||_(this,r,n)}}).</span>call(t,n(24),n(25).setImmediate)},funct<span class="fstat-no" title="function not covered" >io</span>n(e,t){(func<span class="cstat-no" title="statement not covered" >t<span class="fstat-no" title="function not covered" >io</span>n(t){function n(e,t<span class="fstat-no" title="function not covered" >){</span>function n(){i<span class="fstat-no" title="function not covered" >f(</span>!i<span class="cstat-no" title="statement not covered" >){if(r(<span class="cstat-no" title="statement not covered" >"throwDeprecation"))throw<span class="cstat-no" title="statement not covered" > new Error(t);r("tr<span class="cstat-no" title="statement not covered" >a</span></span>ceDeprecation")?console.trace(t):console.warn(t),i=!0}return<span class="cstat-no" title="statement not covered" ></span> </span>e.apply(this,arguments)}if(r("n<span class="cstat-no" title="statement not covered" ></span>oDeprecation"))return <span class="cstat-no" title="statement not covered" >e;var i=!1</span></span>;retu<span class="cstat-no" title="statement not covered" >rn <span class="cstat-no" title="statement not covered" ></span>n}function</span> r(e){try<span class="fstat-no" title="function not covered" >{i</span>f(!<span class="cstat-no" title="statement not covered" >t.lo<span class="cstat-no" title="statement not covered" >calStorage)return!1<span class="cstat-no" title="statement not covered" >}catch(e){</span></span>return!1}<span class="cstat-no" title="statement not covered" >var n=t.lo</span>c</span>alSto<span class="cstat-no" title="statement not covered" >rage[e];return nul<span class="cstat-no" title="statement not covered" ></span>l!=n&amp;&amp;"true"===String(n).toLowerCase()}e.exports=n<span class="cstat-no" title="statement not covered" ></span>}).call(t,fun</span>ction(){r<span class="fstat-no" title="function not covered" >et</span>urn this}<span class="cstat-no" title="statement not covered" >())},function</span>(e,t,</span>n<span class="fstat-no" title="function not covered" >){</span>function r(e){if(e&amp;&amp;!u(<span class="fstat-no" title="function not covered" >e)</span>)th<span class="cstat-no" title="statement not covered" >row new Erro<span class="cstat-no" title="statement not covered" >r("Unknown encoding: "+e)}function i(e){r</span></span>eturn e.t<span class="fstat-no" title="function not covered" >oS</span>tri<span class="cstat-no" title="statement not covered" >ng(this.encoding)}function o(e){th</span>is.charRe<span class="fstat-no" title="function not covered" >ce</span>ive<span class="cstat-no" title="statement not covered" >d=e.length%2,this.charLength=this.charReceived?2:0}function a(e){thi</span>s.charRec<span class="fstat-no" title="function not covered" >ei</span>ved<span class="cstat-no" title="statement not covered" >=e.length%3,this.charLength=this.charReceived?3:0}var s=n(47).Buffer</span>,u=s.i<span class="cstat-no" title="statement not covered" >sEncoding||fu</span>nc<span class="cstat-no" title="statement not covered" >tion(e){switch<span class="fstat-no" title="function not covered" >(e</span>&amp;&amp;e.toLowe<span class="cstat-no" title="statement not covered" >rCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:r<span class="cstat-no" title="statement not covered" >eturn!1}},</span>l=t.Str<span class="cstat-no" title="statement not covered" >ingDecoder</span>=</span>f</span>un<span class="cstat-no" title="statement not covered" >ction(e){switch(<span class="fstat-no" title="function not covered" >th</span>is.encodin<span class="cstat-no" title="statement not covered" >g=(e||"utf8").toLowerCase().replace(/[-_]/,""),r(e),this.encoding){case"utf8":this.surrogateSize=<span class="cstat-no" title="statement not covered" >3;break;case"ucs2":ca<span class="cstat-no" title="statement not covered" >s</span>e"utf1</span>6le":this.surrogateSize=<span class="cstat-no" title="statement not covered" >2,this.detectIncompleteChar=o;break;case"base64":<span class="cstat-no" title="statement not covered" >t</span>his.su</span>rrogateSize=<span class="cstat-no" title="statement not covered" >3,this.detectIncompleteChar=a;break;default:retur<span class="cstat-no" title="statement not covered" >n</span> void(</span>this.wr<span class="cstat-no" title="statement not covered" >ite=i)}this.charBuffer=new <span class="cstat-no" title="statement not covered" ></span>s</span>(6),this.charReceived=0,this.charLength=0};l.prototype.write=fu</span>n<span class="cstat-no" title="statement not covered" ></span>ction(e){for(var t<span class="fstat-no" title="function not covered" >="</span>";this.cha<span class="cstat-no" title="statement not covered" >rLength;){var n=e.length&gt;=this.charLe<span class="cstat-no" title="statement not covered" >ngth-this.charReceived?this.charLength-this.charReceived:e.length;if(e.copy(this.charBu<span class="cstat-no" title="statement not covered" ></span>ffer,this.charReceived,0,n),this.charReceived+=n,this.charReceived&lt;this.charLength)return"";e=e.slice(n,<span class="cstat-no" title="statement not covered" >e.length)<span class="cstat-no" title="statement not covered" >,</span></span>t=this.charBuffer.slice(0,this.charLength).toString(this.encoding);var r=t.charCodeAt(t.l</span>ength<span class="cstat-no" title="statement not covered" >-1);if(!(r&gt;=55296&amp;&amp;r&lt;=563<span class="cstat-no" title="statement not covered" ></span>19)){if(this.charReceived=<span class="cstat-no" title="statement not covered" >this.charLength=0,0===e.length)return t;break}this.c<span class="cstat-no" title="statement not covered" >harLength<span class="cstat-no" title="statement not covered" >+</span></span>=this.<span class="cstat-no" title="statement not covered" ></span>s</span>urrogateSize,t=""}this.detectIncompleteCh<span class="cstat-no" title="statement not covered" ></span>a</span>r(e);var i=e.length;this.char</span>Lengt<span class="cstat-no" title="statement not covered" >h&amp;&amp;(e.cop<span class="cstat-no" title="statement not covered" ></span>y(this.charBuffer,0,e.length-this.charReceived,i),i-=this.charReceived),t+=e.toString(this.encoding,0,i);var i=t.length-1,r=t.cha</span>rCode<span class="cstat-no" title="statement not covered" >At(i);if(r&gt;</span>=5<span class="cstat-no" title="statement not covered" >5296&amp;&amp;r&lt;=56319){<span class="cstat-no" title="statement not covered" ></span>var o=this.surrogateSize;retu<span class="cstat-no" title="statement not covered" >rn this.charLength+<span class="cstat-no" title="statement not covered" ></span>=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),e.copy(this.charBuffer,0,0,o),t.substring(0,i)}return t},l.prototype.de<span class="cstat-no" title="statement not covered" ></span>t</span>ectIncomp</span>leteChar=function(e){for(var t=e.l<span class="fstat-no" title="function not covered" >en</span>gth&gt;=3?3:e<span class="cstat-no" title="statement not covered" >.length;t&gt;0;t--){var n=e[e.length-t];if(1==t&amp;&amp;n&gt;<span class="cstat-no" title="statement not covered" >&gt;5==6){this.ch<span class="cstat-no" title="statement not covered" ></span>arLength=2;break}i<span class="cstat-no" title="statement not covered" >f(t&lt;=2&amp;&amp;n&gt;&gt;4==14){<span class="cstat-no" title="statement not covered" >t</span>his.ch<span class="cstat-no" title="statement not covered" ></span>a</span>rLength=3;break}if<span class="cstat-no" title="statement not covered" >(t&lt;=3&amp;&amp;n&gt;&gt;3==30){t<span class="cstat-no" title="statement not covered" >h</span>is.cha<span class="cstat-no" title="statement not covered" ></span>r</span>Length=4;break}}th<span class="cstat-no" title="statement not covered" >is.charReceived=t}<span class="cstat-no" title="statement not covered" >,</span>l.prot</span>o<span class="cstat-no" title="statement not covered" ></span>t</span>ype.end=function(e){</span>var t="";if(e&amp;&amp;e.<span class="fstat-no" title="function not covered" >le</span>ngth&amp;&amp;(t=this.wr<span class="cstat-no" title="statement not covered" >ite<span class="cstat-no" title="statement not covered" ></span>(e)),this.charReceived){var n=this.charReceived,r=this.char<span class="cstat-no" title="statement not covered" >Buffer,i=this.enco</span>di<span class="cstat-no" title="statement not covered" >ng;t+=r.slice(0,</span>n)<span class="cstat-no" title="statement not covered" >.toString(i)}r<span class="cstat-no" title="statement not covered" ></span>eturn t}},function(e,t,n){"us<span class="cstat-no" title="statement not covered" ></span>e</span> strict";</span>fu</span>n<span class="fstat-no" title="function not covered" >ct</span>ion r(e){this.afterTransform=functio<span class="fstat-no" title="function not covered" >n(</span>t,n<span class="cstat-no" title="statement not covered" >){return i(e,t,n)},t<span class="fstat-no" title="function not covered" >hi</span>s.needTransf<span class="cstat-no" title="statement not covered" >orm=!1,this.trans</span>forming=!1,this.writecb=null,this.writechunk=null,this.writeencoding=null}function i(e,t,n){var r=e._transfo</span>rmState;r<span class="fstat-no" title="function not covered" >.t</span>ransforming=!<span class="cstat-no" title="statement not covered" >1;var i=r.writecb;<span class="cstat-no" title="statement not covered" ></span>if(!i)return e.emit</span>("err<span class="cstat-no" title="statement not covered" >or",new Er<span class="cstat-no" title="statement not covered" ></span>ror("n<span class="cstat-no" title="statement not covered" >o writecb in Transform class"));r.writechunk=null,r.writecb=null,n<span class="cstat-no" title="statement not covered" >u</span></span>ll!==n&amp;&amp;void 0!==n&amp;&amp;e.push(n),i(t);var o=e._readableState;o.reading=!1</span>,(o.n<span class="cstat-no" title="statement not covered" >eedReadable||o.le<span class="cstat-no" title="statement not covered" ></span>ngth&lt;o.highWaterMark)&amp;&amp;e._read(o.highWaterMark)}function o(e){if(!(this instanceof </span>o))return<span class="fstat-no" title="function not covered" > n</span>ew <span class="cstat-no" title="statement not covered" >o(e);s.call(this,e),this<span class="cstat-no" title="statement not covered" >._transformState<span class="cstat-no" title="statement not covered" >=</span></span>new r(this);var t=this;this._readableState.needR</span>eadab<span class="cstat-no" title="statement not covered" >le=!0<span class="cstat-no" title="statement not covered" ></span>,this._readableState.sync=!1,e&amp;&amp;("function"==typeof e.transform&amp;&amp;(this._transform=e.transform),"function"==typeof e.flush&amp;&amp;(this._flush=e.flush)),this.once("prefinish",function(){"function"==typeof this.<span class="fstat-no" title="function not covered" >_f</span>lush?this<span class="cstat-no" title="statement not covered" >._flush(function(e,n){a(t,e,n)}):a(t)})}fun<span class="fstat-no" title="function not covered" >ct</span>ion a(e,t,n)<span class="cstat-no" title="statement not covered" >{if(t)retu</span>rn e.emi</span>t("</span>error",t)<span class="fstat-no" title="function not covered" >;n</span>ull!==n<span class="cstat-no" title="statement not covered" >&amp;&amp;voi<span class="cstat-no" title="statement not covered" >d 0!==n&amp;&amp;e.push(n);var r=<span class="cstat-no" title="statement not covered" >e</span></span>._writableState,i=e._transformSt</span>ate;i<span class="cstat-no" title="statement not covered" >f(r.length)throw </span>ne<span class="cstat-no" title="statement not covered" >w Error("Calling t<span class="cstat-no" title="statement not covered" ></span>ransform don<span class="cstat-no" title="statement not covered" >e when ws.length != 0");if(i.transforming)throw new Error("Cal<span class="cstat-no" title="statement not covered" >l</span></span>ing transform don<span class="cstat-no" title="statement not covered" >e when still transforming");return e.push(null)}e.exports=o;var s=<span class="cstat-no" title="statement not covered" >n</span></span>(55),u=n(52);u.inher<span class="cstat-no" title="statement not covered" ></span>its=n(42),u.i</span>nheri<span class="cstat-no" title="statement not covered" >ts(o,s</span>),<span class="cstat-no" title="statement not covered" >o.prot<span class="cstat-no" title="statement not covered" ></span>otype.push=function(e,t){return this._transformSta<span class="fstat-no" title="function not covered" >te</span>.needTransfo<span class="cstat-no" title="statement not covered" >rm=!1,s.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,n){</span>throw new Error("_transf<span class="fstat-no" title="function not covered" >or</span>m() is not imp<span class="cstat-no" title="statement not covered" >lemented")},o.prototype._write=function(e,t,n){var r</span>=this._transformStat<span class="fstat-no" title="function not covered" >e;</span>if(r.writecb=n,r.wri<span class="cstat-no" title="statement not covered" >techunk=e,r.writeenco<span class="cstat-no" title="statement not covered" ></span>ding=t,!r.transforming){var i=this._readableState;(r.needTransform||i.n<span class="cstat-no" title="statement not covered" >eedReadable||i.lengt<span class="cstat-no" title="statement not covered" ></span>h&lt;i.highWaterMark)&amp;&amp;this._read(i.highWaterMark)}},o.prototype._read=function(e){var t=this</span>.</span>_transformState;nul<span class="fstat-no" title="function not covered" >l!</span>==t.writechunk&amp;&amp;<span class="cstat-no" title="statement not covered" >t.writecb&amp;&amp;!t.transfo<span class="cstat-no" title="statement not covered" ></span>rming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0}},function(e,t,n){"use strict";function r(e</span>){</span>r<span class="fstat-no" title="function not covered" >et</span>urn this instanceof r?void i.call(th<span class="fstat-no" title="function not covered" >is</span>,e)<span class="cstat-no" title="statement not covered" >:new r(e)}e.exports=r;var i=n(59),o=n(52);o.inherits=n(<span class="cstat-no" title="statement not covered" ></span>42),o.inherit</span>s(r,i<span class="cstat-no" title="statement not covered" >),r.pr</span>ot<span class="cstat-no" title="statement not covered" >otype.<span class="cstat-no" title="statement not covered" ></span>_transform=function(e,t,n){n(null,e)}},function(e,t,n){e<span class="fstat-no" title="function not covered" >.e</span>xports=n(56)},<span class="cstat-no" title="statement not covered" >function(e,</span>t,</span>n<span class="fstat-no" title="function not covered" >){</span>e.exports=n(55<span class="cstat-no" title="statement not covered" >)},function(e,t,n</span>)<span class="fstat-no" title="function not covered" >{e</span>.exports=n(59)<span class="cstat-no" title="statement not covered" >},function(e,t,n)</span>{<span class="fstat-no" title="function not covered" >e.</span>exports=n(60)}<span class="cstat-no" title="statement not covered" >,function(e,t,n){</span>(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){fu<span class="cstat-no" title="statement not covered" >nction i(e,n){var</span> <span class="fstat-no" title="function not covered" >r=</span>{seen:[],styli<span class="cstat-no" title="statement not covered" >z<span class="fstat-no" title="function not covered" >e:</span>a};return arguments.l<span class="fstat-no" title="function not covered" >en</span>gth&gt;=3&amp;&amp;(r.<span class="cstat-no" title="statement not covered" >depth=arguments[2]),<span class="cstat-no" title="statement not covered" ></span>arguments.length&gt;=4&amp;&amp;(r.colors=arguments[3]),v(n)?r.showHidden=n:n&amp;&amp;t._extend(r,n),x(r.showHidden)&amp;&amp;(r.showHidden=!1),x(r.depth)&amp;&amp;(r.depth=2),x(r.colors)&amp;&amp;(r.colors=!1),x(r.customInspect)&amp;&amp;(r.customInspect=!0),r.colors&amp;&amp;(r.stylize=o),u(r,e,r.depth)}function o(e,t){var n=i.styles[t];return n?"["+i.co</span>lors[n][0<span class="fstat-no" title="function not covered" >]+</span>"m"+e+"["+<span class="cstat-no" title="statement not covered" >i.colors[n][<span class="cstat-no" title="statement not covered" ></span>1]+"m":e}function a(e,t){return e}function s(e){var t={};retur</span>n e.forEa<span class="fstat-no" title="function not covered" >ch</span>(func<span class="cstat-no" title="statement not covered" >tion(e,n){</span>t[e]=!0})<span class="fstat-no" title="function not covered" >,t</span>}function<span class="cstat-no" title="statement not covered" > u(<span class="cstat-no" title="statement not covered" ></span>e,n,r){if(e.custo<span class="fstat-no" title="function not covered" >mI</span>nspect&amp;&amp;n&amp;&amp;S<span class="cstat-no" title="statement not covered" >(n.inspec</span>t)&amp;&amp;n</span>.inspect!<span class="fstat-no" title="function not covered" >==</span>t.inspe<span class="cstat-no" title="statement not covered" >ct&amp;&amp;(!n.constructor||n.constructor.prototype!==n)){var i=n.inspect(r,e);return b(i)||(i=u(e,i,r)),i}var o=l(e,n);<span class="cstat-no" title="statement not covered" >if(o)return o;v<span class="cstat-no" title="statement not covered" ></span>ar a=Object.keys(n),v=s(a);if</span>(</span>e.sho<span class="cstat-no" title="statement not covered" >wHidden<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;(a=<span class="cstat-no" title="statement not covered" >Object.get</span></span>OwnPr<span class="cstat-no" title="statement not covered" >opertyNames(n))</span>,E<span class="cstat-no" title="statement not covered" >(n)&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>(a.indexOf("message")&gt;=0||a.indexOf("description")&gt;=0))return c(n);if(0===a.length){if(S(n)){var g=n.name?": "+n<span class="cstat-no" title="statement not covered" >.name:"";ret<span class="cstat-no" title="statement not covered" >u</span></span>rn e.stylize("[F<span class="cstat-no" title="statement not covered" >unction"+g+"]",<span class="cstat-no" title="statement not covered" >"special")}if(_(n))ret<span class="cstat-no" title="statement not covered" ></span>urn e.stylize(RegExp.prototype.toString.call(n)<span class="cstat-no" title="statement not covered" ></span>,</span>"regexp<span class="cstat-no" title="statement not covered" >");if(T(n))return e.stylize(Date.prototype.toString.call(n),"<span class="cstat-no" title="statement not covered" >d</span></span>ate");i<span class="cstat-no" title="statement not covered" >f(E(n))return c(n)}var y="",m=!1,w=["{","}"];if(p(n)&amp;&amp;(m=<span class="cstat-no" title="statement not covered" >!</span></span>0,w=["[<span class="cstat-no" title="statement not covered" >","]"]),S(n))</span></span>{</span>var x<span class="cstat-no" title="statement not covered" >=n.</span>na<span class="cstat-no" title="statement not covered" >me?</span>":<span class="cstat-no" title="statement not covered" > "+n.name:<span class="cstat-no" title="statement not covered" ></span>"";y=" [Function"+x+"]"}if(_(n)&amp;&amp;(y=" "+<span class="cstat-no" title="statement not covered" >RegExp.prototype.toStr<span class="cstat-no" title="statement not covered" ></span>ing.call(n)),T(n)&amp;&amp;(y=<span class="cstat-no" title="statement not covered" ></span>"</span> "+Date.prototype.toUTCString.call(n)),E(n)&amp;&amp;(y=" "+c(n)),0===a.length&amp;&amp;(!m||0==n.length))return w[0]+y+w[1];if(r&lt;0)return _(n)?e.stylize(RegExp.proto<span class="cstat-no" title="statement not covered" >type.toString.call(<span class="cstat-no" title="statement not covered" >n</span></span>),"reg<span class="cstat-no" title="statement not covered" >exp"):e.stylize("[Object]","special");e.seen.push(n);var k;return k=m?f(e,n,r,v,a):a.map(function(<span class="cstat-no" title="statement not covered" >t</span></span>){return h(e,n,</span>r,v,t<span class="cstat-no" title="statement not covered" >,m)}),e.seen.pop(),d(k,y,w)}fu<span class="fstat-no" title="function not covered" >nc</span>tion l(e,t<span class="cstat-no" title="statement not covered" >){if(x(t))return e.styl</span>ize("undefined","undefine</span>d");if(b(<span class="fstat-no" title="function not covered" >t)</span>){var<span class="cstat-no" title="statement not covered" > n="'"+J<span class="cstat-no" title="statement not covered" >SON.stringify(t).replace(/^"|"$/g,"").repl<span class="cstat-no" title="statement not covered" >a</span></span>ce(/'/g,"\\'")<span class="cstat-no" title="statement not covered" >.replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return m(t)?e.stylize(""+t,"numbe<span class="cstat-no" title="statement not covered" ></span>r"):v(t)?e.stylize(""+t,"boole<span class="cstat-no" title="statement not covered" ></span>a</span>n"):g(t)?e.stylize("null","null"):void 0}function c(e){return"["+Error.prototype.toString.call(e)+"]"}fun</span>ction f(e<span class="fstat-no" title="function not covered" >,t</span>,n,<span class="cstat-no" title="statement not covered" >r,i){for(var o=[],a=0,s=t.length;a&lt;s;++a)I(t,Str</span>ing(a))?o<span class="fstat-no" title="function not covered" >.p</span>ush(h(e,t,n<span class="cstat-no" title="statement not covered" >,r,String(a),!0)):o.push("");return <span class="cstat-no" title="statement not covered" >i.forEach(function(i){i.match(/^\d+$/)||o.push(h(e,t,n,r,i<span class="cstat-no" title="statement not covered" >,</span></span>!0))}),o}functio<span class="fstat-no" title="function not covered" >n </span>h(e,t,n,r,<span class="cstat-no" title="statement not covered" >i,o){var a,s,l;if(l=Object.getOwnPropertyDe</span>scrip</span>tor(t,i)|<span class="fstat-no" title="function not covered" >|{</span>value:t[i]},l.get?s=l.s<span class="cstat-no" title="statement not covered" >et?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&amp;&amp;(s=e.stylize("[Setter]","special")),I(r,i)||(a="["+i+"]"),s||(e.seen.indexOf(l.value)&lt;0?(s=g(n)?u(e,l.value,null):u(e,l.value,n-1),s.indexOf("\n")&gt;-1&amp;&amp;(s=o?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").<span class="fstat-no" title="function not covered" >ma</span>p(function<span class="cstat-no" title="statement not covered" >(e){return"   </span>"+e}).join("\n"))):s=e.stylize("[Circular]","s<span class="fstat-no" title="function not covered" >pe</span>cial")),x(<span class="cstat-no" title="statement not covered" >a)){if(o&amp;&amp;i.mat</span>ch(/^\d+$/))return s;a=JSON.stringify(""+i),a.match(/^"([a<span class="cstat-no" title="statement not covered" >-zA-Z_][a-zA-Z_0-9]*)"$<span class="cstat-no" title="statement not covered" >/)?(a=a.s<span class="cstat-no" title="statement not covered" >u</span></span>bstr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function d(e,t,n){var r=0,i=e.reduce(function(e,t){ret<span class="cstat-no" title="statement not covered" ></span>u</span>rn r++,t.indexOf</span>("\n")&gt;=0<span class="fstat-no" title="function not covered" >&amp;&amp;</span>r++,e+t.repla<span class="cstat-no" title="statement not covered" >ce</span>(/<span class="cstat-no" title="statement not covered" >\u001b\[\<span class="fstat-no" title="function not covered" >d\</span>d?m/g,"").le<span class="cstat-no" title="statement not covered" >ngth+1},0);return i&gt;60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[</span>0]+t<span class="cstat-no" title="statement not covered" ></span>+" "+e.join(", ")+" "+n[1]}function p(e){return Array.isArray(e)}function v(e){return"boolean"==type</span>of e}func<span class="fstat-no" title="function not covered" >ti</span>on <span class="cstat-no" title="statement not covered" >g(e){return null===e}func</span>tion y(e)<span class="fstat-no" title="function not covered" >{r</span>etu<span class="cstat-no" title="statement not covered" >rn null==e}function m(e){re</span>turn"numb<span class="fstat-no" title="function not covered" >er</span>"==<span class="cstat-no" title="statement not covered" >typeof e}function</span> b(e){ret<span class="fstat-no" title="function not covered" >ur</span>n"s<span class="cstat-no" title="statement not covered" >tring"==typeof e</span>}function<span class="fstat-no" title="function not covered" > w</span>(e)<span class="cstat-no" title="statement not covered" >{return"symbol"==typeof e}</span>function <span class="fstat-no" title="function not covered" >x(</span>e){<span class="cstat-no" title="statement not covered" >return void 0===e}function</span> _(e){ret<span class="fstat-no" title="function not covered" >ur</span>n k<span class="cstat-no" title="statement not covered" >(e)&amp;&amp;"[object RegExp]"===R</span>(e)}funct<span class="fstat-no" title="function not covered" >io</span>n k<span class="cstat-no" title="statement not covered" >(e){return"object"=</span>=typeof e<span class="fstat-no" title="function not covered" >&amp;&amp;</span>nul<span class="cstat-no" title="statement not covered" >l!==e}function T(e){return k(e)&amp;&amp;"[obje</span>ct Date]"<span class="fstat-no" title="function not covered" >==</span>=R(<span class="cstat-no" title="statement not covered" >e)}function E(e){return k(e)&amp;&amp;("[obj</span>ect Error<span class="fstat-no" title="function not covered" >]"</span>===<span class="cstat-no" title="statement not covered" >R(e)||e instanceof Error)}function S(</span>e){return<span class="fstat-no" title="function not covered" >"f</span>unc<span class="cstat-no" title="statement not covered" >tion"==typeof e}function N(e){return null===e||"boolean"==ty</span>peof e||"<span class="fstat-no" title="function not covered" >nu</span>mbe<span class="cstat-no" title="statement not covered" >r"==typeof e||"string"==type</span>of e||"sy<span class="fstat-no" title="function not covered" >mb</span>ol"<span class="cstat-no" title="statement not covered" >==typeof e||"undefined"==typeof e}function R(e){return Object.prototype.toString.call(e)}function j(e){return e&lt;10?"0"+e.</span>toString(<span class="fstat-no" title="function not covered" >10</span>):e<span class="cstat-no" title="statement not covered" >.toString(10)}function O(){var e=new Date,</span>t=[j(e.ge<span class="fstat-no" title="function not covered" >tH</span>our<span class="cstat-no" title="statement not covered" >s()),j(e.getMinutes()),j(e.getSeconds())].join(</span>":");retu<span class="fstat-no" title="function not covered" >rn</span>[e.getDa<span class="cstat-no" title="statement not covered" >te(),D[e.ge</span>tM<span class="cstat-no" title="statement not covered" >onth()],t].join(" ")}function I(e,t){return Object.prototype.has<span class="cstat-no" title="statement not covered" ></span>OwnProperty.call(e,t)}var C=/%[sdj%]/g;t.format=f</span>unction(e<span class="fstat-no" title="function not covered" >){</span>if(!b<span class="cstat-no" title="statement not covered" >(e)){for(var t=[],n=0;n&lt;arguments.length;n++)t.pus</span>h(i(ar<span class="cstat-no" title="statement not covered" >guments[n])<span class="cstat-no" title="statement not covered" ></span>);return <span class="fstat-no" title="function not covered" >t.</span>join(" ")}<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >1,r=arguments,o=r.length,a=String(e).rep<span class="cstat-no" title="statement not covered" >lace(C,function(e){if("%<span class="cstat-no" title="statement not covered" >%</span></span>"===e)return"%";if(<span class="cstat-no" title="statement not covered" ></span>n</span>&gt;=o)return e;switch(e){case"%s":return String(r[n++]);case"%d":return Number(r[n++]);case"%j":try{return JSON.stringify(r[n++])}catch(e){return"[Circular]"}default:return e}}),s=r[n];n&lt;o;s=r[++n])a+=g(s)||!k(s)?" "+s:" "+i(s);return a},t.deprecate=function(n,i){function o(){if(!a){if(r.throwD<span class="cstat-no" title="statement not covered" >eprecation)throw new Error(i);<span class="cstat-no" title="statement not covered" >r</span></span>.traceDep</span>recation?cons<span class="fstat-no" title="function not covered" >ol</span>e.trace(i):console.er<span class="fstat-no" title="function not covered" >ro</span>r(<span class="cstat-no" title="statement not covered" >i),a=!0<span class="cstat-no" title="statement not covered" >}return n.apply(this,a<span class="cstat-no" title="statement not covered" >rguments)}if(x(e.pr<span class="cstat-no" title="statement not covered" >o</span></span>cess))return function(){return t.deprecate(n,i).apply(this<span class="cstat-no" title="statement not covered" ></span>,</span>arguments)};if(r.noDeprecation=<span class="cstat-no" title="statement not covered" ></span>==!0)return n;va<span class="cstat-no" title="statement not covered" >r a=!1;<span class="fstat-no" title="function not covered" >re</span>turn o};v<span class="cstat-no" title="statement not covered" >ar A,L={};t.debuglog=function(e){if(x(A)&amp;&amp;(A=r.</span>e<span class="cstat-no" title="statement not covered" >n</span></span>v.NODE_DEBUG||""),e=e.t<span class="cstat-no" title="statement not covered" >oUpperCase</span></span>(),!L<span class="cstat-no" title="statement not covered" >[e]<span class="cstat-no" title="statement not covered" ></span>)if(new Re</span>gE</span>xp("\\b<span class="cstat-no" title="statement not covered" >"+e<span class="cstat-no" title="statement not covered" ></span>+"\\b","i")<span class="fstat-no" title="function not covered" >.t</span>est(A)){va<span class="cstat-no" title="statement not covered" >r n=r.pid;L[e]=function(){var r=t.format.apply(t,arguments<span class="cstat-no" title="statement not covered" >);console.error("%s %d: %s",e,n,r)}}else L[e]=fu<span class="cstat-no" title="statement not covered" >nction<span class="cstat-no" title="statement not covered" ></span>(){};<span class="fstat-no" title="function not covered" >re</span>turn L[e]},t.in<span class="cstat-no" title="statement not covered" >spect=i,i.colors={bold:[1,22<span class="cstat-no" title="statement not covered" ></span>],italic:[3,23],underline:[4,24],i</span>nv</span>erse:<span class="cstat-no" title="statement not covered" >[7,27<span class="fstat-no" title="function not covered" >],</span>white:[37,3<span class="cstat-no" title="statement not covered" >9</span></span></span>],grey:[90,3</span>9],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},i.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.isArray=p,t.isBoolean=v,t.isNull=g,t.isNullOrUndefined=y,t.isNumber=m,t.isString=b,t.isSymbol=w,t.isUndefined=x,t.isRegExp=_,t.isObject=k,t.isDate=T,t.isError=E,t.isFunction=S,t.isPrimitive=N,t.isBuffer=n(66);var D=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];t.log=function(){console.l</span>og("%<span class="cstat-no" title="statement not covered" >s - %s",O(),t.format.apply(t,arguments))},t.inherits=n(67),t._extend=funct<span class="cstat-no" title="statement not covered" ></span>ion(e,<span class="fstat-no" title="function not covered" >t)</span>{if(!t||!<span class="cstat-no" title="statement not covered" >k(t))return e;for(var n=Object.keys(t),r=n.length;r--;)e</span>[n[r]]=t[n[r]];return e}}).c<span class="fstat-no" title="function not covered" >al</span>l(t,function<span class="cstat-no" title="statement not covered" >(){return thi<span class="cstat-no" title="statement not covered" >s}(),n(24<span class="cstat-no" title="statement not covered" >)</span></span>)},function(e,t){e.exports=function(e){r<span class="cstat-no" title="statement not covered" >eturn e&amp;&amp;"object<span class="cstat-no" title="statement not covered" >"</span></span>==typeof </span>e&amp;</span>&amp;"functio<span class="fstat-no" title="function not covered" >n"</span>==typeof <span class="cstat-no" title="statement not covered" >e.copy&amp;&amp;"func</span>tion"==type</span>o<span class="fstat-no" title="function not covered" >f </span>e.fill&amp;&amp;"fun<span class="cstat-no" title="statement not covered" >ction"==ty<span class="fstat-no" title="function not covered" >pe</span>of e.readU<span class="cstat-no" title="statement not covered" >Int8}},42,function(e,t,n){function r(e){if(!(this instanceof r))return new r(e);i.call(this,{encoding:"utf8"}),this.</span>_w</span>rita<span class="fstat-no" title="function not covered" >bl</span>eState.objectMode=!0;va<span class="fstat-no" title="function not covered" >r </span>t=t<span class="cstat-no" title="statement not covered" >his,n=new a({write:funct<span class="cstat-no" title="statement not covered" >ion(e,n,r){t.pus<span class="cstat-no" title="statement not covered" >h</span></span>(e),r&amp;&amp;r()},end:function(e){t.push(null),e&amp;&amp;e()}},e);this._transf</span>orm=f<span class="cstat-no" title="statement not covered" >uncti</span>on<span class="cstat-no" title="statement not covered" >(e,t,r){n.addTriple(e,r)},this._flush=function(<span class="fstat-no" title="function not covered" >e){n.e</span>nd(e)}}<span class="cstat-no" title="statement not covered" >var i=n(40).Transf</span>orm,o=n(65),a=n(69);o.inherits(r,i),e.e<span class="fstat-no" title="function not covered" >xpor</span>ts=<span class="cstat-no" title="statement not covered" >r},function(e,t){func</span>tion <span class="cstat-no" title="statement not covered" ></span>n(e,t){if(!(this<span class="fstat-no" title="function not covered" > i</span>nstanceof n))r<span class="cstat-no" title="statement not covered" >eturn new n(e,t);i</span>f(e&amp;&amp;"functio<span class="fstat-no" title="function not covered" >n"</span>!=typeof e<span class="cstat-no" title="statement not covered" >.write&amp;&amp;(t</span>=e</span>,e=nul<span class="cstat-no" title="statement not covered" >l),t=t||{},e)thi</span>s.<span class="cstat-no" title="statement not covered" >_outpu</span>tS<span class="cstat-no" title="statement not covered" >tream=<span class="cstat-no" title="statement not covered" ></span>e,this._endStream=void 0===t.</span>e<span class="fstat-no" title="function not covered" >nd</span>||!!t.end;else{var r=<span class="fstat-no" title="function not covered" >""</span>;this<span class="cstat-no" title="statement not covered" >._outputStream={write:fu<span class="cstat-no" title="statement not covered" >nction(e,t,n){r+=e<span class="cstat-no" title="statement not covered" >,</span></span>n&amp;&amp;n()},end:function(e){e&amp;&amp;e(null,r)}},this._endStream=!<span class="cstat-no" title="statement not covered" >0}this._subject=null,/triple|quad/i.test(t.format)?this._write</span>Triple=thi<span class="cstat-no" title="statement not covered" >s._<span class="cstat-no" title="statement not covered" ></span>writeTripleLine:(this._graph="",this._prefixIRIs=Object.crea<span class="fstat-no" title="function not covered" >te(nul</span>l),t.pr<span class="cstat-no" title="statement not covered" >efixes&amp;&amp;this.</span>addPrefixes(t.prefixes))}function r(e){<span class="fstat-no" title="function not covered" >var </span>t=l<span class="cstat-no" title="statement not covered" >[e];return voi</span>d 0===t&amp;&amp;(1===e.length<span class="cstat-no" title="statement not covered" ></span>?</span>(t=e.charCodeAt(0).toString(16),t="\\u0000".substr(0,6-t.length)+t):(t=(1024*(e.charCodeAt(0)-55296)+e.charCodeAt(1)+9216).toString(16),t="\\U00000000".substr(0,10-t.length)+t)),t}var </span>i=/^"([^]<span class="fstat-no" title="function not covered" >*)</span>"(?:\^\^(<span class="cstat-no" title="statement not covered" >.+)|@<span class="cstat-no" title="statement not covered" ></span>([\-a-z]+))?$/i,o="http://www.w3.org/1999/02/22-rdf-syntax-ns#",a=o+"type",s=/["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/,u=/["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g,l={"\\":"\\\\",'"':'\\"',"\t</span>":"\\t<span class="cstat-no" title="statement not covered" >","\n":"\\n","\r":"\\r","\b":"\\b","\f"</span>:"<span class="cstat-no" title="statement not covered" >\\f"};n.prototype={_write:function(e,t){this._</span>ou<span class="cstat-no" title="statement not covered" >tputStrea</span>m.<span class="cstat-no" title="statement not covered" >write(e,"utf8",t)},_writeTriple:function(e,t</span>,n<span class="cstat-no" title="statement not covered" >,r,i){try{this._graph!==r&amp;&amp;(this._write((null===this._subject?"</span>":<span class="cstat-no" title="statement not covered" >this._graph?"\n}\n":".\n")+(r?this._encodeIriOrBlankNode(r)+" {\n":"")),this._s<span class="cstat-no" title="statement not covered" ></span>ubject=null,this._graph="["!==r[0]?r:"]"),this._subjec<span class="fstat-no" title="function not covered" >t===e?t</span>his._<span class="cstat-no" title="statement not covered" >predicate===t?this._write(", "+this._e</span>ncodeObject(n),i):this._write(";\n    "+this._en<span class="fstat-no" title="function not covered" >codePredicate</span>(this._pred<span class="cstat-no" title="statement not covered" >icat<span class="cstat-no" title="statement not covered" >e=t)+" "+this._encodeObject(n),i):this._write((null===this._subject?"":".\n")+this._encodeSubject(this._subject=e)+" "+this._encodePredicate(this._predicate=t)+" "+this._encodeObject(n),i)}catch(e){i&amp;&amp;i(e)}},_writeTripleLine:function(e,t,n,r,i){delete this._prefixMatch;try{this._write(this._encodeIriOrBlankNode(e)+" "+this._encodeIriOrBlankNode(t)+" "+this._encodeObject(n)+(r?" "+this._encodeIriOrBlankNode(r)+".\n":".\n"),i)}catch(e){i&amp;&amp;i(e)}},_encodeIriOrBlankNode:function(e){var t=e[0];if("["===t|</span>|"("===t|<span class="cstat-no" title="statement not covered" >|"_"===t&amp;</span>&amp;</span>":"===e[1])return e;s.test(e)&amp;&amp;(e=e.replace(u,r));va<span class="fstat-no" title="function not covered" >r n=this._prefixR</span>egex.exec(e<span class="cstat-no" title="statement not covered" >);return n?n[1]?this._pre<span class="cstat-no" title="statement not covered" >f</span>ixI<span class="cstat-no" title="statement not covered" >RIs[n[1]]+n[2]:e:"&lt;"+e+"&gt;"},_encodeLiteral:function(e,t,n){return s.test(e)&amp;&amp;(e=e.replace(u,r)),n?'"'+e+'"@'+n:t?'"'+e+'"^^'+this._encodeIriOrBlankNode(t):'</span>"'+e+'"'}<span class="cstat-no" title="statement not covered" >,_encodeS</span>u</span>bject:function(e){if('"'===e[0])throw new Error("A litera<span class="fstat-no" title="function not covered" >l as subject is not al</span>lowed: "+<span class="cstat-no" title="statement not covered" >e);re<span class="cstat-no" title="statement not covered" ></span>turn"["===e[0]&amp;&amp;(this._subject="]"),this.<span class="cstat-no" title="statement not covered" >_encodeIr<span class="cstat-no" title="statement not covered" >i</span></span>OrBlankNode(e)},_encodePredica</span>te:fu<span class="cstat-no" title="statement not covered" >nction(e){if('"'===e[0])th<span class="cstat-no" title="statement not covered" ></span>row new Error("A literal as predicate is not allowed: "</span>+e);return e===a?"a":this._encodeIriOrBlankNode(e)<span class="fstat-no" title="function not covered" >},_encodeObject</span>:functi<span class="cstat-no" title="statement not covered" >on(e){if('"'!==e[0])return this._encodeIriOrBlankNode(e);var t=i.exec(e);if(!t)throw new Error("Invalid lit</span>eral: "+e);return this._encodeLiteral(t[1],t[2],t[<span class="fstat-no" title="function not covered" >3])},_blockedWr</span>ite<span class="cstat-no" title="statement not covered" >:function(){th<span class="cstat-no" title="statement not covered" >row new Error("Cannot write because the writer has been clo<span class="cstat-no" title="statement not covered" >s</span></span>ed.")},addTriple:function(e,t,n,r,i){void 0===n?this._writeTriple(e.</span>subject,e.predicate,e.object,e.graph||"",t):"string"<span class="fstat-no" title="function not covered" >!=typeof r?this._</span>wri<span class="cstat-no" title="statement not covered" >teTriple(e,t,n<span class="cstat-no" title="statement not covered" >,"",r):this._writeTriple(e,t,n,r,i)},addTriples:function(e){f<span class="cstat-no" title="statement not covered" >o</span></span>r(var t=0;t&lt;e.length;t++)this.addTriple(e[t])},</span>addPrefix:function(e,t,n){var r={};r[e]=t,this.ad<span class="fstat-no" title="function not covered" >dPrefixes(r,n)</span>},a<span class="cstat-no" title="statement not covered" >ddPrefixes:fun<span class="cstat-no" title="statement not covered" >ction(e,t){var n=this._prefixIRIs,r=!1</span></span>;for(<span class="cstat-no" title="statement not covered" >var i in e<span class="cstat-no" title="statement not covered" ></span>){var <span class="cstat-no" title="statement not covered" >o=e[i];/[#\/]$/.test(o)&amp;&amp;n[o]!==(i+=":"<span class="cstat-no" title="statement not covered" >)</span></span>&amp;&amp;(r=!0,n[o]=i,null!==this._subject&amp;&amp;(this.</span>_write(this._graph?"\n}\n":".\n"),this._subject=n<span class="fstat-no" title="function not covered" >ull,this._grap</span>h=<span class="cstat-no" title="statement not covered" >""),this._write("@prefix "+i+" &lt;"+o+"&gt;.\n"))}if(r){var a="",s="";for(</span>var u in n)a+=a?"|"+u:u,s+=(s?"|":"")+n[u];a=<span class="fstat-no" title="function not covered" >a.replace(</span>/[\]\/\(\)\<span class="cstat-no" title="statement not covered" >*\+\?\.\\\$]/g,"\\$&amp;"),this._prefixRegex=new RegExp("^(?:"+s+")[^/]*$|^("+a+")([a-zA-Z][\\-_a-zA-Z0-9]*)$")}this._write(r?"\n":"",t)},blank:function(e,t){</span>var n,r,i=e;switch(void 0===e?i=[]:"string"==t<span class="fstat-no" title="function not covered" >ypeof e?i=[</span>{pr<span class="cstat-no" title="statement not covered" >edicate:e,object:t}]:"lengt<span class="cstat-no" title="statement not covered" >h"in e||(i=[e]),r=i.le</span></span>ngth){case 0:return"[]";case 1:if(n=i[0],"["!<span class="fstat-no" title="function not covered" >==n.object</span>[0])return"[ <span class="cstat-no" title="statement not covered" >"+t<span class="cstat-no" title="statement not covered" ></span>his._encodePredicate(n.predica</span>te)+" "+this._encodeObject(n.object)+" ]";defau<span class="fstat-no" title="function not covered" >lt:for(var o</span>="[",a=0;a&lt;<span class="cstat-no" title="statement not covered" >r;a++)n=i[a],n.pr</span>ed<span class="cstat-no" title="statement not covered" >ica<span class="cstat-no" title="statement not covered" ></span>te===e?o+=", "+this._e<span class="cstat-no" title="statement not covered" >ncode<span class="cstat-no" title="statement not covered" ></span>Object(n.object):(o+=(a?";\n  ":"\n  ")+this._encodePredicate(n.predicate)+" "+this._encodeObject(n.object),e=n.predicate);return o+"\n]"}},list:function(e){for(var t=e&amp;&amp;e.length||0,n=new<span class="cstat-no" title="statement not covered" ></span> </span>Array(t),r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;t<span class="cstat-no" title="statement not covered" >;r+<span class="cstat-no" title="statement not covered" ></span>+)n[r]=this._en<span class="cstat-no" title="statement not covered" >codeObject(e[r]);return"("+n.joi<span class="cstat-no" title="statement not covered" >n</span></span>(" ")+")"},_prefixRegex:/$0^/,end:function(e){null!==this._subject&amp;&amp;(this._write(this._graph?"\n}\n":".\n"),this._subject=null),thi<span class="cstat-no" title="statement not covered" ></span>s</span>._write=this._blockedWrit</span>e;var t=e&amp;&amp;function(n,r){t=null,e(n,r)};i<span class="fstat-no" title="function not covered" >f(this</span>._endStream)try<span class="cstat-no" title="statement not covered" >{r<span class="cstat-no" title="statement not covered" ></span>eturn this._outputStream.end(t)}catch(e){}t&amp;&amp;t()}},e.exports=n},function(e,t,n){"use strict";var r=n(8),i=n(12<span class="cstat-no" title="statement not covered" >),o=n(7),a=n</span>(5),s=<span class="cstat-no" title="statement not covered" >n(14),u=function(){function <span class="cstat-no" title="statement not covered" >e(e){return encodeURI(e)}function t(e){for(var t,n="",r=0;r&lt;e.length;r++)t=e.charCode</span></span>At(r),n<span class="cstat-no" title="statement not covered" >+=t&gt;65535?"\\U"+("00000000<span class="cstat-no" title="statement not covered" >"+t.toString(16)).slice(-8):t&gt;126?"\\u"+("0000"+t.toString(16)).slice(-4):e[r];return n}var n=function(e){this.flags="",this.base=null,this.prefixes=[],this.namespace<span class="cstat-no" title="statement not covered" >s</span></span>=[],this.sugges</span>t</span>Prefix("rdf","http://www.w3.org/1999/02/<span class="fstat-no" title="function not covered" >22-rd</span>f-s<span class="cstat-no" title="statement not covered" >yntax-ns#"),this.suggestPrefix("xml","reserved:reser<span class="cstat-no" title="statement not covered" >vedForFutureUse"),this.namespa<span class="cstat-no" title="statement not covered" >c</span></span>esUsed=[],this.keywords=["</span>a"],this.prefixchars="abcdefghijklmnopqustuvwxyzABCDEFGHIJ<span class="fstat-no" title="function not covered" >KLMN</span>OPQ<span class="cstat-no" title="statement not covered" >RSTUVWXYZ",this.incoming=null,this.formulas=[],this.store=e};n.prototype.setBase=function(e){return this.base=e,th</span>is},n<span class="cstat-no" title="statement not covered" >.pr<span class="fstat-no" title="function not covered" >ot</span>otype.setFla<span class="cstat-no" title="statement not covered" >gs=function(e){</span>r<span class="cstat-no" title="statement not covered" ></span>eturn this.flags=e?<span class="cstat-no" title="statement not covered" >e:""<span class="cstat-no" title="statement not covered" >,this},n.prototype.toStr=function(</span>e){var t=e<span class="cstat-no" title="statement not covered" >.</span></span>toNT();</span>return"formula"</span>=<span class="fstat-no" title="function not covered" >=e</span>.termType&amp;&amp;(this.formulas[t]=e),t<span class="cstat-no" title="statement not covered" >},n.p</span>ro<span class="cstat-no" title="statement not covered" >totype</span>.f<span class="cstat-no" title="statement not covered" >romSt</span>r=<span class="cstat-no" title="statement not covered" >funct</span>io<span class="cstat-no" title="statement not covered" >n(e){i</span>f(<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >"{</span>"==e[0]){var t=thi<span class="fstat-no" title="function not covered" >s.</span>for<span class="cstat-no" title="statement not covered" >mulas[e];return t||co</span>nsole.log<span class="fstat-no" title="function not covered" >("</span>No <span class="cstat-no" title="statement not covered" >formula object for "+e),t}return t<span class="cstat-no" title="statement not covered" >his.store.fromNT(e)},n.prototype.suggestPrefix=function(e,t){"default"!==e.slice(0,7)&amp;&amp;"ns"!==e.slice(0,2)&amp;&amp;e&amp;&amp;t&amp;&amp;(e in this<span class="cstat-no" title="statement not covered" >.</span></span>namespace</span>s||t i<span class="cstat-no" title="statement not covered" >n this.pr<span class="fstat-no" title="function not covered" >ef</span>ixe<span class="cstat-no" title="statement not covered" >s||(this.prefixes[t]=e,this.namespaces[e]=t))},n.prototype.suggestNamespaces=function(e){for(var t in e)return this.suggestPrefix(t,e[t]),this},n.prototype.checkIntegrity=function(){var e,t;for(e in this.namespaces)if(this.prefixes[this.namespaces[e]]!==e)throw"Serializer integity error 1: "+e+", "+this.namespaces[e]+", "+this.prefixes[this.namespaces[e]]+"!</span>"<span class="cstat-no" title="statement not covered" ></span>;for(t in this.prefi<span class="fstat-no" title="function not covered" >xe</span>s)if(this.<span class="cstat-no" title="statement not covered" >namespaces[this.prefixes[</span>t]]!==t)throw"Serializ<span class="fstat-no" title="function not covered" >er</span> integity <span class="cstat-no" title="statement not covered" >error 2: "+t+", "+this.prefixs[</span>t]+", "+this.namesp<span class="fstat-no" title="function not covered" >ac</span>es[this.prefixes<span class="cstat-no" title="statement not covered" >[t]]+"!"}<span class="cstat-no" title="statement not covered" ></span>,n.prototype.makeUpPrefix=function(e){function t(t){r</span>eturn!!n.prototype.va<span class="fstat-no" title="function not covered" >li</span>dPrefix.te<span class="cstat-no" title="statement not covered" >st(t)&amp;&amp;("ns"!==t&amp;&amp;(!<span class="cstat-no" title="statement not covered" >(t in this.namesp<span class="cstat-no" title="statement not covered" ></span>aces)&amp;&amp;(this.prefixes[e]=t,this.namespaces[t]=e,r=t,!<span class="cstat-no" title="statement not covered" ></span>0</span>)))}var r,i=e;t=t.bind(this)</span>,"#/".indexOf(i[i.length-1]<span class="fstat-no" title="function not covered" >)&gt;</span>=0&amp;&amp;(i=i.sli<span class="cstat-no" title="statement not covered" >ce(0,-1));var o=i.lastIndexOf("/");o&gt;=0&amp;&amp;(i=i.slice(o+1));for(var a=0;a&lt;i.length&amp;&amp;this.prefixchars.indexOf(i[a]);)a++;if(i=i.slice(0,a),i.le</span>ngth&lt;6&amp;&amp;t(i))return r;if(t(i.sl<span class="fstat-no" title="function not covered" >ic</span>e(0,3)))re<span class="cstat-no" title="statement not covered" >turn r;if(t(i.s<span class="cstat-no" title="statement not covered" >lice(0,2)))return r;if(t(i.slice(0,4)))r</span></span>eturn r;if(t(i.slice(0,1)))r<span class="fstat-no" title="function not covered" >et</span>urn r;if(t(i.slic<span class="cstat-no" title="statement not covered" >e(0,5)))return r;n.protot<span class="cstat-no" title="statement not covered" >ype.validPrefix.test(i)||(i="n");for(var <span class="cstat-no" title="statement not covered" >a=0;;a++)if(t(i.slice(0,3)+a))return r},n.prototype.rootSubjects=function(e){for(var t={},n={},r={},i=0;i&lt;<span class="cstat-no" title="statement not covered" >e</span></span></span>.length;i++){var o=e[i<span class="cstat-no" title="statement not covered" >],a=[o.subject,o.predicate,o.object];a.ma<span class="cstat-no" title="statement not covered" >p(function(e){"BlankNode"==e.termType&amp;&amp;(r[e.toNT()]=!0)});var s=e[i].object;t.hasOwnProperty(s)||(t[s]=[</span></span></span>]),t[s].push(o.subject);va<span class="fstat-no" title="function not covered" >r </span>u=n[this.toStr(o.su<span class="fstat-no" title="function not covered" >bj</span>ect<span class="cstat-no" title="statement not covered" >)];u||(u=[]),u.push(o),n[this.toStr(o.subject)]=u}var l=[];for(var c in n)if(n.hasOwnProperty(c)){var s=this.fromStr(c);"Blank</span>Node"==s<span class="cstat-no" title="statement not covered" >.t<span class="cstat-no" title="statement not covered" ></span>ermType&amp;&amp;t[s]&amp;&amp;1==t[s].length||l.push(s)}this.incoming=t;for(var f</span>={},i<span class="cstat-no" title="statement not covered" >=0;i&lt;l.length;i++)f<span class="cstat-no" title="statement not covered" ></span>[l[i].toNT()]=!0;return<span class="cstat-no" title="statement not covered" >{</span>roots:l,subjects:n,rootsHash:f,incoming:t}},n.prototype<span class="cstat-no" title="statement not covered" >.toN<span class="cstat-no" title="statement not covered" >3</span></span>=function(e){return this.statement<span class="cstat-no" title="statement not covered" >sToN3(e.s<span class="cstat-no" title="statement not covered" >t</span></span>atements)},n.proto<span class="cstat-no" title="statement not covered" >type._not<span class="cstat-no" title="statement not covered" >Q</span></span>NameChars="\t\r\n <span class="cstat-no" title="statement not covered" >!\"#$%&amp;'(<span class="cstat-no" title="statement not covered" >)</span></span>*.,+/;&lt;=&gt;?@[\\]^`{<span class="cstat-no" title="statement not covered" >|}~",n.pr<span class="cstat-no" title="statement not covered" >o</span></span>totype._notNameCha<span class="cstat-no" title="statement not covered" >rs=n.prot<span class="cstat-no" title="statement not covered" >o</span></span>type._notQNameChar<span class="cstat-no" title="statement not covered" >s+":",n.p<span class="cstat-no" title="statement not covered" >r</span></span>ototype.explicitURI=function(n){return n<span class="cstat-no" title="statement not covered" >=</span>this.flags.index<span class="cstat-no" title="statement not covered" >Of("r")&lt;0&amp;&amp;this.base?<span class="cstat-no" title="statement not covered" >o.refTo(th</span></span></span>is.base,n):this.flags.inde<span class="fstat-no" title="function not covered" >xO</span>f("u")&gt;=0?<span class="cstat-no" title="statement not covered" >t(n):e(n),"&lt;"+n+"&gt;"},n.prototype.statementsToNTri<span class="cstat-no" title="statement not covered" >ples=</span>fu<span class="cstat-no" title="statement not covered" >nction(e){var t=e.slice();t.sort(<span class="cstat-no" title="statement not covered" ></span>);for(<span class="fstat-no" title="function not covered" >va</span>r n="",r="<span class="cstat-no" title="statement not covered" >http://www.w3.org/1999/02/22-rdf-syntax-ns#</span>",o</span>=this<span class="cstat-no" title="statement not covered" >,a=this.stor<span class="cstat-no" title="statement not covered" ></span>e,s=function e(t){if("collection"!==t.termType)return</span> o.at<span class="cstat-no" title="statement not covered" >omicTermToN3(t);for(var s<span class="cstat-no" title="statement not covered" ></span>=t.elements,u=a.sym(r+"nill"),l=s.length-1;l&gt;=0;</span>l</span>--){v<span class="cstat-no" title="statement not covered" >ar <span class="cstat-no" title="statement not covered" ></span>c=new i;n+=e(c)<span class="cstat-no" title="statement not covered" >+" "+e(a.sym(r+"first"))+" "+e<span class="cstat-no" title="statement not covered" >(s[l])+".\n",n+=<span class="cstat-no" title="statement not covered" ></span>e(c)+" "+e(a.sym(r+"rest"))+" "+e(u)+".\n",u=c}return o.at<span class="cstat-no" title="statement not covered" ></span>o</span></span>micTermToN3(u)}<span class="cstat-no" title="statement not covered" >,</span>u=0;u&lt;t.length;u++){var l=t[u],<span class="cstat-no" title="statement not covered" >c="";c+=s(l.subjec<span class="cstat-no" title="statement not covered" >t</span></span>)+" ",c+=s(l.predicate)+" ",c+=s(l.object)+" ",thi</span>s.flags.indexOf("q<span class="fstat-no" title="function not covered" >")</span>&gt;=0&amp;&amp;(c+=s<span class="cstat-no" title="statement not covered" >(l.why)+" "),c+=".\n",n+=c}return n},n.pro</span>totype.statementsToN3=function(e){function t(e){for(var t=this.rootSubjects(e),n=t.roots,i=[],o=0;o&lt;n.length;o++){var a=n[o];i.push(r(a,t))}return i}f<span class="fstat-no" title="function not covered" >un</span>ction r(e,<span class="cstat-no" title="statement not covered" >t){return"BlankNode"!=e.termType||t.incoming[e]?[a(e,t)].concat([i(e,t)]).concat(["."]):o(e,t,!0).concat(["."])}fun</span>ction i(e,t){var n=[],r=null,i=t.s<span class="fstat-no" title="function not covered" >ub</span>jects[this.toStr<span class="cstat-no" title="statement not covered" >(e)];if("u<span class="cstat-no" title="statement not covered" ></span>ndefined"<span class="cstat-no" title="statement not covered" >=</span>=typeof i)throw"Cant find statements for "+e;i.sort();for(var s=[],u=0;u&lt;i.length;u++){var l=i[u];l.predicate.uri==r?s.push(","):(r&amp;&amp;(n=n.concat([s]).concat([";"]),s=[]),n.push(c[l.predicate.uri]?c[l.predicate.uri]:a(l.predicate,t))),r=l.predicate.uri,s.push(o(l.object,t))}return n=n.concat([s])}function o(e,t,n){return"BlankNode"==e.termType&amp;&amp;t.subjects[this.toStr(e)]&amp;&amp;(n||void 0=<span class="cstat-no" title="statement not covered" >=t.ro</span>ot<span class="cstat-no" title="statement not covered" >sHa<span class="cstat-no" title="statement not covered" ></span>sh[e.toNT()])?["["].concat(i(e,t)).concat(["]"]):a(e,t)}function a(e,n){var r;switch(e.termType){case"formula":var i=["{"]<span class="cstat-no" title="statement not covered" ></span>;</span>return i=</span>i.concat(t(e.statements)),i.<span class="fstat-no" title="function not covered" >co</span>ncat(["}"]);case"co<span class="fstat-no" title="function not covered" >ll</span>ect<span class="cstat-no" title="statement not covered" >ion":var i=["("];for(r=0;r&lt;e.elements.length;r++)i.push([o(e.elements[r]<span class="cstat-no" title="statement not covered" >,n)])<span class="cstat-no" title="statement not covered" ></span>;return i.push("<span class="cstat-no" title="statement not covered" ></span>)</span>"),i;defa</span>ult:retur<span class="fstat-no" title="function not covered" >n </span>this.<span class="cstat-no" title="statement not covered" >atomicTermToN3(e)}}function s(){var e="";this.defaultNamespace&amp;&amp;(e+="@prefix : &lt;"+this.defaultNamespace+"&gt;.\n"</span>);for(var<span class="fstat-no" title="function not covered" > t</span> in this.pr<span class="cstat-no" title="statement not covered" >efi</span>xe<span class="cstat-no" title="statement not covered" >s)thi</span>s.<span class="cstat-no" title="statement not covered" >prefixes.hasOwnProperty(t)<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;this.namespacesUsed[t]&amp;<span class="cstat-no" title="statement not covered" >&amp;(e+="@prefix "+this.prefixes[t]+":<span class="cstat-no" title="statement not covered" > </span></span>"+this.e<span class="cstat-no" title="statement not covered" >x</span>plicitURI(t)+".\n");return e+"\n"}var <span class="cstat-no" title="statement not covered" >u=4,l<span class="cstat-no" title="statement not covered" ></span>=80,c={};this.flags.indexOf("s")&lt;0&amp;&amp;(c["http://www.w3.org/2002/07/owl#sameAs"]="="),this.flags.indexOf("t")&lt;0&amp;&amp;(c["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"]="a"),this.fl<span class="cstat-no" title="statement not covered" ></span>a</span>gs.indexOf("i")&lt;0&amp;&amp;(c["</span>http://ww<span class="fstat-no" title="function not covered" >w.</span>w3.org/<span class="cstat-no" title="statement not covered" >2000/10/swap/log#implies"]="=&gt;");var f=function(e){for(var t="",n=0;n&lt;e;n++)t+=" ";return t},h=function e(t){for(var n="",r=0;r&lt;t.length</span>;r++){var<span class="fstat-no" title="function not covered" > i</span>=t[r],o="st<span class="cstat-no" title="statement not covered" >ring"==typeof i?i:e(i);0!=r&amp;&amp;","!=o&amp;&amp;";<span class="cstat-no" title="statement not covered" >"!=o&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>(n+=" "),n+=o}return n},d=function e(t,n){var r="",i</span>=1e5;n||(n=0);for(var <span class="cstat-no" title="statement not covered" >o=0;o&lt;<span class="cstat-no" title="statement not covered" ></span>t.length;o++){var a=t[o];if("str<span class="cstat-no" title="statement not covered" >ing"!=typeof a){var s=e(a,n+1<span class="cstat-no" title="statement not covered" >)</span></span>;if(s.length&lt;10*(l-u*</span>n)&amp;&amp;s.i<span class="cstat-no" title="statement not covered" >ndexOf('"""')&lt;0){var c=h(a);c.l</span>e</span>ngth&lt;l-u*<span class="fstat-no" title="function not covered" >n&amp;</span>&amp;(a="   <span class="cstat-no" title="statement not covered" >"+c<span class="cstat-no" title="statement not covered" ></span>,s="")}s&amp;&amp;(i=1e4),r+=s}if("string"==typeof a){if("1"==a.length&amp;&amp;"\n"==r<span class="cstat-no" title="statement not covered" >.</span>slice(-1)){if(",.;".indexO<span class="cstat-no" title="statement not covered" >f(a)&gt;=0){r=r.slice(0,-1)+a+"\n",i+=1;continue}if("])}".indexOf(a)&gt;=0){r=r.slice(0,-1)+" "+a+"\n",i+=2;continue}}if(i&lt;u*n+<span class="cstat-no" title="statement not covered" >4</span></span>)r=r.slice(0,-</span>1)+" "<span class="cstat-no" title="statement not covered" >+a</span>+"<span class="cstat-no" title="statement not covered" >\n"</span>,i<span class="cstat-no" title="statement not covered" >+=a<span class="cstat-no" title="statement not covered" ></span>.length+1;else{var c=f(u*n)+a;r+=c+"\n",i=c.length}}}return r};t=t.bind(this),i=i.bind(this),o=o.bind(this),n.prototype.termToN3=a,a=a.bind(this);var s=s.bind(this),p=t(e);return s()+d(p,-1)},n.prototype.atomicTermToN3=function(e,t){switch(e.te</span>rmTyp<span class="cstat-no" title="statement not covered" >e){case"B<span class="fstat-no" title="function not covered" >la</span>nkN<span class="cstat-no" title="statement not covered" >ode":case"Variable":retur<span class="cstat-no" title="statement not covered" >n e.toN<span class="cstat-no" title="statement not covered" >T</span></span>();case"L</span>i</span>te<span class="cstat-no" title="statement not covered" >ral":if(e<span class="fstat-no" title="function not covered" >.d</span>ata<span class="cstat-no" title="statement not covered" >type&amp;&amp;this.flags.indexOf("x")&lt;0)switch(<span class="cstat-no" title="statement not covered" >e.dat</span>at<span class="cstat-no" title="statement not covered" >ype.uri){case"http://www.w<span class="cstat-no" title="statement not covered" ></span>3.org/2001/XMLSchema#integer":return <span class="cstat-no" title="statement not covered" ></span>e</span>.value.to</span>S</span>tr<span class="cstat-no" title="statement not covered" >ing();cas<span class="fstat-no" title="function not covered" >e"</span>http://www.<span class="cstat-no" title="statement not covered" >w3.</span>or<span class="cstat-no" title="statement not covered" >g/20<span class="cstat-no" title="statement not covered" ></span>01/XMLSch<span class="cstat-no" title="statement not covered" >e</span>ma#boolean":return e.value?"true"<span class="cstat-no" title="statement not covered" >:"fal<span class="cstat-no" title="statement not covered" ></span>se"}var n=this.stringToN3(e.v<span class="cstat-no" title="statement not covered" >alue);ret<span class="cstat-no" title="statement not covered" ></span>urn e.language?n+="@"+e.language:e.datatype.equals<span class="cstat-no" title="statement not covered" >(s.st<span class="cstat-no" title="statement not covered" ></span>ring)||(n+="^^"+this.atomicTermToN<span class="cstat-no" title="statement not covered" ></span>3</span>(e.datatype,t)),<span class="cstat-no" title="statement not covered" ></span>n</span>;case"NamedNode":retur<span class="cstat-no" title="statement not covered" >n this.symbolToN3(e);default:throw"In<span class="cstat-no" title="statement not covered" >ternal: atomicTermToN3 c<span class="cstat-no" title="statement not covered" >annot handle "+e+" of termTy<span class="cstat-no" title="statement not covered" >p</span>e: "+e.te<span class="cstat-no" title="statement not covered" ></span>r</span>mType+"\n"}},n.prototyp<span class="cstat-no" title="statement not covered" >e.validPrefix=new RegExp(/^[a-zA<span class="cstat-no" title="statement not covered" >-</span>Z][a-zA-Z</span>0<span class="cstat-no" title="statement not covered" ></span>-</span>9]*$/),n.p<span class="cstat-no" title="statement not covered" >rototype.forbidden1=new RegExp(/[\\"\b\f\r</span>\v\t\n\u00<span class="cstat-no" title="statement not covered" >80-\uffff<span class="cstat-no" title="statement not covered" ></span>]/gm),n.prototype.forb</span>i</span>d<span class="cstat-no" title="statement not covered" ></span>d</span>en3=new R</span>e<span class="cstat-no" title="statement not covered" ></span>gExp(/[\\"\b\f\r\v\u0080-\uffff]/gm),n.prototype.stringToN3=function(e,t){t||(t="e")</span>;var <span class="cstat-no" title="statement not covered" >r,i,o="",a=0,</span>s=<span class="cstat-no" title="statement not covered" >0;e.l<span class="cstat-no" title="statement not covered" ></span>ength&gt;20&amp;&amp;'"'!=e.sli</span>ce(-1)&amp;&amp;t.indexOf("n")&lt;0&amp;&amp;(e<span class="fstat-no" title="function not covered" >.i</span>ndexOf("\n")<span class="cstat-no" title="statement not covered" >&gt;0||e.indexOf('"')&gt;0)?(r='"""',i=n.prototype.forbi<span class="cstat-no" title="statement not covered" >dden3):(r='"',i=n</span>.prototype.fo<span class="cstat-no" title="statement not covered" >rbidden1);for(var a=0;a&lt;e.length;){i.last<span class="cstat-no" title="statement not covered" >Index=0;var u=i.exec(e.slice(a));if(null==u)break;s=a+i.lastIndex-1,o+<span class="cstat-no" title="statement not covered" >=e.slice(a,s);var l=e[s];if</span>('"'==l&amp;&amp;'"""'==r&amp;&amp;'"""'!=e.slice(s,s+3))o+=l;<span class="cstat-no" title="statement not covered" >else{var c='\b\f\r\t\v\n\\"'.in</span>d</span></span>exOf(<span class="cstat-no" title="statement not covered" >l);o+=c&gt;=0?"\\"+'bfrtvn\\<span class="cstat-no" title="statement not covered" ></span>"'[c]:t.indexOf("e")&gt;=0?"\\u"+("000"+l.charCodeAt(0).toString(16).toLowerCase()).slice(-4):l}a=s+1}return r+o+e.</span>slice(a)+r},n.p<span class="cstat-no" title="statement not covered" >rototype.symbolToN3=functio</span>n(e){va<span class="cstat-no" title="statement not covered" >r t=e.uri,r=t.indexOf("#");if(r&lt;0&amp;&amp;this.flags.indexOf("/")&lt;0&amp;&amp;(r=t.lastIndexOf("/")</span>)</span>,r&gt;=0&amp;&amp;this.flags.indexOf("p")&lt;0&amp;&amp;(0===t.indexOf("http")||0===t.indexOf("ws")||0===t.indexOf("file"))){for(var i=!0,o=r+1;o&lt;t.length;o++)if(n.prototype._notNameChars.indexOf(t[o])&gt;=0){i=!1;break}if(t.slice(0,r+1)==this.ba<span class="fstat-no" title="function not covered" >se</span>+"#")return"<span class="cstat-no" title="statement not covered" >&lt;#"+t.slice(</span>r+1)+"&gt;";<span class="cstat-no" title="statement not covered" >if(</span>i)<span class="cstat-no" title="statement not covered" >{v</span>ar<span class="cstat-no" title="statement not covered" > a<span class="cstat-no" title="statement not covered" ></span>=t.slice(r+1),s=t.slice(0,r+1);if(this.defaultNamespace&amp;&amp;this.defaultNamespace==s&amp;&amp;this.flags.indexOf("d")&lt;0)return this.flags.indexOf("k")&gt;=0&amp;&amp;this.keyord<span class="cstat-no" title="statement not covered" >s</span>.indexOf(a)&lt;0?a:":"+a;th<span class="cstat-no" title="statement not covered" >is.checkIntegri</span>ty();<span class="cstat-no" title="statement not covered" >var u=this.prefixes<span class="cstat-no" title="statement not covered" ></span>[s];if(u||(<span class="cstat-no" title="statement not covered" >u=this<span class="cstat-no" title="statement not covered" >.</span></span>makeUpPrefix(s)),u)return this.nam</span>espac<span class="cstat-no" title="statement not covered" >esUse<span class="cstat-no" title="statement not covered" ></span>d[s]=!0,u+":"+a}}return this.explicitURI(t)<span class="cstat-no" title="statement not covered" >},n.pr</span>ototype.wr<span class="cstat-no" title="statement not covered" >iteStore=function(e){var t=th<span class="cstat-no" title="statement not covered" ></span>is.store,n=t.fetcher,r=n&amp;&amp;n.appNode,i=this.store.index[3];for(var o in i){var a=t.fromNT(o);r&amp;&amp;a.sameTerm(r)||e("\n"<span class="cstat-no" title="statement not covered" ></span>+</span>this.a<span class="cstat-no" title="statement not covered" ></span>t</span>omicTermToN3(a)+" "+this</span>.atomicTermToN3(t.sym("h<span class="fstat-no" title="function not covered" >tt</span>p://www.w3.org/2<span class="cstat-no" title="statement not covered" >000/10</span>/s<span class="cstat-no" title="statement not covered" >wap/log#semanti<span class="cstat-no" title="statement not covered" ></span>cs"))+" { "+this.statementsToN3(t.statementsMatching(void 0,void 0,void 0,a))+" }.\n")}t.statementsMatching(void 0,t.sym("http://www.w3.org/2007/ont/link#reques<span class="cstat-no" title="statement not covered" >tedURI")).map(function(n){e("\n&lt;"+<span class="cstat-no" title="statement not covered" >n.object.value+"&gt; log:metadata {\n");var r=t.st<span class="cstat-no" title="statement not covered" >ateme<span class="cstat-no" title="statement not covered" >n</span>tsMatc<span class="cstat-no" title="statement not covered" ></span>h</span></span>ing(void 0,void 0,void 0,n.subje<span class="cstat-no" title="statement not covered" >ct);e(this.statementsToN3(th<span class="cstat-no" title="statement not covered" >i</span></span>s.statement<span class="cstat-no" title="statement not covered" >sToN3(r))),e(</span>"}<span class="cstat-no" title="statement not covered" >.\n")});var s=[<span class="cstat-no" title="statement not covered" ></span>];r&amp;&amp;s.push(r);var u=[];s.map(function(e){u=u.concat(t.statementsMatching(void<span class="cstat-no" title="statement not covered" > 0,void 0,void 0,e))}),e(this.statementsToN3(u))},n.prototype.stateme<span class="cstat-no" title="statement not covered" >n</span></span>tsToXML=function(e){fu</span>nctio<span class="cstat-no" title="statement not covered" >n t(e){this.sugge<span class="cstat-no" title="statement not covered" ></span>stPrefix("rdf","http://www.w3.org<span class="cstat-no" title="statement not covered" >/1999/02/22-rdf-syntax-ns#");for(var t=thi</span></span>s<span class="cstat-no" title="statement not covered" ></span>.</span>rootSubjects(e),n=t.roots,r</span>=[],i=0;i&lt;n.length;i++)r<span class="fstat-no" title="function not covered" >oo</span>t=n[i],r.push(u(<span class="cstat-no" title="statement not covered" >root,t));re</span>tu<span class="cstat-no" title="statement not covered" >rn r}funct</span>io<span class="cstat-no" title="statement not covered" >n i(e){return</span>"u<span class="cstat-no" title="statement not covered" >ndefined"==typeof e?<span class="cstat-no" title="statement not covered" ></span>"@@@undefined@@@@":e.r<span class="cstat-no" title="statement not covered" >eplace(/[&amp;&lt;"<span class="cstat-no" title="statement not covered" ></span>]/g,function(e){switch(e[0]){case"&amp;":return"&amp;amp;";case"&lt;":return"&amp;lt;";case'"':return"&amp;quot;"}})}function o(e){return i(this.base?a.uri.refTo(this.base,e.uri):e.uri)}function u(e,t){var n,a,c,h,d=[],p=t.subje<span class="cstat-no" title="statement not covered" ></span>c</span>ts[this.toStr(e)];if("undefined"==typeof p)throw"Serializing XML - Cant find statement<span class="fstat-no" title="function not covered" >s </span>for "+e;p.<span class="cstat-no" title="statement not covered" >sort(function(e,t){var n=e.predicate.uri,r=t.p</span>redic<span class="cstat-no" title="statement not covered" >ate.uri;if(n.substring(0,v.length)==v||r.substring(0,<span class="cstat-no" title="statement not covered" ></span>v.length)==v)return n.localeCompare(r);var i=n.substring(v</span>.le</span>ngth)<span class="cstat-no" title="statement not covered" >,o=<span class="cstat-no" title="statement not covered" ></span>r.substring(v.</span>lengt<span class="cstat-no" title="statement not covered" >h),<span class="cstat-no" title="statement not covered" ></span>a=pars<span class="fstat-no" title="function not covered" >eI</span>nt(i),s=pa<span class="cstat-no" title="statement not covered" >rseInt(o);return isNaN(a)||isNaN(s)||a!=i||s!=o?n.localeCo</span>mpare(r):a-s});for(var g=0;g&lt;</span>p.length;g++)if(c=p[g],"http:<span class="fstat-no" title="function not covered" >//</span>www.w3.org/1999/02/<span class="fstat-no" title="function not covered" >22</span>-rd<span class="cstat-no" title="statement not covered" >f-syntax-ns#type"!=c.predicate.uri||n||"symbol"!=c.object.termType){if(h<span class="cstat-no" title="statement not covered" >=</span>c.predicate,h.uri.substr(0,v.length)==v){var y=h.uri.substr(v.le<span class="cstat-no" title="statement not covered" >ngth),m=parseInt(y);y==m.toS<span class="cstat-no" title="statement not covered" >t</span></span>ring()&amp;&amp;(</span>h=new r("<span class="fstat-no" title="function not covered" >ht</span>tp:<span class="cstat-no" title="statement not covered" >//www.w3.org/1999/02/22-rdf-syntax-ns#li"))}switch(a=f(h),c.object<span class="fstat-no" title="function not covered" >.t</span>ermType){c<span class="cstat-no" title="statement not covered" >ase"BlankNode":d=1==t<span class="cstat-no" title="statement not covered" >.incoming[c.obj</span>ect].le<span class="cstat-no" title="statement not covered" >ngth?d.concat(</span>["&lt;"+a+<span class="cstat-no" title="statement not covered" >"&gt;",u(c.object,t</span>)</span>,"&lt;</span>/"+a+"&gt;"]<span class="fstat-no" title="function not covered" >):</span>d.c<span class="cstat-no" title="statement not covered" >oncat(["&lt;"+a+' rdf:nodeID="'+c.object.toNT().slice(2)+'"</span>/&gt;']);bre<span class="fstat-no" title="function not covered" >ak</span>;case"NamedNode":d=<span class="cstat-no" title="statement not covered" >d.c</span>on<span class="cstat-no" title="statement not covered" >cat(["&lt;"+a+' rdf:resource=<span class="cstat-no" title="statement not covered" ></span>"'+o(c.object)+'"/&gt;']);br<span class="cstat-no" title="statement not covered" >eak;case"Literal":d=d.concat(["&lt;"+a+(c.object.datatyp<span class="cstat-no" title="statement not covered" >e</span></span>.equal<span class="fstat-no" title="function not covered" >s(</span>s.string)?"":' rdf<span class="cstat-no" title="statement not covered" >:datatype="'+i(c</span>.o<span class="cstat-no" title="statement not covered" >bject.datatype.u<span class="cstat-no" title="statement not covered" ></span>ri)+'"')+(c.object.language?' xml:lang="'+c.object.languag<span class="cstat-no" title="statement not covered" >e+'"':"")+"&gt;"+i(c.object.va</span></span>lue)+<span class="cstat-no" title="statement not covered" >"&lt;/"+a+"&gt;"]);break;cas</span>e"<span class="cstat-no" title="statement not covered" >collection":d=d.concat</span>([<span class="cstat-no" title="statement not covered" >"&lt;"+a+' rdf:</span>pa<span class="cstat-no" title="statement not covered" >rseType="Col<span class="cstat-no" title="statement not covered" ></span>lection"&gt;',l(c.object,t),"&lt;/"+a+"&gt;"]);break;default:throw"Can'</span>t <span class="cstat-no" title="statement not covered" >s</span>erialize object of type "+<span class="cstat-no" title="statement not covered" >c.object.termType+" into XML"}}else n=c.object;var b=n?f(n):"rdf:Description",w="";return"BlankNode"==e.termTy<span class="cstat-no" title="statement not covered" >pe?t.incoming[e]&amp;&amp;1==t.incoming[e].length||(w=' rdf:<span class="cstat-no" title="statement not covered" >nodeID="'+e.toNT().slic</span>e(<span class="cstat-no" title="statement not covered" >2)+'"'):w=' <span class="cstat-no" title="statement not covered" ></span>rdf:about="'+o(e)+'"',["&lt;"+b+w+"&gt;"].concat([d]).concat(["&lt;/"+b+"&gt;"])}function<span class="cstat-no" title="statement not covered" ></span> </span>l(e,t){for(var n=[],r=0;r&lt;e.elements.length;r++)<span class="cstat-no" title="statement not covered" >n.push(u(e.elements[r],t));return n}function c(e,t){var n=[],r=t.subjects[this.toStr(e)];if(void 0==r)return n;r.sort();for(var a=0;a&lt;r.length;a+<span class="cstat-no" title="statement not covered" >+</span>){var </span>u=r[a];switch(u<span class="cstat-no" title="statement not covered" >.object.termType){case"BlankNode":n=t.rootsHash[u.object<span class="cstat-no" title="statement not covered" >.</span>toNT()</span>]?n.concat(["<span class="cstat-no" title="statement not covered" >&lt;"+f(u.predicate)+' rdf:nodeID="'+u.object.toNT().slice(2)+'"&gt;',"&lt;/"+f(u.predicate)+"&gt;"]):n.concat(["&lt;"+f(u.predicate)+' rdf:parseType="Resource"&gt;',c(u.object,t),"&lt;/"+f(u.predicate)+"&gt;"]);break;case"<span class="cstat-no" title="statement not covered" >N</span>amedNo</span>de":n=n.concat([<span class="cstat-no" title="statement not covered" >"&lt;"+f(u.predicate)+' rdf:resource="'+o(u.object)+'"/&gt;']);break;case"Literal"<span class="cstat-no" title="statement not covered" >:</span>n=n.co</span>ncat(["<span class="cstat-no" title="statement not covered" >&lt;"+f(u.predicate)+(u.object.datatype.equals(s.string)?"":' rdf:datatyp</span>e</span>="'+i<span class="cstat-no" title="statement not covered" >(u.object.da</span></span></span>tatyp<span class="cstat-no" title="statement not covered" >e.value)+'"')+(u.object.l</span>an<span class="cstat-no" title="statement not covered" >gua<span class="cstat-no" title="statement not covered" ></span>ge?' xml:lang="'+u.object.language+'"':"")+"&gt;"+i(u.object.value)+"&lt;/"+f(u.predicate)+"&gt;"]);break;case"collection":n=n.concat(["&lt;"+f(u.predicate)+' rdf:parseType="Collection"&gt;',l(u.object</span>,t),"&lt;/"+<span class="fstat-no" title="function not covered" >f(</span>u.pre<span class="cstat-no" title="statement not covered" >dicate)+"&gt;"]);break;default:throw"Can't s<span class="cstat-no" title="statement not covered" >erialize object of type "+u<span class="cstat-no" title="statement not covered" >.</span></span>object.te</span>rmType+" <span class="fstat-no" title="function not covered" >in</span>to XML"}}re<span class="cstat-no" title="statement not covered" >tur</span>n <span class="cstat-no" title="statement not covered" >n}function f(e){var t=e.ur<span class="cstat-no" title="statement not covered" ></span>i,r=t.indexOf<span class="cstat-no" title="statement not covered" >("#");if(<span class="cstat-no" title="statement not covered" >r</span></span>&lt;0&amp;&amp;this<span class="cstat-no" title="statement not covered" >.</span>flags.indexOf("/")&lt;0&amp;&amp;(r=t.lastIn<span class="cstat-no" title="statement not covered" >dexOf<span class="cstat-no" title="statement not covered" ></span>("/")),r&lt;0)throw"Cannot make qname out of <span class="cstat-no" title="statement not covered" >&lt;"+t+"&gt;";for(var i=r+1;i&lt;t.length;i++)if(n.prototype._notNameChars.indexOf(t[i])&gt;=0)throw'Invalid character "'+t[i]+'" cannot be in XML qname for URI: '+t;var o=t.slice(r+1),a=t.slice(0,r+1);if(this.defaultNamespace&amp;&amp;this.defaultN<span class="cstat-no" title="statement not covered" >a</span>mespac</span>e==a&amp;&amp;this.flag<span class="cstat-no" title="statement not covered" >s.indexOf("d")&lt;0)return o;var s=this.prefixes[a];return s||(s=this.ma<span class="cstat-no" title="statement not covered" >k</span>eUpPre</span>fix(a)),p[a]=<span class="cstat-no" title="statement not covered" >!0,s+":"+o}var h=4,d=80,p=[];p["http://www.w3.org/1999/02/22-rdf-syntax-ns#"]=!0;var v="http://www.w3.org/1999/02/22-rdf-syntax-ns#_",g=function(e){for(var t="",n=0;n&lt;e;n++)t+=" ";return t},y=function e(t){for(var n="",r=0;r&lt;t.<span class="cstat-no" title="statement not covered" >l</span>ength;</span>r++){var i=t[r],<span class="cstat-no" title="statement not covered" >o="string"==typeof i?i:e(i);n+=o}return n},m=function e(t,n){var r="",i=1e5;n||(n=0);for(var o=0;o&lt;t.l<span class="cstat-no" title="statement not covered" >e</span>ngth;o</span>++){var<span class="cstat-no" title="statement not covered" > a=t[o];if("string"!=typeof a){var s=e(a,n+1);if(s.length&lt;10*(d-h*n)&amp;&amp;</span>s<span class="cstat-no" title="statement not covered" ></span>.</span>indexOf('</span>"""')&lt;0){<span class="fstat-no" title="function not covered" >va</span>r u=y(a);<span class="cstat-no" title="statement not covered" >u.leng</span>th<span class="cstat-no" title="statement not covered" >&lt;d-h*n&amp;&amp;(a="   <span class="cstat-no" title="statement not covered" ></span>"+u,s="")}s&amp;&amp;(i=1e4),r+=s}if("string"==typeof a)if(i&lt;h*n+4)r=r<span class="cstat-no" title="statement not covered" >.slice(0,-1)+" "+a+"\n",i+=a.length+1;el<span class="cstat-no" title="statement not covered" >s</span></span>e{var u=g(h*n)+a;r+=u+"\n",i<span class="cstat-no" title="statement not covered" >=u.length}}return r};t=t.bind(this),o=o.bind(t<span class="cstat-no" title="statement not covered" >his),u=u.bind(this),c=c.bind(this),f=f.bind(this);var b=t(e),w="&lt;rdf:RDF</span></span></span>";thi<span class="cstat-no" title="statement not covered" >s.defaultName</span>sp<span class="cstat-no" title="statement not covered" >ace&amp;&amp;(w+=' xmln<span class="cstat-no" title="statement not covered" ></span>s="'+i(this.defaultNamespace)+'"');for(var x in p)p.hasOwnProperty(x)&amp;&amp;(w+="\n<span class="cstat-no" title="statement not covered" > xmlns:"+t</span></span>his.p<span class="cstat-no" title="statement not covered" >refixes[x]+'="'+i<span class="cstat-no" title="statement not covered" ></span>(x)+'"');w+="&gt;";var _=[w,b,"&lt;/rdf:RDF&gt;"];return m(_,</span>-1)};v<span class="cstat-no" title="statement not covered" >ar</span> u<span class="cstat-no" title="statement not covered" >=fu</span>nc<span class="cstat-no" title="statement not covered" >tio<span class="cstat-no" title="statement not covered" ></span>n(e){return new n(e)};return u}();e.exports=u},functi</span>on(e,<span class="cstat-no" title="statement not covered" >t,n){"use strict";function r(e,t){if(!(e instan</span>ce<span class="cstat-no" title="statement not covered" >of t))thr<span class="fstat-no" title="function not covered" >ow</span> ne<span class="cstat-no" title="statement not covered" >w TypeError("Cannot call <span class="cstat-no" title="statement not covered" >a class<span class="cstat-no" title="statement not covered" > </span></span>as a func</span>t</span>io<span class="cstat-no" title="statement not covered" >n")}var i<span class="fstat-no" title="function not covered" >=f</span>unc<span class="cstat-no" title="statement not covered" >tion(){function e(e,t){for(var n=0;n&lt;t.<span class="cstat-no" title="statement not covered" >lengt</span>h;<span class="cstat-no" title="statement not covered" >n++){var r=t[n];r.enumerab<span class="cstat-no" title="statement not covered" ></span>le=r.e<span class="cstat-no" title="statement not covered" ></span>n</span>umerable|</span>|</span>!1<span class="cstat-no" title="statement not covered" >,r.config<span class="fstat-no" title="function not covered" >ur</span>able=!0,"va<span class="cstat-no" title="statement not covered" >lue</span>"i<span class="cstat-no" title="statement not covered" >n r&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(r.writa<span class="cstat-no" title="statement not covered" >b</span>le=!0),Object.defineProperty(e,r.<span class="cstat-no" title="statement not covered" >key,r<span class="cstat-no" title="statement not covered" ></span>)}}return function(t,n,r){ret<span class="cstat-no" title="statement not covered" >urn n&amp;&amp;e(<span class="cstat-no" title="statement not covered" ></span>t.prototype,n),r&amp;&amp;e(t,r),t}}(),o=n(10),a=function(<span class="cstat-no" title="statement not covered" >){fun<span class="cstat-no" title="statement not covered" ></span>ction e(t,n,i,a){r(this,e),this.su<span class="cstat-no" title="statement not covered" ></span>b</span>ject=o.fromValue<span class="cstat-no" title="statement not covered" ></span>(</span>t),this.predicate=o.f<span class="cstat-no" title="statement not covered" >romValue(n)<span class="cstat-no" title="statement not covered" >,this.object=o.fromValue(i),this.why=a}ret</span>urn i(e,[{<span class="cstat-no" title="statement not covered" >key:"equa<span class="cstat-no" title="statement not covered" ></span>ls",value:function(e){</span>r<span class="cstat-no" title="statement not covered" ></span></span>e</span>turn e.su</span>b<span class="cstat-no" title="statement not covered" ></span>ject.equals(this.subject)&amp;&amp;e.predicate.equals(this.predicate)&amp;&amp;e.object.equa</span>ls(th<span class="cstat-no" title="statement not covered" >is.ob</span>je<span class="cstat-no" title="statement not covered" >ct)&amp;&amp;e.grap<span class="cstat-no" title="statement not covered" ></span>h.equals(this.graph)}},{key:"substitute",value:function(t){var n=new<span class="cstat-no" title="statement not covered" > </span>e(this.subject<span class="cstat-no" title="statement not covered" >.substitute(t),this.predicate.substitute(t),this.object.substitute(t)<span class="cstat-no" title="statement not covered" >,</span></span>this.wh</span>y.sub<span class="cstat-no" title="statement not covered" >stitute(t));return <span class="cstat-no" title="statement not covered" ></span>console.log("@@@</span> s</span>tatem<span class="cstat-no" title="statement not covered" >ent subst<span class="fstat-no" title="function not covered" >it</span>ute<span class="cstat-no" title="statement not covered" >:"+n),n}},{key:"t</span>o<span class="cstat-no" title="statement not covered" ></span>Canonical"</span>,va<span class="cstat-no" title="statement not covered" ></span>lue:function(</span>)<span class="fstat-no" title="function not covered" >{v</span>ar e=[this.subject.toCanonical(),thi<span class="fstat-no" title="function not covered" >s.</span>predi<span class="cstat-no" title="statement not covered" >cate.toCanonical(),th<span class="cstat-no" title="statement not covered" >is.object.toCanonical()];return this.graph&amp;&amp;"DefaultGraph"</span></span>!==thi<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s.</span>graph.termType&amp;&amp;e.<span class="fstat-no" title="function not covered" >pu</span>sh(th<span class="cstat-no" title="statement not covered" >is.graph.toCanonical()),e.join(" "<span class="cstat-no" title="statement not covered" >)+" .<span class="cstat-no" title="statement not covered" ></span>"}},{key:"toNT",value:function(){return[this.subject.toNT(),this.predicate.toNT(),this.object.toNT()].join(" ")</span>+<span class="cstat-no" title="statement not covered" ></span>" ."}},<span class="fstat-no" title="function not covered" >{k</span>ey:"toString",<span class="cstat-no" title="statement not covered" >value:function(){return this.toNT()}},{k</span>ey</span>:"g</span>ra<span class="cstat-no" title="statement not covered" >ph",ge</span>t:<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){return th<span class="fstat-no" title="function not covered" >is</span>.why;<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
},set:function(e){this.why=e}}]),e}();e.<span class="fstat-no" title="function not covered" >expo</span>rts<span class="cstat-no" title="statement not covered" >=a},function</span>(e,t,n){"u<span class="cstat-no" title="statement not covered" >se strict";fu</span>n<span class="fstat-no" title="function not covered" >ct</span>ion r(e,t){if(!(e instanceof t))thro<span class="fstat-no" title="function not covered" >w </span>new T<span class="cstat-no" title="statement not covered" >ypeError("Cannot call<span class="cstat-no" title="statement not covered" > a class as a function")}function i(e,t){if(!e)throw new R</span></span>eferenceE<span class="fstat-no" title="function not covered" >rr</span>or("t<span class="cstat-no" title="statement not covered" >his ha<span class="cstat-no" title="statement not covered" >sn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&amp;&amp;"fu<span class="cstat-no" title="statement not covered" >n</span></span>ction"!=typeof t?e:t}function o(e,t){if("function"!=typ</span>eof t&amp;&amp;nu<span class="fstat-no" title="function not covered" >ll</span>!==t)<span class="cstat-no" title="statement not covered" >throw new TypeError("Super express<span class="cstat-no" title="statement not covered" >ion must either be null or a function, not "+typeof t);e.prototype=Object.create(t&amp;&amp;t.pro<span class="cstat-no" title="statement not covered" >t</span></span>otype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){fo</span>r(var <span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>0;n&lt;t.length;n++){<span class="fstat-no" title="function not covered" >va</span>r r=t<span class="cstat-no" title="statement not covered" >[n];r.enumerable=r.enumerable||!1,<span class="cstat-no" title="statement not covered" >r.con<span class="cstat-no" title="statement not covered" ></span>figurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(</span>t<span class="cstat-no" title="statement not covered" ></span>.protot<span class="fstat-no" title="function not covered" >yp</span>e,n),r&amp;&amp;e(t,r)<span class="cstat-no" title="statement not covered" >,t}}(),s=n(9),u=n(10),l=n(7),c=function(</span>e)</span>{fu</span>nc<span class="cstat-no" title="statement not covered" >tion </span>t(<span class="cstat-no" title="statement not covered" >){var </span>e=<span class="cstat-no" title="statement not covered" >argum</span>en<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ts</span>.length&lt;=0||void 0=<span class="fstat-no" title="function not covered" >==</span>argument<span class="cstat-no" title="statement not covered" >s[0]?"":arguments[0];r(this,t);var n=i(this,Object.getProto<span class="cstat-no" title="statement not covered" ></span>typeOf(t).c</span>all(t<span class="cstat-no" title="statement not covered" >his));return n.termType=t.termType,n.value=e<span class="cstat-no" title="statement not covered" ></span>,n.base="varid:",n.uri=l.join(e,n.base),n}return o(t,e),a(t,[{key:"equals",value:<span class="cstat-no" title="statement not covered" ></span>function(e){return!!e&amp;&amp;(this.termType===e.termType&amp;&amp;this.value===e.value)<span class="fstat-no" title="function not covered" >}},{ke</span>y:"<span class="cstat-no" title="statement not covered" >hashString",value:function(){return this.toString()}},{key:"s</span>ubstitute",value:function(e){var t;return null!=(t=e[this.to<span class="fstat-no" title="function not covered" >NT()])</span>?t<span class="cstat-no" title="statement not covered" >:this}},{key:"toString",</span>value:function(){return this.uri.slice(0,this.base.length)==<span class="fstat-no" title="function not covered" >=this.</span>base?"?"+<span class="cstat-no" title="statement not covered" >this.uri.slice(this.base.length):"?"+thi</span>s.uri}}]),t}(u);c.termType="Variable",c.prototype.classOrd<span class="fstat-no" title="function not covered" >er=s.V</span>ar<span class="cstat-no" title="statement not covered" >iable,c.prototype.isVar=1,e.exports=c},function(e,t,n){"use strict";function r(e){return function(t){retu</span>rn new </span>i(e+<span class="cstat-no" title="statement not covered" ></span>(t||""))}}var i=n(8);e.exports=r},function(e,t,n){"use strict";function r(e){return e&amp;&amp;e.</span>_<span class="fstat-no" title="function not covered" >_e</span>sModule?e:{default:e}}function i(e,t<span class="fstat-no" title="function not covered" >){</span>if(<span class="cstat-no" title="statement not covered" >!(e ins<span class="fstat-no" title="function not covered" >ta</span>nceof t))t<span class="cstat-no" title="statement not covered" >hrow new TypeError("Canno</span>t </span>call a<span class="cstat-no" title="statement not covered" > clas<span class="cstat-no" title="statement not covered" ></span>s as a functi</span>o<span class="fstat-no" title="function not covered" >n"</span>)}function o(e,t,n,r){function i(e,t<span class="fstat-no" title="function not covered" >){</span>ret<span class="cstat-no" title="statement not covered" >urn e.nvars!==t.nvars?e.nvars-t.nvars:</span>e.index.l<span class="fstat-no" title="function not covered" >en</span>gth-t<span class="cstat-no" title="statement not covered" >.index.length}var o=f<span class="cstat-no" title="statement not covered" >unction(e){var t,n="";for(t in e)e.hasOwnProperty(t)&amp;&amp;(n+=</span></span>"    "+t+<span class="fstat-no" title="function not covered" >" </span>-&gt; "+e[t]);return <span class="fstat-no" title="function not covered" >n}</span>,a=fu<span class="cstat-no" title="statement not covered" >nction(e){var t,n="Bindings: ",r=e.length;for(t=0;t&lt;r;t++)n+=o(e[t][0])+</span>";\n\t<span class="cstat-no" title="statement not covered" >";return <span class="fstat-no" title="function not covered" >n}</span>,s=function<span class="cstat-no" title="statement not covered" >(e,<span class="cstat-no" title="statement not covered" ></span>t,n,r){var <span class="cstat-no" title="statement not covered" >i=n[e];if(void 0===i){if(e.isVar){var o=[];retu<span class="cstat-no" title="statement not covered" >r</span></span>n o[e]=t,</span>[</span>[o<span class="cstat-no" title="statement not covered" >,null]]}i<span class="fstat-no" title="function not covered" >=e</span>}if(!i.comp<span class="cstat-no" title="statement not covered" >lexType)retur</span>n <span class="cstat-no" title="statement not covered" >r.redirec<span class="cstat-no" title="statement not covered" ></span>tions[i]&amp;&amp;(i=r.r<span class="cstat-no" title="statement not covered" >edirections[i]),r.redi<span class="cstat-no" title="statement not covered" >r</span></span>ections[t</span>]</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >(t=r.redi<span class="fstat-no" title="function not covered" >re</span>ctions[t]),i.sa<span class="cstat-no" title="statement not covered" >meTer<span class="cstat-no" title="statement not covered" ></span>m(t)?[[[],null]<span class="cstat-no" title="statement not covered" >]:[];if(e instance<span class="cstat-no" title="statement not covered" >of <span class="cstat-no" title="statement not covered" ></span>Array)return t instanceof <span class="cstat-no" title="statement not covered" ></span>A</span>rray<span class="cstat-no" title="statement not covered" ></span>?</span>c(e,t,n):[];throw<span class="cstat-no" title="statement not covered" > new Error("query.js: oops - code not written yet")},c=function e(t,n,r,i){var o;if(t.length!==n.length)return[];if(!t<span class="cstat-no" title="statement not covered" >.</span></span>length)return[[[],nul<span class="cstat-no" title="statement not covered" >l]];var a=s(t[0],n[0],r,i);if(0===a.le<span class="cstat-no" title="statement not covered" >n</span></span>gth)return a;var u,l,c,f,h,d,p,v=[],g=a.length;for(u=0;u&lt;</span>g</span>;u<span class="cstat-no" title="statement not covered" >++){l=a[u<span class="fstat-no" title="function not covered" >][</span>0],p=[];for(h i<span class="cstat-no" title="statement not covered" >n l)l.hasOwnProperty(h)<span class="cstat-no" title="statement not covered" >&amp;&amp;(p[h]=l<span class="cstat-no" title="statement not covered" >[</span></span>h]);for(h in<span class="cstat-no" title="statement not covered" > r)r.hasOwnProperty</span></span>(h)&amp;&amp;<span class="cstat-no" title="statement not covered" >(p[h]=r[h]);for(o<span class="cstat-no" title="statement not covered" ></span>=e(t.slice(1),n.<span class="cstat-no" title="statement not covered" >slice(1),p</span></span>,i),f=o.length,c=0;<span class="cstat-no" title="statement not covered" >c&lt;f</span>;c<span class="cstat-no" title="statement not covered" >++){d=o[c<span class="cstat-no" title="statement not covered" ></span>][0];for(h in l)l<span class="cstat-no" title="statement not covered" >.hasOwnProperty<span class="cstat-no" title="statement not covered" >(</span>h)&amp;&amp;(d[h]=<span class="cstat-no" title="statement not covered" >l[h]);v.push([d,null])}}return v}<span class="cstat-no" title="statement not covered" >,</span></span>f=function<span class="cstat-no" title="statement not covered" >(e,t){var n=t[e];return void 0===<span class="cstat-no" title="statement not covered" >n</span></span>?e:n},h=function(e,t){var n,r={};for(n in e)e.hasOwnProper<span class="cstat-no" title="statement not covered" >ty(n)&amp;&amp;(r[<span class="cstat-no" title="statement not covered" >n</span>]=e[n]);fo<span class="cstat-no" title="statement not covered" >r(n in t)t.hasOwnProperty(n)&amp;&amp;(r[<span class="cstat-no" title="statement not covered" >n</span></span>]=t[n]);return r}</span>,<span class="cstat-no" title="statement not covered" ></span>d</span>=function</span>(</span>e,<span class="cstat-no" title="statement not covered" >t){return<span class="fstat-no" title="function not covered" > t</span>his.trunkBi<span class="cstat-no" title="statement not covered" >nding<span class="cstat-no" title="statement not covered" ></span>s=t,this.originalCallba</span>c</span>k=<span class="cstat-no" title="statement not covered" >e,this.br<span class="fstat-no" title="function not covered" >an</span>ches=[],this}<span class="cstat-no" title="statement not covered" >;d.<span class="cstat-no" title="statement not covered" ></span>prototype.c<span class="cstat-no" title="statement not covered" >heckAllDone=function(){var e;for(<span class="cstat-no" title="statement not covered" >e</span></span>=0;e&lt;this.<span class="cstat-no" title="statement not covered" >branches.length;e++)if(!this.bran<span class="cstat-no" title="statement not covered" >c</span></span>hes[e].do</span>n</span>e)<span class="cstat-no" title="statement not covered" >return;u.<span class="fstat-no" title="function not covered" >de</span>bug("<span class="cstat-no" title="statement not covered" >OPTIONAL BIDNINGS ALL DONE:"),this.doCallBacks(this.branches.length-1,this.</span>t<span class="cstat-no" title="statement not covered" ></span>runkBindings)},d.prototyp<span class="fstat-no" title="function not covered" >e.</span>doCallBacks=fun<span class="cstat-no" title="statement not covered" >ction(e,t){var n;if(e&lt;0)return this<span class="cstat-no" title="statement not covered" >.originalCallback(t);for(n<span class="cstat-no" title="statement not covered" >=0;n&lt;th<span class="cstat-no" title="statement not covered" >i</span></span></span>s.branches[e].results.length;n++)this.doCallBacks(e-1,h(t,this.branches[e].results[n]))};var p=func</span>tion(e,t){return this.cou<span class="fstat-no" title="function not covered" >nt</span>=0,this.success=!1<span class="cstat-no" title="statement not covered" >,this.d<span class="cstat-no" title="statement not covered" >one=!1,this.callback=e,this.onDo<span class="cstat-no" title="statement not covered" >n</span></span>e=t,this};p.prototype.reportMatch=function(e)<span class="cstat-no" title="statement not covered" >{this.callback(e),this.success=!0},p.prototype.reportDon</span></span>e=</span>funct<span class="cstat-no" title="statement not covered" >ion(){thi<span class="fstat-no" title="function not covered" >s.</span>done=<span class="cstat-no" title="statement not covered" >!0,u.info("Mandatory query branch finished.***"),void 0!==this.onDone&amp;&amp;this.onDone()}</span>;<span class="cstat-no" title="statement not covered" ></span>var v=function(e){return<span class="fstat-no" title="function not covered" > t</span>his.count=<span class="cstat-no" title="statement not covered" >0,this.done=!1,this.results=[],thi</span>s.junction=e,e.branches.<span class="fstat-no" title="function not covered" >pu</span>sh(this),<span class="cstat-no" title="statement not covered" >this};v.prototype.reportMatch=function(e){this.results.push(e)},v.prototype.reportDone=function(</span>){</span>u.deb<span class="cstat-no" title="statement not covered" >ug("Optio<span class="fstat-no" title="function not covered" >na</span>l b<span class="cstat-no" title="statement not covered" >ranch finished - results.length = "+this.results.length),0===this.results.length&amp;&amp;(this.resul</span>t<span class="cstat-no" title="statement not covered" ></span>s.push({}),u.debug("Opti<span class="fstat-no" title="function not covered" >on</span>al branch <span class="cstat-no" title="statement not covered" >FAILED - that's OK."))</span>,this.done=!0,this.junct<span class="fstat-no" title="function not covered" >io</span>n.checkAl<span class="cstat-no" title="statement not covered" >lDone()};var g=function(e,t,n){var r,i,o,a,s;for(t.nvars=0,t.index=null,i=[t.subject,t.predicate,t.object],s=[e.subjectIndex,e.predicateIndex,e.objectIndex],a=0;a&lt;3;a++)if(i[a].isVar&amp;&amp;void 0===n[i[a]])t.nvars++;else</span>{i</span>f(r=f<span class="cstat-no" title="statement not covered" >(i[a],n),<span class="fstat-no" title="function not covered" >e.</span>redirections[r.hashSt<span class="cstat-no" title="statement not covered" >ring()]&amp;&amp;(r=e.redirections[r.hashString()]),o=s[a][r.hashString()],!o)return t.index=[],!1;(null===t.index||t.index.length&gt;o<span class="cstat-no" title="statement not covered" >.length)&amp;&amp;(t.index=o)}return nul<span class="cstat-no" title="statement not covered" >l===t.index</span>&amp;&amp;(t<span class="cstat-no" title="statement not covered" >.index=e.statements),!0},y=0,m=function e(n,r,i,a,s,c,f){u.debug("Match begins, Branch count now: "+f.count+<span class="cstat-no" title="statement not covered" >" for "+f.pattern_deb<span class="cstat-no" title="statement not covered" >u</span></span>g);var h=n.fetcher?n.fetcher:null,p=r.statements;if(0==<span class="cstat-no" title="statement not covered" ></span>=</span></span>p.length){if(u.debug("FOUND MATCH WITH BINDINGS:"</span>+</span>o(<span class="cstat-no" title="statement not covered" >i)</span>),<span class="cstat-no" title="statement not covered" >0===r.opt<span class="fstat-no" title="function not covered" >io</span>nal.length)f.re<span class="cstat-no" title="statement not covered" >portMatch(i);else{u.debug("OPTIONAL: "+r.optional);var g,m=new d(t,i),b=[];fo</span>r(g=0<span class="cstat-no" title="statement not covered" >;g&lt;r.optional.length;g++)</span>b[<span class="cstat-no" title="statement not covered" >g]=new v(m),b<span class="cstat-no" title="statement not covered" ></span>[g].pattern_debug<span class="cstat-no" title="statement not covered" >=r.optional[g];for(g=0;g&lt;r.optional.length;g++)b[g].count=b[g].count<span class="cstat-no" title="statement not covered" >+1,e(n,r.optional[</span>g],i<span class="cstat-no" title="statement not covered" >,"",s,t,b[g])}return f.count--,voi</span>d u.deb<span class="cstat-no" title="statement not covered" >ug("Match e</span>nd<span class="cstat-no" title="statement not covered" >s -<span class="cstat-no" title="statement not covered" ></span>- success , Branch count now: "+<span class="cstat-no" title="statement not covered" >f.count+" for "+f.pattern_debug)}var x,_,k=p.le<span class="cstat-no" title="statement not covered" >n</span></span>gth;if(h){var T="match"+y++,E=f<span class="cstat-no" title="statement not covered" >unction(t,o){var u=t.uri.split("#")[0];h.nowOrWhenFetched(<span class="cstat-no" title="statement not covered" ></span></span>u</span>,void 0,function(o,u,l){o&amp;&amp;console.log("Error following link to &lt;"+t.uri+"&gt; in query: "+u),e(n,r,i,a,s,c,f)}</span>)</span>};for(_=0<span class="cstat-no" title="statement not covered" >;_&lt;k;_++)<span class="cstat-no" title="statement not covered" ></span>{if(x=p[_],v<span class="cstat-no" title="statement not covered" >oid 0!==i[x.</span>su<span class="cstat-no" title="statement not covered" >bject]&amp;&amp;i<span class="fstat-no" title="function not covered" >[x</span>.subject].u<span class="cstat-no" title="statement not covered" >ri&amp;&amp;h&amp;&amp;"unrequested"<span class="cstat-no" title="statement not covered" ></span>===h.getState(l(i[x.subject]<span class="fstat-no" title="function not covered" >.u</span>ri)))return vo<span class="cstat-no" title="statement not covered" >id E(i[x.subject],T);if(void 0!==i[x.object]&amp;&amp;i[x.object].uri&amp;&amp;h&amp;&amp;"unrequested"===h.g</span>etS</span>t<span class="cstat-no" title="statement not covered" ></span>ate(l(i[x.object]<span class="cstat-no" title="statement not covered" >.uri)))return void E(i[x.object],T)}}w(n,r,i,a,s,c,f)},b=function(e,t){var n,r,i=!0;for(n in e)e.hasOw<span class="cstat-no" title="statement not covered" >nProperty(n)&amp;&amp;t[n]&amp;&amp;(r=t[n].te<span class="cstat-no" title="statement not covered" >s</span></span>t,r&amp;&amp;!r(e[n])&amp;&amp;(i=!1));return i},w=function(e,t,n,r,s,l,f){var h,d,p,v,y,w,x,_=t.statements<span class="cstat-no" title="statement not covered" >,k=_.length;for(h=0;h&lt;k;h++)x=</span></span>_<span class="cstat-no" title="statement not covered" ></span>[</span>h],u.info("match2</span>:</span> i<span class="cstat-no" title="statement not covered" >tem="+x+"<span class="fstat-no" title="function not covered" >, </span>bindingsSoFar="<span class="cstat-no" title="statement not covered" >+o(<span class="cstat-no" title="statement not covered" ></span>n)),g(e,x,n<span class="cstat-no" title="statement not covered" >);_.sort(i),x=_[0];var T=e.formula();T.optional=t.optional,T.<span class="cstat-no" title="statement not covered" >c</span></span>onstraint</span>s</span>=t<span class="cstat-no" title="statement not covered" >.constraints,T.statements=_.slice(<span class="fstat-no" title="function not covered" >1)</span>,u.debug(r+"match2 searching "+x.in<span class="cstat-no" title="statement not covered" >dex.length+" </span>fo<span class="cstat-no" title="statement not covered" >r "+x+"; <span class="cstat-no" title="statement not covered" ></span>bindings so far=<span class="cstat-no" title="statement not covered" >"+o(n));var E,S,N,R=x.index.length,j=0;for(E=0;E&lt;R;E++)for(N=x.ind<span class="cstat-no" title="statement not covered" >e</span></span>x[E],S=c([x.subje</span>ct,x.<span class="cstat-no" title="statement not covered" >predicate,x.<span class="cstat-no" title="statement not covered" ></span>object],[N.subject,N.predicate,N.object],n,e),u.info(r+" From first: "+S.length+": "+a(S)),p=S.length,d=0;d&lt;p;d++)if(y=[],w=S[d][0],b(w,t.constraints)){for(v</span> in w)w.has<span class="cstat-no" title="statement not covered" >OwnProperty(v)&amp;</span>&amp;(<span class="cstat-no" title="statement not covered" >y[<span class="cstat-no" title="statement not covered" ></span>v]=w[v]);for(v i<span class="cstat-no" title="statement not covered" >n n)n.hasOwnProperty(v)&amp;&amp;(y[v]=n[v]);f.count++,j++,m(e,T,y,r+"  ",s,l,f)}else u.debug("Branch count CS: "+f.count);f.count--,0===j&amp;&amp;u.debug("Match2 fails comple<span class="cstat-no" title="statement not covered" >tely on "+x),u.debug("Match2 ends, Bra<span class="cstat-no" title="statement not covered" >nch count: <span class="cstat-no" title="statement not covered" >"+f.count+" for "+f.pattern_debug<span class="cstat-no" title="statement not covered" >)</span></span>,0===f.cou<span class="cstat-no" title="statement not covered" >nt&amp;&amp;(u.debug("Branch finished."),<span class="cstat-no" title="statement not covered" >f</span></span>.reportDone())},x=this;u.debug("Quer</span>y on <span class="cstat-no" title="statement not covered" >"+this.statements.length);var _=new p<span class="cstat-no" title="statement not covered" >(</span></span></span></span>t,r);_.count++,setTimeout(function(){m(x,e.pat,e.pat.initBindings,"",n,t,_)},0)}var a=n(4),s=r(a),u=n(15),l=n(7).docpart,c=function e(t,n){i(this,e),this.pat=new s.default,this.vars=[],th</span>i</span>s.<span class="cstat-no" title="statement not covered" >name=<span class="cstat-no" title="statement not covered" ></span>t,this.id=n};e.exports.Query=c,e.exports.inde</span>xedFo<span class="cstat-no" title="statement not covered" >rmulaQuery=<span class="cstat-no" title="statement not covered" ></span>o},function(e,t,n){"u<span class="fstat-no" title="function not covered" >se</span> strict";<span class="cstat-no" title="statement not covered" >function r(e){return e&amp;&amp;e.__esModule?e:{</span>defau</span>lt:e}}<span class="cstat-no" title="statement not covered" >funct</span>io<span class="cstat-no" title="statement not covered" >n i(e</span>){<span class="cstat-no" title="statement not covered" >return</span> n<span class="cstat-no" title="statement not covered" >ew m(e)}funct</span>io<span class="cstat-no" title="statement not covered" >n o(e){re<span class="fstat-no" title="function not covered" >tu</span>rn ne<span class="cstat-no" title="statement not covered" >w b(e)}function a(){return new w}function s(e,t,n){return new x(e,t,n)}</span>f<span class="cstat-no" title="statement not covered" ></span>unction u(){return new y.default}function l(e,t,n){</span>r<span class="fstat-no" title="function not covered" >et</span>urn new _(""+e,t,n)}function c(e,t){<span class="fstat-no" title="function not covered" >re</span>tur<span class="cstat-no" title="statement not covered" >n"string"==typeof t?t.indexOf(":")===-</span>1?new _(e<span class="fstat-no" title="function not covered" >,t</span>):n<span class="cstat-no" title="statement not covered" >ew _(e,null,f(t))</span>:new _(e,<span class="fstat-no" title="function not covered" >nu</span>ll,<span class="cstat-no" title="statement not covered" >t)}function f(e){</span>return ne<span class="fstat-no" title="function not covered" >w </span>k(<span class="cstat-no" title="statement not covered" >e)}function h(e,</span>t,n,r){re<span class="fstat-no" title="function not covered" >tu</span>rn r=r|<span class="cstat-no" title="statement not covered" >|new w,new T(e,t,n,r)</span>}function<span class="fstat-no" title="function not covered" > d</span>(e<span class="cstat-no" title="statement not covered" >,t,n,r){return new T(e,t</span>,n,r)}fun<span class="fstat-no" title="function not covered" >ct</span>ion p(e<span class="cstat-no" title="statement not covered" >,t,n){return h(e,t,n)}fu</span>nction v(<span class="fstat-no" title="function not covered" >e)</span>{retu<span class="cstat-no" title="statement not covered" >rn new E(e)}var g=n(4),y=r(g),m=n(12),b=n(11),w=n(76),x=n(77),_=n(13),k=n(8),T=n(71),E=n(72)</span>;e.export<span class="fstat-no" title="function not covered" >s.</span>bla<span class="cstat-no" title="statement not covered" >nkNode=i,e.export</span>s.default<span class="fstat-no" title="function not covered" >Gr</span>aph=a,e.e<span class="cstat-no" title="statement not covered" >xports.graph=u,e.exports.literal=c,e</span>.exports.<span class="fstat-no" title="function not covered" >na</span>medNode=f<span class="cstat-no" title="statement not covered" >,e.exports.quad=h,e.exp</span>orts.trip<span class="fstat-no" title="function not covered" >le</span>=p,e.ex<span class="cstat-no" title="statement not covered" >ports.variable=v,</span>e.exports<span class="fstat-no" title="function not covered" >.c</span>oll<span class="cstat-no" title="statement not covered" >ection=o,e.export</span>s.fetc<span class="cstat-no" title="statement not covered" >her=s</span>,e<span class="cstat-no" title="statement not covered" >.expo</span>rt<span class="cstat-no" title="statement not covered" >s.lit=</span>l,<span class="cstat-no" title="statement not covered" >e.expo</span>rt<span class="cstat-no" title="statement not covered" >s.st=d</span>},<span class="cstat-no" title="statement not covered" >functi</span>on<span class="cstat-no" title="statement not covered" >(e,t,n</span>){<span class="cstat-no" title="statement not covered" >"use </span>st<span class="cstat-no" title="statement not covered" >rict";</span>fu<span class="cstat-no" title="statement not covered" >nction<span class="cstat-no" title="statement not covered" ></span> r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&amp;&amp;"function"!=typ</span>e<span class="fstat-no" title="function not covered" >of</span> t?e:t}function o(e,t){if("function"<span class="fstat-no" title="function not covered" >!=</span>typeo<span class="cstat-no" title="statement not covered" >f t&amp;&amp;null!==t)throw n<span class="cstat-no" title="statement not covered" >ew TypeError("Super expression must either be null or a fu</span></span>nction, n<span class="fstat-no" title="function not covered" >ot</span> "+ty<span class="cstat-no" title="statement not covered" >peof t<span class="cstat-no" title="statement not covered" >);e.prototype=Object.create(t&amp;&amp;t.prototype,{constructor:{value:e,enumerable:!1,writabl<span class="cstat-no" title="statement not covered" >e</span></span>:!0,configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object</span>.setProto<span class="fstat-no" title="function not covered" >ty</span>peOf(<span class="cstat-no" title="statement not covered" >e,t):e.__proto__=t)}var a=function<span class="cstat-no" title="statement not covered" >(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r<span class="cstat-no" title="statement not covered" >.</span></span>configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s=n(10),u=function(e){function </span>t(){r(<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >th</span>is,t);var e=i(this<span class="fstat-no" title="function not covered" >,O</span>bject<span class="cstat-no" title="statement not covered" >.getPrototypeOf(t).call(this));ret<span class="cstat-no" title="statement not covered" >urn e<span class="cstat-no" title="statement not covered" ></span>.termType="DefaultGraph",e.value="",e}return o(t,e),a(t,[{key:"toCanonical",value:function(){return this.value}</span>}<span class="cstat-no" title="statement not covered" ></span>]),t}(s<span class="fstat-no" title="function not covered" >);</span>e.exports=u},f<span class="cstat-no" title="statement not covered" >unction(e,t,n){"use strict";var r="funct</span>io</span>n"=</span>=t<span class="cstat-no" title="statement not covered" >ypeof </span>Sy<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >mb</span>ol&amp;&amp;"symbol"==typeo<span class="fstat-no" title="function not covered" >f </span>Sy<span class="cstat-no" title="statement not covered" >mbol.iterat</span>or?fu<span class="cstat-no" title="statement not covered" >nction(e){return typeof e}:function(e){retur<span class="cstat-no" title="statement not covered" ></span>n e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor==<span class="cstat-no" title="statement not covered" ></span>=Symbol?"symbol":typeof e},i=n(15),o=n(78),a=n(8),s=n(73),u=n(79),l=n(80).pars<span class="fstat-no" title="function not covered" >eRDFaD</span>OM<span class="cstat-no" title="statement not covered" >,c=n(81),f=n(7),h=n</span>(5),d=n</span>(21)<span class="cstat-no" title="statement not covered" ></span>,p={"text/n3"</span>:<span class="fstat-no" title="function not covered" >!0</span>,"text/turtle":!0,"application/rd<span class="cstat-no" title="statement not covered" >f+xml":!0,"application/xhtml+xml":!0,"text/html":!0,"applica<span class="fstat-no" title="function not covered" >ti</span>on/ld+json<span class="cstat-no" title="statement not covered" >":!0},v=function </span>e<span class="fstat-no" title="function not covered" >(t</span>,n,v){this<span class="cstat-no" title="statement not covered" >.store=t,this.thisURI="http://dig.csail.mit.edu/2005/ajar/ajaw/rdf/sources.js#S</span>o</span>ur<span class="cstat-no" title="statement not covered" >ceFetc</span>he<span class="cstat-no" title="statement not covered" >r",thi</span>s.<span class="cstat-no" title="statement not covered" >timeo</span>ut<span class="cstat-no" title="statement not covered" >=n||3e</span>4,<span class="cstat-no" title="statement not covered" >this.a</span>sy<span class="cstat-no" title="statement not covered" >nc=null==v||v,this.</span>ap<span class="cstat-no" title="statement not covered" >pNode=</span>th<span class="cstat-no" title="statement not covered" >is.st</span>or<span class="cstat-no" title="statement not covered" >e.bno</span>de<span class="cstat-no" title="statement not covered" >(),thi</span>s.<span class="cstat-no" title="statement not covered" >store.fetcher=this,this.requested={},this.redirectedTo={},this.fetchCallbacks={},this.nonexistant={},this.lookedUp={},this.h</span>an<span class="cstat-no" title="statement not covered" >dlers=[],<span class="fstat-no" title="function not covered" >th</span>is.medi<span class="cstat-no" title="statement not covered" >atypes={};var g=this,y=this.store,m={};m.link=s("http://www.w3.org/2007/ont/link#"),m.http=s("http://www.w3.org/2007/ont/http#"),m.httph=s("http://www.w3.org/2007/ont/httph#"),m.rdf=s("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),m.rdfs=s("http://www.w3.org/2000/01/rdf-schema#"),m.dc=s("http://purl.org/dc/elements/1.1/"),g.media</span>types<span class="cstat-no" title="statement not covered" >["ima</span>ge<span class="cstat-no" title="statement not covered" >/*"]={q:.9}</span>,g<span class="cstat-no" title="statement not covered" >.me<span class="cstat-no" title="statement not covered" ></span>diatypes["*/*"]={q:.1},e.crossSiteProxy=function(t){return e.crossSiteProxyTemplate?e.crossSiteProxyTemplate.replace("{uri}",encodeURIComponent(t)):void 0},e.RDFXMLHandler=function(e){e&amp;&amp;(this.dom=e[0]),this.handlerFactory=function(e){e.handle=function(t){var n=g.store;this.dom||(this.dom=h.parseXML(e.responseText));var r=this.dom.documentElement;if("parsere<span class="fstat-no" title="function not covered" >rr</span>or"===r.no<span class="cstat-no" title="statement not covered" >deName)throw g.failFetch(e,"Badly formed XML in "+e.resource.uri),new Error("Badly formed XML in "+e.res</span>ource.uri);var i=<span class="fstat-no" title="function not covered" >ne</span>w c(n);try<span class="cstat-no" title="statement not covered" >{i.parse(this.dom,e.original.uri,e.orig<span class="fstat-no" title="function not covered" >in</span>al)}catch(<span class="cstat-no" title="statement not covered" >t){g.addS<span class="fstat-no" title="function not covered" >ta</span>tus(e.req,"Synta<span class="cstat-no" title="statement not covered" >x error <span class="cstat-no" title="statement not covered" ></span>parsing RDF/XML! "+t),console.log("Syntax error p</span>arsin<span class="cstat-no" title="statement not covered" >g RDF/XML! "+t)}e.options<span class="cstat-no" title="statement not covered" ></span>.noMeta||n.add(e.original,m.rd<span class="cstat-no" title="statement not covered" >f("type"),m.link("RDFDocument"),g.appNode),t()}}},e.RDFXMLHandler.toString=function(){return"RDFXMLHandler"},</span></span>e.RDF<span class="cstat-no" title="statement not covered" >XMLHandle<span class="cstat-no" title="statement not covered" ></span>r.re<span class="cstat-no" title="statement not covered" >gister=function(e){e.mediatypes["application/</span>rdf+xml"]<span class="cstat-no" title="statement not covered" >={q:.9}},e.RDFXMLHandler.pattern=new RegExp("application/rdf\\+xml"),e.XHTMLHandler=function(e){e&amp;&amp;(thi<span class="cstat-no" title="statement not covered" ></span>s</span>.dom=e[0]),this.handlerFactory=function(e){e.handle=function(t){var n,r;this.dom||(thi</span>s.</span>do</span>m=h.parseXML(e.responseTex<span class="fstat-no" title="function not covered" >t)</span>);var i=g<span class="cstat-no" title="statement not covered" >.store,o=this.dom.getEl</span>ementsByTagName("title");o<span class="fstat-no" title="function not covered" >.l</span>ength&gt;0&amp;&amp;i<span class="cstat-no" title="statement not covered" >.add(e.resource,m.dc("title"),i.literal(o[0]</span>.textContent),e.resource);for(var a=this.dom.getElementsByTagName("link"),s=<span class="fstat-no" title="function not covered" >a.</span>length-1;s<span class="cstat-no" title="statement not covered" >&gt;=0;s--)n=a[s].getAttribute("rel"),r=!1<span class="fstat-no" title="function not covered" >,n</span>||(n=a[s].<span class="cstat-no" title="statement not covered" >getAttrib<span class="fstat-no" title="function not covered" >ut</span>e("rev"),r=!0),n&amp;&amp;<span class="cstat-no" title="statement not covered" >g.linkData(e,n,a[s].getAttribute("href"),e.resour</span>ce,r)<span class="cstat-no" title="statement not covered" >;for(var</span> c<span class="cstat-no" title="statement not covered" >=this.dom.getElementsByTagName("script"<span class="cstat-no" title="statement not covered" ></span>),f=0;f&lt;c.length;f++){var d=c[f].getAttribute("type");p[d]&amp;&amp;u(c[f].textContent,i,e.<span class="cstat-no" title="statement not covered" >o</span>riginal.uri,d)}if(e.options.noMeta||i.add(e.resource,m.rdf("type"),m.<span class="cstat-no" title="statement not covered" >link("WebPage"),g.appNode),!e.options.noRDFa&amp;&amp;l)try{l(this.dom,i,e.original.uri)}catch(t){var v="Error trying to parse "+e.reso<span class="cstat-no" title="statement not covered" >u</span></span>rce+" as RDFa:\n"+t+":\n"+t.stack;return void g.failFetch(e,v)}t()}}},e.XHT<span class="cstat-no" title="statement not covered" >MLHandler.toString=functio<span class="cstat-no" title="statement not covered" ></span>n(){return"XHTMLHandler"},e.XHTMLHandler.regis<span class="cstat-no" title="statement not covered" ></span>t</span>er=function(e){e.mediatypes["application/xhtml+xml"]={}},e.XHTMLHandler.pattern=new RegExp("applicati<span class="cstat-no" title="statement not covered" >on/x<span class="cstat-no" title="statement not covered" >html"),e.XMLHandler=function()</span>{this.handlerFa<span class="cstat-no" title="statement not covered" >ctory=function(e){e.handle=function(t){for(var n=h.parseXML(e.resp<span class="cstat-no" title="statement not covered" ></span>onseText),r=0;r&lt;n.childNodes.l<span class="cstat-no" title="statement not covered" ></span>e</span></span>ngth</span>;r</span>++</span>)if(1===n.childNodes[r].n<span class="fstat-no" title="function not covered" >od</span>eType){va<span class="cstat-no" title="statement not covered" >r i=n.childNodes[r].na</span>mespaceURI;if(i&amp;&amp;i===i.rd<span class="fstat-no" title="function not covered" >f)</span>return g.a<span class="cstat-no" title="statement not covered" >ddStatus(e.req,"Has XML root element in th</span>e RDF namespace, so assume RDF/XML."),void g.switchHandler("RDFXMLHan<span class="fstat-no" title="function not covered" >dl</span>er",e,t,[<span class="cstat-no" title="statement not covered" >n]);break}if(n.docty<span class="fstat-no" title="function not covered" >pe</span>&amp;&amp;"html"==<span class="cstat-no" title="statement not covered" >=n.doctyp<span class="fstat-no" title="function not covered" >e.</span>name&amp;&amp;n.do<span class="cstat-no" title="statement not covered" >ctype.publicId.match(/^-\/\/W3C\/\/DTD XHTML/)&amp;&amp;n.doctype.systemId.<span class="cstat-no" title="statement not covered" >match(/http:\/\/www.w3.org\/TR\/xhtml/)<span class="cstat-no" title="statement not covered" >)return g.addStatus(e.req,"Ha<span class="cstat-no" title="statement not covered" ></span>s XHTML DOCTYPE.<span class="cstat-no" title="statement not covered" > Switching to XHTML Handler.\n"),void g.switchHandler("XHTMLHandler",e,t);var o=n.getElementsByTagName("html")[0];if(o){var a=o.getAttri<span class="cstat-no" title="statement not covered" >b</span></span>ute("x<span class="cstat-no" title="statement not covered" ></span>m</span></span>lns");if(a&amp;&amp;a.match(/^http:\/\/www.w3.org\/1999\/xhtml/))return g.addStatus(e.req,"Has a default namespace for XHTML. Switching to XHTMLHandler.\n"),<span class="cstat-no" title="statement not covered" >void g.switchHandler("XHTMLHandler",e,t)}g.failFetch(e,"Unsupported dialect of XML: not RDF or XHTML namespace, etc.\n"</span></span>+e.re<span class="cstat-no" title="statement not covered" >sponseText.slice(0,80))}}},e.XMLHa<span class="cstat-no" title="statement not covered" ></span>ndler.toStri<span class="cstat-no" title="statement not covered" >ng=function(){return"XML<span class="cstat-no" title="statement not covered" ></span>Handler"},e.XMLHandler.register=function(e){e.media<span class="cstat-no" title="statement not covered" >types["text/xml"]={q:.5},e.mediatypes["application/xml"]={q:.5}},e.XMLHandler.pattern=new RegExp("(text|application)/(.*)xml"),e.HTMLH<span class="cstat-no" title="statement not covered" ></span></span>a</span>ndler=function(){this.handlerFactory=function(e){e.handle=function(t){var n=e.responseText;if(n.match(/\s*&lt;</span>\?</span>xm</span>l\s+version\s*=[^&lt;&gt;]+\?<span class="fstat-no" title="function not covered" >&gt;/</span>))return <span class="cstat-no" title="statement not covered" >g.addStatus(e.req,"H</span>as an XML declaration. <span class="fstat-no" title="function not covered" >We</span>'ll assume<span class="cstat-no" title="statement not covered" > it's XHTML as the content-type was text/html.\n"),void g.switchHandler(</span>"XHTMLHandler",e,t);if(n.match(/.*&lt;!DOCTYPE\s+html[^&lt;]+-\/\/W3C\/\/DTD XHTML[<span class="fstat-no" title="function not covered" >^&lt;</span>]+http:\/<span class="cstat-no" title="statement not covered" >\/www.w3.org\/TR\/xh<span class="fstat-no" title="function not covered" >tm</span>l[^&lt;]+&gt;/))<span class="cstat-no" title="statement not covered" >return g.<span class="fstat-no" title="function not covered" >ad</span>dStatus(e.req,"H<span class="cstat-no" title="statement not covered" >as XHTML DOCTYP<span class="cstat-no" title="statement not covered" ></span>E. Switching to XHTMLHandler.\n"),void g.switch<span class="cstat-no" title="statement not covered" >Handler("XHTMLHandler",e,t);if(n.match(/[^(&lt;html)]*&lt;html\s+[^&lt;]*xmlns=['"]http:\/\/www.w3.org\/1999\/xhtml["'][^&lt;]*&gt;/))return g.addStatus(e.req,"Has defau<span class="cstat-no" title="statement not covered" >l</span></span>t namespace for XHTML, so switching to XHTMLHandler.\n"),void g.switchHandler("XHTMLHandler",e,t);v<span class="cstat-no" title="statement not covered" >ar r=new RegExp("&lt;title&gt;([\\s\\S]+?)&lt;/title&gt;","im").exec(n);if(r){var i=g.store;return i.add(e.resource,m.dc("title")<span class="cstat-no" title="statement not covered" >,</span></span>i.literal(r[1]),e.resource),i.add(e.resource,m.rdf("type"),m.link("WebPage"),g.appNode),vo<span class="cstat-no" title="statement not covered" >id t()}g.addStatus(e.req,"non-XML HTML document, not parsed for data."),g.doneFetch(e)}}},e.HTMLHandler.toString=function(){return"HTML</span></span>Handl<span class="cstat-no" title="statement not covered" >er"},e.HTMLHandler.register=function(e){e.mediatypes["t<span class="cstat-no" title="statement not covered" ></span>ext/html"]={<span class="cstat-no" title="statement not covered" >q:.9}},e<span class="cstat-no" title="statement not covered" ></span>.HTMLHandler.pattern=new RegExp("text/html"),e.TextHandler=function(){this.handlerFactory=function(e){e.handle=function(t){var n=e.respo<span class="cstat-no" title="statement not covered" ></span>n</span>seText;return n.match(/\s*&lt;\?xml\s+version\s*=[^&lt;&gt;]+\?&gt;/)?(g.addStatus(e.req,"Wa</span>rn</span>in</span>g: "+e.resource+" has an<span class="fstat-no" title="function not covered" > X</span>ML declar<span class="cstat-no" title="statement not covered" >ation. We'll assume i</span>t's XML but its content-<span class="fstat-no" title="function not covered" >ty</span>pe wasn't <span class="cstat-no" title="statement not covered" >XML.\n"),void g.switchHandler("XML</span>Handler",e,t)):n.slice(0,500).match(/xmlns:/)?(g.addStatus(e.<span class="fstat-no" title="function not covered" >re</span>q,"May ha<span class="cstat-no" title="statement not covered" >ve an XML namespace.<span class="fstat-no" title="function not covered" > W</span>e'll assum<span class="cstat-no" title="statement not covered" >e it's XM<span class="fstat-no" title="function not covered" >L </span>but its content-<span class="cstat-no" title="statement not covered" >type wasn't XML<span class="cstat-no" title="statement not covered" ></span>.\n"),void g.switchHandler("XMLHandler",e,t)):(g.addStatus(e.req,"Plain text document, no known RDF semantics."),void g.doneFetch(e))}}},e.TextHandler.toString=function(){return"TextHandler"},e.TextHandler.register=function(e){e.mediatypes["text/plain"]={q:.5}},e.TextHandler.pattern=new RegExp("text/plain"),e.N3Handler=function(){this.handlerFactory=function(e){e.handle=function(t){var n=o(y,y,e.original.uri,e.original.uri,null,null,"",null);try{n.loadBuf(e.responseText)}catch(t)</span>{v</span>ar</span> r="Error trying to pars<span class="fstat-no" title="function not covered" >e </span>"+e.resou<span class="cstat-no" title="statement not covered" >rce+" as Notation3:\n</span>"+t+":\n"+t.stack;return<span class="fstat-no" title="function not covered" > v</span>oid g.fail<span class="cstat-no" title="statement not covered" >Fetch(e,r)}g.addStatus(e.req,"N3 pa</span>rsed: "+n.statementCount+" triples in "+n.lines+" lines."),g<span class="fstat-no" title="function not covered" >.s</span>tore.add(<span class="cstat-no" title="statement not covered" >e.original,m.rdf("ty<span class="fstat-no" title="function not covered" >pe</span>"),m.link(<span class="cstat-no" title="statement not covered" >"RDFDocum<span class="fstat-no" title="function not covered" >en</span>t"),g.appNode),g<span class="cstat-no" title="statement not covered" >.doneFetch(e)}}},e.N3Handler.toString=function(){return<span class="cstat-no" title="statement not covered" ></span>"N3H<span class="cstat-no" title="statement not covered" >andler"},e.N3Handler.regist</span>er=function(e){<span class="cstat-no" title="statement not covered" >e.mediatypes["text/n3"]={q:"1.0"},e.mediatypes["text/turtle"]={q:1}},e.<span class="cstat-no" title="statement not covered" ></span>N3Handler.pattern=new RegExp("<span class="cstat-no" title="statement not covered" ></span>(</span>application|text)/(x-)?(rdf\\+)?(n3|turtle)"),h.callbackify(this,["request","recv","headers","load","fail","refresh","retract","done"]),this.addHandler=function(e){g.ha</span>nd</span>le</span>rs.push(e),e.register(<span class="fstat-no" title="function not covered" >g)</span>},this.sw<span class="cstat-no" title="statement not covered" >itchHandler=functio</span>n(t,n,i,o){for(var a=n<span class="fstat-no" title="function not covered" >ul</span>l,s=0;s&lt;th<span class="cstat-no" title="statement not covered" >is.handlers.length;s++)""+this.handlers[s]===t&amp;&amp;(a=this.handlers[s]);</span>if(!a)throw new Error("web.js: switchHandler: name="+t+" , this.handlers ="+this.handlers+"\nswitchHandler: switching to "+a+"; sf="+g+"; typeof Fetcher="+("undefined"==typeof e?"undefin<span class="fstat-no" title="function not covered" >ed</span>":r(e))+";<span class="cstat-no" title="statement not covered" >\n\t Fetcher.HTMLHandler="+e.HTMLH</span>andler+"\n\n\tsf.han<span class="fstat-no" title="function not covered" >dl</span>ers="+g.handlers<span class="cstat-no" title="statement not covered" >+"\n");new a(o).handlerFactory(n),n.handle(i)}<span class="cstat-no" title="statement not covered" >,this.addStatus=function(e,t){var n=new Date;t<span class="cstat-no" title="statement not covered" >=</span></span>"["+n<span class="cstat-no" title="statement not covered" >.getHours()+":"+n.getMinutes()+":"+n.getSeconds()+"."+n.getMilliseconds()+"] "+t;var r=this.store,o=r.the(e,m.link("status"));o&amp;&amp;o.append?o.append(r.literal(t)):i.warn("web.js: No list to add to: "+o+","+t)},this.failFetch=function(e,t){for(this.addStatus(e.req,t),e.opti<span class="cstat-no" title="statement not covered" >o</span></span>ns.noMeta||y.add(e.original,m.link("err</span>or"),t),e.resour<span class="fstat-no" title="function not covered" >ce</span>.sameTerm(e.origin<span class="cstat-no" title="statement not covered" >al)?console<span class="cstat-no" title="statement not covered" ></span>.log("@@ Recording failure for "+e.original+": "+e.status):console.log("@@ Recording fail</span>ure o<span class="cstat-no" title="statement not covered" >riginal "+e</span>.o<span class="cstat-no" title="statement not covered" >riginal+"( as "+e.resource<span class="cstat-no" title="statement not covered" ></span>+") : "+e.status),this.requested[f.docpart(e.original.uri)]=e.status;this.fetchCal</span>lbacks[e.origina<span class="fstat-no" title="function not covered" >l.</span>uri]&amp;&amp;this.f<span class="cstat-no" title="statement not covered" >etchCallbacks[e.original.uri].length;)this.fetchCallbacks[e.original.uri].shift()(!1,"Fetch of &lt;"+e.original.uri+"&gt; failed: "+t,e);return delete this.fetchCallbacks[e.original.uri],this.fireCallbacks("fail",[e.original.uri,t]),e.abort(),e},this.linkData=function(e,t,n,r,i){if(n){var o,a=y.sym(f.join(n,e.original.uri));if("alternate"===t||"seeAlso"===t||"meta"===t||"describedby"===t){if(a.uri===e.origi<span class="cstat-no" title="statement not covered" >nal.uri)return;o=m.rdfs("seeAlso")}else o="type"===t?y.sym("http://www.w3.org/1999/02/22-rdf-<span class="cstat-no" title="statement not covered" >s</span></span>yntax-ns#type"):y.sym(f.join(t,"http://www.iana.org/assignments/link-relations/"));i?y.add(a,o,e.original,r)</span>:y.add(e.origin<span class="fstat-no" title="function not covered" >al</span>,o,a,r)}},this.par<span class="cstat-no" title="statement not covered" >seLinkHeader=f<span class="cstat-no" title="statement not covered" >unction(e,t){var n;try{n=e.getRe<span class="cstat-no" title="statement not covered" ></span>sponseHeader("link")}catch(e){}if(n)for(var r=/&lt;[^&gt;]*&gt;\s*(\s*;\s*[<span class="cstat-no" title="statement not covered" >^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t<span class="cstat-no" title="statement not covered" >]+=(([^<span class="cstat-no" title="statement not covered" >\</span></span>(\)&lt;&gt;@,;:"\/\[\]\?={</span>} \t]<span class="cstat-no" title="statement not covered" >+)|("[^"]*")))*(,|$)/g,i=/[^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t]+=(([^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g,o=n.match(r),a=0;a&lt;o.length;a++)for<span class="cstat-no" title="statement not covered" >(</span></span>var s=o[a].split("&gt;"),u=s[0].substring(1),l=s[1],c</span>=</span>l.match(i),f=0;f&lt;c.len<span class="fstat-no" title="function not covered" >gt</span>h;f++){var h=c[f],<span class="cstat-no" title="statement not covered" >d=h.<span class="cstat-no" title="statement not covered" >split("="),p=d[1].replace(/["']</span>/g,"");thi<span class="cstat-no" title="statement not covered" >s</span>.lin<span class="cstat-no" title="statement not covered" >kData(e,p,u,t)}},this.doneFetch=function(e){for(this.addStatus(e.req,"Done."),this.requested[e.original.uri]="done";this.fetchCallbacks[e.original.uri]&amp;&amp;this.fetchCallbacks[e.original.uri].length;)this.fetchCallbacks[e.orig<span class="cstat-no" title="statement not covered" >inal.uri].shift()(!0,void 0,e);delete this.fetchCallbacks[e.original.uri],this.fireCallbacks<span class="cstat-no" title="statement not covered" >("don</span>e"<span class="cstat-no" title="statement not covered" >,[e.original.</span>ur<span class="cstat-no" title="statement not covered" >i])};var b=[e.RDFXMLHandl<span class="cstat-no" title="statement not covered" ></span>er,e.XHTMLHandler,e.XMLH</span>a</span></span></span>ndler,e.HTMLHand<span class="fstat-no" title="function not covered" >le</span>r,e.TextHa<span class="cstat-no" title="statement not covered" >ndler,e.N3Handler];b.map(this.addHandler),this.nowKnownAs=function(e,t){this.lookedUp[e.uri]?this.lookedUp[t.uri]||this.lookUpThing(t,e):this.lookedUp[t.<span class="cstat-no" title="statement not covered" >uri]&amp;&amp;(this.lookedUp[e.uri]||this.lookUpThing(e,t))},this<span class="cstat-no" title="statement not covered" >.</span></span>putBack=function(e,t){e=e.uri||e;var n=new a(e).doc();return t.data=d(n,this.store,n.ur</span>i,</span>t.con<span class="cstat-no" title="statement not covered" >tentType||"text/turtle"),this.webOperation("PUT",e,t)},this.webOperation=function(e,t,<span class="cstat-no" title="statement not covered" ></span>n){t=t.uri||t,n=n||{},t=this.proxyIfNec<span class="fstat-no" title="function not covered" >es</span>sary(t);var <span class="cstat-no" title="statement not covered" >r=this;return new Promise(function(i,o){var a=h.XMLHTTPFactory();a.options=n,a.original=r.store.sym(t),n.noMeta||"undefined"==typeof t</span>abulator||r.sa<span class="fstat-no" title="function not covered" >ve</span>RequestMetad<span class="cstat-no" title="statement not covered" >ata(a,r.stor</span>e,t),<span class="cstat-no" title="statement not covered" >a.onreadystatec<span class="cstat-no" title="statement not covered" ></span>hange=function(){if(4===a.readyState){var e=!a.status||a.status&gt;=200&amp;&amp;a.status&lt;300;n.noMeta||"u</span>ndefined"==typeof t<span class="fstat-no" title="function not covered" >ab</span>ulator||r.save<span class="cstat-no" title="statement not covered" >ResponseMetadata(a,r.store),e?i(a):o(a.status+"</span> "+a.<span class="cstat-no" title="statement not covered" >statu<span class="cstat-no" title="statement not covered" ></span>sText)}},a.open(e,t<span class="fstat-no" title="function not covered" >,!</span>0),a.setRequestHea<span class="cstat-no" title="statement not covered" >der("Content-type",<span class="cstat-no" title="statement not covered" ></span>n.contentType||"text/turtle"),a.send(n.data?n.data:void 0)})},this.webCopy=function(e,t,n){var r=this;return e=e.uri||e,new Promise(fun<span class="fstat-no" title="function not covered" >ct</span>ion(i,o){<span class="cstat-no" title="statement not covered" >r.webOperation("GET",e).the<span class="cstat-no" title="statement not covered" >n(function(e){r.webOperation("PUT",t,{d<span class="cstat-no" title="statement not covered" ></span>ata:e.responseText,contentType:n}).then(function(e){i(e)}).catch(function(e){o(e)})}).catch(function(e){o(e)})})</span>}</span>,this.lookUpThing=function(e,t,n,r,i){var o,a=y.uris(e),s=!0,u="",l={};if(n===!1||n===!0?(o=n,n={force:o}):(vo</span>id </span>0===n&amp;&amp;(n={}),<span class="fstat-no" title="function not covered" >o=</span>!!n.force),"undefine<span class="cstat-no" title="statement not covered" >d"!=t<span class="cstat-no" title="statement not covered" ></span>ypeof a)for(var c=0;c&lt;a.length<span class="fstat-no" title="function not covered" >;c</span>++){var h=a[<span class="cstat-no" title="statement not covered" >c];l[h]=!0,this.lookedUp[h]=!<span class="fstat-no" title="function not covered" >0;</span>var d=this<span class="cstat-no" title="statement not covered" >,p=function(e){d.requestURI(f.docpart(e),t,n,function(t,n,o){t?r&amp;<span class="fstat-no" title="function not covered" >&amp;r</span>(!0,e):(r&amp;<span class="cstat-no" title="statement not covered" >&amp;r(!1,</span>n),s=!1,<span class="fstat-no" title="function not covered" >u+</span>=n+"\n"),d<span class="cstat-no" title="statement not covered" >elete </span>l[h</span>],Object<span class="fstat-no" title="function not covered" >.k</span>eys(l).len<span class="cstat-no" title="statement not covered" >gth&gt;0|</span>|i&amp;</span>&amp;i(</span>s,u)})};p(h)}retur<span class="fstat-no" title="function not covered" >n </span>a.length},this.load=functi<span class="cstat-no" title="statement not covered" >on(e,t){va</span>r <span class="cstat-no" title="statement not covered" >n=t</span>hi<span class="cstat-no" title="statement not covered" >s;i</span>f(<span class="cstat-no" title="statement not covered" >e i<span class="cstat-no" title="statement not covered" ></span>nstanceof Array){var r=e.map(function(e){return n.load(e)});return Promise.all(r)}return e=<span class="cstat-no" title="statement not covered" >e.uri||e,new Promise(function(r,i)<span class="cstat-no" title="statement not covered" >{n.no<span class="cstat-no" title="statement not covered" ></span>wOrWhenFetched(e,t,function(e</span>,t,n)<span class="cstat-no" title="statement not covered" >{e?r(</span>n)<span class="cstat-no" title="statement not covered" >:i(t)})})<span class="fstat-no" title="function not covered" >},</span>thi<span class="cstat-no" title="statement not covered" >s.nowOrWhenFetched=function(e,<span class="fstat-no" title="function not covered" >t,</span>n,r){e=e.uri||<span class="cstat-no" title="statement not covered" >e,"function"==typeof t?(r={},n=t):"undefined"==typeof t||(r=t instanceof a?{referingTerm:</span>t}:</span>t<span class="cstat-no" title="statement not covered" ></span>),this<span class="cstat-no" title="statement not covered" ></span>.</span></span>requestURI(e,t,r</span>||{},n)},th<span class="fstat-no" title="function not covered" >is</span>.get=this.nowOrWhe<span class="cstat-no" title="statement not covered" >nFetc<span class="cstat-no" title="statement not covered" ></span>hed,this.getHeader=function(e<span class="cstat-no" title="statement not covered" >,t){fo<span class="fstat-no" title="function not covered" >r(</span>var n=this<span class="cstat-no" title="statement not covered" >.store,r=n.each(vo</span>id<span class="cstat-no" title="statement not covered" ></span> 0,m.link("requestedURI<span class="cstat-no" title="statement not covered" ></span>"</span>),e.uri),i=0;i&lt;r.length;i++){<span class="fstat-no" title="function not covered" >va</span>r o=r[i];if(<span class="cstat-no" title="statement not covered" >void 0!==o){var a=n.any<span class="fstat-no" title="function not covered" >(o</span>,m.link("respo<span class="cstat-no" title="statement not covered" >nse"));if(voi</span>d 0</span>!==</span>o){var s=n.each(a,m.htt<span class="fstat-no" title="function not covered" >ph</span>(t.toLowerCase()<span class="cstat-no" title="statement not covered" >));return s.length?s.map(function(e){return e.value}):[]}}}},this.proxyIfNecessary=function(t){if("undefined"!=typeof tabulator&amp;&amp;tabul</span>ator.isExtension)return t;if("undefined"!=typeo<span class="fstat-no" title="function not covered" >f </span>$SolidTestEn<span class="cstat-no" title="statement not covered" >vironment&amp;&amp;$SolidTestEnvironment.localSiteMap){var n=t.split("/").slice(2),r=function e(t,n){<span class="cstat-no" title="statement not covered" >var r<span class="cstat-no" title="statement not covered" ></span>=n[t.shift()];return <span class="cstat-no" title="statement not covered" >r?"string"==typeof r?r+t.joi<span class="cstat-no" title="statement not covered" ></span>n("/"):t?e(t,r):null:<span class="cstat-no" title="statement not covered" >null},i=r(n,$SolidTestEnvironment.l<span class="cstat-no" title="statement not covered" ></span>ocalSiteMap);if(i)retu<span class="fstat-no" title="function not covered" >rn</span> i}return <span class="cstat-no" title="statement not covered" >e.crossSiteProxy</span>Templa</span>t</span>e</span>&amp;</span>&amp;"undefined"!=typeof do<span class="fstat-no" title="function not covered" >cu</span>ment&amp;&amp;docu<span class="cstat-no" title="statement not covered" >ment.location&amp;&amp;"https:"===(""+document.location).slice(0<span class="cstat-no" title="statement not covered" >,6)&amp;&amp;"htt<span class="cstat-no" title="statement not covered" >p</span></span>:"===t.slice(0,5)?e.crossSiteProxyTemplate.replace("{uri}",encodeURIComponent(t)):t},th<span class="cstat-no" title="statement not covered" >is.saveRequestMetadata</span>=f<span class="cstat-no" title="statement not covered" >unction(e<span class="fstat-no" title="function not covered" >,t</span>,n){var r=t<span class="cstat-no" title="statement not covered" >.bnode();if(e<span class="cstat-no" title="statement not covered" ></span>.resource=t.sym(n),e.req=r,!e.options.noMeta){var i=new Date,o</span>=</span>"[<span class="cstat-no" title="statement not covered" >"+i.getHours()+":"+i.getMinutes()+":"+i.<span class="cstat-no" title="statement not covered" ></span>getSe<span class="cstat-no" title="statement not covered" >conds()+"]<span class="cstat-no" title="statement not covered" ></span></span> </span>";t.add(r,m.rdfs("label"),t.literal(o+" Request for "+n),this.appNode),t.add(r,m.link("requestedURI"),t.literal(n),this.appNode),e.original&amp;&amp;e.original.uri!==n&amp;&amp;t.add(r,m.link("orginalURI"),t.literal(e.original.uri),t</span>his.appNode),t.add(r,m.lin<span class="fstat-no" title="function not covered" >k(</span>"status"),t.collecti<span class="cstat-no" title="statement not covered" >on(),this.<span class="cstat-no" title="statement not covered" ></span>appNode)}return r},this.saveResponseMetadata=function(e,<span class="cstat-no" title="statement not covered" >t){var n=t.</span>bn<span class="cstat-no" title="statement not covered" >ode();if(e.req&amp;&amp;t.add(e.req,m.link("response"),n),t.add(n,m.<span class="cstat-no" title="statement not covered" ></span>http("status"),t.literal(e.status),n),t.add(n,m.http("statusText"),t.literal(e.statusText),n),e.headers={},"http"===f.protocol(e.resource.uri)||"https"===f.protocol(e.resource.uri)){e.headers=h.getHTTPHeaders(e);for(var r in e.headers){var i=e.headers[r].trim(),o=r.toLowerCase();t.a<span class="cstat-no" title="statement not covered" ></span>d</span>d(n,m.htt</span>ph(o),i,n),"content-type"==<span class="fstat-no" title="function not covered" >=o</span>&amp;&amp;t.add(e.resource<span class="cstat-no" title="statement not covered" >,m.rdf("ty<span class="cstat-no" title="statement not covered" ></span>pe"),h.mediaTypeClass(i),n)}}return n},this.requestURI=function(t,n,r,o){t=t.uri||t,t=t.split("#")[0],"boolean"==typeof r&amp;&amp;(r={force:r}),"undefined"==typeof r&amp;&amp;(r={});var a=!!r.force,s=this.store,u=arguments,l=r.baseURI||t;r.userCallbac<span class="cstat-no" title="statement not covered" >k=o;var c=f.protocol(t);if("te<span class="cstat-no" title="statement not covered" >l</span>"===c||"mailto"===c||"urn"===<span class="cstat-no" title="statement not covered" >c)return console.log</span>("<span class="cstat-no" title="statement not covered" >Unsupported prot<span class="cstat-no" title="statement not covered" ></span>ocol in: "+t),o(!1,"Unsupported protocol",{status:900})||void 0;var d=s.sym(t),p=this.getState(t);i</span>f<span class="cstat-no" title="statement not covered" ></span>(</span>a)delete </span>this.nonexistant[<span class="fstat-no" title="function not covered" >t]</span>;else{if("fetche<span class="cstat-no" title="statement not covered" >d"===p)return o?o(!0):void 0;if("failed"===p)return o?o(!1,"Previously failed. "+this.requested</span>[t],{<span class="cstat-no" title="statement not covered" >status:thi</span>s.<span class="cstat-no" title="statement not covered" >requested[t</span>]}<span class="cstat-no" title="statement not covered" >):void 0}i</span>f(<span class="cstat-no" title="statement not covered" >this.fireCall<span class="cstat-no" title="statement not covered" ></span>backs("request",u)</span>,o&amp;&amp;(<span class="cstat-no" title="statement not covered" >this.fetchCall<span class="cstat-no" title="statement not covered" ></span>backs[t]?this.fetchCallbacks[t].push(o<span class="cstat-no" title="statement not covered" >):this.fetchCallbacks[t]=[o]),this.requested[t]!==!0){this.requested[t]=!0,!r.noMeta&amp;&amp;n&amp;&amp;n.uri&amp;&amp;s.add</span></span>(d.ur<span class="cstat-no" title="statement not covered" >i,m.link(</span>"r<span class="cstat-no" title="statement not covered" >equestedBy"),n.ur<span class="cstat-no" title="statement not covered" ></span>i,thi<span class="cstat-no" title="statement not covered" >s.appNode);var v=h.XMLHTTPFa</span>ctor<span class="cstat-no" title="statement not covered" >y(),g=v.req=s.bno<span class="cstat-no" title="statement not covered" >de();v.original=s.sym(<span class="cstat-no" title="statement not covered" >l</span></span>),v.options=r,v<span class="cstat-no" title="statement not covered" >.resource=d;var y=this,b=new Date,w="["+b.getHours()+":"+b.getMinutes()+":"+b.getSeconds()<span class="cstat-no" title="statement not covered" ></span></span>+</span>"] ";r.noMeta||(s.add(g,m.rdfs("label"),s.literal(w+" Request for "+t),this.appNode),s.add(g,m.link("requestedURI"),s.literal(t),this.appNode),s<span class="cstat-no" title="statement not covered" >.add(g,m.link("status"),s.collection(),this.appNode));var x=function(){if(!v.withCredentials)retu</span>rn!1;<span class="cstat-no" title="statement not covered" >if(v.retriedWithCre</span>de<span class="cstat-no" title="statement not covered" >ntials)return!0;<span class="cstat-no" title="statement not covered" ></span>v.retriedWithCredentials=!0,console.log("web: </span>Retry<span class="cstat-no" title="statement not covered" >ing w</span>it<span class="cstat-no" title="statement not covered" >h no creden</span>ti<span class="cstat-no" title="statement not covered" >als for "+v.resource),v.abort(),delete y.requested[t];var e=<span class="cstat-no" title="statement not covered" ></span>{};for(var i in r)r.hasOwnProperty(i)&amp;&amp;(e[i]=r[i]);return e.withCredentials=!1,y.addStatus(v.req,"Abort: Will retry with credentials SUPPRESSED to see if that helps"),y.requestURI(t,n,e,v.userCa</span>llbac<span class="cstat-no" title="statement not covered" >k),!0},_=<span class="fstat-no" title="function not covered" >fu</span>nc<span class="cstat-no" title="statement not covered" >tion(t){return functio<span class="cstat-no" title="statement not covered" >n(n){if(t<span class="cstat-no" title="statement not covered" >.</span></span>onErrorWasCalled=!0,"undefi<span class="cstat-no" title="statement not covered" >ned"!=typ<span class="cstat-no" title="statement not covered" >e</span></span>of document&amp;&amp;e.crossSiteProxyTemplate&amp;&amp;document.location&amp;&amp;!t.proxyUsed){var r=f.hostpart,i=""+document.location,o=t.resource.</span>uri;i<span class="cstat-no" title="statement not covered" >f(r<span class="cstat-no" title="statement not covered" ></span>(i)&amp;&amp;r(o)&amp;&amp;r(i)<span class="cstat-no" title="statement not covered" >!==r(o))if(401===t.status||403===<span class="cstat-no" title="statement not covered" >t</span></span>.status||404===t.status)k(t)();else{if(x(t))return;var a=e.crossSiteProxy(o);if(console.log("web: Direct failed so trying proxy "+a),y.addStatus(t.req,"BL</span>O</span>CK<span class="cstat-no" title="statement not covered" >ED -&gt; Cro<span class="fstat-no" title="function not covered" >ss</span>-si<span class="cstat-no" title="statement not covered" >te Prox<span class="fstat-no" title="function not covered" >y </span>to &lt;"+a+"&gt;<span class="cstat-no" title="statement not covered" >"),t.aborted)return;var s=y.store,u=t.req;t.options.noMeta||s.add(u,m.http("redirectedTo"),s.sym(a),u),t.abort(),t.abort<span class="cstat-no" title="statement not covered" >ed=!0,y.add</span>St<span class="cstat-no" title="statement not covered" >atus(u,"redirected to</span> n<span class="cstat-no" title="statement not covered" >ew request"),y.<span class="cstat-no" title="statement not covered" ></span>requested[t.resource.uri]="<span class="cstat-no" title="statement not covered" >redirected",y.redirectedTo[t.resource.uri]=a,y.fet<span class="cstat-no" title="statement not covered" >chCallba</span>cks[<span class="cstat-no" title="statement not covered" >t.resour<span class="cstat-no" title="statement not covered" >ce.uri]&amp;</span></span>&amp;(y.f<span class="cstat-no" title="statement not covered" >etchCallbacks[a]||(y<span class="cstat-no" title="statement not covered" ></span>.fetchCallbacks[a]=[]),y.fetchCallbacks[a]===y.fetchCallbacks[a].concat(y.fetchCallbacks[t.resource.uri]),delete y.fetchCallba<span class="cstat-no" title="statement not covered" >cks[t.re</span></span>sourc<span class="cstat-no" title="statement not covered" >e.uri]);</span>va<span class="cstat-no" title="statement not covered" >r l=y.<span class="cstat-no" title="statement not covered" ></span>requestURI(a,t.resource,t.options,t.userCallback);if(l&amp;&amp;(l.proxyUsed=!0,l.original=t.original,console.log("Proxying but original still "+l.original)),l&amp;&amp;l.req)return void(t.options.noMeta||s.add(t.req,s.sym("http://www.w3.org/2007/ont/link#redirectedRequest"),l.req,y.appNode))}t.CORS_status=999}}},k=function(e){return function(){var n=function(){if(!e.handleResponseDone){e.handleResponseDone=!0;var n=nul</span>l,i=e<span class="cstat-no" title="statement not covered" >.req;y.fireCallbacks("recv",u);var o=y.store;if(y.sa<span class="cstat-no" title="statement not covered" ></span>veResponseMetadata(e,o),y.fireCallbacks("headers",[{uri:t,headers:e.headers}]),0===e.status){if(console.log("<span class="cstat-no" title="statement not covered" >Masked error - status 0 for "+e.resource.uri),x(e))return;return void(e.CORS_status=900)}if(e.status&gt;=400){if(404===e.st<span class="cstat-no" title="statement not covered" ></span></span>a</span></span>tus&amp;&amp;(o.fetcher.no</span>n</span>ex</span>i</span>st<span class="cstat-no" title="statement not covered" >ant[e.res<span class="fstat-no" title="function not covered" >ou</span>rce<span class="cstat-no" title="statement not covered" >.uri]=!<span class="fstat-no" title="function not covered" >0)</span>,e.responseText<span class="cstat-no" title="statement not covered" >.length&gt;10){var s=o.bnode();o.add(<span class="fstat-no" title="function not covered" >s,</span>m.<span class="cstat-no" title="statement not covered" >http("content"),o.literal(<span class="cstat-no" title="statement not covered" >e.responseText),s),e.stat</span>usTex<span class="cstat-no" title="statement not covered" >t&amp;&amp;o.</span>ad<span class="cstat-no" title="statement not covered" >d(s,m.<span class="cstat-no" title="statement not covered" ></span>http("statusText"),o.litera</span>l(e.s<span class="cstat-no" title="statement not covered" >tatusTex<span class="cstat-no" title="statement not covered" ></span>t),s)}return void y.failFetch(e,"HTTP error for "+e.resource+": "+e.status+" "+e.statusText)}var l,c<span class="cstat-no" title="statement not covered" >=e.headers["content-location"],h=function(e){var t=i;if(c){var n=o.<span class="cstat-no" title="statement not covered" >any(t,m<span class="cstat-no" title="statement not covered" >.</span></span>link("requestedURI"));n!==c&amp;&amp;o.<span class="cstat-no" title="statement not covered" ></span>a</span>dd(o.sym(c),m.rdf<span class="cstat-no" title="statement not covered" >("type"),e,y.appNode)}for(;;){var r=o.any(t,m.link("requestedURI"));if(r&amp;&amp;r.value&amp;&amp;o.add(o.sym<span class="cstat-no" title="statement not covered" >(r.value),<span class="cstat-no" title="statement not covered" ></span>m.rdf("type"),e,y.appNode),t=o.any(void 0,o.sym("http://www.w3.org/2007/ont/link#redirectedRequest"),t),!t)break;var a=o.any(t<span class="cstat-no" title="statement not covered" ></span>,</span>o.sym("http://www.w3.org/2007/ont/link#response"));if(!a)break;var s=o.any(a,o.sym("htt</span>p</span>://www.<span class="cstat-no" title="statement not covered" >w3.org/2007/ont/http#status"))</span>;i<span class="cstat-no" title="statement not covered" >f(!s)brea<span class="fstat-no" title="function not covered" >k;</span>if("301"!<span class="cstat-no" title="statement not covered" >==<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;"302"!==s<span class="cstat-no" title="statement not covered" >)break}},d={rdf:"application/rdf<span class="cstat-no" title="statement not covered" ></span>+xml",owl:"application/rdf+xml",n3:"text/n3",ttl:"<span class="cstat-no" title="statement not covered" ></span>t</span>ext/turtle",n<span class="cstat-no" title="statement not covered" >t:"text/n3",acl:"text/n3",html:"<span class="cstat-no" title="statement not covered" ></span>text/html",xml:"text/xml"};if(200===e.status){h(m.link("Document"));var p=e.headers["content-type"];r.forceContentType&amp;&amp;(e.headers["content-typ<span class="cstat-no" title="statement not covered" >e"]=r.f</span></span>orceC<span class="cstat-no" title="statement not covered" >ontentType),(!p||p.indexOf("application/octet-stream")&gt;=0)&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(l=d[<span class="cstat-no" title="statement not covered" >e.resou</span></span>rce.u<span class="cstat-no" title="statement not covered" >ri.split(".").pop()],l&amp;&amp;(e.headers["content-type"]=l)),p&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;(0!==<span class="cstat-no" title="statement not covered" >p.inde<span class="cstat-no" title="statement not covered" >x</span></span>Of("image/")&amp;&amp;0!==p.ind<span class="cstat-no" title="statement not covered" >exOf("a</span></span>p</span>p</span>li<span class="cstat-no" title="statement not covered" >cation/pdf")||h(o.sym("http://purl.org/dc/terms/Image"))),r.clearPreviousData&amp;&amp;o.removeDocument(e.resource)}if("file"!==f.protocol(e.resource.ur<span class="cstat-no" title="statement not covered" ></span>i)&amp;&amp;"chrome"!==f.pr<span class="cstat-no" title="statement not covered" >otocol(e.resource.uri)|</span>|(r.f<span class="cstat-no" title="statement not covered" >orceContentType?e.headers[<span class="cstat-no" title="statement not covered" ></span>"content-type"]=r.forceContentType:(l=d[e.resource.uri.split(".").pop()],l?e.headers["content-type"]=l:e.headers["content-type"]="text/xml")),c){var v=f.join(e.resource.uri,c);if(!a&amp;&amp;v!==e.resource.uri&amp;&amp;y.requested[v]&amp;&amp;"done"===y.requested[v])return y.doneFetch(e),void e.abort();y.requested[v]=!0}for(var g=0;g&lt;y.handlers.length;g++)if(e.header<span class="cstat-no" title="statement not covered" ></span>s</span>["content-type"]&amp;&amp;e.headers["content-type"].match(y.handlers[g].pattern)){n=new y.handlers[g];break}if(y.parseLinkHeader(e,i),!n)return void y.doneFetch(e);try{n.handlerFactory(e)}catch(t){y.failFetch(e,"Exception handling content-type "+e.headers["content-ty<span class="cstat-no" title="statement not covered" >pe"]+" was: "+t)}}};switc<span class="cstat-no" title="statement not covered" ></span>h(e.readyState){case 0:var i,o=e.resource.uri;if(this.crossSiteProx<span class="cstat-no" title="statement not covered" >yTemplate&amp;&amp;"undefined"!=typeof docume<span class="cstat-no" title="statement not covered" >n</span></span>t&amp;&amp;document.locati<span class="cstat-no" title="statement not covered" ></span>o</span>n){var s=f.hostpart,l=""+document.l<span class="cstat-no" title="statement not covered" >ocation;if(s(l)&amp;&amp;s(o)&amp;&amp;s(l)!==s(o)){if(i=this.crossSiteProxyTemplate.replace("{uri}",e<span class="cstat-no" title="statement not covered" >ncodeURIComponent(o)),<span class="cstat-no" title="statement not covered" >y</span>.addSt<span class="cstat-no" title="statement not covered" ></span>a</span></span>tus(e.req,"BLOCKED -&gt; Cross-<span class="cstat-no" title="statement not covered" >site Proxy to &lt;"+i+"&gt;"),e.a<span class="cstat-no" title="statement not covered" >b</span></span>ort<span class="cstat-no" title="statement not covered" >ed)return;var c=y.sto</span>re,h=e.re<span class="cstat-no" title="statement not covered" >q;c.add(h,m.http("redirectedTo"),c.sym(i),h);var d=e.req=c.bnode();c.add(h,m.http("redir</span>e</span>c</span>t<span class="cstat-no" title="statement not covered" ></span>edRequest"),d,e.req);var p=new Date,<span class="cstat-no" title="statement not covered" >v="["+p.getHour<span class="cstat-no" title="statement not covered" ></span>s()+":"+p.getMinutes()+":"+p.getSeconds()+"] ";c.add(d,m.rdfs("label"),c.literal(v+" Re<span class="cstat-no" title="statement not covered" >quest for "</span>+i<span class="cstat-no" title="statement not covered" >),this.appNode),c.add<span class="cstat-no" title="statement not covered" ></span>(d,m.link("status"),c.collec<span class="cstat-no" title="statement not covered" >tion(),this.appNode),c.add(d,m.link("requestedURI"),c.literal(i),this.appNode);var g=c.bnode();c.add(h,m.link("response"),g),e.abort(),e.abort<span class="cstat-no" title="statement not covered" >ed=!0,e.</span></span>redir<span class="cstat-no" title="statement not covered" >ected=!0</span>,y<span class="cstat-no" title="statement not covered" >.addSt<span class="cstat-no" title="statement not covered" ></span>atus(h,"redirected XHR"),y.fetchCallbacks[e.</span>resou<span class="cstat-no" title="statement not covered" >rce.uri]&amp;&amp;(y.fet<span class="cstat-no" title="statement not covered" ></span>chCallbacks[i]||(y.fetchCallbacks[i]=[]),y.fet</span>chCal<span class="cstat-no" title="statement not covered" >lbacks[i]==</span>=y<span class="cstat-no" title="statement not covered" >.fetchCallbacks[i].concat(y.fetchCallbacks[e.resource.uri]),<span class="cstat-no" title="statement not covered" ></span>delete y.fetchCallbacks[e.resource.uri]),y.fireCallbacks("redirected",u),y.requested[e.resource.uri]="redirected";var b=y.requestURI(i,e.resource,e.options||{},e.userCallback);if(b&amp;&amp;</span>b.req<span class="cstat-no" title="statement not covered" >)return vo<span class="cstat-no" title="statement not covered" ></span>id c.add(e.req,c.sym("http://www.w3.org/2007/ont/link#redirectedRequest"),b.req,y.appNode)}}y.failFetch(e,"HTTP Blocked. (ReadyState 0) Cross-site violation for &lt;"+t+"&gt;");break;case 3:break;case 4:if(n(),e.handle&amp;&amp;void 0!==e.responseText){if("redirected"===y.requested[e.resource.uri])break;y.fireCallbacks("load",u),e.handle(function(){y.doneFetch(e)})}else e.redirected?y.addSta</span>tus(e<span class="cstat-no" title="statement not covered" >.req,"Aborted and redirected to new request."):y.addStat<span class="cstat-no" title="statement not covered" ></span>us(e.req,"Fe<span class="cstat-no" title="statement not covered" >tch over. No data handled. Aborted = "+e.aborted)}}},T=t;"undefined"!=typeof tabulator&amp;&amp;tabulator.pre</span></span>f<span class="cstat-no" title="statement not covered" ></span>e</span>rences.get("offlineModeUsingLocalhost")&amp;&amp;"http://"===T.slice(0,7)&amp;&amp;"localhost/<span class="cstat-no" title="statement not covered" >"</span>!==T.s</span>lice(7<span class="cstat-no" title="statement not covered" >,17)&amp;&amp;(</span>T="htt<span class="cstat-no" title="statement not covered" >p://localhost/"+T.slice(7),i.warn("Localho<span class="cstat-no" title="statement not covered" >st kludge for offline use: actually getting &lt;"<span class="cstat-no" title="statement not covered" >+T+"&gt;"<span class="cstat-no" title="statement not covered" >)</span></span>);var E="https:"===T.slice(0,6);vo<span class="fstat-no" title="function not covered" >id</span> 0!==r.wi<span class="cstat-no" title="statement not covered" >thCredentials&amp;&amp;(</span>E=r</span>.with<span class="cstat-no" title="statement not covered" >Credentials);var S=this.proxyIfNecessary(T);v.onerror=_(v),v.onreadystatechange=k(v),v.timeout=y.timeout,v.withCredentials=E,v.actualProxyURI=S,v</span></span>.</span>re</span>q</span>=g<span class="cstat-no" title="statement not covered" >,v<span class="cstat-no" title="statement not covered" ></span>.options=r,v.options=r,v.resource=d,v.requestedURI=T,v.ontimeout=function(){y.failFetch(v,"requestTimeout")};try{v.open("GET",S,this.async)}catch(e){return this.failFetch(v,"XHR open for GET failed for &lt;"+T+"&gt;:\n\t"+e)}if(a&amp;&amp;v.setRequestHeader("Cac</span>he-co<span class="cstat-no" title="statement not covered" >ntrol","no-cache"),"unde<span class="cstat-no" title="statement not covered" ></span>fined"!=typeof tabulator&amp;&amp;tabulator.isExtension&amp;&amp;v.</span>chann<span class="cstat-no" title="statement not covered" >el&amp;&amp;("http"===f.protocol(<span class="cstat-no" title="statement not covered" ></span>v.resource.uri)||"https"===f.protocol(v.resource.uri)))try{v.channel.notificationCallbacks={getInterface:function(e){return e.equals(Components.interfaces.nsIChannelEventSink<span class="fstat-no" title="function not covered" >)?</span>{onChanne<span class="cstat-no" title="statement not covered" >lRedirect:function(e,t,i){if(!v.a</span>b<span class="cstat-no" title="statement not covered" >o</span>rte<span class="cstat-no" title="statement not covered" >d){var o=y.store,a=t.URI.spe</span>c,s=v.req<span class="cstat-no" title="statement not covered" >;if(!v.options.noMeta){y.addStatus(v.req,"Redirected: "+v.status+" to &lt;<span class="cstat-no" title="statement not covered" ></span>"</span>+a+"&gt;"),o.add(s,m.http("redirectedTo"),o.sym(a),v.req);var l=v.req=o.bnode();o.add(s,m.http("redirectedRequest"),l,this.appNode);var c=new Date,h="["+c.getHours()+":"+c.getMinutes()+":"+c.getSe<span class="cstat-no" title="statement not covered" >cond<span class="cstat-no" title="statement not covered" >s()+"] ";o.add(l,m.rdfs("label"),o.literal(h+" Request for "+a),this.appNode),o.<span class="fstat-no" title="function not covered" >add(l,m.link(</span>"st<span class="cstat-no" title="statement not covered" >atus"),o.collection(),this.appNode),o.add(l,m.link("requestedURI"),o.literal(a),this.appNode);var d=o.bnode();o.<span class="fstat-no" title="function not covered" >add(s,m.link("resp</span>onse"),<span class="cstat-no" title="statement not covered" >d),o.add(d,m.http("st<span class="cstat-no" title="statement not covered" >atus"),o</span>.l<span class="cstat-no" title="statement not covered" >iteral(v.st</span>at<span class="cstat-no" title="statement not covered" >us),d)<span class="cstat-no" title="statement not covered" ></span>,v.statusText&amp;&amp;o.add(d<span class="cstat-no" title="statement not covered" >,m.http("statusText"),o.literal(v.statusText),d)}if(v.status-0!==303&amp;&amp;(o.HTTPRedirects[v.resource.uri]=a)</span>,v.st<span class="cstat-no" title="statement not covered" >atus-0===301&amp;&amp;n)<span class="cstat-no" title="statement not covered" ></span>{var p=f.docpart(n.uri),g="Warning: "+v.resource+" ha</span>s mov<span class="cstat-no" title="statement not covered" >ed to &lt;"+a+</span>"&gt;<span class="cstat-no" title="statement not covered" >.";n&amp;&amp;(g+=" Link in &lt;"+p+" &gt;should be changed",o.add(p,o.sym<span class="cstat-no" title="statement not covered" ></span>("http://www.w3.org/2007/ont/link#warning"),g,y.appNode));<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
}<span class="cstat-no" title="statement not covered" >v.abort(),v.aborted=!0,y.fetchCallbacks[v.resource.uri]&amp;&amp;(y.fetchCallbacks[a]||(y.fetchCallbacks[a]=[]),y.fetchCallbacks[a]===y.fetchCallbacks[a].concat(y.fetchCallbacks[v.resource.uri]),delete y.fetchCallbacks[v.resource.uri]),y.addStatus(s,"redirected"),y.fireCallbacks("redirected",u),y.requested[v.resource.uri]="redirected",y.redirectedTo[v.resource.uri]=a;v</span>ar b=<span class="cstat-no" title="statement not covered" >a.indexOf("#");<span class="cstat-no" title="statement not covered" ></span>b&gt;=0&amp;&amp;(v.options.noMeta||o.add(v.resource,o.sym("http://www.w3.org/2007/ont/link#warning"),"Warning: "+v.resource+" HTTP redirects to"+a+' which should not contain a "#" sign'),a=a.slice(0,b));v</span>ar w=<span class="cstat-no" title="statement not covered" >y.requestURI(a,v.resource,v.options,v.userCallback);<span class="cstat-no" title="statement not covered" ></span>w&amp;&amp;w.req&amp;&amp;!r.noMeta&amp;&amp;o.add(v.req,o.sym("http://www.w3.org/2007/ont/link#redirectedRequest"),w.req,y.appNode)}}</span>,asyncOnChannelRedirect:function(e,t,r,i){if(!v.aborted){va<span class="fstat-no" title="function not covered" >r o=y.store,a=t.URI.spe</span>c,s=v.req<span class="cstat-no" title="statement not covered" >;y.addStatus(v.req,"R<span class="cstat-no" title="statement not covered" >edirecte</span>d:<span class="cstat-no" title="statement not covered" > "+v.status</span>+"<span class="cstat-no" title="statement not covered" > to &lt;"<span class="cstat-no" title="statement not covered" ></span>+a+"&gt;"),o.add(s,m.http("redirectedTo"),o.sym(a),v.req);var u=v.req=o.bnode();o.add(s,m.http("redirectedRe</span>quest<span class="cstat-no" title="statement not covered" >"),u,v.req);var <span class="cstat-no" title="statement not covered" ></span>l=new Date,c="["+l.getHours()+":"+l.getMinutes</span>()+":<span class="cstat-no" title="statement not covered" >"+l.getSeco</span>nd<span class="cstat-no" title="statement not covered" >s()+"] ";o.add(u,m.rdfs("label"),o.literal(c+" Request for "<span class="cstat-no" title="statement not covered" ></span>+a),this.appNode),o.add(u,m.link("status"),o.collection(),this.appNode),o.add(u,m.link("requestedURI"),o.literal(a),this.appNode);var h=o.bnode();if(o.add(s,m.link("response"),h),o.a</span>dd(h,<span class="cstat-no" title="statement not covered" >m.http("st<span class="cstat-no" title="statement not covered" ></span>atus"),o.literal(v.status),h),v.statusText&amp;&amp;o.add(h,m.http("statusText"),o.literal(v.statusText),h),v.status-0!==303&amp;&amp;(o.HTTPRedirects[v.resource.uri]=a),v.status-0===301&amp;&amp;n){var d=f.docpart(n.uri),p="Warning: "+v.resource+" has mov<span class="cstat-no" title="statement not covered" >ed to &lt;"+a+"&gt;.";n</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >(p+=" Link in &lt;"+d+" &gt;should be changed",o.add(d<span class="cstat-no" title="statement not covered" ></span>,o.sym("http://www.w3.org/2007/ont/link#warning"),p,y.appNode))}v.abort(),v.aborted=!0;var g=a.indexOf("#");if(g&gt;=0)<span class="cstat-no" title="statement not covered" ></span>{</span>var b="Warning: "+v.res</span>ource<span class="cstat-no" title="statement not covered" >+" HTTP redirec<span class="cstat-no" title="statement not covered" ></span>ts to"+a+' whic<span class="cstat-no" title="statement not covered" >h do not normally contain a "#" sign';o.add(v.resource,o.sym("http://www.w3.org/2007/ont/l<span class="cstat-no" title="statement not covered" ></span>ink#warning"),b),a=a.slice(0,g)}y.requested[v.resource.uri]="redirected",y.redirected<span class="cstat-no" title="statement not covered" ></span>T</span>o[v.resource.uri]=a;var w=y.requestURI(a,v.resource,v.options,v.userCallba</span>ck);w<span class="cstat-no" title="statement not covered" >&amp;&amp;(w.original=v.original,w.req&amp;&amp;o.add(v.req,o.sym("h<span class="cstat-no" title="statement not covered" ></span>ttp://www.w3.org/2007/ont/link#redirectedRequest"),w.req,y.appNode))}}}:Components.results.NS_NOINTERFACE}}}catch(e){return</span> </span>y.failFetch(v,"@@ Couldn't set callback for redir<span class="cstat-no" title="statement not covered" >ects: "+e)}try{var N="";for(var R in this.mediatypes){""!==N&amp;&amp;(N+=",<span class="cstat-no" title="statement not covered" ></span> "),N+=R;f<span class="cstat-no" title="statement not covered" >or(<span class="cstat-no" title="statement not covered" ></span>var j in this.mediatypes[R])N+<span class="cstat-no" title="statement not covered" >=";"+j+"="+this.mediaty<span class="cstat-no" title="statement not covered" >p</span>es[R][j]}v.setRequestHeader("Ac<span class="cstat-no" title="statement not covered" >cept",N),this.addStatus(v.req,"Accep<span class="cstat-no" title="statement not covered" ></span></span>t</span>: "+N)}catch(e){throw new Error("Can't set Accept header: "+e)}try</span>{v.send(n<span class="cstat-no" title="statement not covered" >ull)}catch(e){return this.failFetch(v,"XHR send <span class="cstat-no" title="statement not covered" ></span>f</span>ail<span class="cstat-no" title="statement not covered" >ed:"+e)}return</span> setTimeo<span class="cstat-no" title="statement not covered" >ut(function(){4!==v.readyState&amp;&amp;y.isPending(v.r<span class="cstat-no" title="statement not covered" ></span>e</span>source.uri)&amp;&amp;y.fa<span class="fstat-no" title="function not covered" >il</span>Fetch(v,"<span class="cstat-no" title="statement not covered" >requestTimeout")},this.timeout),this.addStatus(v.req,"HTTP Request sent."),v}},t</span>his.objectRefresh=function(e){var t=y.uris(e);if("undefined"!</span>=typeof t)for(var n=0<span class="fstat-no" title="function not covered" >;n</span>&lt;t.length;n++)th<span class="cstat-no" title="statement not covered" >is.refresh<span class="cstat-no" title="statement not covered" ></span>(this.store.sym(f.docpart<span class="cstat-no" title="statement not covered" >(t[n])))},this.unload=funct<span class="cstat-no" title="statement not covered" >ion(e){this.store.removeMany(void 0,void 0,void</span></span></span> 0,e),delete <span class="fstat-no" title="function not covered" >th</span>is.request<span class="cstat-no" title="statement not covered" >ed[e.uri]},this.refresh=function(e,t){this.fireCallbacks("refresh",arguments</span>),this.request<span class="fstat-no" title="function not covered" >UR</span>I(e.uri,void<span class="cstat-no" title="statement not covered" > 0,{force:!0,clearPreviousData:!0},t)},this.retract=function(e){this.store.removeMany(void 0,void 0,void </span>0,e),e.uri&amp;&amp;de<span class="fstat-no" title="function not covered" >le</span>te this.re<span class="cstat-no" title="statement not covered" >quested[f.docpart(e.uri)],this.fireCallbacks("retract",arguments)},this.getState=function(e){return"undefined"==typeof this.requested[</span>e]?"unrequested<span class="fstat-no" title="function not covered" >":</span>this.reque<span class="cstat-no" title="statement not covered" >sted[e]===!0?"requested":"done"===this.requested[e]?"fetched":"redirected"===this.requested[e]?this.getState(this.redirectedTo[e]):"failed"},this.isPending=function(e){return this.requested[e]===!0}};e.exports</span>=v},function(e,t<span class="fstat-no" title="function not covered" >,n</span>){"use str<span class="cstat-no" title="statement not covered" >ict";var r="function"==typeof S</span>ymb<span class="cstat-no" title="statement not covered" >ol&amp;&amp;"symbol"=</span>=<span class="fstat-no" title="function not covered" >ty</span>peof Symbol.iterator?function(e){<span class="cstat-no" title="statement not covered" >return typeof e}:function(e){return e&amp;&amp;"function"==typeof Sy<span class="fstat-no" title="function not covered" >mb</span>ol&amp;&amp;e.cons<span class="cstat-no" title="statement not covered" >tructor===Symbol?</span>"<span class="fstat-no" title="function not covered" >sy</span>mbol":type<span class="cstat-no" title="statement not covered" >of e},i=n(7),o=n(5).ArrayIndexOf,a=function(){function e(e){return encodeURI(e)</span>}</span>fu<span class="cstat-no" title="statement not covered" >nctio</span>n <span class="cstat-no" title="statement not covered" >t(e,t,r,i,o,a,s,u)</span>{r<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >et</span>urn new n(e,t,r,i,<span class="fstat-no" title="function not covered" >o,</span>a,s<span class="cstat-no" title="statement not covered" >,u)}function n(e,t,n,</span>r,i,o,a,s<span class="fstat-no" title="function not covered" >){</span>"undefined"==type<span class="cstat-no" title="statement not covered" >of t&amp;&amp;(t=null),"undefined"==typ</span>eof n&amp;&amp;(n<span class="fstat-no" title="function not covered" >="</span>"),"undefined"==t<span class="cstat-no" title="statement not covered" >ypeof r&amp;&amp;(r=null),"undefined"==typeof i&amp;&amp;(i=""),"undefined"==typeof o&amp;&amp;(o=null),"undefined"==typeof a&amp;&amp;(a=""),"undefined"==typeof s&amp;&amp;(s=null),this._bindings=new h([]),this._flags=a,""!=n&amp;&amp;(m(n.indexOf(":")&gt;=0,"Document URI not absolute: "+n),this._bindings[""]=n+"#"),this._store=e,i&amp;&amp;e.setGenPrefix(i),this._thisDoc=n,this.source=e.sym(n),this.lines=0,this.statementCount=0,this.startOfLine=0,this.previousLine=0,this._genPrefix=i,this.keywords=new f(["a","this","bind","has","is","of","true","false"]),this.keywordsSet=0,this._anonymousNodes=new h([]),this._variables=new h([]),this._parentVariables=new h([]),this._reason=s,this._reason2=null,_&amp;&amp;(this._reason2=why_BecauseOfData(e.sym(n),this._reason)),r?this._baseURI=r:n?this._baseURI=n:this._baseURI=null,m(!this._baseURI||this._baseURI.indexOf(":")&gt;=0),this._genPrefix||(this._thisDoc?this._genPrefix=this._thisDoc+"#_g":this._genPrefix=RDFSink_uniqueURI()),null==t?this._thisDoc?this._formula=e.formula(n+"#_formula"):this._formula=e.formula():this._formula=t,this._context=this._formula,this._parentContext=null}function a(e,t,n,r,i){this._str=n.encode("utf-8"),this._str=n,this._i=r,this.</span>_why=i,th<span class="fstat-no" title="function not covered" >is</span>.lines=t,th<span class="cstat-no" title="statement not covered" >is._uri=e}function s(e,t,n,r,i){return"Line "+(t+1)+" of &lt;"+e+"&gt;: Bad syntax: "+i+'\nat:</span> "'+p(n,r<span class="fstat-no" title="function not covered" >,r</span>+30)+'"'}va<span class="cstat-no" title="statement not covered" >r u={encode:function(e){e=e.replace(/\r\n/g,"\n");for(var t="",n=0;n&lt;e.length</span>;n++){<span class="cstat-no" title="statement not covered" >var r=e.charCodeAt(n);r&lt;128?t+=String.from<span class="fstat-no" title="function not covered" >CharCod</span>e(r<span class="cstat-no" title="statement not covered" >):r&gt;127&amp;&amp;r&lt;2048?(t+=String<span class="cstat-no" title="statement not covered" >.</span>fromCharCode(r&gt;&gt;6|192),t+=String.fromC<span class="cstat-no" title="statement not covered" >harCode(63&amp;r|128<span class="cstat-no" title="statement not covered" ></span>)):(t+=String.fromCharCode(r&gt;&gt;12|224),t+=String.fromCharCode(r&gt;&gt;6&amp;63|128),t+=String.fromCharCode(63&amp;r|128))}return t},decode:function(e){for(var t="",n=0;n&lt;e.length;){var r=e.charCodeAt(n);r&lt;128?(t+=String.fromCharCode(r<span class="cstat-no" title="statement not covered" ></span>)</span>,n++):r&gt;1</span>91&amp;&amp;r&lt;224?(t+=String.fromCharCode((31&amp;r)&lt;&lt;<span class="fstat-no" title="function not covered" >6|63&amp;e.</span>cha<span class="cstat-no" title="statement not covered" >rCodeAt(n+1)),n+=2):(t+=String.fromC<span class="cstat-no" title="statement not covered" >harCode((15&amp;r)&lt;&lt;<span class="cstat-no" title="statement not covered" ></span>12|(63&amp;e.charCodeAt(n+1))&lt;&lt;6|63&amp;e.charCodeAt(n+2)),n+=3)}return t}},l="http://www.w3.org/2000/10/swap/log#",c=function(e){return e},f=function(e){return e},h=function(e){if(e.length&gt;0)throw"missing.js: o<span class="cstat-no" title="statement not covered" ></span>o</span>ps nnonem</span>pt</span>y <span class="cstat-no" title="statement not covered" >dict not imp";return[]},d=function(e){</span>re<span class="cstat-no" title="statement not covered" >turn e.le<span class="fstat-no" title="function not covered" >ng</span>th}<span class="cstat-no" title="statement not covered" >,p=functio</span>n</span>(e<span class="cstat-no" title="statement not covered" >,t,n){if(<span class="fstat-no" title="function not covered" >"u</span>nde<span class="cstat-no" title="statement not covered" >fined"==ty</span>p</span>eo<span class="cstat-no" title="statement not covered" >f e.slice<span class="fstat-no" title="function not covered" >)t</span>hro<span class="cstat-no" title="statement not covered" >w"@@ mising.js<span class="cstat-no" title="statement not covered" >: No .slice function for "+e+" of type "+("unde<span class="cstat-no" title="statement not covered" >f</span></span>ined"==ty</span>p</span>eo<span class="cstat-no" title="statement not covered" >f e?"unde<span class="fstat-no" title="function not covered" >fi</span>ned<span class="cstat-no" title="statement not covered" >":r(e));return"un</span>d</span>ef<span class="cstat-no" title="statement not covered" >ined"==ty<span class="fstat-no" title="function not covered" >pe</span>of n||n<span class="cstat-no" title="statement not covered" >ull==n?e.slice(t):e.slice(t,n)}<span class="cstat-no" title="statement not covered" >,v=Error("dummy error stop iteration"),g=function(e){return this.last=0,this.li=e,this.next=function<span class="cstat-no" title="statement not covered" >(</span></span>){if(this.last==this.li.length)throw v;return this.li[this.la</span>s</span>t+<span class="cstat-no" title="statement not covered" >+]},this},y=function(e,t){return e.i</span>nd<span class="cstat-no" title="statement not covered" >exOf(t)},<span class="fstat-no" title="function not covered" >m=</span>fun<span class="cstat-no" title="statement not covered" >ction(e,t){if(!e){if(t)throw"python Ass<span class="fstat-no" title="function not covered" >er</span>tion fail<span class="cstat-no" title="statement not covered" >ed: "+t;throw"(python) Assert<span class="cstat-no" title="statement not covered" >ion fail<span class="cstat-no" title="statement not covered" >e</span></span>d."}},b=function(e){return S</span>tring.f</span>r</span>om<span class="cstat-no" title="statement not covered" >CharCode(<span class="fstat-no" title="function not covered" >e)</span>};Str<span class="cstat-no" title="statement not covered" >ing.prototype.encode=</span>f</span>un<span class="cstat-no" title="statement not covered" >ction(e){<span class="fstat-no" title="function not covered" >if</span>("utf<span class="cstat-no" title="statement not covered" >-8"!=e)<span class="cstat-no" title="statement not covered" >throw<span class="cstat-no" title="statement not covered" >"UTF8_converter: can only do utf-8"<span class="cstat-no" title="statement not covered" >;</span></span>return u.encode(this)},String.prot</span>o</span>t</span>yp<span class="cstat-no" title="statement not covered" >e.decode=<span class="fstat-no" title="function not covered" >fu</span>nct<span class="cstat-no" title="statement not covered" >ion(e){if("utf-8"!=e)throw"UTF8</span>_<span class="cstat-no" title="statement not covered" ></span>converter: can only do u<span class="fstat-no" title="function not covered" >tf</span>-8";return<span class="cstat-no" title="statement not covered" > this};var w=f<span class="cstat-no" title="statement not covered" >unction(e,t){return i.join(t,e)},x=null,_<span class="cstat-no" title="statement not covered" >=</span></span>0,k=0,T=function(e){},</span>E="http://www.w3.org/1999<span class="fstat-no" title="function not covered" >/0</span>2/22-rdf-s<span class="cstat-no" title="statement not covered" >yntax-ns#type"<span class="cstat-no" title="statement not covered" >,S="http://www.w3.org/2002/07/owl#sameAs"<span class="cstat-no" title="statement not covered" >,</span></span>N="#",R="htt</span>p:</span>//www<span class="cstat-no" title="statement not covered" >.w3.org/2<span class="fstat-no" title="function not covered" >00</span>1/XML<span class="cstat-no" title="statement not covered" >Schema#integer",j="h</span>t</span>tp<span class="cstat-no" title="statement not covered" >://ww</span>w.<span class="cstat-no" title="statement not covered" >w3</span>.o<span class="cstat-no" title="statement not covered" >rg</span>/2<span class="cstat-no" title="statement not covered" >001/XMLSc<span class="fstat-no" title="function not covered" >he</span>ma#do</span>ub<span class="cstat-no" title="statement not covered" >le",O="http://www.w3.org/2001/XMLSchema#decimal",I</span>="<span class="cstat-no" title="statement not covered" >http://www.w3.org/2001/XMLSchema#date",</span>C=<span class="cstat-no" title="statement not covered" >"htt</span>p:<span class="cstat-no" title="statement not covered" >//www.w3.org/2001/XMLSchema#dateTime",A="\t</span>\r<span class="cstat-no" title="statement not covered" >\n !\"#$%&amp;'()*.,+/;&lt;=&gt;?@[\\]^`{|}~",L=A+":</span>",<span class="cstat-no" title="statement not covered" >D=(new RegExp("^[ \\t]*(#[^\\n]*)?\\r?\\n",</span>"g<span class="cstat-no" title="statement not covered" >"),new RegExp("^[ \\t]*(#[^\\n]*)?$","g"</span>),<span class="cstat-no" title="statement not covered" >new RegExp("^[ \\t]*","g"),new RegExp("^[-+]</span>?[<span class="cstat-no" title="statement not covered" >0-9]+","g"),new RegExp("^([-+]?[0-9]+)(\\</span>.[<span class="cstat-no" title="statement not covered" >0-9]+)</span>?(e<span class="cstat-no" title="statement not covered" >[-+]?[0-9]+)?","g")),P=new RegExp("^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9](T[0-9][0-9]:[0-9][0-9](:[0-9][0-9](\\.[0-9]*)?)?)?Z?"),U=(new RegExp("^[0-9]+","g"),new RegExp('[\\\\\\r\\n\\"]',"g")),M=ne</span>w R<span class="cstat-no" title="statement not covered" >egExp("^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*","g");return n.prototype.here=function(e){return this._genPrefix+"_L"+this</span>.li<span class="cstat-no" title="statement not covered" >nes+"C"+(e-this.startOfLine+1)},n.prototype.formula=function</span>(){<span class="cstat-no" title="statement not covered" >return this._formula},n.prototype.loadStream=fun<span class="cstat-no" title="statement not covered" ></span>ction(e){return this.loa<span class="fstat-no" title="function not covered" >dB</span>uf(e.read(<span class="cstat-no" title="statement not covered" >))},n.prototype.loadBuf=function(e){return this.startDoc(),this.fee</span>d(e),this.endDoc()},n<span class="fstat-no" title="function not covered" >.p</span>rototype.<span class="cstat-no" title="statement not covered" >feed=function(e){for(v</span>ar t=e.decode("utf-8"),n<span class="fstat-no" title="function not covered" >=0</span>;n&gt;=0;){va<span class="cstat-no" title="statement not covered" >r r=this.skipSpace(t,n);if(r&lt;0)</span>return;var n=this.dir<span class="fstat-no" title="function not covered" >ec</span>tiveOrStat<span class="cstat-no" title="statement not covered" >ement(t,r);if(n&lt;0)throw s(this._thisDoc,this.lines,</span>t,r,"expected dire<span class="fstat-no" title="function not covered" >ct</span>ive or sta<span class="cstat-no" title="statement not covered" >tement")}},n.prototype.directiveOrStatement=f<span class="cstat-no" title="statement not covered" >unction(e,t){var n=t<span class="cstat-no" title="statement not covered" ></span>his.ski<span class="cstat-no" title="statement not covered" >pSpace(e</span></span>,t);i<span class="cstat-no" title="statement not covered" >f(n&lt;0)return n;var r=this.direc<span class="cstat-no" title="statement not covered" ></span>tive(e,<span class="cstat-no" title="statement not covered" >n);if(r&gt;=0)return this.checkDot(e,r);var r=this.statement(e,n);return r&gt;=</span></span>0</span>?this.checkDot(e,r):r},n.prototype<span class="fstat-no" title="function not covered" >.t</span>ok=function(e,t,n)<span class="cstat-no" title="statement not covered" >{if("@"==p(t,n,n+1))<span class="cstat-no" title="statement not covered" ></span>var n=n<span class="cstat-no" title="statement not covered" >+1;else if</span></span>(o(th<span class="cstat-no" title="statement not covered" >is.keywords,e)&lt;0)ret<span class="cstat-no" title="statement not covered" ></span>urn-1;va<span class="cstat-no" title="statement not covered" >r r=n+d(e);return p(t,n,r)=</span></span>=e&amp;&amp;A<span class="cstat-no" title="statement not covered" >.indexOf(t.charAt(r)<span class="cstat-no" title="statement not covered" ></span>)&gt;=0?r:-1},n.prototype.directive=f</span>unction(t,n){var <span class="fstat-no" title="function not covered" >r=</span>this.skipSpace<span class="cstat-no" title="statement not covered" >(t,n);if(r&lt;0)return r;var<span class="cstat-no" title="statement not covered" > i=n</span>ew f(<span class="cstat-no" title="statement not covered" >[]),r=this.tok("bind",t,<span class="cstat-no" title="statement not covered" >n);if(r&gt;0)</span></span></span>throw<span class="cstat-no" title="statement not covered" > s(this<span class="cstat-no" title="statement not covered" ></span>._thisDoc,this.lines,t,n,"keyword bind is obsolete: </span>use @prefix");var r=thi<span class="fstat-no" title="function not covered" >s.</span>tok("keywords",t,n<span class="cstat-no" title="statement not covered" >);if(r&gt;0){var n=this<span class="cstat-no" title="statement not covered" ></span>.commaS<span class="cstat-no" title="statement not covered" >eparatedLi</span></span>st(t,<span class="cstat-no" title="statement not covered" >r,i,!1);if</span>(n<span class="cstat-no" title="statement not covered" >&lt;0)throw s(this._this<span class="cstat-no" title="statement not covered" ></span>Doc,thi<span class="cstat-no" title="statement not covered" >s.lines,t,n,"'@keywords' needs comma separated list of words");return this.setK</span></span>eywor<span class="cstat-no" title="statement not covered" >ds(p(i,null,null)),k&gt;80&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>T("Keywords ",<span class="cstat-no" title="statement not covered" >this.keywords),n}var r=this.tok("f<span class="cstat-no" title="statement not covered" ></span>orAll",<span class="cstat-no" title="statement not covered" >t,n);if(r&gt;0){var n=this.commaSeparatedList(t,r,i,!0);if(n&lt;0)throw s(this._thisDoc,this.l<span class="cstat-no" title="statement not covered" >i</span></span>nes,t,n,"Bad variable list after @forAll");var a=new g(i);try{for(;;){var u=a</span>.</span>next(<span class="cstat-no" title="statement not covered" >);(o(this._variables,u)<span class="cstat-no" title="statement not covered" ></span>&lt;0||o(this._pa<span class="cstat-no" title="statement not covered" >rentVariables,u)&gt;=0)&amp;&amp;(this._varia<span class="cstat-no" title="statement not covered" ></span>bles[u]<span class="cstat-no" title="statement not covered" >=this._context.newUniversal(u))}}catch(e){if(e!=v)throw e}return n}var r=</span></span>this.<span class="cstat-no" title="statement not covered" >tok("forS<span class="cstat-no" title="statement not covered" ></span>ome"<span class="cstat-no" title="statement not covered" >,t,n);if(r&gt;0){<span class="cstat-no" title="statement not covered" >var n=thi<span class="cstat-no" title="statement not covered" ></span>s.commaSeparatedList(t,r,i,this.uri_ref2);if(n&lt;0)throw s(this._thisDoc,this.lines,t,n,"Bad variable list afte</span>r</span> @forSome<span class="cstat-no" title="statement not covered" >");var a<span class="cstat-no" title="statement not covered" >=new g(i)<span class="cstat-no" title="statement not covered" ></span></span>;</span>try{for(;</span>;</span>){var<span class="cstat-no" title="statement not covered" > u=a.next();this._contex<span class="cstat-no" title="statement not covered" ></span>t.declareExist<span class="cstat-no" title="statement not covered" >ential(u)}}catch(e){if(e!=v)throw e}return n}<span class="cstat-no" title="statement not covered" ></span>var r=t<span class="cstat-no" title="statement not covered" >his.tok("prefix",t,n);if(r&gt;=0){var l=new f([]),n=this.qname(t,r,l);if(n&lt;0)</span></span>throw<span class="cstat-no" title="statement not covered" > s(this._<span class="cstat-no" title="statement not covered" ></span>this<span class="cstat-no" title="statement not covered" >Doc,this.lines<span class="cstat-no" title="statement not covered" >,t,r,"exp<span class="cstat-no" title="statement not covered" ></span>ected qname after @prefix");var r=thi</span>s</span>.uri_ref2<span class="cstat-no" title="statement not covered" >(t,n,l);<span class="cstat-no" title="statement not covered" >if(r&lt;0)th<span class="cstat-no" title="statement not covered" ></span></span>r</span>ow s(this</span>.</span>_this<span class="cstat-no" title="statement not covered" >Doc,this.lines,t,n,"exp<span class="cstat-no" title="statement not covered" ></span>ected &lt;uriref&gt; <span class="cstat-no" title="statement not covered" >after @pre</span>fi<span class="cstat-no" title="statement not covered" >x _qname_");var c=<span class="cstat-no" title="statement not covered" ></span>l[1].ur<span class="cstat-no" title="statement not covered" >i;if(this._baseURI)var c=w(this._baseURI,c);else m(c.indexOf(":")&gt;=0,"</span></span>With <span class="cstat-no" title="statement not covered" >no base URI, cannot h<span class="cstat-no" title="statement not covered" ></span>andle r<span class="cstat-no" title="statement not covered" >elative URI for NS");return m(c.indexOf(":")&gt;=0),this._bindings[l[0][0]]=c,this.b</span></span>ind(l<span class="cstat-no" title="statement not covered" >[0][0],e(<span class="cstat-no" title="statement not covered" ></span>c)),r}var r=this.tok("b<span class="cstat-no" title="statement not covered" >ase",t,n);if(r&gt;=0){</span>var l<span class="cstat-no" title="statement not covered" >=new f([]),n=this.uri_ref2(t,r,l);if(n&lt;0)throw s(this._thisDoc,this.lines,t<span class="cstat-no" title="statement not covered" >,</span></span>r,"expected &lt;uri&gt; after @base ");var c=l[0].uri;if(!this._baseURI)throw s(this._</span>t</span>hisDo<span class="cstat-no" title="statement not covered" >c,this.lines,t,r,"Wit<span class="cstat-no" title="statement not covered" ></span>h no previous b<span class="cstat-no" title="statement not covered" >ase URI, c</span>an<span class="cstat-no" title="statement not covered" >not use relative URI <span class="cstat-no" title="statement not covered" ></span>in @bas<span class="cstat-no" title="statement not covered" >e  &lt;"+c+"&gt;");var c=w(this._baseURI,c);return m(c.indexOf(":")&gt;=0),thi</span></span>s._ba<span class="cstat-no" title="statement not covered" >seURI=c,n<span class="cstat-no" title="statement not covered" ></span>}return-1},n.proto<span class="cstat-no" title="statement not covered" >type.bind=function(e,t){""==e||this._store.setPrefixForURI(e,t)},n.prototype.setKeywords=function(e){null==e?t</span></span>his.k<span class="cstat-no" title="statement not covered" >eywordsSet=0:(this.<span class="cstat-no" title="statement not covered" ></span>keywords=e,this.keywordsSet=1)},n.prototype.sta<span class="cstat-no" title="statement not covered" ></span>r</span>tDoc=func</span>tion(){},n.prototy<span class="fstat-no" title="function not covered" >pe</span>.endDoc=func<span class="cstat-no" title="statement not covered" >tion(){return this._formula},n.prototype.</span>makeStatement=function(e)<span class="fstat-no" title="function not covered" >{e</span>[0].add(e[<span class="cstat-no" title="statement not covered" >2],e[1],e[3],this.source),this.statementCount+=1},n.prototype.sta</span>tement=function(e,t){v<span class="fstat-no" title="function not covered" >ar</span> n=new f([]),t=this.object(e,t<span class="fstat-no" title="function not covered" >,n</span>);if(t&lt;0)<span class="cstat-no" title="statement not covered" >return t;var r=this.pr</span>operty_list(e,t,n[0]);if(r&lt;<span class="fstat-no" title="function not covered" >0)</span>throw s(th<span class="cstat-no" title="statement not covered" >is._thisDoc,this.lines,e,t,"expected propertylist");return r}</span>,n.prototype.subject=fu<span class="fstat-no" title="function not covered" >nc</span>tion(e,t,n){return<span class="cstat-no" title="statement not covered" > this.item</span>(e<span class="cstat-no" title="statement not covered" >,t,n)},n.prototype.<span class="cstat-no" title="statement not covered" ></span>verb=fu<span class="cstat-no" title="statement not covered" >nction(e,t</span></span>,n){v<span class="cstat-no" title="statement not covered" >ar r=this.skipSpace(e,t);if(r<span class="cstat-no" title="statement not covered" ></span>&lt;0)retu<span class="cstat-no" title="statement not covered" >rn r;var i=new f([]),r=this.tok("has",e,t);if(r&gt;=0){var t=this<span class="cstat-no" title="statement not covered" >.</span></span>prop(e,r,</span>i);if(t&lt;0)throw s(thi<span class="fstat-no" title="function not covered" >s.</span>_thisDoc,this.<span class="cstat-no" title="statement not covered" >lines,e,r,"expected prope</span>rty after 'has'");<span class="fstat-no" title="function not covered" >re</span>turn n.push(new c(["<span class="cstat-no" title="statement not covered" >-&gt;",i[0]])),t}var r=<span class="cstat-no" title="statement not covered" ></span>this.to<span class="cstat-no" title="statement not covered" >k("is",e,t</span></span>);if(<span class="cstat-no" title="statement not covered" >r&gt;=0){var </span>t=<span class="cstat-no" title="statement not covered" >this.prop(e,r,i);if(<span class="cstat-no" title="statement not covered" ></span>t&lt;0)throw s(thi<span class="cstat-no" title="statement not covered" >s._thisDoc,this.l<span class="cstat-no" title="statement not covered" ></span>ines,e,<span class="cstat-no" title="statement not covered" >r,"expected &lt;property&gt; after 'is'");var r=this.skipSpace(e,t);if(r&lt;0)t<span class="cstat-no" title="statement not covered" >h</span></span>row s(this._thisDoc,this.lines,e,t,"</span>E</span>nd of<span class="cstat-no" title="statement not covered" > file found, expect<span class="cstat-no" title="statement not covered" ></span>ed property aft<span class="cstat-no" title="statement not covered" >er 'is'");var t=r<span class="cstat-no" title="statement not covered" ></span>,r=this<span class="cstat-no" title="statement not covered" >.tok("of",e,t);if(r&lt;0)throw s(this._thisDoc,this.lines,e,t,"expected 'of</span></span>' aft<span class="cstat-no" title="statement not covered" >er 'is' &lt;prop&gt;");ret<span class="cstat-no" title="statement not covered" ></span>urn n.p<span class="cstat-no" title="statement not covered" >ush(new c(["&lt;-",i[0]])),r}var r=this.tok("a",e,t);if(r&gt;=0)return n.push(new c(["-&gt;",this.</span></span>_stor<span class="cstat-no" title="statement not covered" >e.</span>sy<span class="cstat-no" title="statement not covered" >m(E)])),r;if("&lt;="==<span class="cstat-no" title="statement not covered" ></span>p(e,t,t<span class="cstat-no" title="statement not covered" >+2))return n.push(new c(["&lt;-",this._store.sym(l+"implies")])),t+2;if("="<span class="cstat-no" title="statement not covered" >=</span></span>=p(e,t,t+1))return"&gt;"==p(e,t+1,t+2)?</span>(</span>n.pus<span class="cstat-no" title="statement not covered" >h(new c(["-&gt;",this<span class="cstat-no" title="statement not covered" ></span>._store.<span class="cstat-no" title="statement not covered" >sym(l+"implies")])),t+2):(n.push(new c(["-&gt;",this.<span class="cstat-no" title="statement not covered" >_</span></span>store.sym(S)])),t+1<span class="cstat-no" title="statement not covered" >);if(":="==p(e,t,t+2))return n.push(new c(["-&gt;",l+"becomes"]))<span class="cstat-no" title="statement not covered" >,</span></span>t+2;var r=this.pro<span class="cstat-no" title="statement not covered" >p(e,t,i);if(r&gt;=0)return n.push(new c(["-&gt;",i[0]])),r;if("&gt;-"==p(e,t,t+2)||"&lt;-"==p(e,t,t+2))throw s(this._thisDoc,this.lines,e,r,<span class="cstat-no" title="statement not covered" >"</span></span>&gt;- ... -&gt; syntax is<span class="cstat-no" title="statement not covered" > obsolete.");return-1},n.prototype.prop=functi</span></span>on(e,<span class="cstat-no" title="statement not covered" >t,n){return this.<span class="cstat-no" title="statement not covered" ></span>item(e,t<span class="cstat-no" title="statement not covered" >,n)},n.prototype.item=function(e,t,n<span class="cstat-no" title="statement not covered" >)</span></span>{return this.path(e,t,n)},n.prototype<span class="cstat-no" title="statement not covered" >.blankNode=function(e){return this._context.bnode(e,this._reason2)},n.<span class="cstat-no" title="statement not covered" >p</span></span>rototype.</span>path=function(e,t,<span class="fstat-no" title="function not covered" >n)</span>{var r=this.no<span class="cstat-no" title="statement not covered" >deOrLiteral(e,t,n);if(r&lt;0</span>)return r;for(;"!^<span class="fstat-no" title="function not covered" >."</span>.indexOf(p(e,r<span class="cstat-no" title="statement not covered" >,r+1))&gt;=0;){var i=p(e,r,r</span>+1);if("."==i){var o=p(<span class="fstat-no" title="function not covered" >e,</span>r+1,r+2);i<span class="cstat-no" title="statement not covered" >f(!o||L.indexOf(o)&gt;=0&amp;&amp;":?&lt;[{(".indexOf(o)&lt;0)</span>break}var a=n.pop(<span class="fstat-no" title="function not covered" >),</span>u=this.blankNode(thi<span class="cstat-no" title="statement not covered" >s.here(r)),r=this.node(e,r<span class="cstat-no" title="statement not covered" ></span>+1,n);i<span class="cstat-no" title="statement not covered" >f(r&lt;0)thr<span class="cstat-no" title="statement not covered" >o</span></span>w s(this._thisDoc,this.lines,e,r,"EOF fou<span class="cstat-no" title="statement not covered" >nd in middl<span class="cstat-no" title="statement not covered" ></span>e of path syntax"<span class="cstat-no" title="statement not covered" >);var l=n.pop<span class="cstat-no" title="statement not covered" ></span>();"^"==i?this.makeStatement(new c([this._cont<span class="cstat-no" title="statement not covered" >ext,l,u</span></span>,</span>a])):<span class="cstat-no" title="statement not covered" >this.mak</span>eS<span class="cstat-no" title="statement not covered" >tatement(new c([this._context</span>,l<span class="cstat-no" title="statement not covered" >,a,u])),n.push(u)}r<span class="cstat-no" title="statement not covered" ></span>eturn r<span class="cstat-no" title="statement not covered" >},n.prototype.anonymousNode=function(e){var t=this._anonymousNodes[e];if(t)r</span></span>eturn<span class="cstat-no" title="statement not covered" > t;var t<span class="cstat-no" title="statement not covered" ></span>=this._store.bnode(this._context,this._reason2);return this._anonymousNodes[e]=t,t},n.prototype.node=function(e,t,n,<span class="cstat-no" title="statement not covered" ></span>r</span>){"undefi</span>ned"==typeof r&amp;&amp;(r=null);va<span class="fstat-no" title="function not covered" >r </span>i=r,o=this.skipS<span class="cstat-no" title="statement not covered" >pace(e,t);if(o&lt;0)return <span class="cstat-no" title="statement not covered" ></span>o;var<span class="cstat-no" title="statement not covered" > t=o,a=p(e</span></span>,t,t+<span class="cstat-no" title="statement not covered" >1);if("["==a){var u=this.here(t),o=this.skipSpa<span class="cstat-no" title="statement not covered" ></span>ce(e,t+1);if(o&lt;0)throw s(this._thisD</span>oc,this.lines,e,t,<span class="fstat-no" title="function not covered" >"E</span>OF after '['");i<span class="cstat-no" title="statement not covered" >f("="==p(e,o,o+1)){var t=o+1,l=ne</span>w f([<span class="cstat-no" title="statement not covered" >])</span>,o<span class="cstat-no" title="statement not covered" >=this.objectList(e,t<span class="cstat-no" title="statement not covered" ></span>,l);if(<span class="cstat-no" title="statement not covered" >!(o&gt;=0))th</span></span>row s<span class="cstat-no" title="statement not covered" >(t</span>hi<span class="cstat-no" title="statement not covered" >s._thisDoc,<span class="cstat-no" title="statement not covered" ></span>this.lines,e,t,"o<span class="cstat-no" title="statement not covered" >bjectList exp</span>ec<span class="cstat-no" title="statement not covered" >ted after [= ");var i=<span class="cstat-no" title="statement not covered" ></span>l[0];if<span class="cstat-no" title="statement not covered" >(d(l)&gt;1){var y=new g(l);try{for(;;){var m=y.next();thi<span class="cstat-no" title="statement not covered" >s</span></span>.makeStatement(new c([thi<span class="cstat-no" title="statement not covered" >s._c</span>on<span class="cstat-no" title="statement not covered" >text,this.</span>_s<span class="cstat-no" title="statement not covered" >tore.sym(S),i,m]))}}cat<span class="cstat-no" title="statement not covered" ></span>ch(e){if(e!<span class="cstat-no" title="statement not covered" >=v)throw e}}var o=this.skipSpace(e,o);if(o&lt;0)throw s(this._thisDoc,this</span></span>.line<span class="cstat-no" title="statement not covered" >s,e,t<span class="cstat-no" title="statement not covered" ></span>,"EOF when object<span class="cstat-no" title="statement not covered" >List expe<span class="cstat-no" title="statement not covered" ></span>cted<span class="cstat-no" title="statement not covered" > after [ = ");<span class="cstat-no" title="statement not covered" >if(";"==p<span class="cstat-no" title="statement not covered" ></span>(e,o,o+1))var o=o+1}if(null==i)var i=this.blankNode(u);var t=this.p</span>r</span>operty_li<span class="cstat-no" title="statement not covered" >st(e,o,i<span class="cstat-no" title="statement not covered" >);if(t&lt;0)</span></span>t</span>h</span>row s<span class="cstat-no" title="statement not covered" >(this._thisDoc,this.<span class="cstat-no" title="statement not covered" ></span>lines,e<span class="cstat-no" title="statement not covered" >,o,"property_list expected");var o=this.skipSpace(e,t);if(o&lt;0)throw s(this._this<span class="cstat-no" title="statement not covered" >D</span></span>oc,this.lines,e,t,"EOF w<span class="cstat-no" title="statement not covered" >hen </span>'<span class="cstat-no" title="statement not covered" ></span>]</span>' expected after<span class="cstat-no" title="statement not covered" > [ &lt;propertyList&gt;"</span>)</span>;if("<span class="cstat-no" title="statement not covered" >]"!=p(e,o,o+1))throw s(thi<span class="cstat-no" title="statement not covered" ></span>s._this<span class="cstat-no" title="statement not covered" >Doc,this.lines,e,o,"']' expected");return n.push(i),o+1}if("{"==</span></span>a){va<span class="cstat-no" title="statement not covered" >r b=p(e,t+1,t+2);if(<span class="cstat-no" title="statement not covered" ></span>"$"==b)<span class="cstat-no" title="statement not covered" >{t+=1;for(var o=t+1,w=new f([]),_=!0;;){var t=this.skipSpace(e,o);if(t&lt;0)throw s(this<span class="cstat-no" title="statement not covered" >.</span></span>_thisDoc,this.line<span class="cstat-no" title="statement not covered" >s,e,t,"needed '$}', found end.");if("$}"==p(e,t,t+2))<span class="cstat-no" title="statement not covered" >{</span></span>var o=t+2;break}if(_)<span class="cstat-no" title="statement not covered" ></span>v</span>ar _=!1;else{if(<span class="cstat-no" title="statement not covered" >","!=p(e,t,t+<span class="cstat-no" title="statement not covered" ></span>1))throw s(<span class="cstat-no" title="statement not covered" >this.<span class="cstat-no" title="statement not covered" >_</span>thisDoc,this.lines,e,t,"expected: ','")<span class="cstat-no" title="statement not covered" >;t+=1}var k=new f([]<span class="cstat-no" title="statement not covered" ></span>),o=thi<span class="cstat-no" title="statement not covered" >s.item(e,t,k);if(o&lt;0)throw s(this._thisDoc,this.lines,e,t,"expec<span class="cstat-no" title="statement not covered" >t</span></span>ed item in set or '$}'");w<span class="cstat-no" title="statement not covered" >.pus<span class="cstat-no" title="statement not covered" ></span>h(k[0])<span class="cstat-no" title="statement not covered" ></span>}</span>return n.p<span class="cstat-no" title="statement not covered" >ush</span>(this<span class="cstat-no" title="statement not covered" >._store.newSet(w,th<span class="cstat-no" title="statement not covered" >is._context)),o}var o=t+1,T=this._parentContext;this._<span class="cstat-no" title="statement not covered" >p</span></span>arent</span>C</span>ontex<span class="cstat-no" title="statement not covered" >t=this._co</span>nt<span class="cstat-no" title="statement not covered" >ext;var E=this._a<span class="cstat-no" title="statement not covered" ></span>nonymou<span class="cstat-no" title="statement not covered" >sNodes,N=this._parentVariables;this._parentVariables=this._variables,<span class="cstat-no" title="statement not covered" >t</span></span>his._anonymou<span class="cstat-no" title="statement not covered" ></span>s</span>Nodes=new h([]),this._variables=this._variables.slice</span>(</span>);var<span class="cstat-no" title="statement not covered" > R=t</span>hi<span class="cstat-no" title="statement not covered" >s._reason2;if(this._<span class="cstat-no" title="statement not covered" ></span>reason2=x,null==i)var i=this._store</span>.form<span class="cstat-no" title="statement not covered" >ula();for(this._conte</span>xt<span class="cstat-no" title="statement not covered" >=i;;){var t=this.skipS<span class="cstat-no" title="statement not covered" ></span>pace(e,o);if(t&lt;0)throw s(this._thisDoc,this.lines,e,t,"needed '}', found end.");if("}"==p(e,t,t+1)){var o=t+1;</span>break<span class="cstat-no" title="statement not covered" >}var o=this.di<span class="cstat-no" title="statement not covered" ></span>rectiveOrStatement(e,t);if(o&lt;0)th<span class="cstat-no" title="statement not covered" >row s(this._thisDoc,th<span class="cstat-no" title="statement not covered" ></span>i</span>s.lines,e,t,"expected statem<span class="cstat-no" title="statement not covered" >ent or '}'")}return <span class="cstat-no" title="statement not covered" ></span>this._a<span class="cstat-no" title="statement not covered" >nonymousNodes=E,this._variables=this._parentVariables,this._par<span class="cstat-no" title="statement not covered" >e</span></span>ntVariables=N,this._conte<span class="cstat-no" title="statement not covered" >xt=t<span class="cstat-no" title="statement not covered" ></span>his._pa</span>r</span>entCo<span class="cstat-no" title="statement not covered" >ntext,this._reason2=R,this._par<span class="cstat-no" title="statement not covered" ></span>entCont<span class="cstat-no" title="statement not covered" >ext=T,n.push(i.close()),o}if("("==a){var j=this._store.list,b=p(e,t<span class="cstat-no" title="statement not covered" ></span></span>+</span>1,t+2);if("$"==b){var j=this._store.newSet;t+=1}for(var o=t+1,w=new f([]);;){var t=this.skipSpace(e,o);if(t&lt;0)throw s(this._thisDoc,this.lines,e,t,"needed ')', found end.");if(")"==p(e<span class="cstat-no" title="statement not covered" ></span>,</span>t,t+1)){var o=t+<span class="cstat-no" title="statement not covered" >1;break}var k=new</span> f<span class="cstat-no" title="statement not covered" >([]),o=this.i<span class="cstat-no" title="statement not covered" ></span>tem(e,t,k);if(o&lt;0<span class="cstat-no" title="statement not covered" >)throw s(this._this<span class="cstat-no" title="statement not covered" ></span>Doc,th<span class="cstat-no" title="statement not covered" ></span>i</span>s.lines,e,t,"expected item in list<span class="cstat-no" title="statement not covered" > or ')'");w.push(k[0<span class="cstat-no" title="statement not covered" ></span>])}retu<span class="cstat-no" title="statement not covered" >rn n.push(j(w,this._context)),o}var o=this.tok("this",e,t);if(o<span class="cstat-no" title="statement not covered" >&gt;</span></span>=0)throw s(this._thisDoc,<span class="cstat-no" title="statement not covered" >this<span class="cstat-no" title="statement not covered" ></span>.lines,</span>e</span>,t,"K<span class="cstat-no" title="statement not covered" >eyword 'th</span>is<span class="cstat-no" title="statement not covered" >' was ancient N3.<span class="cstat-no" title="statement not covered" ></span> Now us<span class="cstat-no" title="statement not covered" >e @forSome and @forAll keywords.");var o=this.tok("true",e,t);if(o&gt;=0<span class="cstat-no" title="statement not covered" >)</span></span>return n.push<span class="cstat-no" title="statement not covered" ></span>(</span>!0),o;var o=this.tok("false",e,t);if</span>(</span>o&gt;=0)<span class="cstat-no" title="statement not covered" >return n.push(!1),o;i<span class="cstat-no" title="statement not covered" ></span>f(null==<span class="cstat-no" title="statement not covered" >i){var o=this.uri_ref2(e,t,n);if(o&gt;=0)return o}return-1},n.prototype.property_list=function(e,t,n){for(;;){var </span></span>r=thi<span class="cstat-no" title="statement not covered" >s.skipSpace(e,t);if(r<span class="cstat-no" title="statement not covered" ></span>&lt;0)throw<span class="cstat-no" title="statement not covered" > s(this._thisDoc,this</span></span>.line<span class="cstat-no" title="statement not covered" >s,e,t,"EOF found when <span class="cstat-no" title="statement not covered" ></span>expected<span class="cstat-no" title="statement not covered" > verb in property li<span class="cstat-no" title="statement not covered" >s</span></span>t");if(":-"!=p(e,<span class="cstat-no" title="statement not covered" >r,r+2)){var t=r,i=new<span class="cstat-no" title="statement not covered" ></span> f([]),r<span class="cstat-no" title="statement not covered" >=this.verb<span class="cstat-no" title="statement not covered" ></span></span>(</span>e,t,i);if</span>(r&lt;=0)return t;var o=new f(<span class="fstat-no" title="function not covered" >[]</span>),t=this.objec<span class="cstat-no" title="statement not covered" >tList(e,r,o);i<span class="cstat-no" title="statement not covered" >f(t&lt;0)throw s(this._<span class="cstat-no" title="statement not covered" ></span>thisDoc<span class="cstat-no" title="statement not covered" >,this.lines,e,r,"objectList expected");var a=new g(o);try{for(;;){var u=a.next(),l=i[0<span class="cstat-no" title="statement not covered" >]</span></span>,h=l[0],d=l[1];"-&gt;"==h?thi<span class="cstat-no" title="statement not covered" >s.</span>ma<span class="cstat-no" title="statement not covered" >keStatemen</span>t(<span class="cstat-no" title="statement not covered" >new c([this._cont<span class="cstat-no" title="statement not covered" ></span>ext,d,n,<span class="cstat-no" title="statement not covered" >u])):this.</span></span>makeS<span class="cstat-no" title="statement not covered" >tatement(n</span>ew<span class="cstat-no" title="statement not covered" > c([this._context,d,u,n<span class="cstat-no" title="statement not covered" ></span>]))}}ca<span class="cstat-no" title="statement not covered" >tch(e){if(e!=v)throw e}var r=this.skipSpace(e,t);if(r&lt;0)throw</span></span> s(th<span class="cstat-no" title="statement not covered" >is._thisD<span class="cstat-no" title="statement not covered" ></span>oc,t<span class="cstat-no" title="statement not covered" >his.lines,e,r,<span class="cstat-no" title="statement not covered" >"EOF foun</span>d <span class="cstat-no" title="statement not covered" >in li</span>st<span class="cstat-no" title="statement not covered" > of o</span>bj<span class="cstat-no" title="statement not covered" >ects"<span class="cstat-no" title="statement not covered" ></span>);if(";"!=p(e,t,t+1))return t;var t=t+1}else{var t=r+2,y=new f([]),r=this.node(e,t,y,n);if(r&lt;0)throw s(this</span>.</span>_thisDoc,<span class="cstat-no" title="statement not covered" >this.lin<span class="cstat-no" title="statement not covered" >es,e,t,"b</span></span>a</span>d {} <span class="cstat-no" title="statement not covered" >or () or [] node aft<span class="cstat-no" title="statement not covered" ></span>er :- "<span class="cstat-no" title="statement not covered" >);var t=r}}},n.prototype.commaSeparatedList=function(e,t,n,r){var i=t<span class="cstat-no" title="statement not covered" >h</span></span>is.skipSpace(e,t);<span class="cstat-no" title="statement not covered" >if(i&lt;0)thr</span></span>ow s(<span class="cstat-no" title="statement not covered" >this</span>._thisDoc,th<span class="cstat-no" title="statement not covered" >is.l</span>in<span class="cstat-no" title="statement not covered" >es,e,i,"EO</span>F <span class="cstat-no" title="statement not covered" >found expecting com<span class="cstat-no" title="statement not covered" ></span>ma sep <span class="cstat-no" title="statement not covered" >list");if("."==e.charAt(i))return t;if(r)var i=this.uri_ref2(e,i,n);else va</span></span>r i=t<span class="cstat-no" title="statement not covered" >hi</span>s.</span>b</span>areWord(e,i,n);if(i&lt;0)return-1;f<span class="fstat-no" title="function not covered" >or</span>(;;){var t=this.skipSp<span class="cstat-no" title="statement not covered" >ace(e,i);if(t&lt;0)retu<span class="cstat-no" title="statement not covered" ></span>rn t;va<span class="cstat-no" title="statement not covered" >r o=p(e,t,t+1);if(","!=o)return"."!=o?-1:t;if(r)var i=this.uri_ref2(e,t+1,n<span class="cstat-no" title="statement not covered" >)</span></span>;else var i=this.ba<span class="cstat-no" title="statement not covered" >reWord(e,<span class="cstat-no" title="statement not covered" >t</span></span>+1,n);if(i<span class="cstat-no" title="statement not covered" >&lt;0)throw s(this._this</span>Doc,this.li<span class="cstat-no" title="statement not covered" >nes,e,i,"bad list con<span class="cstat-no" title="statement not covered" ></span>t</span>ent")}<span class="cstat-no" title="statement not covered" >},n.proto<span class="cstat-no" title="statement not covered" >t</span></span>ype.objectLis<span class="cstat-no" title="statement not covered" >t=function(e,t,n){va<span class="cstat-no" title="statement not covered" ></span>r t=thi<span class="cstat-no" title="statement not covered" >s.object(e</span></span>,t,n)<span class="cstat-no" title="statement not covered" >;if(t&lt;0)ret<span class="cstat-no" title="statement not covered" ></span>urn-1;for(<span class="cstat-no" title="statement not covered" >;;){var r=this.ski<span class="cstat-no" title="statement not covered" >p</span></span>Space(e,t)<span class="cstat-no" title="statement not covered" >;if(r&lt;0)throw s(this._t</span>hisDoc,this<span class="cstat-no" title="statement not covered" >.lines,e,r,"EOF found a<span class="cstat-no" title="statement not covered" ></span>f</span>ter ob<span class="cstat-no" title="statement not covered" >ject");if(","!=p(e,r,r+1))return r;var t=this.object(e,r+1</span></span>,</span>n);if(t&lt;0)return t}},n.p<span class="fstat-no" title="function not covered" >ro</span>totype.checkDot=func<span class="cstat-no" title="statement not covered" >tion(e,t){var n=thi<span class="cstat-no" title="statement not covered" ></span>s.skipS<span class="cstat-no" title="statement not covered" >pace(e,t)<span class="cstat-no" title="statement not covered" >;</span></span>if(n&lt;0)return<span class="cstat-no" title="statement not covered" > n;if("."==p(e,n,n+1<span class="cstat-no" title="statement not covered" ></span>))retur<span class="cstat-no" title="statement not covered" >n n+1;if("}"==p(e,n,n+1))return n;if("]"==p(e,n,n+1))return n;t<span class="cstat-no" title="statement not covered" >h</span></span>row s(this._thisDo<span class="cstat-no" title="statement not covered" >c,this.lin</span></span>es,e,<span class="cstat-no" title="statement not covered" >n,"expected '.' or '}<span class="cstat-no" title="statement not covered" ></span>' or ']<span class="cstat-no" title="statement not covered" >' at end o</span></span>f</span> statement")},n.protot<span class="fstat-no" title="function not covered" >yp</span>e.uri_ref2=functio<span class="cstat-no" title="statement not covered" >n(e,t,n){var r=new f<span class="cstat-no" title="statement not covered" ></span>([]),i=<span class="cstat-no" title="statement not covered" >this.qnam<span class="cstat-no" title="statement not covered" >e</span></span>(e,t,r);if(i&gt;=0){v<span class="cstat-no" title="statement not covered" >ar a=r[0],u<span class="cstat-no" title="statement not covered" >=</span></span>a[0],l=a[1];if(nul<span class="cstat-no" title="statement not covered" >l==u){m(0<span class="cstat-no" title="statement not covered" >,</span></span>"not used?");var c<span class="cstat-no" title="statement not covered" >=this._ba<span class="cstat-no" title="statement not covered" >s</span></span>eURI+N}else{var c=this._bindings[u];if(!c){if("_"==u)return n.push(this.anonymousNode(l</span>)),i;throw s(this._thi<span class="fstat-no" title="function not covered" >sD</span>oc,this.lines,e,t,"P<span class="cstat-no" title="statement not covered" >refix "+u+</span>" <span class="cstat-no" title="statement not covered" >not bound.")}}var <span class="cstat-no" title="statement not covered" ></span>h=this._store.s<span class="cstat-no" title="statement not covered" >ym(c+</span>l)<span class="cstat-no" title="statement not covered" >;retu</span>rn<span class="cstat-no" title="statement not covered" > o(th<span class="cstat-no" title="statement not covered" ></span>is._variable<span class="cstat-no" title="statement not covered" >s,h)&gt;=0?n.push(thi</span>s._va<span class="cstat-no" title="statement not covered" >riables[h]):n.pu</span>sh(h),i}var <span class="cstat-no" title="statement not covered" >t=this.skipSpace(e<span class="cstat-no" title="statement not covered" ></span>,t);if(<span class="cstat-no" title="statement not covered" >t&lt;0)return<span class="cstat-no" title="statement not covered" >-1;if("?"==e.charAt(t)){var v=new f([])<span class="cstat-no" title="statement not covered" >,</span></span>i=this.variable(e,t,v);return i&gt;0?(n.push(v[0]),i):-1}if("&lt;"==e.</span>c</span>h</span>arAt(<span class="cstat-no" title="statement not covered" >t)){for(var t=t+1,g=t<span class="cstat-no" title="statement not covered" ></span>;t&lt;d(e);){if("&gt;"==e.charAt(t)){var y=p(e,g,t);if(this._baseURI)var y=w(</span>t</span>his._<span class="cstat-no" title="statement not covered" >baseURI,y);else m(y.<span class="cstat-no" title="statement not covered" ></span>indexOf<span class="cstat-no" title="statement not covered" >(":")&gt;=0,<span class="cstat-no" title="statement not covered" >"</span></span>With no base URI, cannot d<span class="cstat-no" title="statement not covered" >eal with r</span>el<span class="cstat-no" title="statement not covered" >ative URIs");if("#"==<span class="cstat-no" title="statement not covered" ></span>p(e,t-1,t)&amp;&amp;"#"!=p(y,-1,null))va<span class="cstat-no" title="statement not covered" ></span>r</span> y=y+"#";var h=this.<span class="cstat-no" title="statement not covered" >_store.sym(y);return o(this<span class="cstat-no" title="statement not covered" >._variables,h)&gt;=0?n.push(th<span class="cstat-no" title="statement not covered" >is._varia<span class="cstat-no" title="statement not covered" ></span>bles[h]):n.push(h),t+1}<span class="cstat-no" title="statement not covered" >var t=t+1}throw s(t</span>his._<span class="cstat-no" title="statement not covered" >thisDoc,this.lines,e,i,"unterminated URI reference")}if(this.keywordsSet<span class="cstat-no" title="statement not covered" >)</span></span>{var v=new f([]),i=this.bareWord(e,t,v);if(<span class="cstat-no" title="statement not covered" >i&lt;0)re</span>t</span>urn-1<span class="cstat-no" title="statement not covered" >;if(o(this.keywords<span class="cstat-no" title="statement not covered" ></span>,v[0])&gt;=0)throw s(this._thisDoc,this.lines,e,t,'Keyword "'+v[0]+'" not al</span>l</span>owed <span class="cstat-no" title="statement not covered" >here</span>.<span class="cstat-no" title="statement not covered" >'</span>);return n.push(this._store.sym(this._bindings[""]+v[0])),i}return-<span class="cstat-no" title="statement not covered" ></span>1</span>},n.prototype.skipSpace=fu<span class="cstat-no" title="statement not covered" >nction(e,t</span>){<span class="cstat-no" title="statement not covered" >for(var n=" \n\r\t\f\<span class="cstat-no" title="statement not covered" ></span>v      <span class="cstat-no" title="statement not covered" >      ​\u<span class="cstat-no" title="statement not covered" >2</span></span>028\u2029　",r=t?t:0;r&lt;e.len<span class="cstat-no" title="statement not covered" >gth;r++){var i=e.charAt(r);if(n.indexOf(i)&lt;0){if("#"!==e.charAt(r))return r;f<span class="cstat-no" title="statement not covered" >o</span></span>r(;;r++){if(r===e.length)return-1;if("\n"===e.charAt(r)){t<span class="cstat-no" title="statement not covered" ></span>h</span>is.lines=</span>this.lines+1;break}}}el<span class="fstat-no" title="function not covered" >se</span>"\n"===e.cha<span class="cstat-no" title="statement not covered" >rAt(r)&amp;&amp;(this.lines=this.lines+1)}return-1},n.prototype.variable=function(e,t,n)<span class="cstat-no" title="statement not covered" >{var r=this.<span class="cstat-no" title="statement not covered" ></span>skipSpace(e,t);if(r<span class="cstat-no" title="statement not covered" >&lt;0)return-1;if("?"!=p<span class="cstat-no" title="statement not covered" >(e,r,r+1)<span class="cstat-no" title="statement not covered" >)</span></span>return-1;v<span class="cstat-no" title="statement not covered" >ar r=r+1,t=r;if(<span class="cstat-no" title="statement not covered" >"01234567<span class="cstat-no" title="statement not covered" >8</span></span>9-".indexOf(e.charAt(r<span class="cstat-no" title="statement not covered" >))&gt;=0)throw s(this._this<span class="cstat-no" title="statement not covered" >D</span>oc,thi</span>s</span>.</span>line<span class="cstat-no" title="statement not covered" >s,e,r,"Varible name can't start with '"+e.charA<span class="cstat-no" title="statement not covered" ></span></span>t</span>(r)+"s'")</span>;for(;t&lt;d(e)&amp;&amp;L.indexO<span class="fstat-no" title="function not covered" >f(</span>e.charAt(t))&lt;0;)var <span class="cstat-no" title="statement not covered" >t=t+1;if(null==this.<span class="cstat-no" title="statement not covered" ></span>_parent<span class="cstat-no" title="statement not covered" >Context)t<span class="cstat-no" title="statement not covered" >h</span></span>row s(this._thisDo<span class="cstat-no" title="statement not covered" >c,this.lin</span></span>es,e,<span class="cstat-no" title="statement not covered" >r,"C</span>an<span class="cstat-no" title="statement not covered" >'t<span class="cstat-no" title="statement not covered" ></span> use ?xxx syntax for variable in outermos<span class="cstat-no" title="statement not covered" >t level: "+p(e,r-1,t));return n.push(this._store.variable(p(e,r,t))),t},n.prototype.bareW<span class="cstat-no" title="statement not covered" >o</span></span>rd=function(e,t,n){var r=this.skipSpace(e,t)<span class="cstat-no" title="statement not covered" >;if(<span class="cstat-no" title="statement not covered" ></span>r</span>&lt;0)return-1;var i=e.charAt(r<span class="cstat-no" title="statement not covered" >);if("0123456789-".indexOf(i)&gt;=0)return-1;if(L.indexOf(i)&gt;=0)return-1;for(var t=r;t&lt;d(e)&amp;&amp;L.indexOf(e.charA<span class="cstat-no" title="statement not covered" >t</span></span>(t))&lt;0;)var t=t+1;return n.push(p(e,r,t)),t},n.p</span>rototype.qname=functio<span class="fstat-no" title="function not covered" >n(</span>e,t,n){var t=this.sk<span class="cstat-no" title="statement not covered" >ipSpace(e,t);if(t&lt;0)<span class="cstat-no" title="statement not covered" ></span>return-<span class="cstat-no" title="statement not covered" >1;var r=e.</span></span>charA<span class="cstat-no" title="statement not covered" >t(t);if("012<span class="cstat-no" title="statement not covered" ></span>3456789-+".indexOf(r)&gt;=0)return<span class="cstat-no" title="statement not covered" >-1;if(L.i<span class="cstat-no" title="statement not covered" >n</span></span>dexOf(r)&lt;0)for(var<span class="cstat-no" title="statement not covered" > i=r,t=t+<span class="cstat-no" title="statement not covered" >1</span></span>;t&lt;d(e);){var r=e.charAt(t);if(!(L.indexOf(r)&lt;0))br<span class="cstat-no" title="statement not covered" >eak;<span class="cstat-no" title="statement not covered" ></span>v</span>ar i=i+r,t=t+1}else var i=</span>"";if(t&lt;d(e)&amp;&amp;":"==<span class="fstat-no" title="function not covered" >e.</span>charAt(t)){for(var a<span class="cstat-no" title="statement not covered" >=i,t=t+1,i="";t&lt;d(e)<span class="cstat-no" title="statement not covered" ></span>;){var <span class="cstat-no" title="statement not covered" >r=e.charAt</span></span>(t);i<span class="cstat-no" title="statement not covered" >f(!(L.indexO<span class="cstat-no" title="statement not covered" ></span>f(r)&lt;0))break;var i=i+r,t=t+1}re<span class="cstat-no" title="statement not covered" >turn n.pu<span class="cstat-no" title="statement not covered" >s</span></span>h(new c([a,i])),t<span class="cstat-no" title="statement not covered" >}return i&amp;&amp;this.keywordsSet&amp;&amp;o(th<span class="cstat-no" title="statement not covered" >is.keywords,<span class="cstat-no" title="statement not covered" ></span>i)&lt;0?(n.push(new c(["<span class="cstat-no" title="statement not covered" >",i])),</span></span>t):-1<span class="cstat-no" title="statement not covered" >},n.</span>pr<span class="cstat-no" title="statement not covered" >otot</span>yp</span>e.object=f<span class="cstat-no" title="statement not covered" >unc<span class="cstat-no" title="statement not covered" ></span>t</span>ion(e,t,n){var r=this.subjec<span class="cstat-no" title="statement not covered" >t(e,t,n);if(r&gt;=0)return r;var r=this.s<span class="cstat-no" title="statement not covered" >kipSpace(e,t<span class="cstat-no" title="statement not covered" ></span>);if(r&lt;0)return-1;var<span class="cstat-no" title="statement not covered" > t=r;if</span></span>('"'=<span class="cstat-no" title="statement not covered" >=e.c</span>ha<span class="cstat-no" title="statement not covered" >rAt(</span>t<span class="cstat-no" title="statement not covered" >)</span>){if('"""'==p(e,t,t+3))var i='<span class="cstat-no" title="statement not covered" ></span>"</span>""';else var i='"';var t=t+d(i),o=this.strconst(e,t,i),r=o[0],a=o[1];return n.</span>push(this._store.lit<span class="fstat-no" title="function not covered" >er</span>al(a)),T("New string<span class="cstat-no" title="statement not covered" > const ",a,r),r}retu<span class="cstat-no" title="statement not covered" ></span>rn-1},n.<span class="cstat-no" title="statement not covered" >prototype.</span></span>nodeO<span class="cstat-no" title="statement not covered" >rLiteral=function(e,<span class="cstat-no" title="statement not covered" ></span>t,n){va<span class="cstat-no" title="statement not covered" >r r=this.n</span></span>ode(e<span class="cstat-no" title="statement not covered" >,t<span class="cstat-no" title="statement not covered" ></span>,n);if(r&gt;=0)return r;<span class="cstat-no" title="statement not covered" >var r=this.skipSpace(e,t);i<span class="cstat-no" title="statement not covered" >f(r&lt;0)</span>return-1;va<span class="cstat-no" title="statement not covered" >r t=</span>r</span>,i=e.<span class="cstat-no" title="statement not covered" >charAt(</span>t)<span class="cstat-no" title="statement not covered" >;if("-+0987654321".in</span>de<span class="cstat-no" title="statement not covered" >xOf(i</span>)&gt;<span class="cstat-no" title="statement not covered" >=0){P<span class="cstat-no" title="statement not covered" ></span>.lastIndex=0;var o=P.exec(e.slice(t));if(null!=o){var a=o[0];r=t+a.l<span class="cstat-no" title="statement not covered" ></span>e</span>ngth,a.in</span>dexOf("T")&gt;=0?n.push(this._<span class="fstat-no" title="function not covered" >st</span>ore.literal(a,void 0<span class="cstat-no" title="statement not covered" >,this._store.sym(<span class="cstat-no" title="statement not covered" ></span>C))):n.p<span class="cstat-no" title="statement not covered" >ush(this._</span></span>store<span class="cstat-no" title="statement not covered" >.literal(a,void 0,th<span class="cstat-no" title="statement not covered" ></span>is._sto<span class="cstat-no" title="statement not covered" >re.sym(I))</span></span>)}els<span class="cstat-no" title="statement not covered" >e{</span>D.<span class="cstat-no" title="statement not covered" >lastIndex=0;<span class="cstat-no" title="statement not covered" ></span>var o=D.exec(e.slice(t));if(null=<span class="cstat-no" title="statement not covered" >=o)throw s(this</span>._thi<span class="cstat-no" title="statement not covered" >sDoc,this.lines,e,t<span class="cstat-no" title="statement not covered" ></span>,"Bad number or da<span class="cstat-no" title="statement not covered" >te sy<span class="cstat-no" title="statement not covered" ></span>ntax");r=t+D.lastIndex;var a=p(e,t,r);a.indexOf("e")&gt;=0?n.push(this._store.literal(parseFloat(a),void 0,this._store.sym(j))):p(e,t,r).indexOf(".")</span>&gt;=0?n<span class="cstat-no" title="statement not covered" >.push(this._sto</span>re.li<span class="cstat-no" title="statement not covered" >teral(parseFloat(a)<span class="cstat-no" title="statement not covered" ></span>,void 0,thi<span class="cstat-no" title="statement not covered" >s._store.sym(O))):n.push(this._store.literal(parseInt(a),void 0,th<span class="cstat-no" title="statement not covered" >i</span></span>s._store.sym(R))</span>)}ret<span class="cstat-no" title="statement not covered" >urn r}if(<span class="cstat-no" title="statement not covered" ></span>'"'==e.charAt(t)){if('"""'==p(e,t,t+3))var u='"""';else var u='"';var t=t+d(u),l=null,c=this.strconst(e,t,u),r=c[0],h=c[1],v=null;if("@"==p(e,r,r+1)){M.lastIndex=0;var o=M.exec(e.slice(r+1));if(null==o)throw s(this._thisDoc,startline,e,t,"Bad langua<span class="cstat-no" title="statement not covered" ></span>g</span>e code sy<span class="cstat-no" title="statement not covered" ></span>n</span>tax on string litera<span class="cstat-no" title="statement not covered" >l, after @");var t=M.lastIn<span class="cstat-no" title="statement not covered" >dex+r+</span>1,v=p(e,r+1<span class="cstat-no" title="statement not covered" >,t),</span>r</span>=t}if<span class="cstat-no" title="statement not covered" >("^^"==</span>p(<span class="cstat-no" title="statement not covered" >e,r,r</span>+2<span class="cstat-no" title="statement not covered" >))var g=new f([]),r=t</span>hi<span class="cstat-no" title="statement not covered" >s.uri</span>_r<span class="cstat-no" title="statement not covered" >ef2(e</span>,r<span class="cstat-no" title="statement not covered" >+2,g)<span class="cstat-no" title="statement not covered" ></span>,l=g[0];return n.pus<span class="cstat-no" title="statement not covered" >h(this._store.l</span>itera<span class="cstat-no" title="statement not covered" >l(h,v,l)),r}return-1}<span class="cstat-no" title="statement not covered" ></span>,n.prototyp<span class="cstat-no" title="statement not covered" >e.strconst=function(e,t,n){for(var r=t,i="",o=this.lines;r&lt;d(e);){var t=r+d(n);if(p(e,r,t)==</span></span>n)ret<span class="cstat-no" title="statement not covered" >urn new c([t,i])</span>;i<span class="cstat-no" title="statement not covered" >f('"'!=e.ch</span>ar<span class="cstat-no" title="statement not covered" >At</span>(<span class="cstat-no" title="statement not covered" >r</span>)){U.lastIndex=0;var a=U.<span class="cstat-no" title="statement not covered" >exec(e.sli</span>ce<span class="cstat-no" title="statement not covered" >(r));if(!a)throw s(this</span>._<span class="cstat-no" title="statement not covered" >thisD<span class="cstat-no" title="statement not covered" ></span>o</span>c,o,e,r,"Closing quote missing in string at <span class="cstat-no" title="statement not covered" ></span>^</span> in "+p(e</span>,r-20,r)+"^"+p(e,r,r+2<span class="fstat-no" title="function not covered" >0)</span>);var t=r+U.la<span class="cstat-no" title="statement not covered" >stIndex-1,i=i+p(e,r,t),u=e.charAt(t);if('"'!=<span class="cstat-no" title="statement not covered" >u)if("\<span class="cstat-no" title="statement not covered" ></span>r"!=u){if("\n"=<span class="cstat-no" title="statement not covered" >=u){if('"'==n)throw <span class="cstat-no" title="statement not covered" >s</span></span>(this._thisDoc,o,e,t<span class="cstat-no" title="statement not covered" >,"newline found</span> in s<span class="cstat-no" title="statement not covered" >tring literal");thi<span class="cstat-no" title="statement not covered" ></span>s.line<span class="cstat-no" title="statement not covered" >s=this.lines+1;var i=i+u,r=t+1;this.previousLine=this.startOfLine,this.startOfLine=r}else if("\\"==u)</span></span>{var <span class="cstat-no" title="statement not covered" >r=t+1,u=p(e,r,r+</span>1)<span class="cstat-no" title="statement not covered" >;if(!u)thro</span>w <span class="cstat-no" title="statement not covered" >s(this._this<span class="cstat-no" title="statement not covered" ></span>Doc,o,e,t,"<span class="cstat-no" title="statement not covered" >unterminated<span class="cstat-no" title="statement not covered" > string lite<span class="cstat-no" title="statement not covered" >ral (2)");<span class="cstat-no" title="statement not covered" >var l=y('abfrtvn\\"',u);if(l&gt;=0)var f='a\b\f\r\t\v\n\\"'.charAt<span class="cstat-no" title="statement not covered" >(</span></span>l),i=i+f,r=r+1;else if("</span>u"==u<span class="cstat-no" title="statement not covered" >)var</span> h<span class="cstat-no" title="statement not covered" >=thi<span class="cstat-no" title="statement not covered" ></span>s.uEscape(e,r+1,o),r=h[0],u=h[1],i=i+u;else{if("U"!=u)t</span>hrow <span class="cstat-no" title="statement not covered" >s(this._thisDoc,th<span class="cstat-no" title="statement not covered" >is.l</span>in<span class="cstat-no" title="statement not covered" >es,e,t,"bad<span class="cstat-no" title="statement not covered" ></span> escap<span class="cstat-no" title="statement not covered" >e");var h=this.UEscape(e,r+1,o),r=h[0],u=h[1],i=i+u}}}else var r</span></span>=t+1;<span class="cstat-no" title="statement not covered" >else var r=t}else <span class="cstat-no" title="statement not covered" ></span>var i=i+'"',r=<span class="cstat-no" title="statement not covered" >r+1}throw s(this._thisDoc,thi</span>s.<span class="cstat-no" title="statement not covered" >line</span>s,<span class="cstat-no" title="statement not covered" >e,t,</span>"unte<span class="cstat-no" title="statement not covered" >rminated string <span class="cstat-no" title="statement not covered" >literal")},n.prototype</span>.u<span class="cstat-no" title="statement not covered" >Escap</span>e=<span class="cstat-no" title="statement not covered" >funct</span>io<span class="cstat-no" title="statement not covered" >n(e,</span>t,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t,i=0,o=0;i&lt;4;){var a=p(e,r,r+1),u=a.toLowerCase(),r</span></span>=r+1;<span class="cstat-no" title="statement not covered" >if(""==u)throw s(this.</span>_t<span class="cstat-no" title="statement not covered" >hisDo</span>c,<span class="cstat-no" title="statement not covered" >n,e,t</span>,"<span class="cstat-no" title="statement not covered" >unte</span>rm</span></span>i</span></span>nated strin<span class="cstat-no" title="statement not covered" >g li</span>t</span>eral(3)");v<span class="cstat-no" title="statement not covered" >ar</span> </span>l=y("012345<span class="cstat-no" title="statement not covered" >6789ab</span>cd<span class="cstat-no" title="statement not covered" >ef",</span>u<span class="cstat-no" title="statement not covered" ></span>)</span>;if(l&lt;0)throw s(this._thisDoc,n,e,t,"bad string literal hex escape")</span>;var o=16*o+l,i=i+1}v<span class="fstat-no" title="function not covered" >ar</span> f=String.from<span class="cstat-no" title="statement not covered" >CharCode(o);return new c([r,f])}<span class="cstat-no" title="statement not covered" >,n.prototyp</span>e.<span class="cstat-no" title="statement not covered" >UEscape=function</span>(e<span class="cstat-no" title="statement not covered" >,t,n<span class="cstat-no" title="statement not covered" ></span>){for(var<span class="cstat-no" title="statement not covered" > r=t,i=0,o="\\U";i&lt;8;){var a=p(e,r,r+1),u=a.toLowerCase(),r=r+1</span></span>;if("<span class="cstat-no" title="statement not covered" >"==u)throw s(this._thisD<span class="cstat-no" title="statement not covered" ></span>oc,n,e,<span class="cstat-no" title="statement not covered" >t,"unterminated string literal(3)");var l=y("0123456789abcdef"</span></span>,u);i<span class="cstat-no" title="statement not covered" >f(l&lt;0)t</span>hr<span class="cstat-no" title="statement not covered" >ow s</span>(t</span>his._<span class="cstat-no" title="statement not covered" >thisDoc,n,e,t,"bad stri<span class="cstat-no" title="statement not covered" ></span>ng literal hex escape</span>");var o=o+u,i=i+1}va<span class="fstat-no" title="function not covered" >r </span>f=b("0x"+p(o,2<span class="cstat-no" title="statement not covered" >,10)-0);return new c([r,f])},a.proto<span class="cstat-no" title="statement not covered" >type.toStri</span>ng<span class="cstat-no" title="statement not covered" >=function(){var </span>e=<span class="cstat-no" title="statement not covered" >this<span class="cstat-no" title="statement not covered" ></span>._str,t=t<span class="cstat-no" title="statement not covered" >his._i,n=0;if(t&gt;60)var r="...",n=t-60;else var r="";if(d(e)-t&gt;6</span></span>0)var<span class="cstat-no" title="statement not covered" > i="...";else var i="";r<span class="cstat-no" title="statement not covered" ></span>eturn'L<span class="cstat-no" title="statement not covered" >ine %i of &lt;%s&gt;: Bad syntax (%s) at ^ in:\n"%s%s^%s%s"'%new c([</span></span>this.<span class="cstat-no" title="statement not covered" >line</span>s+<span class="cstat-no" title="statement not covered" >1,th</span>is</span>._uri<span class="cstat-no" title="statement not covered" >,this._why,r,p(e,n,t<span class="cstat-no" title="statement not covered" ></span>),p(e,t,t+60),i])},t}</span>();e.exports=a},functi<span class="fstat-no" title="function not covered" >on</span>(e,t,n){"use st<span class="cstat-no" title="statement not covered" >rict";func</span>ti<span class="cstat-no" title="statement not covered" >on r(e,t</span>,n<span class="cstat-no" title="statement not covered" >,r<span class="cstat-no" title="statement not covered" ></span>,p){function v<span class="cstat-no" title="statement not covered" >(){p&amp;&amp;</span>p(<span class="cstat-no" title="statement not covered" >null,</span>t)}function<span class="cstat-no" title="statement not covered" > g(<span class="cstat-no" title="statement not covered" ></span>e</span>){if("application/<span class="cstat-no" title="statement not covered" >ld+jso</span>n"!==r||"ap<span class="cstat-no" title="statement not covered" >pli<span class="cstat-no" title="statement not covered" ></span>c</span>ation/nquads"!==r||"application/n-quads"!==r){if(!p)throw new Error("Error trying to parse &lt;"+n+"&gt; as "+r+":\n"+e+":\n"+e.stack);p</span>(e,t</span>)}}<span class="cstat-no" title="statement not covered" ></span>function y(e,</span>n<span class="fstat-no" title="function not covered" >){</span>e&amp;&amp;p(e,t);try{k.parse(n,m)}catch(e){<span class="fstat-no" title="function not covered" >p(</span>e,t)}}function m(e,n<span class="fstat-no" title="function not covered" >,r</span>){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;p(e,t),n</span>)T.push(n<span class="fstat-no" title="function not covered" >);</span>els<span class="cstat-no" title="statement not covered" >e{for(var i=0;i&lt;T.length;i++)b(t,T[i]);p(null,t)}}function b(e,t){var n=w(t.subject<span class="cstat-no" title="statement not covered" >),r=w(<span class="cstat-no" title="statement not covered" >t.predicate),i=w(t.object),o=null;t.graph&amp;&amp;(o=w(t.graph)),e.add(n,r,i,o)}func<span class="cstat-no" title="statement not covered" >t</span></span>ion w(e</span>)</span>{var t;if<span class="fstat-no" title="function not covered" >(s</span>.Util<span class="cstat-no" title="statement not covered" >.isLiteral<span class="cstat-no" title="statement not covered" >(</span>e))<span class="cstat-no" title="statement not covered" >{t=s.Util.getL</span>iteralVal<span class="cstat-no" title="statement not covered" >ue(e);va</span>r</span> n=s.Util<span class="fstat-no" title="function not covered" >.g</span>etLiter<span class="cstat-no" title="statement not covered" >alLanguage(e),r<span class="cstat-no" title="statement not covered" >=new l(s.Ut</span>il.g<span class="cstat-no" title="statement not covered" >etLiteralType(e));return ne<span class="cstat-no" title="statement not covered" >w a(t,n,r)<span class="cstat-no" title="statement not covered" >}</span></span>return s.U</span>t</span>il.isIRI(<span class="fstat-no" title="function not covered" >e)</span>?new l(e):s<span class="cstat-no" title="statement not covered" >.Util.isBlank</span>(e<span class="cstat-no" title="statement not covered" >)?(t=e.substrin</span>g(<span class="cstat-no" title="statement not covered" >2,e.length),</span>ne<span class="cstat-no" title="statement not covered" >w i(t<span class="cstat-no" title="statement not covered" ></span>)):null}try{if("text/n3"===r||"text/turt</span>le"===r){<span class="fstat-no" title="function not covered" >va</span>r x=u(t,t<span class="cstat-no" title="statement not covered" >,n,n,null,null,"",null);<span class="cstat-no" title="statement not covered" >x.loadBuf(e),v()}else if("app</span>licat<span class="cstat-no" title="statement not covered" >ion/rdf+xml"===r){var _=new f</span>(t<span class="cstat-no" title="statement not covered" >);_.parse(d.parseXML(e),n,t.sym(<span class="cstat-no" title="statement not covered" ></span>n)),v()}else if("appl<span class="cstat-no" title="statement not covered" ></span>i</span>cation/xhtml+xml"===r)c(d.parseXML(e,{contentType:"application/xhtml+xml"}),t,n),v();else if<span class="cstat-no" title="statement not covered" ></span>("te<span class="cstat-no" title="statement not covered" >xt/html"===r)c(d.parseXML(e,{contentType:"t<span class="cstat-no" title="statement not covered" >ext/html"}),t,n),v();else if(<span class="cstat-no" title="statement not covered" ></span>"application/sparq</span>l-upd<span class="cstat-no" title="statement not covered" >ate"===r)h(e,t,n),v();else{if("appli<span class="cstat-no" title="statement not covered" >cation/ld<span class="cstat-no" title="statement not covered" ></span>+json"!==r&amp;&amp;"application/nquads"!==r&amp;&amp;"</span>appli<span class="cstat-no" title="statement not covered" >cation/n-quads"!==r)throw new E<span class="cstat-no" title="statement not covered" >rror("Don't know how to parse "+r+" yet");var k=s.Parser(),T=[];</span>if("<span class="cstat-no" title="statement not covered" >application/ld+json<span class="cstat-no" title="statement not covered" >"===r){var E;try{E=JSON.parse(e)}catch(e){p(e,null)}</span>o.to<span class="cstat-no" title="statement not covered" >RDF(E,{format:"application/nquads"}<span class="cstat-no" title="statement not covered" >,y)}else y(nul</span>l,e)<span class="cstat-no" title="statement not covered" >}}catch(e){g(e)}}e.exports=r;var i=n(12),o=n(27),a=n(13),s=n(33),u=n(78),l=n(8),c=<span class="cstat-no" title="statement not covered" >n(80).parseRDFaDOM,f=n(81),h=n(82),d=n(5)},function(e,</span></span>t,n){<span class="cstat-no" title="statement not covered" >"use strict</span>";<span class="cstat-no" title="statement not covered" >fun<span class="cstat-no" title="statement not covered" ></span>ction r(e,t){if(!(e instanceof t))th<span class="cstat-no" title="statement not covered" >row <span class="cstat-no" title="statement not covered" >new TypeError("Ca</span>nnot call<span class="cstat-no" title="statement not covered" > a class as<span class="cstat-no" title="statement not covered" ></span> </span>a function")}var i=function(){function e(e,</span>t){fo<span class="cstat-no" title="statement not covered" >r(var n=0;n</span></span>&lt;</span></span></span></span></span>t.length;<span class="cstat-no" title="statement not covered" >n++){v</span>a<span class="cstat-no" title="statement not covered" ></span>r r=t[n];r.en</span>umera<span class="cstat-no" title="statement not covered" >ble=r.</span>en<span class="cstat-no" title="statement not covered" >umerab</span>le<span class="cstat-no" title="statement not covered" >||!1,r</span>.c<span class="cstat-no" title="statement not covered" >onfigu</span>ra<span class="cstat-no" title="statement not covered" >ble=!0</span>,"<span class="cstat-no" title="statement not covered" >value</span>"i<span class="cstat-no" title="statement not covered" >n r&amp;&amp;(r.writable=!0</span>),<span class="cstat-no" title="statement not covered" >Object</span>.d<span class="cstat-no" title="statement not covered" >efineP</span>ro<span class="cstat-no" title="statement not covered" >perty</span>(e<span class="fstat-no" title="function not covered" >,r</span>.key,r)}}return function(t,n,r){retu<span class="fstat-no" title="function not covered" >rn</span> n&amp;&amp;e<span class="cstat-no" title="statement not covered" >(t.prototype,n),r&amp;&amp;e(<span class="cstat-no" title="statement not covered" >t,r),t}}(),o=n(12),a=n(13),s=n(75),u=n(8),l=n(7),c=n(5);if</span></span>("unde<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fi</span>ned"==typeof f)var<span class="fstat-no" title="function not covered" > f</span>={ELE<span class="cstat-no" title="statement not covered" >MENT_NODE:1,ATTRIBUTE_NODE:2,TEXT_<span class="cstat-no" title="statement not covered" >NODE:<span class="cstat-no" title="statement not covered" ></span>3,CDATA_SECTION_NODE:4,ENTITY_REFERENCE_NODE:5,ENTITY_NODE:6,PROCESSING_INSTRUCTION_NODE:7,COMMENT_NODE:8,DOCUM</span>E<span class="cstat-no" title="statement not covered" ></span>NT_NODE<span class="fstat-no" title="function not covered" >:9</span>,DOCUMENT_TYPE<span class="cstat-no" title="statement not covered" >_NODE:10,DOCUMENT_FRAGMENT_NODE:11,NOTAT</span>IO</span>N_N</span>OD<span class="cstat-no" title="statement not covered" >E:12};</span>va<span class="cstat-no" title="statement not covered" >r h=fu</span>nc<span class="cstat-no" title="statement not covered" >tion()</span>{f<span class="cstat-no" title="statement not covered" >uncti</span>on<span class="cstat-no" title="statement not covered" > e(t,</span>n)<span class="cstat-no" title="statement not covered" >{r(th<span class="cstat-no" title="statement not covered" ></span>is,e),this.options=n||{},this.k<span class="cstat-no" title="statement not covered" >b=t,this.target=n.target||{graph:{subjects:{},prefixes:{},terms:{}}},this.blankNodes=[],this.htmlOptions={selfClosing:"br img input area base basefont col colgroup source wbr isindex link meta param hr"},this.theOne="_:"+(new Date)</span>.</span>getTi<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >me</span>(),this.language=n<span class="fstat-no" title="function not covered" >ul</span>l,thi<span class="cstat-no" title="statement not covered" >s.vocabulary=null,this.blankCounter=0,this.langAttributes=[{namespaceURI:"http://www.w3.org/XML/1998/namespace",localName:"lang"}],this.inXHTMLMode=!1,this.absURIRE=/[\w\_\-]+:\S+/,this.finishedHandlers=[],this.init()}return i(e,[{key:"addTriple",value:function(e,t,n,r){var i,o,a,u;i="undefined"==typeof t?s.namedNode(this.options.base):this.toRDFNodeObject(t),a=this.toRDFNodeObject(n),o=this.toRDFNodeObject(r),u=s.namedNode(this.options.base),this.kb.add(i,a,o,u)}},{key:"ancestorPath",value:function(e){for(var t=<span class="cstat-no" title="statement not covered" ></span>"";e&amp;&amp;e.nodeType!==f.DOCUMENT_NODE;)t="/"+e.localName+t,e=e.parentNod<span class="fstat-no" title="function not covered" >e;retu</span>rn t}},{key:"copyMapp<span class="cstat-no" title="statement not covered" >ings",value:function(e){var t={};for(var n in e)t[n]=e[n];return t}},{key:"copyProperties",value:function(){}},{key:"deriveDateTimeType",value:function(t){for(var n=0;n&lt;e.dateTimeTypes.l</span>ength;n++){var r=e.dateTimeTypes[n].pattern.exec(t);if(r&amp;&amp;r[0]<span class="fstat-no" title="function not covered" >.lengt</span>h==<span class="cstat-no" title="statement not covered" >=t.length)return e.dateTimeTypes[n].type}retur<span class="cstat-no" title="statement not covered" >n null}},{key:"init",value:function<span class="cstat-no" title="statement not covered" >(</span></span>){}},{key</span>:"newBlankNode",value:function(){return this.blankCounter++,"_<span class="fstat-no" title="function not covered" >:"+thi</span>s.blankCo<span class="cstat-no" title="statement not covered" >unt<span class="cstat-no" title="statement not covered" ></span>er}},{key:"newS<span class="cstat-no" title="statement not covered" >ubjectOrig<span class="cstat-no" title="statement not covered" >i</span></span>n",value:</span>function(e,t){}},{key:"parseCURIE",value:function(t,n,r){var i,o<span class="fstat-no" title="function not covered" >=t.ind</span>exOf(":");if(o&gt;=0){var a=t.substring(0,o);if(""===a)return i=n[""],i?i+<span class="fstat-no" title="function not covered" >t.subs</span>tri<span class="cstat-no" title="statement not covered" >ng(o+1):null;if("_"===a)return"_:"+t.substring(o<span class="cstat-no" title="statement not covered" >+1);if(e.NCNAME.test(a)&amp;&amp;(i=n[a]))r<span class="cstat-no" title="statement not covered" ></span>eturn i+t.substring(o+1)}retu<span class="cstat-no" title="statement not covered" >rn null}},{key:"parseCURIEOrURI"<span class="cstat-no" title="statement not covered" ></span></span>,</span>value:functi</span>on(e,t,n){var r=this.parseCURIE(e,t,n);return r?r:this<span class="fstat-no" title="function not covered" >.resol</span>veAndNormalize(n,e)}},{key:"parsePredicate",value:function(e,t,n,<span class="fstat-no" title="function not covered" >r,i,o)</span>{i<span class="cstat-no" title="statement not covered" >f(""===e)return null;var a=this.parseTermOrCURIEOrA</span>bsURI(e,t,o?null:n,r,i);return a&amp;&amp;0===a.indexOf("_:")?null:a}},{ke<span class="fstat-no" title="function not covered" >y:"par</span>sePrefixMappings",value:function(e,t){for(var n=this.tokenize(e),r<span class="fstat-no" title="function not covered" >=null,</span>i=0;i&lt;n.length;<span class="cstat-no" title="statement not covered" >i++)":"===n[i][<span class="cstat-no" title="statement not covered" ></span>n[i].length-1]?<span class="cstat-no" title="statement not covered" >r=n[i].substring(<span class="cstat-no" title="statement not covered" ></span>0,n[i].len<span class="cstat-no" title="statement not covered" >gth-1):r&amp;&amp;(t[r]=this.options.base?l.join(<span class="cstat-no" title="statement not covered" >n</span></span>[i],this.o<span class="cstat-no" title="statement not covered" >ptions.base):n[i],r=null)}},<span class="cstat-no" title="statement not covered" >{</span></span>key:"parseSafeCURIEOrCURIEOrU<span class="cstat-no" title="statement not covered" >RI",value:function(e,t,n){r<span class="cstat-no" title="statement not covered" ></span></span>e</span>turn e=this.</span>trim(e),"["===e.charAt(0)&amp;&amp;"]"===e.charAt(e.length-1)?(e=e.substr<span class="fstat-no" title="function not covered" >ing(1,</span>e.length-1),e<span class="cstat-no" title="statement not covered" >=e.trim(e),0===e.length<span class="cstat-no" title="statement not covered" ></span>?null:"_:"===e?this.theOne:this.parseCURIE</span>(e,t,n)):this.parseCURIEOrURI(e,t,n)}},{key:"parseTermOrCURIEOrA<span class="fstat-no" title="function not covered" >bsURI"</span>,value:functi<span class="cstat-no" title="statement not covered" >on(e,t,n,r<span class="cstat-no" title="statement not covered" >,i){e=this.tr</span></span>im(e)<span class="cstat-no" title="statement not covered" >;var o=this.parseCURIE(e,r,i);if(o)return o;if(n<span class="cstat-no" title="statement not covered" ></span>){if(t&amp;&amp;!this.absURIRE.exec(e))return </span>t+e;var a=n[e];if(a)return a;var s=e.toLowerCase();if(a=n[s])return a<span class="fstat-no" title="function not covered" >}retur</span>n thi<span class="cstat-no" title="statement not covered" >s.absURIRE.exec(e)?this.resolveAndNormalize(i,e):null<span class="cstat-no" title="statement not covered" >}},{key:"parseTermOrCURIEOrURI",value:function(e,t,n,r,i){e=this.trim(e);var o=this.parseCURIE(e,r,i);if(o)return o;var a=n[e];if(a)</span></span>return a;var s=e.toLowerCase();return(a=n[s])?a:t&amp;&amp;!this.absURIRE.exec(e)?t+<span class="fstat-no" title="function not covered" >e:this</span>.resolv<span class="cstat-no" title="statement not covered" >eAndNormalize(i,e)}},{key:"parseURI",value:function(e){return e}},{key:"process",value:function(t,n){var r;t.nodeType===f.DOCUMENT_NODE?(r=t.baseURI,t=t.documentElement,t.baseURI=r,this.setContext(t)):</span>t.parentNode.nodeType===f.DOCUMENT_NODE&amp;&amp;this.setContext(t);var i=[],o=fun<span class="fstat-no" title="function not covered" >ction(</span>e){if(!e&amp;&amp;n<span class="cstat-no" title="statement not covered" >&amp;&amp;n.baseURI)retu</span>rn n.<span class="cstat-no" title="statement not covered" >baseURI;var t=e.indexOf<span class="cstat-no" title="statement not covered" ></span>("#")<span class="cstat-no" title="statement not covered" >;return t<span class="cstat-no" title="statement not covered" >&gt;</span></span>=0&amp;&amp;(<span class="cstat-no" title="statement not covered" >e=e.substring(0,t)),n&amp;&amp;n.base<span class="cstat-no" title="statement not covered" >URIMap&amp;&amp;(e=n</span></span>.base<span class="cstat-no" title="statement not covered" >URIMa<span class="cstat-no" title="statement not covered" ></span>p(e))<span class="cstat-no" title="statement not covered" >,e};for(i.</span></span>push(<span class="cstat-no" title="statement not covered" >{current:t,conte<span class="cstat-no" title="statement not covered" ></span>xt:this.pu<span class="cstat-no" title="statement not covered" >sh(null,o(<span class="cstat-no" title="statement not covered" ></span></span>t</span>.baseURI))});i.length&gt;0;){var a=i.shift();if(a.parent){if(a.cont</span>ext.parent&amp;&amp;a.context.parent.listMapping===a.listMapping)continue;for(v<span class="fstat-no" title="function not covered" >ar s i</span>n a.listMap<span class="cstat-no" title="statement not covered" >ping){var u=a.li</span>stMap<span class="cstat-no" title="statement not covered" >ping[s];if(0!==u.length<span class="cstat-no" title="statement not covered" ></span>){for<span class="cstat-no" title="statement not covered" >(var c=[],</span></span>h=0;h<span class="cstat-no" title="statement not covered" >&lt;u.le<span class="cstat-no" title="statement not covered" ></span>ngth;<span class="cstat-no" title="statement not covered" >h++)c.push</span></span>(this<span class="cstat-no" title="statement not covered" >.newBlankNode())<span class="cstat-no" title="statement not covered" ></span>;for(var d=0;d&lt;c.length;d++)this.addTriple(a.parent,c[d],"http://www.w3.org/19</span>99/02/22-rdf-syntax-ns#first",u[d]),this.addTriple(a.paren<span class="fstat-no" title="function not covered" >t,c[d]</span>,"h<span class="cstat-no" title="statement not covered" >ttp://www.</span>w3.org/1999/02/22-rdf-syntax-ns#rest",{type:e.objectURI,v<span class="fstat-no" title="function not covered" >alue:d</span>+1&lt;c.length<span class="cstat-no" title="statement not covered" >?c[d+1]:"http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"});this.addTriple(a.parent,a.subject,s,{type:e.objectURI,value:c[0]})}else this.addTriple(a.parent,</span>a.sub<span class="cstat-no" title="statement not covered" >jec</span>t,<span class="cstat-no" title="statement not covered" >s,{type:e<span class="fstat-no" title="function not covered" >.o</span>bje<span class="cstat-no" title="statement not covered" >ctURI,value:"http://<span class="cstat-no" title="statement not covered" >www.w3.org/1999/02</span></span>/22-r<span class="cstat-no" title="statement not covered" >df-syntax-ns#ni<span class="cstat-no" title="statement not covered" ></span>l"})}}else{var p=a.current,v=a.context,g=!1,y=null,m=null,b=null,w=v.prefi</span>x<span class="cstat-no" title="statement not covered" ></span>es,x=!1,_=[],k=v.listMapping,T=!v.parent,E=v.language,S=v.vocabulary;r=this.pars<span class="cstat-no" title="statement not covered" >eURI(o(p.b<span class="cstat-no" title="statement not covered" ></span>aseURI)),p.it<span class="cstat-no" title="statement not covered" >em=null;var N=p.getAttributeNode("vocab");if(N){var R=this.trim(N.<span class="cstat-no" title="statement not covered" >value);if<span class="cstat-no" title="statement not covered" >(</span></span>R.length&gt;0){S=R;var j=r.spec;this<span class="cstat-no" title="statement not covered" >.addTriple(p,j,"h<span class="cstat-no" title="statement not covered" ></span>ttp://www.w3.org/<span class="cstat-no" title="statement not covered" >ns/rdfa#usesVocabulary",{type:e.<span class="cstat-no" title="statement not covered" >objectURI,value:S})}else S=t<span class="cstat-no" title="statement not covered" >h</span></span>is.vocabulary}for(var O=0;<span class="cstat-no" title="statement not covered" >O&lt;p.attributes.length;O++){var I=p.attributes[O];if("x"===I.nodeName.charAt(0)&amp;&amp;0===I.nodeName.indexOf("xmlns:")){x||(w=this.copyMappings(w),x=!0);var C=I.nodeName.substring(6),A=e.trim(I.value);w[C]=this.options.base?l.join(A,this.options.base):A}}var L=p.get<span class="cstat-no" title="statement not covered" >A</span></span>ttributeNode("prefix");L&amp;&amp;(x||(w=this.copyMappings(w),x=!0),this.pa</span>rsePr<span class="cstat-no" title="statement not covered" >efixMappings(L.value,w));for(var D=null,P=0;!D&amp;&amp;P&lt;this.langAttributes.length;P++)D=p.getAttributeNodeNS(this.lan</span></span>g</span>Attributes[<span class="cstat-no" title="statement not covered" >P].namespa</span>ce<span class="cstat-no" title="statement not covered" >URI,this.l</span>an<span class="cstat-no" title="statement not covered" >gAt</span>tr<span class="cstat-no" title="statement not covered" >ibute</span>s[<span class="cstat-no" title="statement not covered" >P].lo</span>ca<span class="cstat-no" title="statement not covered" >lName</span>);<span class="cstat-no" title="statement not covered" >if(D){var U</span>=e<span class="cstat-no" title="statement not covered" >.tr</span>im<span class="cstat-no" title="statement not covered" >(D.</span>va<span class="cstat-no" title="statement not covered" >lue);E=U.lengt</span>h&gt;<span class="cstat-no" title="statement not covered" >0?U:null}v</span>ar<span class="cstat-no" title="statement not covered" > M,q,F=p.ge</span>tA<span class="cstat-no" title="statement not covered" >ttributeNode(<span class="cstat-no" title="statement not covered" ></span>"rel"),B=p.getAttributeNode("rev"),H=p.getA</span>ttrib<span class="cstat-no" title="statement not covered" >uteNode("typeof"),z=p.getAtt<span class="cstat-no" title="statement not covered" ></span>ributeNode("<span class="cstat-no" title="statement not covered" >property"),V=p.getA<span class="cstat-no" title="statement not covered" ></span>ttributeNode("d<span class="cstat-no" title="statement not covered" >ataty</span>pe"),<span class="cstat-no" title="statement not covered" >W=this.<span class="cstat-no" title="statement not covered" ></span>inHTMLMode?p.getAttributeNode("datetime"):null,X=p.getAttributeNode("content"),J=p.getAttri</span>buteN<span class="cstat-no" title="statement not covered" >ode("about"),G=p.ge<span class="cstat-no" title="statement not covered" ></span></span>t</span>AttributeNode("src"),$=p.getAttributeNode("r<span class="cstat-no" title="statement not covered" >esource"),Y=p.ge<span class="cstat-no" title="statement not covered" ></span>tAttributeNode("href"),Q=p.getAttributeNode("inlist"),K=[];<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(F){<span class="cstat-no" title="statement not covered" >q=this.tokenize(F.value);<span class="cstat-no" title="statement not covered" >f</span>or(var Z=0;Z&lt;q.length;Z++)<span class="cstat-no" title="statement not covered" >M=this.parsePredicate(q[Z],S,v.terms,w,r,this.inHTMLMode&amp;&amp;null!==z),M&amp;&amp;K.push(M)}v</span></span>a</span>r ee=[<span class="cstat-no" title="statement not covered" >];i<span class="cstat-no" title="statement not covered" ></span>f(B){q<span class="cstat-no" title="statement not covered" >=this.tokenize(B.value);f<span class="cstat-no" title="statement not covered" >o</span>r(var te=0;te&lt;q.length;te++)M<span class="cstat-no" title="statement not covered" >=this.parsePredicate(q[te],S,v.terms,w,r,this.inHTMLMode&amp;&amp;z),M&amp;&amp;ee.push(M)}if<span class="cstat-no" title="statement not covered" ></span></span>(</span>this.inHTMLMode&amp;&amp;(F||B)&amp;&amp;z&amp;&amp;(0===K.length&amp;&amp;(F=null),0===ee.length&amp;&amp;(B=null)),F||B?(J&amp;&amp;(y=this.parseSafeCURIEOrCURIEOrURI(J.value,w,r)),H&amp;&amp;(b=y),y||(p.parentNode.nodeType===f.DOCUMENT_NODE?y=o(p.baseURI):v.parentObject&amp;&amp;(y=o(p.parentNode.baseURI)===v.parentObject?o(p.baseURI):v.parentObject)),$&amp;&amp;(m=this.parseSafeCURIEOrCURIEOrURI($.value,w,r)),m||(Y?m=this.resolveAndNormalize(r,encodeURI(Y.value)):G?m=this.resolveAndNormalize(r,encodeURI(G.value)):!H||J||this.inXHTMLMode&amp;&amp;("head"===p.localName||"body"===p.localName)||(m=this.newBlankNode())),!H||J||!this.inXHTMLMode||"head"!==p.localName&amp;&amp;"body"!==p.localName?H&amp;&amp;!J&amp;&amp;(b=m):b=y):!z||X||V?(J&amp;&amp;(y=this.parseSafeCURIEOrCURIEOrURI(J.value,w,r)),!y&amp;&amp;$&amp;&amp;(y=this.parseSafeCURIEOrCURIEOrURI($.value,w,r)),!y&amp;&amp;Y&amp;&amp;(y=this.resolveAndNormalize(r,encodeURI(Y.value))),!y&amp;&amp;G&amp;&amp;(y=this.resolveAndNormalize(r,encodeURI(G.value))),y||(p.parentNode.nodeType===f.DOCUMENT_NODE?y=o(p.baseURI):!this.inXHTMLMode&amp;&amp;!this.inHTMLMode||"head"!==p.localName&amp;&amp;"body"!==p.localName?H?y=this.newBlankNode():v.parentObject&amp;&amp;(y=o(p.parentNode.baseURI)===v.parentObject?o(p.baseURI):v.parentObject,z||(g=!0)):y=o(p.parentNode.baseURI)===v.parentObject?o(p.baseURI):v.parentObject),H&amp;&amp;(b=y)):(J&amp;&amp;(y=this.parseSafeCURIEOrCURIEOrURI(J.value,w,r),H&amp;&amp;(b=y)),y||p.parentNode.nodeType!==f.DOCUMENT_NODE?!y&amp;&amp;v.parentObject&amp;&amp;(y=o(p.parentNode.baseURI)===v.parentObject?o(p.baseURI):v.parentObject):(y=o(p.baseURI),H&amp;&amp;(b=y)),H&amp;&amp;!b&amp;&amp;($&amp;&amp;(b=this.parseSafeCURIEOrCURIEOrURI($.value,w,r)),!b&amp;&amp;Y&amp;&amp;(b=this.resolveAndNormalize(r,encodeURI(Y.value))),!b&amp;&amp;G&amp;&amp;(b=this.resolveAndNormalize(r,encodeURI(G.value))),b||!this.inXHTMLMode&amp;&amp;!this.inHTMLMode||"head"!==p.localName&amp;&amp;"body"!==p.localName||(b=y),b||(b=this.newBlankNode()),m=b)),y&amp;&amp;(J||$||b)){var ne=y;<span class="cstat-no" title="statement not covered" >H&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;!J&amp;&amp;!$&amp;&amp;m&amp;&amp;(ne=m),this.newSubjectOrigin(p,ne)}if(<span class="cstat-no" title="statement not covered" ></span>b</span>){q=t<span class="cstat-no" title="statement not covered" >his.tokenize(H.value);for<span class="cstat-no" title="statement not covered" >(</span>var re=0;re&lt;q.length;re++){var ie=thi<span class="cstat-no" title="statement not covered" >s.parseTermOrCURIEOrAbsURI(q[re],S,v.terms,w,r);ie&amp;<span class="cstat-no" title="statement not covered" ></span>&amp;this.addTriple(p,b,e.typeURI,{type:e.objectURI,value:ie})}}if(</span>y<span class="cstat-no" title="statement not covered" ></span>&amp;</span>&amp;y!==v.parentObject&amp;&amp;(k={},T=!0),m){if(F<span class="cstat-no" title="statement not covered" >&amp;&amp;Q)for(<span class="cstat-no" title="statement not covered" >var oe=0;oe&lt;K.length;oe++){var ae=k[K[<span class="cstat-no" title="statement not covered" >oe]];ae||<span class="cstat-no" title="statement not covered" ></span>(ae=[],k[K[oe]]=ae),ae.push({type:e.objectURI,value:m})}else </span>i</span>f(F)<span class="cstat-no" title="statement not covered" >for(v<span class="cstat-no" title="statement not covered" >ar se=0;se&lt;K.length;se++)this.<span class="cstat-no" title="statement not covered" >addTriple(p,y,K[se],{type:e.objectURI,value:m});if(B)<span class="cstat-no" title="statement not covered" >f</span></span></span></span>or(v<span class="cstat-no" title="statement not covered" >ar ue=0;ue&lt;ee.length;ue++)this.<span class="cstat-no" title="statement not covered" >addTriple(p,m,ee[ue],{type:e.objectURI,value:y})}else{i</span></span></span>f(y&amp;&amp;<span class="cstat-no" title="statement not covered" >!m&amp;&amp;(F||B)&amp;&amp;(m=this.newBlankNode()),F&amp;&amp;Q)for(va<span class="cstat-no" title="statement not covered" >r le=0;le&lt;K.length;le++){var ce=k[K[le<span class="cstat-no" title="statement not covered" >]];ce||(c<span class="cstat-no" title="statement not covered" ></span>e=[],k[M]=ce),_.push({predicate:K[le],list:ce})}else if</span>(</span>F)fo<span class="cstat-no" title="statement not covered" >r(var<span class="cstat-no" title="statement not covered" > fe=0;fe&lt;K.length;fe++)_.push(<span class="cstat-no" title="statement not covered" >{predicate:K[fe],forward:!0});if(B)fo<span class="cstat-no" title="statement not covered" >r</span></span></span></span>(var<span class="cstat-no" title="statement not covered" > he=0;he&lt;ee.length;he++)_.push(<span class="cstat-no" title="statement not covered" >{predicate:ee[he],forward:!1})}if(z){va<span class="cstat-no" title="statement not covered" ></span></span></span>r</span> de=null,pe=<span class="cstat-no" title="statement not covered" >null;</span>V?(<span class="cstat-no" title="statement not covered" >de=""<span class="cstat-no" title="statement not covered" ></span>===V.value?e.PlainLiteralURI:this.parseTermOrCURIEOrAbsURI(V.value,S,v.terms,w,r),pe=W&amp;&amp;!X?W.value:de===e.XMLLiteralURI||de===e.HTMLLiteralURI?null:X?X.value:p.textContent):X?(de=e.PlainLiteralURI,pe=X.value):W?(pe=W.value,de=e.deriveDateTimeType(pe),de||(de=e.PlainLiteralURI)):F||B||($&amp;&amp;(pe=this.parseSafeCURIEOrCURIEOrURI($.value,w,r)),!pe&amp;&amp;Y?pe=this.resolveAndNormalize(r,encodeURI(Y.value)):!pe&amp;&amp;G&amp;&amp;(pe=this.resolveAndNormalize(r,encodeURI(G.value))),pe&amp;&amp;(de=e.objectURI)),de||(H&amp;&amp;!J?(de=e.objectURI,pe=b):(pe=p.textContent,this.inHTMLMode&amp;&amp;"time"===p.localName&amp;&amp;(de=e.deriveDateTimeType(pe)),de||(de=e.PlainLiteralURI))),q=this.tokenize(z.value);for(var <span class="cstat-no" title="statement not covered" >v</span>e=0;ve&lt;q.length;ve++){var ge=this.par<span class="cstat-no" title="statement not covered" >sePredicate(q[ve],S,v.terms,w,r);if(ge)if<span class="cstat-no" title="statement not covered" ></span>(Q){va<span class="cstat-no" title="statement not covered" >r ye=k[ge];ye<span class="cstat-no" title="statement not covered" >||(ye=<span class="cstat-no" title="statement not covered" ></span>[],k[ge]=ye),ye.push(de===e.XMLLiteralURI||de===e.HTMLLiteralURI?{type:de,value:p.childNodes}:{type:de?de:e.PlainLiteralURI,value:pe,language:E})}else de==</span>=e.XM<span class="cstat-no" title="statement not covered" >LLiteralURI||de===e.HTMLLiteralURI?this.addTriple(p,y,ge,{type:de,value:p.childNodes}):this.addTriple(p,y,ge,{type:de?de:e.PlainLiteralURI,value:pe,language:E})}}if(y&amp;&amp;!g)</span></span></span>f<span class="cstat-no" title="statement not covered" ></span>o</span>r(var me<span class="cstat-no" title="statement not covered" >=0;me&lt;v.incomplete.length;me++)v.incomple<span class="cstat-no" title="statement not covered" >te[me].list?v.incomplete[me].list.push({type:e.objectURI,value:y}):v.incomplete[me].forward?this.addTriple(p,v.subject,v.incomplete[me].predicate,{type:e.objectURI,value:y}):this.addTriple(p,y,v.incomplete[me].predicate,{type:e.objectURI,value:v.subject});var be=null</span></span></span>,we=y;<span class="cstat-no" title="statement not covered" >g?(be</span>=th<span class="cstat-no" title="statement not covered" >is<span class="cstat-no" title="statement not covered" ></span>.push(v,v.subject),be.parentObject=o(p.parentNode.baseURI)===v.parentObject?o(p.baseURI):v.parentObject,be.incomplete=v.incomplete,be.language=E,be.prefixes=w,be.vocabulary=S):(be=this.push(v,y),be.parentObject=m?m:y?y:v.subject,be.prefixes=w,be.incomplete=_,m&amp;&amp;(we=m,k={},T=!0),be.listMapping=k,be.language=E,be.vocabulary=S),T&amp;&amp;i.unshift({parent:p,context:v,subject:we,listMapping:k});for(var xe<span class="cstat-no" title="statement not covered" >=</span>p.lastChild;xe;xe=xe.previousSibling)xe.nodeTyp<span class="cstat-no" title="statement not covered" >e===f.ELEMENT_NODE&amp;&amp;(xe.baseURI=p.baseURI,i.unshift({current:xe,context:be}))}}this.inHTM</span></span>L<span class="cstat-no" title="statement not covered" >Mode&amp;&amp;this.copyProperties();for(var _e=<span class="cstat-no" title="statement not covered" >0</span>;_e&lt;this.finishedHandlers.length;_e++)this.finish<span class="cstat-no" title="statement not covered" >edHandlers[_e](t)}},{key:"push</span></span>",value:function(e,t){return{parent:e,subject:t?t:e?e.<span class="fstat-no" title="function not covered" >subjec</span>t:nul<span class="cstat-no" title="statement not covered" >l,parentObject:null,incomplete:[],listMapping:e?e.listMapping:{},language:e?e.language:this.language,prefixes:e?e.prefixes:this.target.graph.prefixes,terms:e?e.terms:this.target.graph.terms,vocabulary:e?e.vocabulary:this.vocabulary}}},{key:"resolveAndNormalize",value:function(</span>e,t){return l.join(t,e)}},{key:"setContext",value:function(e){"html"=<span class="fstat-no" title="function not covered" >==e.lo</span>calNa<span class="cstat-no" title="statement not covered" >me&amp;&amp;"XHTML+RDFa 1.1"</span>===e.getAttribute("version")?this.setXHTMLContext():"html"==<span class="fstat-no" title="function not covered" >=e.loc</span>alN<span class="cstat-no" title="statement not covered" >ame||"http://www.w3.org/1999/xhtml"===e.namespaceURI?"undefined"!=typeof document&amp;&amp;document.doctype?"-//W3C//DTD XHTML+RDFa 1.0//EN"===document.doctype.publicId&amp;&amp;"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd"===document.doctype.systemId?(console.log("WARNING: RDF 1.0 is not supported.  Defaulting to HTML5 mode."),this.setHTMLContext()):"-//W3C//DTD XHTML+RDFa 1.1//EN"===document.doctype.publicId&amp;&amp;"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd"===document.doctype.systemId?this.setXHTMLContext():this.setHTMLContext():this.setHTMLContext():this.setXMLContext()}},{key:"setHTMLContext",value:function(){this.setInitialContext(),this.langAttributes=[{namespaceURI:"http:/</span>/www.w3.org/XML/1998/namespace",localName:"lang"},{namespaceURI:<span class="fstat-no" title="function not covered" >null,l</span>oc<span class="cstat-no" title="statement not covered" >alName:"lang"}],this.inXHTMLMode=!1,this.inHTMLMode=!0}},{key:"setInitialContext",value:function(){this.vocabulary=null,this.langAttributes=[{namespaceURI:"http://www.w3.org/XML/1998/namespace",l</span>ocalName:"lang"}]}},{key:"setXHTMLContext",value:function(){this.se<span class="fstat-no" title="function not covered" >tIniti</span>al<span class="cstat-no" title="statement not covered" >Context(),this.inXHTMLMode=!0,this.inHTMLMode=!1,this.langAttributes=[{namespaceURI:"http://www.w3.org/XML/1998/nam</span>espace",localName:"lang"},{namespaceURI:null,localName:"lang"}],t<span class="fstat-no" title="function not covered" >his.ta</span>rg<span class="cstat-no" title="statement not covered" >et.graph.terms.alternate="http://www.w3.org/1999/xhtml/vocab#alternate",this.target.graph.terms.appendix="http://www.w3.org/1999/xhtml/vocab#appendix",this.target.graph.terms.bookmark="http://www.w3.org/1999/xhtml/vocab#bookmark",this.target.graph.terms.cite="http://www.w3.org/1999/xhtml/vocab#cite",this.target.graph.terms.chapter="http://www.w3.org/1999/xhtml/vocab#chapter",this.target.graph.terms.contents="http://www.w3.org/1999/xhtml/vocab#contents",this.target.graph.terms.copyright="http://www.w3.org/1999/xhtml/vocab#copyright",this.target.graph.terms.first="http://www.w3.org/1999/xhtml/vocab#first",this.target.graph.terms.glossary="http://www.w3.org/1999/xhtml/vocab#glossary",this.target.graph.terms.help="http://www.w3.org/1999/xhtml/vocab#help",this.target.graph.terms.icon="http://www.w3.org/1999/xhtml/vocab#icon",this.target.graph.terms.index="http://www.w3.org/1999/xhtml/vocab#index",this.target.graph.terms.last="http://www.w3.org/1999/xhtml/vocab#last",this.target.graph.terms.license="http://www.w3.org/1999/xhtml/vocab#license",this.target.graph.terms.meta="http://www.w3.org/1999/xhtml/vocab#meta",this.target.graph.terms.next="http://www.w3.org/1999/xhtml/vocab#next",this.target.graph.terms.prev="http://www.w3.org/1999/xhtml/vocab#prev",this.target.graph.terms.previous="http://www.w3.org/1999/xhtml/vocab#previous",this.target.graph.terms.section="http://www.w3.org/1999/xhtml/vocab#section",this.target.graph.terms.stylesheet="http://www.w3.org/1999/xhtml/vocab#stylesheet",this.target.graph.terms.subsection="http://www.w3.org/1999/xhtml/vocab#subsection",this.target.graph.terms.start="http://www.w3.org/1999/xhtml/vocab#start",this.target.graph.terms.top="http://www.w3.org/1999/xhtml/vocab#top",this.target.graph.terms.up="http://www.w3.org/1999/xhtml/vocab#up",this.target.graph.terms.p3pv1="http://www.w3.org/1999/xhtml/vocab#p3pv1",this.target.graph.terms.related="http://www.w3.org/1999/xhtml/vocab#related",this.target.graph.terms.role="http://www.w3.org/1999/xhtml/vocab#role",this.target.graph.terms.transformation="http://www.w3.org/1999/xhtml/vocab#transformation"}},{key:"setXMLContext",value:function(){this.setInitialContext(),this.inXHTMLMode=!1,this.inHTMLMode=!1}},{key:"tokenize",value:function(e){return this.trim(e).split(/\s+/)}},{key:"toRDFNodeObject",value:</span>function(t){if("undefined"!=typeof t){if("string"==typeof t)ret<span class="fstat-no" title="function not covered" >urn"_:</span>"=<span class="cstat-no" title="statement not covered" >==t.substring(0,2)?("undefined"==typeof this.blankNodes[t.substri</span>ng(2)]&amp;&amp;(this.blankNodes[t.substring(2)]=new o(t.substring<span class="fstat-no" title="function not covered" >(2))),</span>thi<span class="cstat-no" title="statement not covered" >s.blankNodes[t.substring(2)]):s.na</span>medNode(t);switch(t.type){case e.objectURI:return"_:"===t.value.s<span class="fstat-no" title="function not covered" >ubstri</span>ng(<span class="cstat-no" title="statement not covered" >0,2)?("undefined"==typeof <span class="cstat-no" title="statement not covered" >this.blankNodes[t.valu<span class="cstat-no" title="statement not covered" >e.substring(2)]&amp;&amp;(this.blankNodes[t.value.substring(2)]=new o(t.value.substring(2))),this.blankNodes[t.value.substring(2)]):s.namedNode(t.value);case e.PlainLiteralURI:return new a(t.value<span class="cstat-no" title="statement not covered" >,</span></span>t.language||"");case e.XMLLiter<span class="cstat-no" title="statement not covered" >alURI:case e.HTMLLiteralURI:var n="";return Object.keys(t.value).forEach(function(e){n+=c.domToString(t.value[e],this.htmlOptions)}),new a(n,"",new u(t.type));default:return new a(t.value,"",new u(t.type))}}}},{key:"trim",val</span>ue:function(e){return <span class="cstat-no" title="statement not covered" >e.replace(/^\s\s*/,"").replace(/\s\s*$</span>/,"")}}],[{key:"parseRDFaDOM",value:function(t,n<span class="cstat-no" title="statement not covered" >,r)<span class="cstat-no" title="statement not covered" ></span>{var i=new e(n,{base:r});t.baseURI=r<span class="fstat-no" title="function not covered" >,i</span>.process(t<span class="cstat-no" title="statement not covered" >)}}]),e}();h.XMLLiteralURI="http://www.w3.org/1</span>999/02/22-rdf-syntax-ns#XMLLi</span>teral",<span class="cstat-no" title="statement not covered" >h.HTMLLiteralURI="http://www.w3.org/1999</span>/</span>0</span>2/22-rdf-syntax-ns#HTML",h.PlainLiteralURI="http://www<span class="fstat-no" title="function not covered" >.w3.or</span>g/1<span class="cstat-no" title="statement not covered" >999/02/22-rdf-syntax-ns#PlainLiteral",h.objectURI="h</span>ttp://www.w3.org/1999/02/22-rdf-syntax-ns#object",h.typeURI="htt<span class="fstat-no" title="function not covered" >p://ww</span>w.w3.org/1999<span class="cstat-no" title="statement not covered" >/02/22-rdf-syntax-<span class="cstat-no" title="statement not covered" ></span>ns#type",h.nameChar="[-A-Z</span>_a-zÀ-ÖØ-ö<span class="cstat-no" title="statement not covered" >ø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�က0-F.0-9·̀-ͯ‿-⁀]",h.nameStartChar="[A-Za-zÀ-ÖØ-öø-ÿĀ-ıĴ-ľŁ-ňŊ-žƀ-ǃǍ-ǰǴ-ǵǺ-ȗɐ-ʨʻ-ˁΆΈ-ΊΌΎ-ΡΣ-ώϐ-ϖϚϜϞϠϢ-ϳЁ-ЌЎ-яё-ќў-ҁҐ-ӄӇ-ӈӋ-ӌӐ-ӫӮ-ӵӸ-ӹԱ-Ֆՙա-ֆא-תװ-ײء-غف-يٱ-ڷں-ھۀ-ێې-ۓەۥ-ۦअ-हऽक़-ॡঅ-ঌএ-ঐও-নপ-রলশ-হড়-ঢ়য়-ৡৰ-ৱਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઋઍએ-ઑઓ-નપ-રલ-ળવ-હઽૠଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଶ-ହଽଡ଼-ଢ଼ୟ-ୡஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-வஷ-ஹఅ-ఌఎ-ఐఒ-నప-ళవ-హౠ-ౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹೞೠ-ೡഅ-ഌഎ-ഐഒ-നപ-ഹൠ-ൡก-ฮะา-ำเ-ๅກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-ຮະາ-ຳຽເ-ໄཀ-ཇཉ-ཀྵႠ-Ⴥა-ჶᄀᄂ-ᄃᄅ-ᄇᄉᄋ-ᄌᄎ-ᄒᄼᄾᅀᅌᅎᅐᅔ-ᅕᅙᅟ-ᅡᅣᅥᅧᅩᅭ-ᅮᅲ-ᅳᅵᆞᆨᆫᆮ-ᆯᆷ-ᆸᆺᆼ-ᇂᇫᇰᇹḀ-ẛẠ-ỹἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼΩK-Å℮ↀ-ↂぁ-ゔァ-ヺㄅ-ㄬ가-힣一-龥〇〡-〩_]",h.NCNAME=new RegExp("^"+h.nameStartChar+h.nameChar+"*$"),h.dateTimeTypes=[{pattern:/-?P(?:[0-9]+Y)?(?:[0-9]+M)?(?:[0-9]+D)?(?:T(?:[0-9]+H)?(?:[0-9]+M)?(?:[0-9]+(?:\.[0-9]+)?S)?)?/,type:"http://www.w3.org/2001/XMLSchema#duration"},{pattern:/-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9]T(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\.[0-9]+)?(?:Z|[+\-][0-9][0-9]:[0-9][0-9])?/,type:"http://www.w3.org/2001/XMLSchema#dateTime"},{pattern:/-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9](?:Z|[+\-][0-9][0-9]:[0-9][0-9])?/,type:"http://www.w3.org/2001/XMLSchema#date"},{pattern:/(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\.[0-9]+)?(?:Z|[+\-][0-9][0-9]:[0-9][0-9])?/,type:"http://www.w3.org/2001/XMLSchema#time"},{pattern:/-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]/,type:"http://www.w3.org/2001/XMLSchema#gYearMonth"},{pattern:/-?[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9]/,type:"http://www.w3.org/2001/XMLSchema#gYear"}],e.exports=h},function(e,t,n){"use strict";var r=n(7),i=function e(t){var e={};e.ns={RDF:"http://www.w3.org/1999/02/22-rdf-syntax-ns#",RDFS:"http://www.w3.org/2000/01/rdf-schema#"},e.nodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12},this.frameFactory</span>=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,i){return{NODE:1,ARC:2<span class="cstat-no" title="statement not covered" >,pare</span>nt<span class="cstat-no" title="statement not covered" >:n,parser<span class="fstat-no" title="function not covered" >:t</span>,store:t.<span class="cstat-no" title="statement not covered" >sto<span class="cstat-no" title="statement not covered" ></span>re,element:i,lastChild:0,base:null,lang:null,node:null,nodeType:null,listIndex:1,rdfid:null,datatype:null,collection:!1,terminateFrame:function(){this.collection&amp;&amp;this.node.close()},addSymbol:function(e,t){t=r.join(t,this.base),this.node=this.store.sym(t),this.nodeType=e},loadTriple:function(){if(this<span class="fstat-no" title="function not covered" >.p</span>arent.parent.c<span class="cstat-no" title="statement not covered" >ollection?this.parent.parent.node.append(this.node):this.store.add(this.parent.parent.node,this.parent.node,this.node,this.parser.why),null!=this.parent.rdfid){var t=this.store.sym(r.join("#"+this.parent.rdfid,this.bas<span class="fstat-no" title="function not covered" >e));this.store.</span>ad<span class="cstat-no" title="statement not covered" >d(t,this.store.sym(e.ns.RDF+"type"),</span>this.store.sym(e.ns.RDF+"Statement"),this.par<span class="fstat-no" title="function not covered" >ser.why),t</span>his.s<span class="cstat-no" title="statement not covered" >tore.add(t,this.store.sym(e.ns.RDF+"subject"),this.parent.parent.no</span>de,this.parser.why),this.store.add(t,this.stor<span class="fstat-no" title="function not covered" >e.sym(e.ns.</span>RD<span class="cstat-no" title="statement not covered" >F+"predicate"),this.parent.node,this.parser.why),this.store.add(t,this.store.sym(e.ns.RDF+"object"),this.node,this.parser.why)}},isTripleToLoad:function(){return null!=this.parent&amp;&amp;null!=th<span class="cstat-no" title="statement not covered" >is.parent.parent&amp;&amp;this.nodeType===this.NODE&amp;&amp;this.parent<span class="cstat-no" title="statement not covered" ></span>.nodeType===this.ARC&amp;&amp;this.parent.parent.nodeType===this.NODE},addNode:function(e){this.addSymbol(this.NODE,e),this.isTripleToLoad()&amp;&amp;this.loadTriple()},addCollection:function(){this.nodeType=this.NODE,this.node=this.store.collection(),this.collection=!0,this.isTripleToLoad()&amp;&amp;this.loadTriple()},addCollectionArc:function(){this.nodeType=this.ARC},addBNode:funct</span>i</span>on(e){null!=e?null!=this.parser.bnodes[e]?this.nod<span class="fstat-no" title="function not covered" >e=this.parser.b</span>no<span class="cstat-no" title="statement not covered" >des[e]:this.node=this.parser.bnodes[e]=this.store.bnode():this.node=this.store.bnode(),this.nodeType=this.NODE,this.isTripleToLoad()&amp;&amp;this.loadTriple()},</span>addArc:function(t){t===e.ns.RDF+"li"&amp;&amp;(t=e.<span class="fstat-no" title="function not covered" >ns.RDF+"</span>_"+<span class="cstat-no" title="statement not covered" >this.parent.listIndex,this.parent.listIndex++),this.addSymbol(this.ARC</span>,t)},addLiteral:function(e){this.parent.datatype?<span class="fstat-no" title="function not covered" >this.node=this</span>.s<span class="cstat-no" title="statement not covered" >tore.literal(e,"",this.store.sym(this.parent.datatype)):this.node=this.store.literal(e,this.lang),this.nodeType=this.NO</span>DE,this.isTripleToLoad()&amp;&amp;this.loadTriple()}}},this.<span class="fstat-no" title="function not covered" >getAttributeNodeN</span>S=<span class="cstat-no" title="statement not covered" >function(e,t,n){var r=nu</span>ll;if(e.getAttributeNodeNS)r=e.getAttributeN<span class="fstat-no" title="function not covered" >odeNS(t,n</span>);e<span class="cstat-no" title="statement not covered" >lse for(var i,o,a=e.attributes,s=0;s&lt;a.length;++s)if(i=a[s],i.namespaceURI===t&amp;&amp;(o=i.prefix?i.prefix+":"+n:n,o===i.nodeName)){r=i;break}return r},this.store=t,this.bnodes={},this.why=null,this.reify=!1,this.parse=f</span>unction(t,n,r){var i=t.childNodes;this.cle<span class="fstat-no" title="function not covered" >anParse</span>r()<span class="cstat-no" title="statement not covered" >;var o;if(t.nodeType===e.nodeType.DOCUMENT){for(var a=0;a&lt;i.length;a++)if(i[a].nodeType===e.nodeType.ELEMENT){</span>o=i[a];break}}else{if(t.nodeType!==e.nodeType.<span class="fstat-no" title="function not covered" >ELEMENT)thr</span>ow <span class="cstat-no" title="statement not covered" >new Error("RDFParser: can't find root in "+n+". Halting. ");o=t}this.why=r;var s=this.frameFactory(this);return this.base=n,s.base=n,s.lang=null,this.parseDOM(this.buildFrame(s,o)),!0},this.parseDOM=fu</span>nct</span>ion(t){for(var n,i=functi<span class="fstat-no" title="function not covered" >on</span>(e){var t="";if(null<span class="cstat-no" title="statement not covered" >==e.n<span class="cstat-no" title="statement not covered" ></span>amespaceURI)throw new Er<span class="cstat-no" title="statement not covered" >ror("RDF/XML syntax error: No</span> nam<span class="cstat-no" title="statement not covered" >espace for "+e.localName+" in "+this.base);ret<span class="cstat-no" title="statement not covered" >urn e.namespaceURI&amp;&amp;(t+=e.namespaceURI),e.localName?t+=e.localName:e.nodeNam<span class="cstat-no" title="statement not covered" >e&amp;&amp;(<span class="cstat-no" title="statement not covered" >t</span>+=e.no<span class="cstat-no" title="statement not covered" ></span>d</span></span></span>eName.ind</span>exOf(":")&gt;=0?e.nodeName.split(":")[1]:e.nodeName),t}.bind(this),o=!0<span class="fstat-no" title="function not covered" >;t</span>.parent;){var a=t.el<span class="cstat-no" title="statement not covered" >ement,s=a.att<span class="cstat-no" title="statement not covered" ></span>ributes;if(a.nodeTyp</span>e===e<span class="cstat-no" title="statement not covered" >.nodeType.TEXT||a.nodeType===e.nodeTy<span class="cstat-no" title="statement not covered" >pe.CDATA_SECTION)t.parent.n<span class="cstat-no" title="statement not covered" >odeType===t.NODE&amp;&amp;(t.addArc(e.ns.RDF+"v<span class="cstat-no" title="statement not covered" >alue"),<span class="cstat-no" title="statement not covered" >t</span>=this.</span>b</span></span>uildF<span class="cstat-no" title="statement not covered" >rame(t)),t.addLiteral(a.nodeValue);<span class="cstat-no" title="statement not covered" >else if(i(a)!==e.ns.RDF+"RDF")if(t.parent&amp;&amp;t.parent.collection&amp;&amp;(t<span class="cstat-no" title="statement not covered" >.</span></span>addC<span class="cstat-no" title="statement not covered" ></span>o</span>llectionArc</span>(),t=<span class="cstat-no" title="statement not covered" >this.buildFrame(t,t.elem<span class="cstat-no" title="statement not covered" ></span>ent),t.parent.element=null),t.parent&amp;&amp;t.parent.nodeType&amp;&amp;t.parent.nodeType!==t.A</span>RC){t.addArc(i(<span class="fstat-no" title="function not covered" >a)</span>),this.rei<span class="cstat-no" title="statement not covered" >fy&amp;&amp;(n=this.getAttributeNodeNS(a,e.ns.RDF,"ID"),n&amp;&amp;(t.rdfid=n.nodeValue,a.removeAttributeNode(n)));var u=this.getAttributeNodeNS(a,e.ns.RDF,"parseType"),l=this.getAttributeNodeNS(a,e.ns.RDF,"datatype");if(l&amp;&amp;(t.datatype=l.nodeValue,a.removeAttributeNode(l)),u){var c=u.nodeValue;"Literal"===c?(t.datatype=e.ns.RDF+"XMLLiteral",t=thi<span class="cstat-no" title="statement not covered" >s.buildFra</span>me<span class="cstat-no" title="statement not covered" >(t),t.addLite<span class="cstat-no" title="statement not covered" ></span>ral(a),o=!1):"Resource"===c?(t=this.buildFrame(t,t.element),t.parent.el<span class="cstat-no" title="statement not covered" >ement=null,t.addBNode()):"Collection"===c&amp;&amp;(t=this.buildFrame(t,t.element),t.parent.element=null,t.addCol</span>lect<span class="cstat-no" title="statement not covered" >ion()),a.removeAttributeN<span class="cstat-no" title="statement not covered" >ode(u)}if(0!==s.length){var f=this.getAttributeNodeNS(a,e.ns.RDF,"resource"),h=this.getAttributeNodeNS(a,e.ns.RDF,"nodeID");t=this.buildFrame(t),f?(t.addNode(f.nodeVa<span class="cstat-no" title="statement not covered" >lue),a.removeAttributeNode(f)):h?(t.addBNode(h.nodeValue),a.removeAttributeNode(h)):t.addBNode();for(var d=s.length-1;d&gt;=0;</span>d--){<span class="cstat-no" title="statement not covered" >var p=this.buildFrame(t);p.addArc(i(s[d])),i(s[d</span>])<span class="cstat-no" title="statement not covered" >===e.ns.RDF+"type"?this.buildFrame(p).addNode(s<span class="cstat-no" title="statement not covered" ></span>[d].nodeValue):this.buildFrame(p).addLiteral(s[d].nodeValue)}}els<span class="cstat-no" title="statement not covered" >e 0===a.chil<span class="cstat-no" title="statement not covered" ></span>dNodes.length&amp;&amp;this.buildFrame(t).addLiteral("")}else{var v=this.getAttributeNodeNS(a,e.ns.RDF,"about");if(n=this.getAttributeNodeNS(a,e.ns.RDF,"ID"),v&amp;&amp;n)throw new Error("RDFParser: "+a.nodeName+" has both rdf:id and rdf:about. Halting. Only one of these properties may be specified on a no<span class="cstat-no" title="statement not covered" ></span>d</span>e.");if(!v&amp;&amp;n)t.addNod<span class="cstat-no" title="statement not covered" >e("#"+n.nodeValue),a.removeAttributeNode(n);els</span>e <span class="cstat-no" title="statement not covered" >if(null==v&amp;&amp;null==n){var g=this.getAttributeN<span class="cstat-no" title="statement not covered" ></span>odeNS(a,e.ns.RDF,"nodeID");g?(t.addBNode(g.nodeValue),a.removeAttributeNode(g)):t.addBNode()}else t.addNode(v.nodeValue),a.removeAttributeN<span class="cstat-no" title="statement not covered" >o</span>de(v);var y=this.getAttributeNodeNS(<span class="cstat-no" title="statement not covered" >a,e.ns.RDF,"type");<span class="cstat-no" title="statement not covered" ></span>e.ns.RDF+"Description"!==i(a)&amp;&amp;(y={nodeValue:i(a)}),null!=y&amp;&amp;(this.store.add(t.node,this.store.sym(e.ns.RDF+"type"),this.store.sym(r.j</span>o</span>in(y.<span class="cstat-no" title="statement not covered" >nodeValue,t.base)),this.why),y.nodeName&amp;&amp;a.removeAttributeNo</span></span>de(y));for(<span class="cstat-no" title="statement not covered" >var m=s.length-1;m&gt;=0;m--)this.store.add(t.n<span class="cstat-no" title="statement not covered" ></span>ode,this.store.sym(i(s[m])),this.store.literal(s[m]<span class="cstat-no" title="statement not covered" >.nodeValue,t.lang),this.why)}for(a=t.element;t.parent;){for(var b=t;null==a;)t=t.parent,a=t.element;var w=a.childNodes&amp;&amp;a.childNodes[t.lastChi<span class="cstat-no" title="statement not covered" >l</span></span>d];if(w&amp;<span class="cstat-no" title="statement not covered" >&amp;o){if((w.nodeType===e.nodeType.ELEMENT||w.nodeType==</span>=e.n<span class="cstat-no" title="statement not covered" >odeType.TEXT||w.nodeType===<span class="cstat-no" title="statement not covered" >e.nodeType.CDATA_SECTION)&amp;&amp;(w.nodeType!==e.no<span class="cstat-no" title="statement not covered" ></span>deType.TEXT&amp;&amp;w.nodeType!==e.nodeType.CDATA_SECTION||1===a.childNode</span>s.len<span class="cstat-no" title="statement not covered" >gth)){t.lastChild++,t=this.buildFrame(b,a.childNo</span></span></span>des[t<span class="cstat-no" title="statement not covered" >.lastChild-1]);break}t.lastChild++}else{if(<span class="cstat-no" title="statement not covered" ></span>t.terminateFrame(),!(t=t.parent))break;a=t.element,o=!0}}}},this.cleanParser=function(){this.bnodes={},this.why=null},this.buildFrame=function(t,n){var i=this.frameFactory(this,t,n);if(t&amp;&amp;(i.base=t.base,i.la<span class="cstat-no" title="statement not covered" >n</span>g=t.lang),!n||n.nodeType===e.<span class="cstat-no" title="statement not covered" >nodeType.TEXT||n.nodeType===e.nodeType.CDATA_SECTION)return i;var o=n.attributes,a=n.getAttributeNo<span class="cstat-no" title="statement not covered" ></span></span>d</span></span></span>e("xml:base");null!=a&amp;&amp;(i.<span class="cstat-no" title="statement not covered" >base=a.nodeValue,n.re<span class="cstat-no" title="statement not covered" >moveAttribute("xml:base"</span></span>));va<span class="cstat-no" title="statement not covered" >r s=n.getAttributeNode("xml:lang");null!<span class="cstat-no" title="statement not covered" ></span>=s&amp;&amp;(i.la<span class="cstat-no" title="statement not covered" >ng=s.nodeValue,n.removeAttribute("xml:lang"));for(var u=o.length-1;u&gt;=0;u--)if("xml"===o[u].nodeName.substr(0,3)){if("xmlns:"===o[u].name.slice(0,6)){var l=o[u].nodeValue;this.base&amp;&amp;(l=r.join(l,this.base<span class="cstat-no" title="statement not covered" >)),this.store.setPrefixForURI(o[u].name.slice(6),l)}n.removeAtt<span class="cstat-no" title="statement not covered" >r</span>ibuteN<span class="cstat-no" title="statement not covered" ></span>o</span>de(o[u])}retur</span>n i}}<span class="cstat-no" title="statement not covered" >;e.exports=i},function(e,t,n){"use s<span class="cstat-no" title="statement not covered" >trict"<span class="cstat-no" title="statement not covered" >;</span></span>function r(e,t,n)</span>{</span>v</span>a</span>r r,a,s,u=["INSERT<span class="fstat-no" title="function not covered" >",</span>"DELETE",<span class="cstat-no" title="statement not covered" >"WHERE"],l=o("http://www.w3.or</span>g/ns/pim/patch#")<span class="fstat-no" title="function not covered" >,c</span>=i(t,t,n,n,null,nu<span class="cstat-no" title="statement not covered" >ll,"",null),f={},h=function(<span class="cstat-no" title="statement not covered" ></span>e,t,n,r,i){return"Line "+(t+1)+" of &lt;"+e+"&gt;: Bad syntax:\n   "+i+'\n   at: "'+n.slice(r,r+30)+'"'};r=0;var d<span class="cstat-no" title="statement not covered" >=t.sym(n+"</span></span>#quer<span class="cstat-no" title="statement not covered" >y");for(f.que</span>ry<span class="cstat-no" title="statement not covered" >=d;;){if(a=c.skipSpace(e,r),a&lt;0<span class="cstat-no" title="statement not covered" ></span>)return f;if(";"===e[a]){if(r=c.skipSpace(e,a+1),r&lt;0)return f</span>;a=r}<span class="cstat-no" title="statement not covered" >var p=!1;for(s=0;s&lt;u.length;s++<span class="cstat-no" title="statement not covered" ></span>){var v=u[s];if(e.slice(a,a+v.length)===v){if(r=c.skipSpace(<span class="cstat-no" title="statement not covered" >e</span>,a+v.length),r&lt;0)throw h(c._t<span class="cstat-no" title="statement not covered" >hisDoc,c.lines,e,a+v.length,"found EOF<span class="cstat-no" title="statement not covered" >, needed {...} after "+v);if(("INSERT"===v<span class="cstat-no" title="statement not covered" >||"DELETE"===v)<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;"DATA"===e.slice(r,r+4)){if(a=c.skipSpace(e,r+4),a&lt;0)throw h(c._thisDoc,c.lines,e,r<span class="cstat-no" title="statement not covered" ></span>+</span>4,"needed {...} after INSERT<span class="cstat-no" title="statement not covered" ></span> </span></span>DATA "+v)</span>;r</span>=<span class="cstat-no" title="statement not covered" ></span>a}var g=[];if</span>(<span class="fstat-no" title="function not covered" >a=</span>c.node(e,r,g),a&lt;0)throw h(c._thisDoc<span class="fstat-no" title="function not covered" >,c</span>.lines,e,r,"bad syn<span class="cstat-no" title="statement not covered" >tax or EOF in {...} after "+</span>v)<span class="cstat-no" title="statement not covered" >;f[v.toLowerCase()]=g[0],t.add(d,l(v.</span>to<span class="cstat-no" title="statement not covered" >LowerCase()),g[0]),p=!0,r=a}}</span>if<span class="cstat-no" title="statement not covered" >(!p</span>&amp;&amp;<span class="cstat-no" title="statement not covered" >"@prefix"<span class="fstat-no" title="function not covered" >==</span>=e.slice(a,<span class="cstat-no" title="statement not covered" >a+7)){if(r=c.directive(e,a),r&lt;0)throw h(c._thisDoc,c.lines,e,r,"bad syntax or EOF after </span>@<span class="cstat-no" title="statement not covered" ></span>prefi</span>x ");<span class="cstat-no" title="statement not covered" >r=c.checkDot(e,r),<span class="cstat-no" title="statement not covered" ></span>p=!0}if(!p)throw <span class="cstat-no" title="statement not covered" >h(c._thisDoc,c.lines,e,a,"<span class="cstat-no" title="statement not covered" >Unknown s<span class="cstat-no" title="statement not covered" >y</span></span>ntax at start <span class="cstat-no" title="statement not covered" >of statememt: '"+e.slice(a).<span class="cstat-no" title="statement not covered" >slice(0,2<span class="cstat-no" title="statement not covered" >0</span></span>)+"'</span>"</span>)}}e.<span class="cstat-no" title="statement not covered" >exp<span class="cstat-no" title="statement not covered" ></span>orts=r;var i=n(78),o=n(73)},fu<span class="cstat-no" title="statement not covered" >nctio<span class="cstat-no" title="statement not covered" ></span>n(e,t,n){"use strict";function<span class="cstat-no" title="statement not covered" > r(e,t){if(!(e instanceof t))throw <span class="cstat-no" title="statement not covered" >new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)thr<span class="cstat-no" title="statement not covered" >o</span></span>w new ReferenceError("this hasn't been initialised - supe<span class="cstat-no" title="statement not covered" >r() hasn't been called");ret<span class="cstat-no" title="statement not covered" >urn!t||"object"!=typeof t&amp;&amp;"function"!=typeof t?e:t}function o(e,t){if<span class="cstat-no" title="statement not covered" >(</span></span>"fun</span>c</span>tion"<span class="cstat-no" title="statement not covered" >!=t<span class="cstat-no" title="statement not covered" ></span>ypeof t&amp;&amp;null!==t)throw<span class="cstat-no" title="statement not covered" > new TypeError("Super expression must either be null or a function, no<span class="cstat-no" title="statement not covered" >t</span></span> "+typeof t);e.prototype=Object.create(t&amp;&amp;t.prototype,{constructor</span>:<span class="cstat-no" title="statement not covered" ></span>{</span>value:e,enumerable:!1,writable:!0,<span class="cstat-no" title="statement not covered" >configurable:!0}}),t&amp;&amp;(Obj<span class="cstat-no" title="statement not covered" >ect.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=<span class="cstat-no" title="statement not covered" >f</span></span>unction(){function e(e,<span class="cstat-no" title="statement not covered" ></span>t</span>){for<span class="cstat-no" title="statement not covered" >(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&amp;&amp;(r.wr</span></span>i<span class="cstat-no" title="statement not covered" ></span>table=!0),Obj</span>ect.d<span class="cstat-no" title="statement not covered" >efineP</span>ro<span class="cstat-no" title="statement not covered" >perty(</span>e,<span class="fstat-no" title="function not covered" >r.</span>key,r)}}return function(t,n,r){retur<span class="fstat-no" title="function not covered" >n </span>n&amp;&amp;e(<span class="cstat-no" title="statement not covered" >t.prototype,n),r&amp;&amp;e(t<span class="cstat-no" title="statement not covered" >,r),t}}(),s=n(10),u=function(e){function t(){r(this,t);var</span></span> e=i(this<span class="fstat-no" title="function not covered" >,O</span>bject<span class="cstat-no" title="statement not covered" >.getPr<span class="cstat-no" title="statement not covered" >ototypeOf(t).call(this));return e.termType=t.termType,e}return o(t,e),a(t,[{key:"toStr<span class="cstat-no" title="statement not covered" >i</span></span>ng",value:function(){return"()"}}]),t}(s);u.termType="e</span>mpty",e.e<span class="fstat-no" title="function not covered" >xp</span>orts=<span class="cstat-no" title="statement not covered" >u},function(e,t){"use strict";var <span class="cstat-no" title="statement not covered" >n=function(){return{parseJSON:function(e,t,n){var r,i,o,a={},s=n.sym(t);for(var u in e){0<span class="cstat-no" title="statement not covered" >=</span></span>==u.indexOf("_:")?a[u]?r=a[u]:(r=n.bnode(u),a[u]=r):r=n.sym(u);var l=e[u];for(var c in l){var f=l[c];i=n.sym(c);for(var h in f){var d=f[h];if("uri"===d.type)o=n.sym(d.value),n.</span>add(r,<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >i,</span>o,s);else if("Blan<span class="fstat-no" title="function not covered" >kN</span>ode"=<span class="cstat-no" title="statement not covered" >==d.type)a[d.value]?o=a[d.value]:(<span class="cstat-no" title="statement not covered" >o=n.b<span class="cstat-no" title="statement not covered" ></span>node(d.value),a[d.value]=o),n.add(r,i,o,s);else{if("Literal"!==d.type)throw new Error("error: unexpected termty</span>p<span class="cstat-no" title="statement not covered" ></span>e: "+h.<span class="fstat-no" title="function not covered" >ty</span>pe);o=d.dataty<span class="cstat-no" title="statement not covered" >pe?n.literal(d.value,void 0,n.sym(d.data</span>ty</span>pe)</span>):<span class="cstat-no" title="statement not covered" >d.lang</span>?n<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >.l</span>iteral(d.value,d.la<span class="fstat-no" title="function not covered" >ng</span>):<span class="cstat-no" title="statement not covered" >n.literal(d</span>.valu<span class="cstat-no" title="statement not covered" >e),n.add(r,i,o,s)}}}}}}}();e.exports=n},func<span class="cstat-no" title="statement not covered" ></span>tion(e,t,n){"use strict";functio<span class="cstat-no" title="statement not covered" ></span>n r(e){function t(e){for(var t=s()+"SELECT ",n=0;n&lt;e.vars.length;n++)t+=e.v<span class="fstat-no" title="function not covered" >ars[n]</span>+"<span class="cstat-no" title="statement not covered" > ";return t+</span>="\n"}f</span>unct<span class="cstat-no" title="statement not covered" ></span>ion n(e){var t="",n=e.statements</span>;<span class="fstat-no" title="function not covered" >fo</span>r(var r in n)i.debug("Found sta<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >te</span>ment: "+n<span class="cstat-no" title="statement not covered" >),t+=s()+n[r]+"\n";return t}function r(e){var t="";<span class="fstat-no" title="function not covered" >for(var n </span>in e.constraints){v<span class="cstat-no" title="statement not covered" >ar </span>r=<span class="cstat-no" title="statement not covered" >e.constra<span class="cstat-no" title="statement not covered" ></span>ints[n];t+=s()+"<span class="cstat-no" title="statement not covered" >FILTER ( "+r.describe(n)+" ) \n"}return t}function o(e){for(var t=</span>"",a=<span class="cstat-no" title="statement not covered" >0;a&lt;e<span class="cstat-no" title="statement not covered" ></span>.optional.length;a++)i<span class="cstat-no" title="statement not covered" >.debu<span class="cstat-no" title="statement not covered" ></span>g("Found op<span class="cstat-no" title="statement not covered" >t</span>ional query"),t+=s()+<span class="cstat-no" title="statement not covered" >"OPTI<span class="cstat-no" title="statement not covered" ></span>ONAL { \n",l++,t+=<span class="cstat-no" title="statement not covered" >n(e.optional[a]),t+=r(e.optional[</span>a]),<span class="cstat-no" title="statement not covered" >t+=o(e.optional[a]),l--,<span class="cstat-no" title="statement not covered" >t+=s()+"}\n";return t}function a(e){var t=s()+"WHERE \n{ \n";return l++,t+</span>=n(e<span class="cstat-no" title="statement not covered" >),t+=r(e),t+=o(e),l--,<span class="cstat-no" title="statement not covered" >t+="}"}function s(){for(var e="",t=0;t&lt;l;t++)e+="    ";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}function u(e){return t(e)+a(e.pat)}var l=0;return u(e)}var i=n(15);e.exports=r},function(e,t,n){"use strict";functio</span>n</span></span> </span>r</span>(</span>e,t</span>,n)<span class="cstat-no" title="statement not covered" ></span>{function r(e</span>)<span class="fstat-no" title="function not covered" >{i</span>f(C[e])return C[e];var t=n.variable(<span class="fstat-no" title="function not covered" >e)</span>;return C[e]<span class="fstat-no" title="function not covered" >=t</span>,t}<span class="cstat-no" title="statement not covered" >function a(e){return"string"==typeof e&amp;&amp;e.match(<span class="cstat-no" title="statement not covered" >/[^ \n\t]/)}funct<span class="cstat-no" title="statement not covered" >i</span></span>on s(e){return"</span>string"==<span class="fstat-no" title="function not covered" >ty</span>peof e&amp;&amp;e<span class="cstat-no" title="statement not covered" >.ma</span>tc<span class="cstat-no" title="statement not covered" >h(/^[\?\$]/)}<span class="cstat-no" title="statement not covered" ></span>function u(e){r<span class="cstat-no" title="statement not covered" >eturn"string"==typeof e?e.replace(/^&amp;lt;/,"&lt;").r<span class="cstat-no" title="statement not covered" >e</span></span>place(/&amp;g</span>t;$/,"&gt;")<span class="fstat-no" title="function not covered" >:e</span>}function<span class="cstat-no" title="statement not covered" > l(<span class="cstat-no" title="statement not covered" ></span>e){return"string"==typeof e&amp;&amp;e.mat<span class="cstat-no" title="statement not covered" >ch(/^&lt;[^&gt;]*&gt;$/)}f<span class="cstat-no" title="statement not covered" ></span>unction c(e){return"string"==typeof e&amp;&amp;(e.<span class="cstat-no" title="statement not covered" ></span>m</span>atch(/^_:</span>/)||e.mat<span class="fstat-no" title="function not covered" >ch</span>(/^<span class="cstat-no" title="statement not covered" >$/))}function f(e){return"string"==typeof<span class="cstat-no" title="statement not covered" > e&amp;&amp;e.match(/:$/)}function h(e){return"string"==typeof e&amp;&amp;e.match(/^:|^[^_][^:]*:/)}function d(e){var t=e.split(":");return t[0]}functio<span class="cstat-no" title="statement not covered" >n</span></span> p(e){var</span> t=e.spli<span class="fstat-no" title="function not covered" >t(</span>":");retu<span class="cstat-no" title="statement not covered" >rn t[1]}function v(<span class="cstat-no" title="statement not covered" ></span>e){return l(e)?e.slice(1,e.length-1):e}function</span> g(e){var<span class="fstat-no" title="function not covered" > t</span>=e<span class="cstat-no" title="statement not covered" >.indexOf("'")===-1?null:e<span class="cstat-no" title="statement not covered" >.indexOf("<span class="cstat-no" title="statement not covered" >'</span></span>"),r=e.in</span>dexOf('"'<span class="fstat-no" title="function not covered" >)=</span>==-<span class="cstat-no" title="statement not covered" >1?null:e.indexOf('"');</span>if(!t&amp;<span class="cstat-no" title="statement not covered" >&amp;!<span class="cstat-no" title="statement not covered" ></span>r){var o=new </span>Array(<span class="cstat-no" title="statement not covered" >1);ret<span class="cstat-no" title="statement not covered" ></span>urn o[0]=e,o}</span>v<span class="fstat-no" title="function not covered" >ar</span> a,s,u=new Array(2);if(!t||r&amp;&amp;r&lt;t)a=<span class="fstat-no" title="function not covered" >'"</span>',s=r;else{if(r&amp;<span class="fstat-no" title="function not covered" >&amp;!</span>(t&amp;<span class="cstat-no" title="statement not covered" >&amp;t&lt;r))re<span class="cstat-no" title="statement not covered" >turn i.error(</span></span>"SQAR<span class="cstat-no" title="statement not covered" >QL QUERY OOPS!<span class="cstat-no" title="statement not covered" ></span>"),u;a="'",s=t}u[</span>0]=e.slic<span class="fstat-no" title="function not covered" >e(</span>0,s<span class="cstat-no" title="statement not covered" >);var l=e.slice(s+1).indexOf(a);if(l===-1)retur</span>n i.error<span class="fstat-no" title="function not covered" >("</span>SPA<span class="cstat-no" title="statement not covered" >RQL parsing error: no matching parentheses in </span>literal "<span class="fstat-no" title="function not covered" >+e</span>),e<span class="cstat-no" title="statement not covered" >;var c;return e.slice(l+s+2).match(/^\^\^/)?(c=e.slice(l+s+2).indexOf(" </span>"),u[1]=n<span class="fstat-no" title="function not covered" >.l</span>ite<span class="cstat-no" title="statement not covered" >ral(e.slice(s+1,s+1+l),"",n.sym(v(e.slice(s+4+l,</span>s+2+l+c))<span class="fstat-no" title="function not covered" >))</span>,u=<span class="cstat-no" title="statement not covered" >u.concat(g(e.slice(l+s+3+c)))):e.slice(l+s+2).match(/^@/)?(</span>c=e.slice<span class="fstat-no" title="function not covered" >(l</span>+s+<span class="cstat-no" title="statement not covered" >2).indexOf(" "),u[1]=n.literal(e.slice(s+</span>1,s+1+l),<span class="fstat-no" title="function not covered" >e.</span>sli<span class="cstat-no" title="statement not covered" >ce(s+3+l,s+2+l+c),null),u=u.concat(g(e.slice(l+s+2+c)</span>))):(u[1]<span class="fstat-no" title="function not covered" >=n</span>.literal(<span class="cstat-no" title="statement not covered" >e.slice(s+1,s<span class="cstat-no" title="statement not covered" ></span>+1+l),"",null</span>),i.info(<span class="fstat-no" title="function not covered" >"L</span>iteral fo<span class="cstat-no" title="statement not covered" >und: "+u[1]),<span class="cstat-no" title="statement not covered" ></span>u=u.concat(g(</span>e.slice(l<span class="fstat-no" title="function not covered" >+s</span>+2)<span class="cstat-no" title="statement not covered" >))),u}function y(e){e=e.replace(/\(/g</span>," ( ").r<span class="fstat-no" title="function not covered" >ep</span>lace(/\)/<span class="cstat-no" title="statement not covered" >g," ) ").replace(/&lt;/g," &lt;").replace(/&gt;/g</span>,"<span class="cstat-no" title="statement not covered" >&gt; ").replace(/{/g," { ").replace(/}/g," <span class="cstat-no" title="statement not covered" ></span>} ").replace(/[\t<span class="cstat-no" title="statement not covered" >\n\r]/g," ").<span class="cstat-no" title="statement not covered" ></span>replace(/; /g," ;</span> </span>").replac<span class="cstat-no" title="statement not covered" >e(/\. /g," . <span class="cstat-no" title="statement not covered" ></span>").replace(/, <span class="cstat-no" title="statement not covered" >/g," , "),i</span>.inf<span class="cstat-no" title="statement not covered" >o("New str into <span class="cstat-no" title="statement not covered" >spaceDelimit: \n"+e);var t=[],n=e.split<span class="cstat-no" title="statement not covered" >(</span></span>" ");for(v<span class="cstat-no" title="statement not covered" ></span>a</span>r r in n)a(n[r])&amp;&amp;</span>(t=t.<span class="cstat-no" title="statement not covered" >concat(n[r]));return t}f<span class="cstat-no" title="statement not covered" ></span>unction m(<span class="cstat-no" title="statement not covered" >e){for(var t=e,n=0;n&lt;t.length;n++)if("a"===t[n]&amp;&amp;(t[n]="&lt;http://www.w3.org/1999/0</span></span>2/22-<span class="cstat-no" title="statement not covered" >rdf-syntax-ns#type&gt;"),"is"===t[n]&amp;&amp;"of"===t[n+2]){t.splice(n,1),t.splice(n+1,1);var r=t[n-1];t[n-1]=t[n+1],t[n+1]=r}return t}function b(e){for(var t=[],o=0;o&lt;e.length;o++)"string"==typeof e[o]?(e[o]=u(e[o]),s(e[o])?t[o]=r(e[o].slice(1)):c(e[o])?(i.info(e[o]+" was identified as a bnode."),t[o]=n.bnode()):l(e[o])?(i.info(e[o]+" was identified as a symbol."),t[o]=n.sym(v(e[o]))):h(e[o])?(i.info(e[o]+" was identified as a prefixed symb</span>ol"),D[d(<span class="fstat-no" title="function not covered" >e[</span>o])<span class="cstat-no" title="statement not covered" >]?t[o]=n.sym(e[o]=D[d(e[o])]+p(e[o])):(i.error("SPARQL error: "+e[o]+" with prefix "+d(e[o])+" does not have a correct prefix entry."),t[o]=e[o])):t[o]=e[o]):t[o]=e[o];return t}function w(e){var t=g(e),n=[];for(var r in t)n="string"==typeof t[r]?n.concat(y</span>(t[r]<span class="cstat-no" title="statement not covered" >)):</span>n.<span class="cstat-no" title="statement not covered" >concat(t[r]);<span class="cstat-no" title="statement not covered" ></span>return n=m(n),i<span class="cstat-no" title="statement not covered" >.info("SPARQL Tokens: "+n),n<span class="cstat-no" title="statement not covered" >}</span></span>function </span>x(e,t){fo<span class="fstat-no" title="function not covered" >r(</span>var<span class="cstat-no" title="statement not covered" > n=0;n&lt;t.length;n++)if("string"<span class="cstat-no" title="statement not covered" >==typeof t[n]&amp;&amp;t[n].toLowerCase()===e.toLowerCase())return n;return null}function _(e,t){for(var n=[],<span class="cstat-no" title="statement not covered" >r=0;r&lt;t.length;r++)"string"==ty</span>peof <span class="cstat-no" title="statement not covered" >t[r]&amp;&amp;t<span class="cstat-no" title="statement not covered" ></span>[r].toLowerCase()===e.to<span class="cstat-no" title="statement not covered" ></span>L</span></span>owerCase(</span>)&amp;&amp;n.push<span class="fstat-no" title="function not covered" >(r</span>);r<span class="cstat-no" title="statement not covered" >eturn n}function k(e,t){i.info("<span class="cstat-no" title="statement not covered" >SPARQL vars: "+e);for(var n in e)if(s(e[n])){i.info("Added "+e[n]+" to query variables from SPARQL");var o=r(e[n].slice(1));t.vars.push(o),o.label=e[n].slice(1)}else i.warn("Incorrect SPARQL variable in SELECT: "+e[n])}function T(e){var t=_("PREFIX",e),n=[];for(var r in t){var o=e[t[r]+1],a=e[t[r]+2];if(f(o))if(l(a)){i.info("Prefix found: "+o+" -&gt; "+a);var s=d(o),u=v(a);n[s]=u}else i.error("Invalid SPARQL symbol: "+a);else i.error("Invalid SP<span class="cstat-no" title="statement not covered" >A</span></span>RQL prefi</span>x: "+o)}r<span class="fstat-no" title="function not covered" >et</span>urn n}fun<span class="cstat-no" title="statement not covered" >ction</span> E<span class="cstat-no" title="statement not covered" >(e,<span class="cstat-no" title="statement not covered" ></span>t,n){i.info("Lo<span class="cstat-no" title="statement not covered" >oking for a close bracket of type "+n+" in "+e);for(var r<span class="cstat-no" title="statement not covered" >=</span></span>0,o=0;o&lt;e.length;o++)if(e[o]===t&amp;&amp;r++,e[o]==</span>=n&amp;&amp;r--,r<span class="fstat-no" title="function not covered" >&lt;0</span>)retu<span class="cstat-no" title="statement not covered" >rn o;return i.error("Statem<span class="cstat-no" title="statement not covered" >ent had no close parenthesis in SPARQL query"),0}function S(e){<span class="cstat-no" title="statement not covered" >return th<span class="cstat-no" title="statement not covered" >i</span></span></span>s.describe=f</span>unction(t<span class="fstat-no" title="function not covered" >){</span>retur<span class="cstat-no" title="statement not covered" >n t+" = "+e.toNT()},this.test=fu<span class="cstat-no" title="statement not covered" >nction(t){return e.sameTerm(t)},this}function N(e){this.describe=functi<span class="cstat-no" title="statement not covered" >o</span></span>n(t){retu</span>rn"REGEXP<span class="fstat-no" title="function not covered" >( </span>'"+e+<span class="cstat-no" title="statement not covered" >"' , "+t+" )"},this.test=f<span class="cstat-no" title="statement not covered" >u</span>nction(t){var <span class="cstat-no" title="statement not covered" >n=e,r=new Re<span class="cstat-no" title="statement not covered" >gExp(n);return!!t.value&amp;&amp;r.test(t.value)}}function R(e,t)</span>{3!==<span class="cstat-no" title="statement not covered" >e.length||"Variab<span class="cstat-no" title="statement not covered" ></span>le"!==e[0].termType||"NamedNode"!==e[2</span>].ter<span class="cstat-no" title="statement not covered" >mType&amp;&amp;"Literal"!==e[2].termType?6===e.length&amp;&amp;"string</span></span></span>"==typeof<span class="fstat-no" title="function not covered" > e</span>[0]&amp;&amp;"reg<span class="cstat-no" title="statement not covered" >exp"===e[0].to</span>Lo<span class="cstat-no" title="statement not covered" >wer<span class="cstat-no" title="statement not covered" ></span>Case()&amp;&amp;"("===e[1]&amp;&amp;")<span class="cstat-no" title="statement not covered" >"===e[5]&amp;&amp;</span>",<span class="cstat-no" title="statement not covered" >"===e[3]&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>"Variable<span class="cstat-no" title="statement not covered" >"===e[4].<span class="cstat-no" title="statement not covered" >termType&amp;&amp;"Literal"===e[2].termType&amp;&amp;</span>(i.de<span class="cstat-no" title="statement not covered" >bug("</span>Co<span class="cstat-no" title="statement not covered" >nstra<span class="cstat-no" title="statement not covered" ></span>int adde</span>d: "+<span class="cstat-no" title="statement not covered" >e),t.constraints[e[4]]=new N(e[2].valu</span></span>e)):"<span class="cstat-no" title="statement not covered" >="===e[1]?(i.debug("Constraint added: <span class="cstat-no" title="statement not covered" ></span></span>"</span>+e),t.con</span>straints[<span class="fstat-no" title="function not covered" >e[</span>0]]=new<span class="cstat-no" title="statement not covered" > S(e[2])):"&gt;"===e[1]?(i.debug("Constraint added: "+e),t.co<span class="cstat-no" title="statement not covered" >n</span>straints[e[0]]=new S(e[2])):"&lt;<span class="cstat-no" title="statement not covered" >"===e[1]?(i.debug("Constraint added<span class="cstat-no" title="statement not covered" >: "+e),t.<span class="cstat-no" title="statement not covered" >c</span></span></span>onstraints[e[0]]=new S(e[2])):i.warn("I don't know how to handle the co</span>nstraint:<span class="fstat-no" title="function not covered" > "</span>+e)<span class="cstat-no" title="statement not covered" >}function j(e,t){i.de<span class="fstat-no" title="function not covered" >bu</span>g("Optiona<span class="cstat-no" title="statement not covered" >l query: "+e+" not yet im</span>plemented."<span class="fstat-no" title="function not covered" >);</span>var r=n.fo<span class="cstat-no" title="statement not covered" >rmula();O(e,r),t.optio</span>nal.pus</span>h(r)}func<span class="fstat-no" title="function not covered" >ti</span>on <span class="cstat-no" title="statement not covered" >O(e,t){var n,r<span class="fstat-no" title="function not covered" >=b</span>(e);i.debu<span class="cstat-no" title="statement not covered" >g("WHERE: "+r);for(var o;x("OPTIONA</span>L",r);)o=x(<span class="fstat-no" title="function not covered" >"O</span>PTIONAL",r),i.de<span class="cstat-no" title="statement not covered" >bu</span>g(<span class="cstat-no" title="statement not covered" >"OPT: "+o+" "+<span class="cstat-no" title="statement not covered" ></span>r[o]+" in "+r),"{"!==r[o+1]&amp;&amp;i.war</span>n(</span>"Bad opti<span class="fstat-no" title="function not covered" >on</span>al op<span class="cstat-no" title="statement not covered" >ening bracket in word "+o),n=E(r.slice(o+2),"{","}"),n===-1?i.error("No matching bracket in word "+o):(j(r.slice(o+2,o+2+n),t),o=x("OPTIONAL",r),n=E(r.slice(o+2),"{","}"),r.splice(o,n+3));for(i.debug("WHERE after optionals: "+r);x("FILTER",r);){var a=x("FILTER",r);"("!==r[a+1]&amp;&amp;i.warn("Bad filter opening bracket in word "+a),n=E(r.slice(a+2),"(",")"),n===-1?i.error("No matching bracket in word "+a):(R(r.slice(a+2,a+2+n),t),a=x("FILTER",r),n=E(r.slice(a+2),"(",")"),r.splice(a,n+3))}i.debug("WHERE after filters and optionals: "+r),I(r,t)}function I(e,t){var n=new Array(1);n[0]=-1;for(var r=n.concat(_(".",e)),o=</span>[],a=0;a&lt;<span class="fstat-no" title="function not covered" >r.</span>lengt<span class="cstat-no" title="statement not covered" >h-1;a++)o[a]=e.slice(r[a]+1,r[a+1]);for(a in o){i.info(</span>"s+p+<span class="cstat-no" title="statement not covered" >o "+a+" = "+<span class="cstat-no" title="statement not covered" ></span>o[a]);var s=o[a][0];o[a].sp</span>lice(0,1)<span class="fstat-no" title="function not covered" >;v</span>ar u=n.concat<span class="cstat-no" title="statement not covered" >(_(";<span class="cstat-no" title="statement not covered" ></span>",o[a]));u.push(o[a].<span class="cstat-no" title="statement not covered" >l</span>ength);for(var l=[],c=0;c&lt;<span class="cstat-no" title="statement not covered" >u.length-1;c++)l[c]=o[a].slice(u[c]+1,u[c+1]);for(a in l){i.info("p+o "+a+" = "+o[a]);var f=l[a][0];l[a].splice(0,1);var h=n.concat(_(",",l[a]));h.push(l[a].length);var d=[];for(c=0;c&lt;h.length-1;c++)d[c]=l[a].slice(h[c]+1,h[c+1]);for(a in d){var p=d[a][0];i.info("Subj="+s+" Pred=<span class="cstat-no" title="statement not covered" >"</span></span>+f+" Obj="+p),t.add(s,f,p)}}}}var C=[];i.info("SPARQL input: \<span class="cstat-no" title="statement not covered" >n"+e);var A=ne<span class="cstat-no" title="statement not covered" ></span>w o,L=w(e),D=T(L);D.rdf||(D.rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"),D.rdfs||(D.rdfs="http://www.w3.org/2000/01/rdf-schema#");var P=x("SELECT",L),U=x("WHERE",L);if(P&lt;0||U&lt;0||P&gt;U)return i.error("Invalid or nonexis<span class="cstat-no" title="statement not covered" ></span>t</span>ent SELECT and WHERE tags in SPARQL query"),!1;if(k(L.sl</span>ice(P+1,U<span class="fstat-no" title="function not covered" >),</span>A),O(L.slic<span class="cstat-no" title="statement not covered" >e(U+2,L.lengt<span class="cstat-no" title="statement not covered" ></span>h-1),A.p<span class="cstat-no" title="statement not covered" >a</span>t),t)return A;for(var M in A.pat.statements){var q=A.p<span class="cstat-no" title="statement not covered" >at.statements[M];"NamedNode"<span class="cstat-no" title="statement not covered" >=</span></span>==q.subject<span class="cstat-no" title="statement not covered" >.termType&amp;&amp;n.fetcher&amp;&amp;n.fetcher</span>.look<span class="cstat-no" title="statement not covered" >UpThing(<span class="cstat-no" title="statement not covered" ></span>q.subject,"sparql:</span>"+q.s<span class="cstat-no" title="statement not covered" >ubject),"NamedNode"===<span class="cstat-no" title="statement not covered" ></span>q.object.termType&amp;&amp;n<span class="cstat-no" title="statement not covered" >.</span>fetcher&amp;&amp;n.fetcher.lookUpThing(q.<span class="cstat-no" title="statement not covered" >object,"sparql:"+q.object)}retu<span class="cstat-no" title="statement not covered" >r</span></span>n A}var i=n<span class="cstat-no" title="statement not covered" >(15),o=n(74).Query;e.exports=</span>r},fu<span class="cstat-no" title="statement not covered" >nction(e<span class="cstat-no" title="statement not covered" ></span>,t,n){"use strict"</span>;func<span class="cstat-no" title="statement not covered" >tion r(e){return e&amp;&amp;e.<span class="cstat-no" title="statement not covered" ></span>__esModule?e:{default</span>:e}}v<span class="cstat-no" title="statement not covered" >ar <span class="cstat-no" title="statement not covered" ></span>i="function"==typeof Symb<span class="cstat-no" title="statement not covered" >ol&amp;&amp;"symbol"==typeof Symbol.ite<span class="cstat-no" title="statement not covered" >r</span></span>ator?function(e){<span class="cstat-no" title="statement not covered" >return t<span class="cstat-no" title="statement not covered" ></span>ypeof e}:function(e){return e&amp;&amp;"function"==typeof Sym</span>b</span>o</span>l</span>&amp;&amp;e.co<span class="cstat-no" title="statement not covered" >nst<span class="cstat-no" title="statement not covered" ></span>ructor===Symbol?"symbol":typeo</span>f e},<span class="cstat-no" title="statement not covered" >o=n(4),a</span>=r<span class="cstat-no" title="statement not covered" >(o),s</span>=n<span class="cstat-no" title="statement not covered" >(7).d<span class="cstat-no" title="statement not covered" ></span>ocpart,u=n(77),l=n(75).graph,c=n(75).namedNode,f=n(73),h=n(70),d=n(7).join,p=n(5),v=function(){var e=function(e){if(thi</span>s.sto<span class="cstat-no" title="statement not covered" >re=e,e.updater</span>)t<span class="cstat-no" title="statement not covered" >hrow new Erro<span class="cstat-no" title="statement not covered" ></span>r("You can't have<span class="cstat-no" title="statement not covered" > two UpdateManagers for the same store");e.fetcher||new u(e),e.updater=this,this.i<span class="cstat-no" title="statement not covered" >f</span></span>ps={},this.fps={},this.ns={},this.ns.link=f("http://www.w<span class="cstat-no" title="statement not covered" >3.org/200<span class="cstat-no" title="statement not covered" >7</span></span>/ont/link#"),this.ns.http=f("http://<span class="cstat-no" title="statement not covered" >www.w3.org/2007/ont/<span class="cstat-no" title="statement not covered" ></span>http#"),this.ns.httph=f("http://www.w3.org/2007/ont/httph#"),this.ns.ldp=f("http://www.w3.org/ns/ldp#"),this.ns.rdf=f("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),this.ns.rdfs=f("http://www.w3<span class="cstat-no" title="statement not covered" ></span>.</span>org/2000/</span>01/rdf<span class="cstat-no" title="statement not covered" >-schem</span>a#<span class="cstat-no" title="statement not covered" >"),this.ns.r<span class="cstat-no" title="statement not covered" ></span>df=f("http://</span>w<span class="fstat-no" title="function not covered" >ww</span>.w3.org/1999/02/22-rdf-syntax-ns#"),<span class="fstat-no" title="function not covered" >th</span>is.<span class="cstat-no" title="statement not covered" >ns.owl=f("http://www.w3.org/2002/07/ow</span>l#"),t<span class="cstat-no" title="statement not covered" >his.patchControl=[]};return e.prototype.patchControlFor=func<span class="fstat-no" title="function not covered" >ti</span>on(e){retu<span class="cstat-no" title="statement not covered" >rn this.patchCont</span>r<span class="fstat-no" title="function not covered" >ol</span>[e.uri]||(<span class="cstat-no" title="statement not covered" >this.patchControl[e.uri]=[]),this.patchControl[e.uri]},e.prototype.editable=fun</span>c</span>ti<span class="cstat-no" title="statement not covered" >on(e,</span>t)<span class="cstat-no" title="statement not covered" >{if(!</span>e)<span class="cstat-no" title="statement not covered" >return!1;if(t</span>||<span class="cstat-no" title="statement not covered" >(t=thi</span>s.<span class="cstat-no" title="statement not covered" >store),"file</span>:/<span class="cstat-no" title="statement not covered" >//"===e.slice(0,</span>8)<span class="cstat-no" title="statement not covered" >){if(t</span>.h<span class="cstat-no" title="statement not covered" >olds(t</span>.s<span class="cstat-no" title="statement not covered" >ym(e),c("h</span>tt<span class="cstat-no" title="statement not covered" >p://w</span>ww<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >.w</span>3.org/1999/02/2<span class="cstat-no" title="statement not covered" >2-rdf-syntax-ns#type"),c("http://w<span class="fstat-no" title="function not covered" >ww</span>.w3.o<span class="cstat-no" title="statement not covered" >rg/2007/ont/link#MachineEditab<span class="cstat-no" title="statement not covered" >leDocument")))return"LOCALFILE";var n=t.statementsMatching(t.sym(e),void<span class="cstat-no" title="statement not covered" > </span></span>0,void 0);return console.log("sparql.editable: Not MachineEditableDocument file "+e+"\n"),console.log(n.map(function(e){return e.toNT()}).join("\n")),!1}var r,i=!1,o=t.each(void 0,this.ns.link("requestedURI"),s(e));if(t.holds(c(e),this.ns.rdf("type"),this.ns.ldp("Resource")))return"SPARQL";for(var a,u,l=0;l&lt;o.length;l++)if(r=o[l],void 0!==r){var f=t.any(r,this.ns.link("response"));if(void 0!==r){var h=t.each(f,this.ns.httph("accept-patch"));if(h.length)for(a=0;a&lt;h.length;a++)if(u=h[a].value.trim(),u.indexOf("applicat</span>i<span class="cstat-no" title="statement not covered" ></span>on/sparql-update")&gt;=0)return"SPARQL<span class="fstat-no" title="function not covered" >";</span>var d=t.ea<span class="cstat-no" title="statement not covered" >ch(f,this.ns.httph("ms-author-via"));if(d.length)for(a=0;a&lt;d.length;a++){if(u=d[a].value.</span>trim(),u.indexOf("SPAR<span class="fstat-no" title="function not covered" >QL</span>")&gt;=0)return<span class="cstat-no" title="statement not covered" >"SPARQ<span class="cstat-no" title="statement not covered" >L";if(u.i<span class="cstat-no" title="statement not covered" >n</span></span>dexOf("DAV")&gt;=0)return"DAV"}var p=t.each(f,this<span class="cstat-no" title="statement not covered" >.ns.http("status"));if(p.length)for(a=0;a&lt;p.length;a++)200!==p[a]&amp;&amp;404!==p[a]||(i=!0)}else console.log("sparql.editable: No response fo<span class="cstat-no" title="statement not covered" >r "+e+"\n")}if(0===</span></span>o.len<span class="cstat-no" title="statement not covered" >gth)console.log("sparql.editable: No request <span class="cstat-no" title="statement not covered" ></span>for "+e+"\n");else if(i)return!1;<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >console.log("sparql.editable: inconclusive for "+e+"\n")},</span>e.prototype.anonymize=f<span class="fstat-no" title="function not covered" >un</span>ction(e){r<span class="cstat-no" title="statement not covered" >eturn"_:"===e.toNT().substr(0,2)&amp;&amp;this._mentioned(e)?"?"+e.toNT().substr(2):e.toNT()},e</span>.prototype.anonymizeNT=fu<span class="fstat-no" title="function not covered" >nc</span>tion(e){re<span class="cstat-no" title="statement not covered" >turn this.anonymize(e.subject)+" "+this.anonymize(e.predicate)+" "+this.anonymize(e.object)+" ."},e.</span>prototype._statement_bnodes=fun<span class="fstat-no" title="function not covered" >ct</span>ion(e){ret<span class="cstat-no" title="statement not covered" >urn[e.subject,e.predicate,e.object].filter(fun<span class="fstat-no" title="function not covered" >ct</span>ion(e){ret<span class="cstat-no" title="statement not covered" >urn e.isBlank})},e</span>.pr</span>ototype._statement_array_bnodes=funct<span class="fstat-no" title="function not covered" >io</span>n(e){for(v<span class="cstat-no" title="statement not covered" >ar t=[],n=0;n&lt;e.length;n++)t=t.c<span class="cstat-no" title="statement not covered" >oncat(this._statement_bnodes(e[n]));t.sor<span class="cstat-no" title="statement not covered" >t</span></span>();for(v<span class="cstat-no" title="statement not covered" >a</span>r r=[],i=0;i&lt;t.length;i++)0!==i<span class="cstat-no" title="statement not covered" >&amp;&amp;t[i].sameTerm(t[i-1])||r.push(t[i]);retur<span class="cstat-no" title="statement not covered" >n</span></span> r},e.pro</span>totype._cache_ifps=functi<span class="fstat-no" title="function not covered" >on</span>(){this.i<span class="cstat-no" title="statement not covered" >fps={};for(va<span class="cstat-no" title="statement not covered" >r</span> e=this.store.each(void 0,this.ns.rdf("type"),this.ns.owl("InverseFunctionalProperty")),t=0;t&lt;e.length;t++)this.i<span class="cstat-no" title="statement not covered" >fps[e[t].uri]=!0;for(th<span class="cstat-no" title="statement not covered" >i</span></span>s.fps={},e=this.store.each(void 0,this.ns.rdf("type"),this.ns.owl("FunctionalProperty")),t=0;t&lt;e.length;t++)this.f<span class="cstat-no" title="statement not covered" >ps[e[t].uri]=!0},e.prot</span></span>otype._bnode_context2=functio<span class="fstat-no" title="function not covered" >n(</span>e,t,n){for(var<span class="cstat-no" title="statement not covered" > r,i,o=this.store.statementsMatching(void 0,void 0,e,t),a=0;a&lt;o.length;a++)if(this<span class="cstat-no" title="statement not covered" >.fps[o[a].predicate.uri]){if(r=o[<span class="cstat-no" title="statement not covered" >a].subject,!r.isBlank)return[<span class="cstat-no" title="statement not covered" >o[a]];if(n&amp;&amp;(<span class="cstat-no" title="statement not covered" >i</span></span>=this._bnode_context2(r,t,n-1)))return <span class="cstat-no" title="statement not covered" >i.concat([o[a]])}for(o=th<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>s.store.statementsMatching(e,void 0,void 0,t),a=0;a&lt;o.length;a++)if(this.<span class="cstat-no" title="statement not covered" >ifps[o[a].predicate.uri]){if(r=o[a<span class="cstat-no" title="statement not covered" >].object,!r.isBlank)return[o<span class="cstat-no" title="statement not covered" >[a]];if(n&amp;&amp;(i<span class="cstat-no" title="statement not covered" >=</span></span>this._bnode_context2(r,t,n-1)))return i<span class="cstat-no" title="statement not covered" >.concat([o[a]])}return nu<span class="cstat-no" title="statement not covered" ></span></span>l</span></span>l},e.prototy</span>pe._bnode_context_1=function(e<span class="fstat-no" title="function not covered" >,t</span>){for(var n=<span class="cstat-no" title="statement not covered" >0;n&lt;3;n++){var r=this._bnod<span class="cstat-no" title="statement not covered" >e_context2(e,t,n);if(null!==<span class="cstat-no" title="statement not covered" ></span>r)return r}r<span class="cstat-no" title="statement not covered" >eturn this<span class="cstat-no" title="statement not covered" ></span></span>.</span>store.connectedStatements(e,t)},e.prototype</span>._mentioned=function(e){<span class="fstat-no" title="function not covered" >re</span>turn 0!==t<span class="cstat-no" title="statement not covered" >his.store.statementsMatching(e).length||0!==this.store.statementsMatching(void 0,e).length||0!==this.store.statementsMatching(void 0,void 0,e).length},e.prototype.</span>_bnode_context=function(e,t)<span class="fstat-no" title="function not covered" >{v</span>ar n=[];if(e.lengt<span class="cstat-no" title="statement not covered" >h){<span class="cstat-no" title="statement not covered" ></span>this._cache_i<span class="cstat-no" title="statement not covered" >fps();for(var r=0;r<span class="cstat-no" title="statement not covered" >&lt;</span>e.length;r++){var i=e[r];this._me<span class="cstat-no" title="statement not covered" >ntion<span class="cstat-no" title="statement not covered" ></span>ed(i)&amp;&amp;(n=n.concat(this._bnode_context_1(i,t)))}}return n},e.p</span>r<span class="cstat-no" title="statement not covered" ></span>o</span>totype._s</span>tatement_context=function(e){var<span class="fstat-no" title="function not covered" > t</span>=this._statement<span class="cstat-no" title="statement not covered" >_bnodes(e);return this._bn<span class="cstat-no" title="statement not covered" ></span>ode_context(t,e.why)},e.prototype._co</span>ntext_where=function(e){var <span class="fstat-no" title="function not covered" >t=</span>this;return e&amp;&amp;0<span class="cstat-no" title="statement not covered" >!==e.<span class="cstat-no" title="statement not covered" ></span>length?"WHERE { "+e.map(function(e){retu<span class="fstat-no" title="function not covered" >rn</span> t.anonymi<span class="cstat-no" title="statement not covered" >zeNT(e)}).join("\n")+" }\</span>n":""},e.prototype._fire</span>=function(e,t,n){if<span class="fstat-no" title="function not covered" >(!</span>e)throw new Er<span class="cstat-no" title="statement not covered" >ror("N<span class="cstat-no" title="statement not covered" >o URI given for remote editing operation: "+t);console.log("sparq<span class="cstat-no" title="statement not covered" >l</span></span>: sending update to &lt;"+e+"&gt;");var r=p.XMLHTTPFact</span>ory()<span class="cstat-no" title="statement not covered" >;r.options={},r.onr<span class="cstat-no" title="statement not covered" ></span>eadystatechange=function(){if(4===<span class="fstat-no" title="function not covered" >r.</span>readyStat<span class="cstat-no" title="statement not covered" >e){var i=!r.status||r.statu<span class="cstat-no" title="statement not covered" >s&gt;=200&amp;&amp;r.status&lt;300;i?console.log("spa<span class="cstat-no" title="statement not covered" ></span>rql: update Ok for &lt;"+e+"&gt;"):console.log("sparql: update failed for &lt;"+e+"&gt; status="+r.status+", "+r.statusText+", body length="+r.responseText.length+"\n   for query: "+t),n(e,i,r.responseText,r)}},r.open("PATCH",e,</span>!</span>0),r.setRequestHeader("Content-type","application/sparql-update"),r.send(t)},e.prototype.update_</span>statement=function(e){if(!e||e<span class="fstat-no" title="function not covered" >.w</span>hy){var t=<span class="cstat-no" title="statement not covered" >this,n=this._stateme<span class="cstat-no" title="statement not covered" >nt_co</span>nt<span class="cstat-no" title="statement not covered" >ext(e);return{statement:e?[<span class="cstat-no" title="statement not covered" ></span>e.subject,e.predicate,e.object,e.why]:void 0,statementNT:e?this.anonymizeNT(e):void 0,where:t._context_where(n),set_object:function(e,n){var r=this.where;r+="DELETE DATA { "+thi<span class="fstat-no" title="function not covered" >s.statement</span>NT+" } ;\n"<span class="cstat-no" title="statement not covered" >,r+="INSERT<span class="cstat-no" title="statement not covered" ></span> DATA { "+this.anonymize(this.statement[0])+" "+this.anonymize(this.statement[1])+" "+this.anonymize(e)+"  . }\n",t._fire(this.statement[3].uri,r,n)}}}},e.prototype.insert_statement=function(e,t){var n=e in</span>sta</span>n</span>ceof Array?e[0]:e,r=this._cont<span class="fstat-no" title="function not covered" >ex</span>t_where(this._stat<span class="cstat-no" title="statement not covered" >ement_context(n));if(e ins</span>ta<span class="cstat-no" title="statement not covered" >nceof Array){for(var i="",o=0;o&lt;e.length;o++)i+=<span class="cstat-no" title="statement not covered" ></span>e[o]+"\n";r+="INSERT DA<span class="cstat-no" title="statement not covered" >TA { "+i+" }\n"}else r+="INSERT <span class="cstat-no" title="statement not covered" >DATA { "+this<span class="cstat-no" title="statement not covered" >.</span></span>anonymize(e.subject)+" "+this</span>.anon<span class="cstat-no" title="statement not covered" >ymize(e.predicate)+" "+this.anonymize(e.object)+"  . }\n";this._fire(n.why.uri,r,t)},e.prototype.delete_statement=fun<span class="cstat-no" title="statement not covered" >c</span></span>tion(e,t){var n=e instance</span>of Array?e[0]:e,r=this._contex<span class="fstat-no" title="function not covered" >t_</span>where(this._statem<span class="cstat-no" title="statement not covered" >ent_context(n));if(e insta</span>nc<span class="cstat-no" title="statement not covered" >eof Array){for(var i="",o=0;o&lt;e.length;o++)i+=e[<span class="cstat-no" title="statement not covered" ></span>o]+"\n";r+="DELETE DATA<span class="cstat-no" title="statement not covered" > { "+i+" }\n"}else r+="DELETE DA<span class="cstat-no" title="statement not covered" >TA { "+this.a<span class="cstat-no" title="statement not covered" >n</span></span>onymize(e.subject)+" "+this.a</span>nonym<span class="cstat-no" title="statement not covered" >ize(e.predicate)+" "+this.anonymize(e.object)+"  . }\n";this._fire(n.why.uri,r,t)},e.prototype.requestDownstreamActio<span class="cstat-no" title="statement not covered" >n</span></span>=function(e,t){var n=this.</span>patchControlFor(e);if(n.pendingUpstre<span class="fstat-no" title="function not covered" >am</span>){if(n.downstreamA<span class="cstat-no" title="statement not covered" >ction){if(n.downstreamAc<span class="cstat-no" title="statement not covered" ></span>tion===t)return;throw <span class="cstat-no" title="statement not covered" >new Error("Can't wait f<span class="cstat-no" title="statement not covered" >or &gt; 1 differnt downstream<span class="cstat-no" title="statement not covered" > action<span class="cstat-no" title="statement not covered" >s</span></span>")}n.downstreamAction=t}else t(e)},e.prototype.clearUpstreamCount=<span class="cstat-no" title="statement not covered" ></span>f</span>unction(e){var t=this</span>.patc<span class="cstat-no" title="statement not covered" >hContr</span></span>olFor(e);t.upstreamCount=0},e.pr<span class="fstat-no" title="function not covered" >ot</span>otype.getUpdates<span class="cstat-no" title="statement not covered" >Via=function(e){var t=th<span class="cstat-no" title="statement not covered" ></span>is.store.fetcher.ge</span>tHeader(e,"updates-via");re<span class="fstat-no" title="function not covered" >tu</span>rn t&amp;&amp;t.length?t<span class="cstat-no" title="statement not covered" >[0].trim():null},e.prototype.addDownstreamChan<span class="cstat-no" title="statement not covered" ></span>geListener=function(e,t){var n=this.p</span>atchControlFor(e);n.downstreamChangeListe<span class="fstat-no" title="function not covered" >ne</span>rs||(n.downstreamC<span class="cstat-no" title="statement not covered" >hangeListeners=[]),n.dow<span class="cstat-no" title="statement not covered" ></span>nstreamChangeListeners.push(t);var r=this;this.setRefreshHandler(e,function(e){r.reloadAndSync(e)})</span>},e.p<span class="cstat-no" title="statement not covered" >rotot<span class="cstat-no" title="statement not covered" ></span>ype.reloadAndSync=functio<span class="fstat-no" title="function not covered" >n(</span>e){var t=t<span class="cstat-no" title="statement not covered" >his.patchControlFor(</span>e),</span>n=this;if(t.reloading)retur<span class="fstat-no" title="function not covered" >n </span>void console.log<span class="cstat-no" title="statement not covered" >("   Already reloading -</span> s<span class="cstat-no" title="statement not covered" >top")<span class="cstat-no" title="statement not covered" ></span>;t.reloading=!0<span class="cstat-no" title="statement not covered" >;var r=1e3,i=function i(){console.log("try reload - tim<span class="cstat-no" title="statement not covered" >e</span></span>out = "+r),n.re</span>load(<span class="cstat-no" title="statement not covered" >n.st</span>or<span class="cstat-no" title="statement not covered" >e,e,funct<span class="fstat-no" title="function not covered" >io</span>n(<span class="cstat-no" title="statement not covered" >n,o,a){if(t.reloading=!1,n){if(t.downstreamChangeListeners)f<span class="fstat-no" title="function not covered" >or</span>(var s=0;s&lt;t.d<span class="cstat-no" title="statement not covered" >ownstreamChangeListen<span class="cstat-no" title="statement not covered" >ers.length;s++)console.log("   <span class="cstat-no" title="statement not covered" >     Calling downstream listener "+s),t.downstreamCha<span class="cstat-no" title="statement not covered" >ngeListeners[s]()}else 0===a.status?(console.log("Network error refreshing the data. Ret</span></span></span>rying<span class="cstat-no" title="statement not covered" > in "+r/1e3),t.reloading=!0,r*=2,setTimeout(i,r)):console.log("Error "+a.status+"refreshing the data:"+o+". Stopped"+e)})};i()},e.prototype.setRefreshHandler=function(e,t){var n=this.getUpdat</span></span>esV</span>i<span class="cstat-no" title="statement not covered" ></span>a(e),</span>r=t,i=this,o=this,a=1500,s=0;if<span class="fstat-no" title="function not covered" >(!</span>n)return console.l<span class="cstat-no" title="statement not covered" >og("Server doies not s</span>up<span class="cstat-no" title="statement not covered" >po</span>rt<span class="cstat-no" title="statement not covered" > live</span> u<span class="cstat-no" title="statement not covered" >pdate</span>s <span class="cstat-no" title="statement not covered" >thoug</span>hU<span class="cstat-no" title="statement not covered" >pd<span class="cstat-no" title="statement not covered" ></span>ates-V<span class="cstat-no" title="statement not covered" >ia :-("),!1;n=d(n,e.uri),n=n.replace(/^http:/,"ws:").replace(/^https:/,"wss:"),consol<span class="cstat-no" title="statement not covered" >e</span></span>.log("Web socket URI "+n);var u=function t(){var u;if("undefined"!=typeof WebSocket)u=new WebSocket(</span>n);el<span class="cstat-no" title="statement not covered" >se if("un<span class="fstat-no" title="function not covered" >de</span>fined"!=<span class="cstat-no" title="statement not covered" >typeof Services)u=Services.wm.get<span class="cstat-no" title="statement not covered" >MostRecentWindow("na</span>viga<span class="cstat-no" title="statement not covered" >tor:browser").WebSocket(n);else{<span class="cstat-no" title="statement not covered" >if("undefined"==typeof window||!window.WebSocket)return void console.</span>log(<span class="cstat-no" title="statement not covered" >"Live update disabled, as WebSocket not supported<span class="cstat-no" title="statement not covered" > by platform :-(");u=window.WebSocket(n)}u.onopen=function(){console.log("    websocket open<span class="cstat-no" title="statement not covered" >"</span></span>),a=1500,this.send("su<span class="cstat-no" title="statement not covered" ></span>b</span></span> "+e.uri<span class="fstat-no" title="function not covered" >),</span>s&amp;&amp;(conso<span class="cstat-no" title="statement not covered" >le.log("Web socket has been down, better check for any news."),o.requestDownstreamAction(e,r))};var l=i.patchControlFor(e);l.upstreamCount=0,u.onclose=function(e){console</span>.l</span>og("*<span class="cstat-no" title="statement not covered" >** Websocket closed w<span class="cstat-no" title="statement not covered" ></span>ith code "+e.code+", reason <span class="fstat-no" title="function not covered" >'"</span>+e.reason+<span class="cstat-no" title="statement not covered" >"' clean = "+e.clean),a*=2,s+=1,console.log("Retrying in "+a+"ms"),setTimeout(function(){console.log("Trying websocket again"),t()},a)},u.onmessage=funct<span class="fstat-no" title="function not covered" >io</span>n(t){if(t<span class="cstat-no" title="statement not covered" >.data&amp;&amp;"pub"===t.data.slice(0,3)){if("upstr</span>eamCo</span>unt"in l&amp;&amp;(l.<span class="fstat-no" title="function not covered" >up</span>streamCoun<span class="cstat-no" title="statement not covered" >t-=1,l.upstreamCount&gt;=0))return void c<span class="cstat-no" title="statement not covered" >onsole.log("just an echo: "+l.upstreamCount);console.log("Assume<span class="cstat-no" title="statement not covered" > a real downstream change: "+l.upstreamCount+" -&gt; 0"),l.up<span class="cstat-no" title="statement not covered" >s</span></span>treamCount=0,i.requestDownstreamAction(e,r)}}};return u(),!0},e.prototype.update=function(e,t,n){try{var r=this.store,o=e?</span>e</span> i</span>n<span class="cstat-no" title="statement not covered" ></span>stanceof a.defa</span>ult?e.statements:e i<span class="fstat-no" title="function not covered" >ns</span>tanceof Array?<span class="cstat-no" title="statement not covered" >e:[e]:[],s<span class="cstat-no" title="statement not covered" >=t?t instan</span>ce<span class="cstat-no" title="statement not covered" >of a.default?t.statements:t instanceof Array?t:[t]:[];if(!(o insta</span>nc<span class="cstat-no" title="statement not covered" >eof Array))throw new Error("Type Error "+("undefined"==typeof o?"u<span class="cstat-no" title="statement not covered" ></span>ndefined":i(o))+": "+o);i<span class="cstat-no" title="statement not covered" >f(!(s instanceof Array))throw new Error("Type Error "+("undefined"==typeof s?"u<span class="cstat-no" title="statement not covered" >n</span></span>defined":i(s))+": "+s);i<span class="cstat-no" title="statement not covered" >f(0===o.length&amp;&amp;0===s.length)return n(null,!0);var u=o.length?o[0].why:s[0].why<span class="cstat-no" title="statement not covered" >,</span></span>l=this.patchControlFor(u),c=D<span class="cstat-no" title="statement not covered" >ate.now(),f=["subje</span></span>ct","<span class="cstat-no" title="statement not covered" >predicate","object","why"],</span>v=<span class="cstat-no" title="statement not covered" >["insert","delete"],g={d</span>el<span class="cstat-no" title="statement not covered" >ete:o,inser</span>t:<span class="cstat-no" title="statement not covered" >s};v.map(function(e){g[e].map(function(</span>e)<span class="cstat-no" title="statement not covered" >{if(!u.sameTerm(e.wh</span>y)<span class="cstat-no" title="statement not covered" >)throw new Error("up<span class="cstat-no" title="statement not covered" ></span>date: <span class="fstat-no" title="function not covered" >de</span>stination <span class="cstat-no" title="statement not covered" >"+u+" inc<span class="fstat-no" title="function not covered" >on</span>sistent wi<span class="cstat-no" title="statement not covered" >th delete quad "+e.why<span class="cstat-no" title="statement not covered" >);f.map(function(t){if("undefined"==typeof e[t])throw new Error("update: undefined<span class="cstat-no" title="statement not covered" > </span></span>"+t+"<span class="fstat-no" title="function not covered" > o</span>f statemen<span class="cstat-no" title="statement not covered" >t.")})})});var y=this.editab<span class="cstat-no" title="statement not covered" >le(u.uri,r);if(!y)throw new Error("Can't make changes in u</span></span>ned</span>ita</span>ble</span> "+u)<span class="cstat-no" title="statement not covered" >;var m,b,w,x;if(y.index<span class="cstat-no" title="statement not covered" ></span>Of("SP<span class="cstat-no" title="statement not covered" >ARQL")&gt;=0){var _=[];o.length&amp;&amp;(_=this._statement_array_b</span></span>nodes(o)),s<span class="cstat-no" title="statement not covered" >.length&amp;&amp;(_=_.concat(this._statem<span class="cstat-no" title="statement not covered" >ent<span class="cstat-no" title="statement not covered" ></span>_array_bnodes(s)));var k=this._bnode_context(_,u),T=this._context_where(k),E="";if(T.length){if(o.lengt</span>h){fo<span class="cstat-no" title="statement not covered" >r(E+="DELETE { ",m=0;m&lt;o.</span>le<span class="cstat-no" title="statement not covered" >ngth;m++)E+=this.anonym</span>iz<span class="cstat-no" title="statement not covered" >eNT<span class="cstat-no" title="statement not covered" ></span>(o[m])+"\n";E<span class="cstat-no" title="statement not covered" >+=" }\n"}if(s<span class="cstat-no" title="statement not covered" >.length){for(E+="INSERT { ",m=0;m&lt;s.le<span class="cstat-no" title="statement not covered" >ngth;m++)E+=this.anonymizeNT(s[<span class="cstat-no" title="statement not covered" >m</span></span>])+"\n";E+<span class="cstat-no" title="statement not covered" ></span>=</span>" }\n"}E+=T}<span class="cstat-no" title="statement not covered" >else{if(o.length){for(E+="DELETE DATA <span class="cstat-no" title="statement not covered" >{ ",m=0;m&lt;o.length;m++)E+=this.<span class="cstat-no" title="statement not covered" >a</span></span>nonymizeNT<span class="cstat-no" title="statement not covered" ></span>(</span>o[m])</span>+"\n"<span class="cstat-no" title="statement not covered" >;E+=" } \n"}i<span class="cstat-no" title="statement not covered" >f(s.length){for(o.length&amp;&amp;(E+=" ; "),E+="IN<span class="cstat-no" title="statement not covered" >SERT DATA { ",m=0;m&lt;s.length;m+<span class="cstat-no" title="statement not covered" >+</span></span>)E+=this.an<span class="cstat-no" title="statement not covered" ></span>o</span>nymizeNT(s[m<span class="cstat-no" title="statement not covered" >])+"\n";E+=" }\n"}}l.pendingUpstream=l.pendingUpstream?l.pending<span class="cstat-no" title="statement not covered" >Upstream+1:1,"upstreamCount"in <span class="cstat-no" title="statement not covered" >l</span></span>&amp;&amp;(l.upstr</span>e<span class="cstat-no" title="statement not covered" ></span>a</span>mCount+=1,console.log("upstream count up to : "+l.upstreamCount)),this._fire(u.uri,E,function(e,t,i,a){if(a.elapsedTime_ms=Date.now()-c,console.log("    sparql: Return "+(t?<span class="fstat-no" title="function not covered" >"s</span>uccess":"FAILURE<span class="cstat-no" title="statement not covered" > "+a.status)+" elapsed "+a.elapsedTime_ms+"ms"),t){try{r.remove(o)}catch(e){t=!1,i="Remote Ok BUT error deleting "+o.length+" from store!!!<span class="cstat-no" title="statement not covered" > "+e<span class="cstat-no" title="statement not covered" >}for(var f=0;</span>f&lt;s.lengt<span class="cstat-no" title="statement not covered" >h;f++)r.add(s[f].subject,s[f].predicate,s[f].object,u)}if(n(e,t,i,a),<span class="cstat-no" title="statement not covered" ></span>l</span>.pendingUpstream-=1,0===l.<span class="cstat-no" title="statement not covered" >pendingUpstream&amp;&amp;l.downstreamAction){var h=l.downs<span class="cstat-no" title="statement not covered" ></span></span>t</span>reamAction;delete l.downstreamAction,console.log("delayed downstream action:"),h(u)<span class="cstat-no" title="statement not covered" >}})}else if(y.index<span class="cstat-no" title="statement not covered" ></span>Of("DAV")&gt;=0){var S=r.any(u,this.ns.link("request"));if(!S)throw new Error</span>(</span>"No</span> reco<span class="cstat-no" title="statement not covered" >rd of our HTTP GET request for<span class="cstat-no" title="statement not covered" > document: "+u);var N=r.any(S,thi<span class="cstat-no" title="statement not covered" ></span>s.ns.l<span class="cstat-no" title="statement not covered" >ink("response"));if(!N)return null;var R=r.the(N,this.ns.httph("content</span></span>-type<span class="cstat-no" title="statement not covered" >")).value;for(b=r.statementsMatchi<span class="cstat-no" title="statement not covered" ></span>ng(voi<span class="cstat-no" title="statement not covered" >d 0,void 0,vo</span></span>id 0,<span class="cstat-no" title="statement not covered" >u).slice(),m=0;m&lt;o.length;m++)p.RDFArrayRemov<span class="cstat-no" title="statement not covered" ></span>e(b,o[m]);for(m=0;m&lt;s.length;m++)b.push(s[m]);switch(x=h(r),x.suggestNamespace<span class="cstat-no" title="statement not covered" >s(r.namespaces),x.setBase<span class="cstat-no" title="statement not covered" >(</span></span>u.uri),R){case"applica<span class="cstat-no" title="statement not covered" >tion/rdf+xml"<span class="cstat-no" title="statement not covered" >:</span></span>w=x.statementsToXML(b);break;case"text/n3":case"text/turtle":case"application/x-turtle":case"<span class="cstat-no" title="statement not covered" >application/n3":w=x.sta<span class="cstat-no" title="statement not covered" >t</span>ements</span>ToN3(b);break;default:throw new Error("Content-type "+R+" not supported for dat<span class="cstat-no" title="statement not covered" >a write")}var j,O=r.th<span class="cstat-no" title="statement not covered" >e</span>(N,thi</span>s.ns.ht<span class="cstat-no" title="statement not covered" >tph("content-location"));O&amp;&amp;(j=d(O.value,j));var I=p.XMLHTTPFactory(</span>)</span>;I.opti<span class="cstat-no" title="statement not covered" >ons={},I.onreadystatechange=function(){if(4<span class="cstat-no" title="statement not covered" ></span>===I.readyState){var </span>e=!I.<span class="cstat-no" title="statement not covered" >status||I.status&gt;=2<span class="cstat-no" title="statement not covered" ></span>00&amp;&amp;I.status&lt;300;if(e){for(var t=0<span class="fstat-no" title="function not covered" >;t</span>&lt;o.length<span class="cstat-no" title="statement not covered" >;t++)r.remove(o[t]);for(t=0<span class="cstat-no" title="statement not covered" >;t&lt;s.length;t++)r.add(s[t].subject,s[t]<span class="cstat-no" title="statement not covered" ></span>.predi<span class="cstat-no" title="statement not covered" >cate,s[t].object,u)}n(u.uri<span class="cstat-no" title="statement not covered" >,e,I.responseTe<span class="cstat-no" title="statement not covered" >x</span></span>t)}},I.open("PUT",j,!0<span class="cstat-no" title="statement not covered" >),I.setRequestHeader("Content-type",R),I.send(w)}e<span class="cstat-no" title="statement not covered" ></span></span>l</span>se{if(!(y.indexOf("LOCALFI</span>L</span>E")&gt;=0))throw new Error("Unhandled edit method: '"+y+"' for "+u);try</span>{for(<span class="cstat-no" title="statement not covered" >console.log("Writing back to loc<span class="cstat-no" title="statement not covered" >al file\n"),b=r.statementsMatching(void 0,void 0,void 0,u<span class="cstat-no" title="statement not covered" >)</span></span>.sl<span class="cstat-no" title="statement not covered" >ice(),m=0;m&lt;o.length;m++)p.RDFArrayRemove(b,o[m]);for(m=0;m&lt;s.length;m++)b.push(s[m]);x=h(r),x.suggestNamespaces(r.namespa<span class="cstat-no" title="statement not covered" >ces),x.setBase(u.uri);var<span class="cstat-no" title="statement not covered" > </span></span>C=u.uri.lastIndexOf(".<span class="cstat-no" title="statement not covered" >");if(C&lt;1)thr<span class="cstat-no" title="statement not covered" >o</span></span>w new Error("Rewriting file: No filename extension: "+u.ur</span>i);va<span class="cstat-no" title="statement not covered" >r A=u.uri.slice(C+1);sw<span class="cstat-no" title="statement not covered" ></span>itch(A)<span class="cstat-no" title="statement not covered" >{case"rdf":case"owl":case"xml":w=x.statementsToXML(b);break;case"n</span></span>3":ca<span class="cstat-no" title="statement not covered" >se"nt":case"ttl":<span class="cstat-no" title="statement not covered" ></span>w=x.statementsToN3(b);break;default:thro<span class="cstat-no" title="statement not covered" >w new Error("File exten<span class="cstat-no" title="statement not covered" >s</span>ion ."</span>+A+" not supported for data<span class="cstat-no" title="statement not covered" > write")}console.log("<span class="cstat-no" title="statement not covered" >W</span>riting</span> back: <span class="cstat-no" title="statement not covered" >&lt;&lt;&lt;"+w+"&gt;&gt;&gt;");var L=u.uri.slice(7),D=Components.classes["@mozilla.org/f<span class="cstat-no" title="statement not covered" ></span>i</span>le/local;1"].createInstance(Components.in</span>terfa<span class="cstat-no" title="statement not covered" >ces.nsILocalFil</span>e)<span class="cstat-no" title="statement not covered" >;if(D.initWithPath(L),!D.exists())throw new Error("Rewriting file &lt;"+u.uri+"&gt; but it does not exist<span class="cstat-no" title="statement not covered" ></span>!");var P=Components.classes["@mo<span class="cstat-no" title="statement not covered" >zilla.org/network/file-output-stream;1"].createInstance(Components.int</span></span>erfac<span class="cstat-no" title="statement not covered" >es.nsIFileOutputStream);for(P.init(D,42,parseInt("0666",8),0),P.write(w,w.length),P.close(),m=0;m&lt;o.length;m++)r.remove(o[<span class="cstat-no" title="statement not covered" ></span>m]);for(m=0;m&lt;s.length;m++)r.add(s[m].subject,s[m].predicate,s[m].object,u);n(u.uri,!0,<span class="cstat-no" title="statement not covered" >"")}catch(e){n(<span class="cstat-no" title="statement not covered" >u</span></span>.uri,!1,"Exception try<span class="cstat-no" title="statement not covered" >ing to write back file &lt;"+u.uri+"&gt;\n")}}}catch(e)<span class="cstat-no" title="statement not covered" >{</span></span>n(void 0,!1,"Ex</span>ception i<span class="cstat-no" title="statement not covered" >n update: "+e+"\n"+$rdf.Util.stackString(e))}},e.prototype.put=fu</span>n</span>c</span></span>tion(e,t,<span class="cstat-no" title="statement not covered" >n,r){var o,a=this.store;if(("undefined"==typeof t?"undefined":i(t))===</span>i</span>(""))o=t;else{var<span class="fstat-no" title="function not covered" > s</span>=h(a);switch(s.suggestNa<span class="cstat-no" title="statement not covered" >mespaces(a.<span class="cstat-no" title="statement not covered" ></span>namespaces),s.setBase(e.uri),n){case"application/rdf<span class="cstat-no" title="statement not covered" >+xml"</span>:o=s.state<span class="cstat-no" title="statement not covered" >ments<span class="cstat-no" title="statement not covered" ></span>ToXML(t);break;case"text/n3":case"text/turtle":case"application/x-turtle":case"applicat<span class="cstat-no" title="statement not covered" >ion/n3":o=s.statementsT<span class="cstat-no" title="statement not covered" >o</span>N3(t);</span>break;default:throw new Error("Content-type "+n+" not supported for data PUT")}<span class="cstat-no" title="statement not covered" >}var u=p.XMLHTTPFactor<span class="cstat-no" title="statement not covered" >y</span>();u.o</span>ptions=<span class="cstat-no" title="statement not covered" >{},u.onreadystatechange=function(){if(4===u.readyState){var n=!u.s</span>t</span>a</span>tus||<span class="cstat-no" title="statement not covered" >u.status&gt;=200&amp;&amp;u.st<span class="cstat-no" title="statement not covered" ></span>atus&lt;300;n&amp;&amp;"string"!=typeof t&amp;&amp;t.<span class="fstat-no" title="function not covered" >ma</span>p(functio<span class="cstat-no" title="statement not covered" >n(e){a.addStatement(e)}),n&amp;<span class="cstat-no" title="statement not covered" >&amp;(delete a.fetcher.nonexistant[e.uri],d<span class="cstat-no" title="statement not covered" ></span>elete a.fetcher.requested[e.u<span class="fstat-no" title="function not covered" >ri</span>]),r(e.uri<span class="cstat-no" title="statement not covered" >,n,u.responseText,u</span>)}},u.open("PUT",e.uri,!0),u.setRequestHeader("Content-type",n),u.send(o)},e.prototype.reload=function(e,t</span>,</span>n){var r=Date.now();e.fetcher.nowOrWhenFetched(t.uri,{force:!0,noMeta:!0</span>,clearPreviousData:!<span class="fstat-no" title="function not covered" >0}</span>,function(e,i,o){if(<span class="cstat-no" title="statement not covered" >e)if(o.onEr<span class="cstat-no" title="statement not covered" ></span>rorWasCalled||200!==o.status)console.log("    Non-HTTP error reloading data<span class="fstat-no" title="function not covered" >! </span>onErrorWasCall<span class="cstat-no" title="statement not covered" >ed="+o<span class="cstat-no" title="statement not covered" >.onErrorWasCalled+" status: "+o.status<span class="cstat-no" title="statement not covered" >),n(!1,"Non-HTTP error reloading data: "+i,o);else{var a=Date.now()-r;t.reloadTime_total||(t.reloadTime_total=0),t.reloadTime_count||(t.reloadTime_count=</span>0),t.reloa<span class="cstat-no" title="statement not covered" >dTime_total+=<span class="cstat-no" title="statement not covered" ></span>a,t.reloadTime_count+=1,console.log("    Fetch took "+a+"ms, av. of "+t.reloadTime_count+" = "+t.reloadTime_total/t.reloadTime_count+"ms."),n(!0)}else console.log("    ERROR reloading data: "+i),n(!1,"Error reloading data: "+i,o)})},e.prototype.oldReloa</span>d</span>=func<span class="cstat-no" title="statement not covered" >tion(e,t,n){var r=l(),i=fetcher(r),o=Date.now();i.nowOrWhenFetched(t.uri,{force:</span></span>!0,</span>noMeta:!0,clearPrevious<span class="fstat-no" title="function not covered" >Da</span>ta:!0},function(i,a,<span class="cstat-no" title="statement not covered" >s){i</span>f(<span class="cstat-no" title="statement not covered" >i)if(s.onEr</span>ro<span class="cstat-no" title="statement not covered" >rWasCalled|<span class="cstat-no" title="statement not covered" ></span>|200!==s.status)console.log("    Non-HTTP error reloading data! onE<span class="fstat-no" title="function not covered" >rr</span>orWasCalled="+<span class="cstat-no" title="statement not covered" >s.onEr<span class="cstat-no" title="statement not covered" >rorWasCalled+" status: "+s.status),n(!<span class="cstat-no" title="statement not covered" >1,"Non-HTTP error reloading data: "+a,s);else{var u=e.statementsMatching(void 0,void 0,void 0,t).slice(),l=r.statementsMatching(void 0,void 0,void 0,t).s</span>lice();con<span class="cstat-no" title="statement not covered" >sole.log("    replacing "+u.length+" with "+l.length+</span>" <span class="cstat-no" title="statement not covered" >out of total statements "+e.statements.length),e.remo<span class="cstat-no" title="statement not covered" ></span>ve(u),e.add(l);var c=Date.now()-o;0===l.length&amp;&amp;console.log("????????????????? 0000000"),t.reloadTime_total||(t.reloadTime_tota</span>l=0),<span class="cstat-no" title="statement not covered" >t.reloadTime_<span class="cstat-no" title="statement not covered" ></span>count||(t.reloadTime_count=0),t.reloadTime_total+=c,t.reloadTime_count+=1,console.log("    fetch took "+c+"ms, av. of "+t.reloadTime_count+" = "+t.reloadTime_total/t.reloadTime_count+"ms."),n(!0)}else console.log("    ERROR reloading data: "+a),n(!1,"Error reloading data: "+a,s)})},e}();e.exports=v},functio</span>n</span>(e,t,<span class="cstat-no" title="statement not covered" >n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot</span></span> ca</span>ll a cl<span class="cstat-no" title="statement not covered" >ass as a func</span>t<span class="fstat-no" title="function not covered" >io</span>n")}var i=function(){function e(e,t)<span class="fstat-no" title="function not covered" >{f</span>or(va<span class="cstat-no" title="statement not covered" >r n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >{var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!</span></span>0,"val<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ue</span>"in r&amp;&amp;(r.writable<span class="fstat-no" title="function not covered" >=!</span>0),Ob<span class="cstat-no" title="statement not covered" >ject.defineProperty(e,r.key,r)}}re<span class="cstat-no" title="statement not covered" >turn <span class="cstat-no" title="statement not covered" ></span>function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),o=n(75).namedNode,a=function(){function e(t,n){r(thi</span>s<span class="cstat-no" title="statement not covered" ></span>,e),thi<span class="fstat-no" title="function not covered" >s.</span>parent=t,this.<span class="cstat-no" title="statement not covered" >via=n,this.connected=!1,this.pending={},</span>th</span>is.</span>su<span class="cstat-no" title="statement not covered" >bscribed={},this</span>.s<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >oc</span>ket={};try{this.so<span class="fstat-no" title="function not covered" >ck</span>et=ne<span class="cstat-no" title="statement not covered" >w WebSocket(n),this.socket.onopen=this.onOpen,this.socket.onclose=this.onClose,this.socket.onmessage=th<span class="cstat-no" title="statement not covered" >i</span>s.o<span class="cstat-no" title="statement not covered" >nMessage,this.socket.onerror=this.onError}catch(e){this.onError(e)}}return i(e,[{key:"_decode",value:function(e){var t,n,r,i,o,a,s;i={},o=function(){var n,r,i,o;for</span>(i=e.spli<span class="cstat-no" title="statement not covered" >t("&amp;"),o=[],n=0,r</span>=<span class="cstat-no" title="statement not covered" ></span>i.length;n&lt;r;n++)t=i[n],o.push(t.split("="));return o}();for(n in o<span class="fstat-no" title="function not covered" >)t=o[n</span>],a=[decodeURICompone<span class="cstat-no" title="statement not covered" >nt(t[0]<span class="fstat-no" title="function not covered" >),</span>decodeURIComponent(t[<span class="cstat-no" title="statement not covered" >1])],r=a[0],s=a[1],null==i[r]&amp;&amp;(i[r]=[]),i[r].p<span class="cstat-no" title="statement not covered" >ush(s);return i}},{key:"_sen<span class="cstat-no" title="statement not covered" >d</span></span>",value:f</span>unc<span class="cstat-no" title="statement not covered" >t</span>ion(e,t,n)<span class="cstat-no" title="statement not covered" >{var r,i;return i=[e,t,n].join(" "),"function"==typeof(r=this.socket).send?r.send(i):void 0}},{key:"_subscribe<span class="cstat-no" title="statement not covered" >"</span></span>,value:fu</span>nction(e){return this._send("sub",e,""),this.subscribed<span class="fstat-no" title="function not covered" >[e]=!0</span>,this.subscribe<span class="cstat-no" title="statement not covered" >d[e]}},{key:"onClose",value:function(e){var t;this.connected=!1;for(t in this.subscr</span>ibed)this.pending[t]=!0;return this.subscribed={},this.subsc<span class="fstat-no" title="function not covered" >ribed}</span>},{<span class="cstat-no" title="statement not covered" >key:"onError",value:function(e){throw new Error("onError"+e)}},{key:"onM</span>essage",value:function(e){var t,n;return n=e.data.split("<span class="fstat-no" title="function not covered" > "),"p</span>ing"===n[<span class="cstat-no" title="statement not covered" >0]?"function"==typ<span class="cstat-no" title="statement not covered" >e</span>of(t=this.socket).send?t<span class="cstat-no" title="statement not covered" >.send("pong "+n.sli<span class="cstat-no" title="statement not covered" >c</span></span>e(1).join(" ")):void 0:"pub"===n[0]?this.p</span>arent.onUpdate(n[1],this._decode(n[2])):void 0}},{key:"on<span class="fstat-no" title="function not covered" >Open",</span>val<span class="cstat-no" title="statement not covered" >ue:function(e){var t,n;this.co</span>nnected=!0,t=[];for(n in this.pending)delete this.pending[n<span class="fstat-no" title="function not covered" >],t.pu</span>sh(this._su<span class="cstat-no" title="statement not covered" >bscribe(n));return t}},{key:"subscribe",value:function(e){return this.connected?this._subscribe(e):(this.pending[e]=!0,this.pending[e])}}]),e}(),s=function(){function e(t){r(this,e),this.fetc</span>her=t,this.graph={},this.via={},this.fetcher.addCallback<span class="fstat-no" title="function not covered" >("head</span>ers",this.o<span class="cstat-no" title="statement not covered" >nHeaders)}return i(e,[{<span class="cstat-no" title="statement not covered" >k</span>ey:"onHeaders",value:<span class="cstat-no" title="statement not covered" >function(e){var t,n,r;return null==e.headers||("un<span class="cstat-no" title="statement not covered" >d</span></span>efined"==</span>typeof WebSocket||null===WebSocket||(t=e.headers.etag,r=e.h<span class="fstat-no" title="function not covered" >eaders</span>["u<span class="cstat-no" title="statement not covered" >pdates-via"],n=e.uri,t&amp;&amp;r&amp;&amp;(this.graph[n]={etag:t,via:r},this.register(r,n)),!0</span>))}},{k</span>ey:</span>"o<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >nU</span>pdate",value:funct<span class="fstat-no" title="function not covered" >io</span>n(e<span class="cstat-no" title="statement not covered" >,t){return this.fetcher.refresh(o(e))}},{key:"register",value:function(e,t){return null==this.via[e]&amp;&amp;(<span class="cstat-no" title="statement not covered" ></span>this.via[e]=new a(this,e)),this.via[e].subscribe(t)}}]),e}();e.export<span class="fstat-no" title="function not covered" >s.Upda</span>tesSocket=a,e<span class="cstat-no" title="statement not covered" >.exports.UpdatesVia=s},function(e,t,n){(function(t){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=function(){function e(</span>e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r<span class="fstat-no" title="function not covered" >.enume</span>rable<span class="cstat-no" title="statement not covered" >||!1,r.configurable=!0,"value"in r&amp;</span>&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return <span class="fstat-no" title="function not covered" >functi</span>on(t,<span class="cstat-no" title="statement not covered" >n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),o=n(90),a="hash",s="query",u="re</span>direct"</span>,l=<span class="cstat-no" title="statement not covered" ></span>function(){function e(){var n=arguments.length&gt;0&amp;&amp;</span>v<span class="fstat-no" title="function not covered" >oi</span>d 0!==argument<span class="cstat-no" title="statement not covered" >s<span class="fstat-no" title="function not covered" >[0</span>]?arguments[0]:{};r(this,e),this<span class="fstat-no" title="function not covered" >.w</span>indow<span class="cstat-no" title="statement not covered" >=n.window||t.window,t<span class="cstat-no" title="statement not covered" >his.localStorage=n.localStorage||t.localStorage,this.curre</span></span>ntClie<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >nt</span>=null,this.provide<span class="fstat-no" title="function not covered" >rU</span>ri=nu<span class="cstat-no" title="statement not covered" >ll,this.webId=null,this.idToken=nu<span class="cstat-no" title="statement not covered" >ll,th<span class="cstat-no" title="statement not covered" ></span>is.accessToken=null,this.method=u}return i(e,[{key:"initEventListeners",value:function(e){e.addEventListener("m</span>e<span class="cstat-no" title="statement not covered" ></span>ssage",<span class="fstat-no" title="function not covered" >th</span>is.onMessage.b<span class="cstat-no" title="statement not covered" >ind(this))}},{key:"currentLocation",valu</span>e:</span>fun</span>ct<span class="cstat-no" title="statement not covered" >ion(){</span>va<span class="cstat-no" title="statement not covered" >r e=thi</span>s.<span class="cstat-no" title="statement not covered" >window;r</span>et<span class="cstat-no" title="statement not covered" >urn e.locat</span>io<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n.</span>href}},{key:"curre<span class="fstat-no" title="function not covered" >nt</span>User",va<span class="cstat-no" title="statement not covered" >lue:function(){if(this.webId)return Promise.resolve(this.w<span class="cstat-no" title="statement not covered" ></span>ebId);var e=this.providerFromCurrentUri();return e?this.login(e):Promise.resolve(null)}},{key:"extractState",value:function(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:a;if(!e)return null<span class="cstat-no" title="statement not covered" ></span>;var n=new URL(e),r=void 0;if(t===a){var i=n.hash||"#",o=new URLSearchParams(i<span class="fstat-no" title="function not covered" >.subst</span>r(1<span class="cstat-no" title="statement not covered" >));r=o.get("state")}return t===s&amp;&amp;(r=n.searchParams.get("</span>state")),r}},{key:"keyByProvider",value:function(){var e=argument<span class="fstat-no" title="function not covered" >s.leng</span>th&gt;0&amp;&amp;vo<span class="cstat-no" title="statement not covered" >id 0!==argum<span class="cstat-no" title="statement not covered" ></span>ents[0]?arguments[0]:thi</span>s.providerUri;return"oidc.rp.by-provider."+e}},{key:"keyBySta<span class="fstat-no" title="function not covered" >te",va</span>lu<span class="cstat-no" title="statement not covered" >e:function(e){<span class="cstat-no" title="statement not covered" >if(!e)throw new TypeError("No state </span></span>provi<span class="cstat-no" title="statement not covered" >ded to keyByState()");return"o<span class="cstat-no" title="statement not covered" ></span>idc.rp.by-state."+e}},{key:"loadOrRegisterClie</span>nt",value:function(e){var t=this;return this.currentClient=nul<span class="fstat-no" title="function not covered" >l,this</span>.loadClie<span class="cstat-no" title="statement not covered" >nt(e).then(function(n){return n?(t.currentClient=n,n):(t.<span class="cstat-no" title="statement not covered" ></span>curren<span class="cstat-no" title="statement not covered" >tClient=null,</span></span>t.reg<span class="cstat-no" title="statement not covered" >isterClient</span>(e<span class="cstat-no" title="statement not covered" >))})}},<span class="cstat-no" title="statement not covered" ></span>{key:"loadClient<span class="cstat-no" title="statement not covered" >",value:func</span>ti<span class="cstat-no" title="statement not covered" >on(e){if(!e){var t=new Error("Can<span class="cstat-no" title="statement not covered" ></span>not load or regist<span class="cstat-no" title="statement not covered" ></span>e</span>r client, providerURI missing");return Promise.r</span>eject(t)}if(this.currentClient&amp;&amp;this.currentClient.provider.url<span class="fstat-no" title="function not covered" >===e)r</span>eturn Pr<span class="cstat-no" title="statement not covered" >omise.resolve(this.currentClient);var n=this.keyByProvider(e),r=localSto<span class="cstat-no" title="statement not covered" ></span>rage.getItem(n);return r?(r=JSON</span>.parse(r),o.from(r)):Promise.resolve(null)}},{key:"loadProvi<span class="fstat-no" title="function not covered" >der",v</span>alu<span class="cstat-no" title="statement not covered" >e:func<span class="cstat-no" title="statement not covered" >tion(e){var t=this.keyByState(e),n=localStorage.getItem(t<span class="cstat-no" title="statement not covered" >)</span></span>;return n}},{key:"login",val</span>ue:function(e){this.clearCurrentUser();var t=this.selectProvider.bind(<span class="fstat-no" title="function not covered" >this),</span>n=this.lo<span class="cstat-no" title="statement not covered" >adOrR<span class="cstat-no" title="statement not covered" ></span>egisterClient.bind(this),r=this.validateOrSendAuthReque<span class="fstat-no" title="function not covered" >st</span>.bind(this<span class="cstat-no" title="statement not covered" >);return Promise.resolve(e).then(t).then(n).then(r)}},{key:"clearCurrentUse</span>r",</span>value:function(){this.webId=null,this.accessToken=null,this.<span class="fstat-no" title="function not covered" >idToke</span>n=n<span class="cstat-no" title="statement not covered" >ull}},{key:"l<span class="cstat-no" title="statement not covered" >ogout",value:function(){return this.clearCurrentUser(),this.curre<span class="cstat-no" title="statement not covered" ></span>ntClient?this.currentClien<span class="cstat-no" title="statement not covered" ></span>t</span>.logout():Promise.resolve(null)}},{key:"selectProvider",va<span class="cstat-no" title="statement not covered" >lue:function(e){return e?Promise.resolve(e):</span></span>(e=th<span class="cstat-no" title="statement not covered" >is.providerFromCurrent</span>Ur<span class="cstat-no" title="statement not covered" >i(),e?Promise.resolve(e)<span class="cstat-no" title="statement not covered" ></span>:this.providerFromUI())}},{key:"providerFromCurrentUri",valu</span>e:function(){var e=this.currentLocation(),t=this.extractState(<span class="fstat-no" title="function not covered" >e,a);r</span>eturn t?t<span class="cstat-no" title="statement not covered" >his.loadProvider(t)</span>:n<span class="cstat-no" title="statement not covered" >ull}},{key:"providerFrom<span class="cstat-no" title="statement not covered" ></span>UI",value:</span>function(){console.log("No state param, getting provide<span class="fstat-no" title="function not covered" >r from</span> UI<span class="cstat-no" title="statement not covered" >"),this.initEventListener</span>s(win<span class="cstat-no" title="statement not covered" >dow)}},{key:"currentUriHasAuthR</span>es<span class="cstat-no" title="statement not covered" >ponse",value:function(){var e=this.cu</span>rr<span class="cstat-no" title="statement not covered" >entLocation(),t=this.extractState(e,a);ret<span class="cstat-no" title="statement not covered" ></span>urn!!t}},{key:"redirectTo",value:function(e){this.w</span>indow.location=e}},{key:"sendAuthRequest",value:function(e){var t=<span class="fstat-no" title="function not covered" >this,n</span>={<span class="cstat-no" title="statement not covered" >},r=e.provider.url;return e.createRequest(n,this.localSto</span>rage).then(function(e){var n=t.extractState(e,s);if(!n)t<span class="fstat-no" title="function not covered" >hrow n</span>ew<span class="cstat-no" title="statement not covered" > Error("Invalid authentication request uri");t.saveProviderByState(n,r),t.method===u&amp;&amp;t.redirectTo(e)</span>})}},{key:"validateOrSendAuthRequest",value:function(e){if(!e){v<span class="fstat-no" title="function not covered" >ar t=n</span>ew <span class="cstat-no" title="statement not covered" >Error("Could not load or register a RelyingParty client");return Promise.reject(t)}return this.currentUriH</span>asAuthResponse()?this.initUserFromResponse(e):this.sendAuthRequest(e)}},<span class="fstat-no" title="function not covered" >{key:"</span>initUser<span class="cstat-no" title="statement not covered" >FromResponse",value:fun</span>ct<span class="cstat-no" title="statement not covered" >ion(e){var t=this;retur<span class="cstat-no" title="statement not covered" ></span>n e.validateResponse(this.currentLoc</span>ation(),this.localStorage).then(function(e){return t.idToken=e.p<span class="fstat-no" title="function not covered" >arams.</span>id<span class="cstat-no" title="statement not covered" >_token,t.accessToken=e.params.access_token,t.extractAndValidateWebId(e.decoded)}).catch(f</span>unction(e){if("Cannot resolve signing key for ID Token."===e.message)return<span class="fstat-no" title="function not covered" > conso</span>le.log("<span class="cstat-no" title="statement not covered" >ID Token found, but cou</span>ld<span class="cstat-no" title="statement not covered" > not validate. Provider<span class="cstat-no" title="statement not covered" ></span> likely has</span> changed their public keys. Please retry login."),null;throw<span class="fstat-no" title="function not covered" > e})}}</span>,{k<span class="cstat-no" title="statement not covered" >ey:"extractAndValidateWe</span>bId",value:function(e){var t=e.payload.sub;return this.webId=t,t}<span class="fstat-no" title="function not covered" >},{key</span>:"registe<span class="cstat-no" title="statement not covered" >rClie</span>nt<span class="cstat-no" title="statement not covered" >",v</span>al<span class="cstat-no" title="statement not covered" >ue:function(e){<span class="cstat-no" title="statement not covered" ></span>var t=this,n=arguments.length&gt;1&amp;&amp;void 0!==argumen<span class="fstat-no" title="function not covered" >ts</span>[1]?arguments[1]<span class="cstat-no" title="statement not covered" >:{};return this.regi<span class="cstat-no" title="statement not covered" ></span>sterPu<span class="cstat-no" title="statement not covered" >blicClient(e,n).then(function(n){return t.storeClient(<span class="cstat-no" title="statement not covered" >n</span></span>,e),n})}},{key:"registerPublicClient",value:function(e){v</span>ar </span>t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};if(console.log(<span class="fstat-no" title="function not covered" >"Regis</span>ter<span class="cstat-no" title="statement not covered" >ing public cl<span class="cstat-no" title="statement not covered" >ient..."),!e)throw new TypeError("Cannot registerClient auth c<span class="cstat-no" title="statement not covered" ></span>lient, missing providerUri<span class="cstat-no" title="statement not covered" ></span>"</span>);var n=t.redirectUri||this.currentLocation();this.redirectUri=n;var r={issuer:e,grant_types:</span>["implicit"],redirect_uris:[n],response_types:["id_token token"],scope<span class="fstat-no" title="function not covered" >:t.sco</span>pe||"open<span class="cstat-no" title="statement not covered" >id pr<span class="cstat-no" title="statement not covered" ></span>ofile"},i={defaults:{authenticate:{redirect_uri:n,response_type:"id_token<span class="fstat-no" title="function not covered" > t</span>oken"}},st<span class="cstat-no" title="statement not covered" >ore:t.store||localStorage};return o.register(e,r,i)}},{key:"onMessage",value:function(e){if(console.log("Auth</span> client <span class="fstat-no" title="function not covered" >re</span>ceived eve<span class="cstat-no" title="statement not covered" >nt: ",e),e&amp;&amp;e.data)switch(e.data.event_type){case"provider<span class="cstat-no" title="statement not covered" >Selected":console.log("Provider selected: ",e.data.value);break;default:console.error("onMessage - unknown event type: ",e)}}},{key:"s<span class="cstat-no" title="statement not covered" >a</span></span>veProvid</span>erB</span>yState",value:function(e,t){if(!e)throw new Error("Cannot save providerUr<span class="fstat-no" title="function not covered" >i - st</span>ate not p<span class="cstat-no" title="statement not covered" >rovided");var <span class="cstat-no" title="statement not covered" ></span>n=this.keyByState(e);lo</span>calStorage.setItem(n,t)}},{key:"storeClient",value:function(e,t)<span class="fstat-no" title="function not covered" >{this.</span>currentCl<span class="cstat-no" title="statement not covered" >ient=</span>e,<span class="cstat-no" title="statement not covered" >localStorage.setItem(this.keyByProvider(t),e.serialize())}<span class="cstat-no" title="statement not covered" ></span>}]),e}();e.exports=l}).call(t,function(){re<span class="fstat-no" title="function not covered" >tu</span>rn this}()<span class="cstat-no" title="statement not covered" >)},function(e,t,n){"use stric</span>t";</span>e.exports=n(91)},function(e,t,n){(function(t){"use strict";function r(<span class="fstat-no" title="function not covered" >e,t){i</span>f(!(e ins<span class="cstat-no" title="statement not covered" >tanceof t))throw new TypeError("Cannot call a class as a f<span class="cstat-no" title="statement not covered" ></span>unction")}function i(e,t){if(!e)throw new Referenc<span class="cstat-no" title="statement not covered" >eError("this hasn't been initialised - super() hasn't been called");return!t||"</span></span>objec<span class="cstat-no" title="statement not covered" >t"!=typeof t&amp;&amp;"function"!=typeof t?e:t<span class="cstat-no" title="statement not covered" ></span>}function o(e,t){if(</span>"func<span class="cstat-no" title="statement not covered" >tion"!=typeof t&amp;&amp;null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.pro</span>to<span class="cstat-no" title="statement not covered" >type=Object.create(t&amp;&amp;t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;(Object.setPrototypeOf?O</span>bject.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){f<span class="fstat-no" title="function not covered" >unctio</span>n e<span class="cstat-no" title="statement not covered" >(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r<span class="cstat-no" title="statement not covered" >.enumerable||!1,r.configurable=!0,"value"in r&amp;&amp;(r<span class="cstat-no" title="statement not covered" >.writable=!0),Object.defineProperty(e,r.key,r)}}<span class="cstat-no" title="statement not covered" >r</span>eturn </span>functio<span class="cstat-no" title="statement not covered" >n(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s</span>=</span></span>n(92),u=n(93),l=u.Headers?u.Headers:t.Headers,c=n(94),f=(c.JSONSchema<span class="fstat-no" title="function not covered" >,c.JSO</span>NDocu<span class="cstat-no" title="statement not covered" >ment),<span class="cstat-no" title="statement not covered" >h=n(103),d=h.JWKSet,p=n(127),v=n(133),g=n(136),y=function(e){func</span></span>tion <span class="cstat-no" title="statement not covered" >t(){return r(this,t<span class="cstat-no" title="statement not covered" ></span>),i(this,(t.__proto__||Obje</span>ct.getPrototypeOf(t)).apply(this,arguments))}return o(t,e),a(<span class="fstat-no" title="function not covered" >t,[{ke</span>y:"di<span class="cstat-no" title="statement not covered" >scover",value:function(){var e=this;try{var t=this.provider.url,n=".well-known/o</span>penid-c</span>onf<span class="cstat-no" title="statement not covered" ></span>iguration";re</span>turn s(t,<span class="fstat-no" title="function not covered" >'R</span>elyingPar<span class="cstat-no" title="statement not covered" >ty provider m</span>ust d</span>e<span class="fstat-no" title="function not covered" >fi</span>ne "url"'),u(t+"/"+n).then(<span class="cstat-no" title="statement not covered" >function(t){retur</span>n<span class="fstat-no" title="function not covered" > t</span>.json().then(f<span class="cstat-no" title="statement not covered" >u<span class="fstat-no" title="function not covered" >nc</span>tion(t){return e.provider.config<span class="fstat-no" title="function not covered" >ur</span>ation<span class="cstat-no" title="statement not covered" >=t})})}catch(e){retur<span class="cstat-no" title="statement not covered" >n Promise.reject(e)}}},{key:"register",value:function(e){v</span></span>ar t=this<span class="fstat-no" title="function not covered" >;t</span>ry{va<span class="cstat-no" title="statement not covered" >r n=th<span class="cstat-no" title="statement not covered" >is.provider.configuration;s(n,"OpenID Configuration is not initialized."),s(n.registra<span class="cstat-no" title="statement not covered" >t</span></span>ion_endpoint,"OpenID Configuration is missing registrat</span>ion_endpo<span class="fstat-no" title="function not covered" >in</span>t.");<span class="cstat-no" title="statement not covered" >var r=n.registration_endpoint,i="p<span class="cstat-no" title="statement not covered" >ost",o=new l({"Content-Type":"application/json"}),a=this.defaults.register,c=JSON.stringi<span class="cstat-no" title="statement not covered" >f</span></span>y(Object.assign({},a,e));return u(r,{method:i,headers:o,body:c}).then(function(e){return e.json().then(function(e){return t.registration=e})})}catch(e){return Promise.reject(e)</span>}}},{k<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ey</span>:"serialize",value<span class="fstat-no" title="function not covered" >:f</span>uncti<span class="cstat-no" title="statement not covered" >on(){return JSON.stringify(this)}}<span class="cstat-no" title="statement not covered" >,{key<span class="cstat-no" title="statement not covered" ></span>:"jwks",value:function(){var e=this;try{var t=this.provider.configuration;s(t,"OpenID Configuration is not init</span>i<span class="cstat-no" title="statement not covered" ></span>alized.<span class="fstat-no" title="function not covered" >")</span>,s(t.jwks_uri,<span class="cstat-no" title="statement not covered" >"OpenID Configuration is missing jwks_ur</span>i.</span>");</span>va<span class="cstat-no" title="statement not covered" >r n=t.</span>jw<span class="cstat-no" title="statement not covered" >ks_uri</span>;r<span class="cstat-no" title="statement not covered" >eturn u(n).then(function(t){re</span>tu<span class="cstat-no" title="statement not covered" >rn t.j</span>son<span class="cstat-no" title="statement not covered" >().then(function(e){return d</span>.im<span class="cstat-no" title="statement not covered" >portKey</span>s(<span class="cstat-no" title="statement not covered" >e)}).then</span>(f<span class="cstat-no" title="statement not covered" >unction</span>(t<span class="cstat-no" title="statement not covered" >){retur</span>n <span class="cstat-no" title="statement not covered" >e.provi</span>de<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r.</span>jwks=t})})}catch(e)<span class="fstat-no" title="function not covered" >{r</span>et<span class="cstat-no" title="statement not covered" >urn Promise.reject(e)}}},{key:"createRequest",value:function(e,t){return p.create(this,e<span class="cstat-no" title="statement not covered" ></span>,t||this.store)}},{key:"validateResponse",value:function(e,t){return t=t||t<span class="fstat-no" title="function not covered" >his.st</span>ore,e=e.<span class="cstat-no" title="statement not covered" >match<span class="cstat-no" title="statement not covered" ></span>(/^http(s?<span class="cstat-no" title="statement not covered" >):\/\//)?{rp:this,</span>re<span class="cstat-no" title="statement not covered" >direct:e,session:t}:{rp:this,body:e<span class="cstat-no" title="statement not covered" ></span>,session:t},v.validateResponse(e)}},{key:"userinfo",value:function(){t<span class="fstat-no" title="function not covered" >ry</span>{var e=thi<span class="cstat-no" title="statement not covered" >s.provider.configurat<span class="fstat-no" title="function not covered" >io</span>n;s(e,"Ope<span class="cstat-no" title="statement not covered" >nID Configuration is not initialize</span>d."</span>),s</span>(e.regist<span class="cstat-no" title="statement not covered" >ration_endpoint,"OpenID Co</span>n</span>figuration is missing registration_endpoint.");var t=e.use<span class="fstat-no" title="function not covered" >rinfo_</span>endpoint,<span class="cstat-no" title="statement not covered" >n=thi<span class="cstat-no" title="statement not covered" ></span>s.session.<span class="cstat-no" title="statement not covered" >access_token;s(n,"Missing ac<span class="cstat-no" title="statement not covered" ></span>cess token.");var r=new l({"Content-Type":"application/json",Authorization:"Bearer "+n});return u(t,{headers:r}).then(status(200)).th</span>en(fu<span class="cstat-no" title="statement not covered" >nction(e){return e.json(</span>)}<span class="cstat-no" title="statement not covered" >)}catch</span>(e<span class="cstat-no" title="statement not covered" >){return Promise.reject(e)}}},{key:"logout"</span>,v<span class="cstat-no" title="statement not covered" >alue:function(){var e=v</span>oi<span class="cstat-no" title="statement not covered" >d 0;try{e=this.provider.configuration,<span class="cstat-no" title="statement not covered" ></span>s(e,"OpenID Configuration is not initialized.<span class="fstat-no" title="function not covered" >")</span>,s(e.end_s<span class="cstat-no" title="statement not covered" >ession_endpoint,"Open<span class="fstat-no" title="function not covered" >ID</span> Configura<span class="cstat-no" title="statement not covered" >tion is missing end_sessi</span>on_</span>end</span>point.")}<span class="cstat-no" title="statement not covered" >catch(e){return Promise.re</span>j</span>ect(e)}var t=e.end_session_endpoint,n="get";return u(t,{met<span class="fstat-no" title="function not covered" >hod:n}</span>)}<span class="cstat-no" title="statement not covered" >}],[{key:"from",value:functio</span>n(e){var n=new t(e),r=n.validate();if(!r.valid)return <span class="fstat-no" title="function not covered" >Promis</span>e.reject<span class="cstat-no" title="statement not covered" >(r);v<span class="cstat-no" title="statement not covered" ></span>ar i=n.pro<span class="cstat-no" title="statement not covered" >vider.jwks;return i?d.import<span class="cstat-no" title="statement not covered" ></span>Keys(i).then(function(e){return n.provider.jwks=e,n}):n.jwks().then(function(){return n})}},{key:"register"</span>,valu<span class="cstat-no" title="statement not covered" >e:function(<span class="cstat-no" title="statement not covered" ></span>e,n,r){var i=new <span class="fstat-no" title="function not covered" >t(</span>{provider:<span class="cstat-no" title="statement not covered" >{url:e},defaults:Obje<span class="fstat-no" title="function not covered" >ct</span>.assign({}<span class="cstat-no" title="statement not covered" >,r.defaults),store:r.sto</span>re});re<span class="fstat-no" title="function not covered" >tu</span>rn Promise<span class="cstat-no" title="statement not covered" >.resolve().then(function()</span>{re</span>tur</span>n i.disco<span class="cstat-no" title="statement not covered" >ver()}).catch(function(e){</span>t</span>hrow console.error("Error in RP register() &gt; discover() step:",<span class="fstat-no" title="function not covered" >e),e})</span>.then<span class="cstat-no" title="statement not covered" >(function(){return i.jwks()}).catch(fun</span>ction(e){throw console.error("Error in RP register() &gt; jwks() step<span class="fstat-no" title="function not covered" >:",e),</span>e}).t<span class="cstat-no" title="statement not covered" >hen(function(){return i.register(n)}).catch(function(e){throw console.error("Error in RP register() &gt; register() step:",e),e}).then(</span>function(){return i})}},{key:"schema",get:function(){retur<span class="fstat-no" title="function not covered" >n g}}]</span>),<span class="cstat-no" title="statement not covered" >t}(f);e.ex<span class="cstat-no" title="statement not covered" >ports=y}).call(t,function(){<span class="cstat-no" title="statement not covered" ></span>return this}())},function(e,t,n){(function(t){"use strict";/*!<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh &lt;feross@feross.org&gt; &lt;http://feross.org&gt;
	 * @license  MIT
	 */
function <span class="fstat-no" title="function not covered" >r(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e===t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=e.length,r=t.length,i=0,o=Math.min(n,r);i&lt;o;++i)<span class="cstat-no" title="statement not covered" >if(e[i]!==t[i]){<span class="cstat-no" title="statement not covered" >n=e[i],r=t[i];<span class="cstat-no" title="statement not covered" >b</span>reak}r<span class="cstat-no" title="statement not covered" ></span>e</span></span>turn n&lt;r?-1:r&lt;n?1:0}fu</span>nction i(<span class="fstat-no" title="function not covered" >e)</span>{re<span class="cstat-no" title="statement not covered" >turn t.Buffer&amp;&amp;"function"==typeof t.Buffer.isBuffer?t.Buffer.isBuffer(e):!(null==e||!e._isBuffer)}fun</span>ction o(e<span class="fstat-no" title="function not covered" >){</span>ret<span class="cstat-no" title="statement not covered" >urn Object.prototype.toString.call(e)}func</span>tion a(e)<span class="fstat-no" title="function not covered" >{r</span>etu<span class="cstat-no" title="statement not covered" >rn!i(e)&amp;&amp;("function"==typeof t.ArrayBuffer&amp;&amp;("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):!!e&amp;&amp;(e instanceof DataView||!!(e.buffer&amp;&amp;e.buffer instanceof ArrayBuffer))))}fun</span>ction s(e<span class="fstat-no" title="function not covered" >){</span>if(<span class="cstat-no" title="statement not covered" >w.isFunction(e)){if(<span class="cstat-no" title="statement not covered" >k)ret<span class="cstat-no" title="statement not covered" >urn e.name;var </span></span>t=e.t<span class="cstat-no" title="statement not covered" >oString(),n=t</span>.m<span class="cstat-no" title="statement not covered" >atch(E);ret<span class="cstat-no" title="statement not covered" ></span>urn n&amp;&amp;n[1]}}fun</span>c</span>tion u(e,<span class="fstat-no" title="function not covered" >t)</span>{retu<span class="cstat-no" title="statement not covered" >rn"string"==typeof e?e.length&lt;t?e:e.slice(0,t):e}funct</span>ion l(e){<span class="fstat-no" title="function not covered" >if</span>(k|<span class="cstat-no" title="statement not covered" >|!w.isFunction(e))retur<span class="cstat-no" title="statement not covered" >n w.inspect(e);var t=</span></span>s(e),<span class="cstat-no" title="statement not covered" >n=t?"</span>: <span class="cstat-no" title="statement not covered" >"+t:"";retur<span class="cstat-no" title="statement not covered" ></span>n"[Function"+n+"]"}functi</span>on c(e){r<span class="fstat-no" title="function not covered" >et</span>urn<span class="cstat-no" title="statement not covered" > u(l(e.actual),128)+" "+e.operator+" "+u(l(e.expected),128)}functio</span>n f(e,t,n<span class="fstat-no" title="function not covered" >,r</span>,i){throw n<span class="cstat-no" title="statement not covered" >ew T.AssertionError({message:n,actual:e,expected:t,operator:r,stackStartFunction:i})}function</span> h(e,t){e<span class="fstat-no" title="function not covered" >||</span>f(e,!<span class="cstat-no" title="statement not covered" >0,t,"==",T.ok)}function </span>d(e,t,n,s<span class="fstat-no" title="function not covered" >){</span>if(e===t)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >if(i(e)&amp;&amp;<span class="cstat-no" title="statement not covered" >i</span></span>(t))return 0=<span class="cstat-no" title="statement not covered" >==r(e,t);if(w.isDa<span class="cstat-no" title="statement not covered" >t</span></span>e(e)&amp;&amp;w.isDate(t))return e.<span class="cstat-no" title="statement not covered" >getTime()===t.getTime();if(w.isRe<span class="cstat-no" title="statement not covered" >g</span></span>Exp(e)&amp;&amp;w.isRegExp(t))return e.<span class="cstat-no" title="statement not covered" >source===t.source&amp;&amp;e.global===t.global&amp;&amp;e.multiline===t.multiline&amp;&amp;e.lastIndex===t.lastIndex&amp;&amp;e.ignoreCase===t.ignoreCase;if(null!=<span class="cstat-no" title="statement not covered" >=</span></span>e&amp;&amp;"object"==typeof e||null!==t&amp;&amp;"object"==typeof t){if(a(e)&amp;&amp;<span class="cstat-no" title="statement not covered" >a(t)&amp;&amp;o(e)===o(t)&amp;&amp;!(e instanceof Float32Array||e instanceof Float64Array))return 0=<span class="cstat-no" title="statement not covered" >==r(new Uint8Array(e.buffer),new Uint8Array(t.buffer));if(i(e)!=<span class="cstat-no" title="statement not covered" >=</span></span>i(t))return!1;<span class="cstat-no" title="statement not covered" >s=s||{act<span class="cstat-no" title="statement not covered" >u</span></span>al:[],expected:[]};var u=s.ac</span>tual.<span class="cstat-no" title="statement not covered" >indexOf(e);return u!<span class="cstat-no" title="statement not covered" ></span>==-1&amp;&amp;u===s.expected.indexOf(t)||(s.actual.push(e),s.expected.push(t),v(e,t,n,s))}return n?e<span class="cstat-no" title="statement not covered" ></span>=</span>==t:e==t}function p(</span>e){return<span class="fstat-no" title="function not covered" >"[</span>obj<span class="cstat-no" title="statement not covered" >ect Arguments]"==Object.prototype.toString.call(e)}function v(e</span>,t,n,r){i<span class="fstat-no" title="function not covered" >f(</span>null===e|<span class="cstat-no" title="statement not covered" >|void 0===e||null===t||void 0===t)return!1;if(<span class="cstat-no" title="statement not covered" >w.isPrimi<span class="cstat-no" title="statement not covered" >t</span></span>ive(e)||w.isPrimitive(t))return e===t<span class="cstat-no" title="statement not covered" >;if(n&amp;&amp;Object<span class="cstat-no" title="statement not covered" >.</span></span>getPrototypeOf(e)!==Object.getPrototypeOf(t))return!1;var<span class="cstat-no" title="statement not covered" > i=p(e),o=</span></span>p(t);<span class="cstat-no" title="statement not covered" >if(i&amp;</span>&amp;!<span class="cstat-no" title="statement not covered" >o||!i<span class="cstat-no" title="statement not covered" ></span>&amp;&amp;o)return!1;if(<span class="cstat-no" title="statement not covered" >i)return <span class="cstat-no" title="statement not covered" >e</span></span>=_.c<span class="cstat-no" title="statement not covered" >all(e),t=_.call(t),d(e,t,n);var a,s,u=S(e</span></span>),l=S(t);<span class="cstat-no" title="statement not covered" >if(u.</span>le<span class="cstat-no" title="statement not covered" >ngth!<span class="cstat-no" title="statement not covered" ></span>==l.length)return!1;for<span class="cstat-no" title="statement not covered" >(u.sort()<span class="cstat-no" title="statement not covered" >,</span></span>l.sort(),s=u.length-1;s&gt;=0;s--)if(u[s]!==l[<span class="cstat-no" title="statement not covered" >s])return!1;for<span class="cstat-no" title="statement not covered" >(s=u.leng<span class="cstat-no" title="statement not covered" >t</span></span></span>h-1;s&gt;=0;s--)if(a=u[s],!d<span class="cstat-no" title="statement not covered" >(e[a],t[a],n,r))return!1;ret<span class="cstat-no" title="statement not covered" >urn!0}fun<span class="cstat-no" title="statement not covered" >c</span></span></span>tion g(e,</span>t,n){d(e,<span class="fstat-no" title="function not covered" >t,</span>!0)&amp;&amp;f(<span class="cstat-no" title="statement not covered" >e,t,n,"notDeepStrictEqual",g)}function y(e,t</span>){if(!e||<span class="fstat-no" title="function not covered" >!t</span>)retu<span class="cstat-no" title="statement not covered" >rn!1;if("[<span class="cstat-no" title="statement not covered" >object Re<span class="cstat-no" title="statement not covered" >g</span></span>Exp]"==Object.prototype.toString.call(t))return t.test(<span class="cstat-no" title="statement not covered" >e);try{if(e insta<span class="cstat-no" title="statement not covered" >n</span></span>ceo<span class="cstat-no" title="statement not covered" >f t)return!0}catch<span class="cstat-no" title="statement not covered" >(e){}retur</span></span>n!Error.is<span class="cstat-no" title="statement not covered" >P</span>rototypeOf(t)&amp;&amp;t.call({},e)===!0}function m(e){va</span>r t;try{e<span class="fstat-no" title="function not covered" >()</span>}catch(e)<span class="cstat-no" title="statement not covered" >{t=e<span class="cstat-no" title="statement not covered" >}retu</span>rn t}func<span class="cstat-no" title="statement not covered" >tion <span class="cstat-no" title="statement not covered" ></span>b</span>(e,t,n,r)</span>{var i;if<span class="fstat-no" title="function not covered" >("</span>function"!=type<span class="cstat-no" title="statement not covered" >of t)throw new TypeError<span class="cstat-no" title="statement not covered" >('"block" argument must be a function');"string"==typeof n&amp;<span class="cstat-no" title="statement not covered" >&amp;</span></span>(r=n,n=null),i=m(t),r=(n&amp;&amp;n.name?" ("+n.name+").":".")+(r?" "+r:"."),e&amp;&amp;!i&amp;&amp;f(i,n,"Missing expected exception"+r);var o="string"==type</span>of r,<span class="cstat-no" title="statement not covered" >a=!e&amp;&amp;w.isError(i),</span>s=<span class="cstat-no" title="statement not covered" >!e&amp;&amp;i&amp;&amp;!n;if((a&amp;&amp;</span>o&amp;<span class="cstat-no" title="statement not covered" >&amp;y(i,n)||s<span class="cstat-no" title="statement not covered" ></span>)&amp;&amp;f(i,n,"Got unwanted exception"+r),e&amp;&amp;i&amp;&amp;n&amp;&amp;!y(i,n)||!e&amp;&amp;i)throw i}var w=n(65)<span class="cstat-no" title="statement not covered" >,x=Object</span></span>.proto<span class="cstat-no" title="statement not covered" >type.h</span>as<span class="cstat-no" title="statement not covered" >OwnProperty,_=Array.prototype.sl</span>ic<span class="cstat-no" title="statement not covered" >e,k=function(){return"</span>fo<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >o"</span>===functi<span class="cstat-no" title="statement not covered" >on(){}.name}()<span class="fstat-no" title="function not covered" >,T</span>=e.exports=h,E=/\</span>s*f</span>un<span class="cstat-no" title="statement not covered" >ction\s+([^\</span>(\<span class="cstat-no" title="statement not covered" >s]*)\s*/;T.AssertionError=func<span class="cstat-no" title="statement not covered" ></span>tion(e){this.name<span class="fstat-no" title="function not covered" >="</span>AssertionE<span class="cstat-no" title="statement not covered" >rror",this.actual=e.actual,this.expected=e.expected,this.operator=e.operator,e.message?(this.message=e.message,this.generatedMessage=!1):(this.message=c(this),this.generatedMessage=!0);var t=e.stackStartFunc</span>tion|<span class="cstat-no" title="statement not covered" >|f;if(Error.captureStack<span class="cstat-no" title="statement not covered" ></span>Trace)Error.captureStackTra<span class="cstat-no" title="statement not covered" >ce(this,t);else{var n=new Error;i</span>f(n.stack)<span class="cstat-no" title="statement not covered" >{var r=n.sta<span class="cstat-no" title="statement not covered" ></span>ck,i=s(t),o=r.inde<span class="cstat-no" title="statement not covered" >xOf("\n"</span>+i<span class="cstat-no" title="statement not covered" >);if(</span>o&gt;<span class="cstat-no" title="statement not covered" >=0){var a=r.indexO<span class="cstat-no" title="statement not covered" ></span>f("\n",o+1);r=r<span class="cstat-no" title="statement not covered" >.substring(a+1)}this<span class="cstat-no" title="statement not covered" ></span>.stack=r}}},w.inheri<span class="cstat-no" title="statement not covered" ></span>t</span>s(T.Assertion</span>E</span>r</span>ror,Error),T.fail=f,T.ok=h,T.equal=function(e,t,n){e!=t&amp;&amp;f(e<span class="fstat-no" title="function not covered" >,t</span>,n,"==",T.equa<span class="cstat-no" title="statement not covered" >l)},T.notEqual=function(e,t,n</span>){e==t&amp;&amp;f(e,<span class="fstat-no" title="function not covered" >t,</span>n,"!=",T.notEq<span class="cstat-no" title="statement not covered" >ual)},T.deepEqual=function(e,t,n</span>){d(e,t,!1)||<span class="fstat-no" title="function not covered" >f(</span>e,t,n,"deepEqu<span class="cstat-no" title="statement not covered" >al",T.deepEqual)},T.deepStrictEqual=function(</span>e,t,n){d(e,t,!0)||f<span class="fstat-no" title="function not covered" >(e</span>,t,n,"deepStri<span class="cstat-no" title="statement not covered" >ctEqual",T.deepStrictEqual)},T.notDeepEqual=function(e,t,</span>n){d(e,t,!1)&amp;&amp;f(<span class="fstat-no" title="function not covered" >e,</span>t,n,"notDeepEq<span class="cstat-no" title="statement not covered" >ual",T.notDeepEqual)},T.notDeepStrictEqual=g,T.stri</span>ctEqual=function(e,t,n){e!==t&amp;&amp;f(e,t,n<span class="fstat-no" title="function not covered" >,"</span>===",T.strictE<span class="cstat-no" title="statement not covered" >qual)},T.notStrictEqual=function(e,t,</span>n){e===t&amp;&amp;f(e,t,n,<span class="fstat-no" title="function not covered" >"!</span>==",T.notStric<span class="cstat-no" title="statement not covered" >tEqual)},T.throws=function(e,t,n){b(!0,e</span>,t,n)},T.d<span class="fstat-no" title="function not covered" >oe</span>sNotThrow=func<span class="cstat-no" title="statement not covered" >tion(e,t,n){b</span>(!1,e,t,n)},T.if<span class="fstat-no" title="function not covered" >Er</span>ror=function(e<span class="cstat-no" title="statement not covered" >){if(e)throw </span>e};var S=Ob<span class="fstat-no" title="function not covered" >je</span>ct.keys||f<span class="cstat-no" title="statement not covered" >uncti<span class="cstat-no" title="statement not covered" >on(e){var</span></span> t</span>=[];f<span class="cstat-no" title="statement not covered" >or(var n in e<span class="fstat-no" title="function not covered" >)x</span>.call(e,n)&amp;&amp;t.pu<span class="cstat-no" title="statement not covered" >sh(<span class="cstat-no" title="statement not covered" ></span>n);return t}}).<span class="cstat-no" title="statement not covered" >call(t,function(){retur<span class="cstat-no" title="statement not covered" >n</span></span> this}())</span>}</span>,function(<span class="fstat-no" title="function not covered" >e,</span>t){e.expo<span class="cstat-no" title="statement not covered" >rts=fetch},fu</span>nction<span class="fstat-no" title="function not covered" >(e</span>,t,n){"use s<span class="cstat-no" title="statement not covered" >trict";e.exports=</span>{<span class="fstat-no" title="function not covered" >Fo</span>rmats:n(95),Initializer:n(9<span class="cstat-no" title="statement not covered" >6),JSONDocument:n(97),JSONMapping:n(100),JSONPatch:n(98),JSONPointer:n(99),JSONSchema:n(101),Validator:n(102)}},function(e,t){"use strict";function n(e,</span>t<span class="fstat-no" title="function not covered" >){</span>if(!(e instanceof t))throw new Typ<span class="fstat-no" title="function not covered" >eE</span>rror(<span class="cstat-no" title="statement not covered" >"Cannot call a class <span class="cstat-no" title="statement not covered" >as a function")}var r=function(){function e(e,t){for(var n</span></span>=0;n&lt;t<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >.l</span>ength;n++){var r=t<span class="fstat-no" title="function not covered" >[n</span>];r.e<span class="cstat-no" title="statement not covered" >numerable=r.enumerable||!1,r.confi<span class="cstat-no" title="statement not covered" >gurab<span class="cstat-no" title="statement not covered" ></span>le=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.proto</span>t<span class="cstat-no" title="statement not covered" ></span>ype,n),<span class="fstat-no" title="function not covered" >r&amp;</span>&amp;e(t,r),t}}(),<span class="cstat-no" title="statement not covered" >i=/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d</span>:[</span>0-5</span>]\<span class="cstat-no" title="statement not covered" >d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,o=/^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$</span>/i<span class="cstat-no" title="statement not covered" >,a=/^[a-z0-9.!#$%&amp;'*+\/=?^_`{|}~-]+@[a-z0-9](?</span>:[<span class="cstat-no" title="statement not covered" >a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,s=/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(</span>?:<span class="cstat-no" title="statement not covered" >25[0-5]|2[0-4]\d|[01]?\d\d?)$/,u=/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]</span>{1<span class="cstat-no" title="statement not covered" >,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,l=/^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.</span>[a<span class="cstat-no" title="statement not covered" >-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i,c=function(){function e(){n(this,e)}return r(</span>e,<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >[{</span>key:"register",val<span class="fstat-no" title="function not covered" >ue</span>:f<span class="cstat-no" title="statement not covered" >unction(e,t<span class="cstat-no" title="statement not covered" ></span>){if("string"!=typeof e)throw new Error("Format name must be a strin<span class="fstat-no" title="function not covered" >g");re</span>turn"<span class="cstat-no" title="statement not covered" >string"==typeof t&amp;&amp;(t=<span class="cstat-no" title="statement not covered" >new RegExp(t)),this[e]=t}},{key:"resolve",value:<span class="cstat-no" title="statement not covered" >f</span></span>unction(e){var t=this[e];if(!t)throw new Error("Unknow</span>n JSON Schema format.");return t}},{key:"test",value:func<span class="fstat-no" title="function not covered" >tion(e</span>,t){var n<span class="cstat-no" title="statement not covered" >=this.re<span class="cstat-no" title="statement not covered" ></span>solve(<span class="cstat-no" title="statement not covered" >e);return n.test(t)}}],[{key:"initialize",value<span class="cstat-no" title="statement not covered" >:</span></span>function(</span>){var t=new e;return t.register("date-time",i),t.regis<span class="fstat-no" title="function not covered" >ter("u</span>ri",o),t.re<span class="cstat-no" title="statement not covered" >gister("email",a<span class="cstat-no" title="statement not covered" ></span>),t.register("ipv4</span>",s),t.register("ipv6",u),t.register("hostname",l),t}}]),e}();<span class="fstat-no" title="function not covered" >e.expo</span>rts=c.in<span class="cstat-no" title="statement not covered" >itialize<span class="cstat-no" title="statement not covered" ></span>()},function(e,t){"use strict";function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var r=function(){fun</span>ction e</span>(e,<span class="cstat-no" title="statement not covered" ></span>t){for(var n=0;n&lt;t.length;</span>n<span class="fstat-no" title="function not covered" >++</span>){var r=t[n];r.enumerable=r.enumer<span class="fstat-no" title="function not covered" >ab</span>le||!<span class="cstat-no" title="statement not covered" >1,r.configurable=!0,"<span class="cstat-no" title="statement not covered" >value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,</span></span>r)}}re<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >tu</span>rn function(t,n,r)<span class="fstat-no" title="function not covered" >{r</span>eturn<span class="cstat-no" title="statement not covered" > n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}<span class="cstat-no" title="statement not covered" >(),i=<span class="cstat-no" title="statement not covered" ></span>function(){function e(t){n(this,e),this.schema=t}return r(e,null,[{key:"compile",value:function(t){var n=new e(</span>t<span class="cstat-no" title="statement not covered" ></span>);retur<span class="fstat-no" title="function not covered" >n </span>n.parse(),n.co<span class="cstat-no" title="statement not covered" >mpile()}}]),r(e,[{key:"parse",value:func</span>ti</span>on(</span>){<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction e(t,r){var <span class="fstat-no" title="function not covered" >i=</span>t.p<span class="cstat-no" title="statement not covered" >roperties||{};Object.keys<span class="cstat-no" title="statement not covered" ></span>(i).forEach(function(t){var o=r.concat([t]),a=i[t],s={key:t,fn:"property<span class="fstat-no" title="function not covered" >",ref:</span>o.join(".<span class="cstat-no" title="statement not covered" >"),chain:<span class="cstat-no" title="statement not covered" ></span>o};a.private&amp;&amp;(s.private=!0),a</span>.default&amp;&amp;(s.default=a.default),a.immutable&amp;&amp;(s.immutable=!0),<span class="fstat-no" title="function not covered" >a.set&amp;</span>&amp;(s.setter=<span class="fstat-no" title="function not covered" >a.</span>set),a.afte<span class="cstat-no" title="statement not covered" >r&amp;&amp;(s.after=a.aft<span class="cstat-no" title="statement not covered" ></span>er),a.properties?(n.get<span class="fstat-no" title="function not covered" >(o</span>)||(s.fn="ensure<span class="cstat-no" title="statement not covered" >Container",n.s</span>et<span class="cstat-no" title="statement not covered" >(o,s)</span>),<span class="cstat-no" title="statement not covered" >e(a,o)):n.set(o,s)})}var t=this.schema,n=this.<span class="cstat-no" title="statement not covered" ></span>operations=new Map;e(t,[])}},{key:"compile",value:function(){var e=this,t="options = options || {}\n";return this.operations.forEach(function(n){t+=e[n.fn](n)}),new Function("target","source","options",t)}},{key:"propert</span>y",</span>value:<span class="cstat-no" title="statement not covered" >function(e){</span>re<span class="cstat-no" title="statement not covered" >turn e.private?this.privat<span class="cstat-no" title="statement not covered" ></span>e(e):this</span>.assign(e)}},{key:"private",value:function(e){return"\n  <span class="fstat-no" title="function not covered" >  if (</span>options.<span class="cstat-no" title="statement not covered" >priva</span>te<span class="cstat-no" title="statement not covered" >) {\n      "+this.assign(e)+<span class="cstat-no" title="statement not covered" ></span>"\n    }\n    "}},{key:"assign"<span class="fstat-no" title="function not covered" >,v</span>alue:funct<span class="cstat-no" title="statement not covered" >ion(e){var t=vo</span>id 0;return t=e.setter?this.setterAssign(e):e.i</span>mmutable?this.immutableAssign(e):this.simpleAssign(e),t="\<span class="fstat-no" title="function not covered" >n    i</span>f (<span class="cstat-no" title="statement not covered" >"+this.condition(e)+") {\n      "+t+"\n    } "+(e</span>.default?this.defaults(e):"")+"\n    ",e.after&amp;&amp;(t+=this.<span class="fstat-no" title="function not covered" >afterA</span>ssi<span class="cstat-no" title="statement not covered" >gn(e)),t}},{key:"immutableAssign",value:function(e){var t="target",n=e.chain.</span>slice(0,e.chain.length-1).join(".");return n&amp;&amp;(t=t+"."+n<span class="fstat-no" title="function not covered" >),"Obj</span>ect.defin<span class="cstat-no" title="statement not covered" >eProper<span class="cstat-no" title="statement not covered" ></span>ty("+t+", '"+e.key+"', {\n        value: source."+e.ref+",\n        writable: "+!e.immutable+",\n        enumerable: true\n      })"}},{key:"simpleAssign",value:function(e){return"target."+e.ref+" = source."+e.ref}},{key:"setterAssign</span>",value:function(e){return"target."+e.ref+" = ("+e.setter.toStrin<span class="fstat-no" title="function not covered" >g()+")</span>(source)"<span class="cstat-no" title="statement not covered" >}},{key:"</span>af<span class="cstat-no" title="statement not covered" >terAssign",value:function(e){return"\n    ("<span class="cstat-no" title="statement not covered" ></span>+e.after.toString()+").call(target, source)\n    "}},{key:"defaults",value:function(e){return"function"==typeof e.default?e.defaultString="("+e.default.toString()+")()":e.defau</span>ltString=JSON.stringify(e.default),"else if (options.defaults <span class="fstat-no" title="function not covered" >!== fa</span>lse<span class="cstat-no" title="statement not covered" >) {\n      "+(e.immutable?this.immutableDe</span>fault(e):this.simpleDefault(e))+"\n    }"}},{key:"simpleDefaul<span class="fstat-no" title="function not covered" >t",val</span>ue:<span class="cstat-no" title="statement not covered" >function(e){return"target."+e.ref+" = "+e.defaultString}},{key</span>:"immutableDefault",value:function(e){var t="target",n=e.chai<span class="fstat-no" title="function not covered" >n.slic</span>e(0<span class="cstat-no" title="statement not covered" >,e.chain.length-1).join(".");return n&amp;&amp;(t=t+"."+n),"Object.definePr</span>operty("+t+", '"+e.key+"', {\n        value: "+e.defaultSt<span class="fstat-no" title="function not covered" >ring+"</span>,\n<span class="cstat-no" title="statement not covered" >        writable: "+!e.immutable+",\n        enumerable: true\n      })"}},{key:"condition",value:function e(t){var n=t.chain,r=t.ref,i=n.reduce(function(e,t,r){return r&gt;0&amp;&amp;e.push("source."+n.slice(0,r).join(".")),e},[]).join(" &amp;&amp; "),e=i?i+" &amp;&amp; </span>source."+r+" !== undefined":"source."+r+" !== undefined";return<span class="fstat-no" title="function not covered" > e}},{</span>key<span class="cstat-no" title="statement not covered" >:"ensureContainer",value:function(e){return"\</span>n    if (!target."+e.ref+") {\n      target."+e.ref+" = {}\n    }\<span class="fstat-no" title="function not covered" >n    "</span>}}]),e}()<span class="cstat-no" title="statement not covered" >;e.export</span>s=<span class="cstat-no" title="statement not covered" >i},function(e,t,n){"use strict";function r(e<span class="cstat-no" title="statement not covered" ></span>,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable</span>||!1,r.configurable=!0,"value"in r<span class="fstat-no" title="function not covered" >&amp;&amp;</span>(r.writab<span class="cstat-no" title="statement not covered" >le=!0),O</span>bj<span class="cstat-no" title="statement not covered" >ect.de</span>fi<span class="cstat-no" title="statement not covered" >nePropert<span class="fstat-no" title="function not covered" >y(</span>e,r.key,r)}}re<span class="cstat-no" title="statement not covered" >turn function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r</span>),t}}(),o=n(98),a=</span>fu<span class="cstat-no" title="statement not covered" >nction(){function e(){var t=arguments.length&gt;0&amp;&amp;void 0!==arguments<span class="cstat-no" title="statement not covered" ></span>[0]?argume</span>nts[0]:{},n=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1<span class="fstat-no" title="function not covered" >]:{};r</span>(th<span class="cstat-no" title="statement not covered" >is,e),this.initialize(t,n)}return i(e,null,[{key:"schema",get:function(){throw new</span> Error(</span>"Sc<span class="cstat-no" title="statement not covered" ></span>hema must be </span>d<span class="fstat-no" title="function not covered" >ef</span>ined by classes extending JSONDocume<span class="fstat-no" title="function not covered" >nt</span>")}}]<span class="cstat-no" title="statement not covered" >),i(e,[{key:"initiali<span class="cstat-no" title="statement not covered" >ze",value:function(){var e=arguments.length&gt;0&amp;&amp;void 0!==ar</span></span>gument<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s[</span>0]?arguments[0]:{}<span class="fstat-no" title="function not covered" >,t</span>=argu<span class="cstat-no" title="statement not covered" >ments.length&gt;1&amp;&amp;void 0!==arguments<span class="cstat-no" title="statement not covered" >[1]?a<span class="cstat-no" title="statement not covered" ></span>rguments[1]:{},n=this.constructor.schema;n.initialize(this,e,t)}},{key:"validate",value:function(e){var t=this.</span>c<span class="cstat-no" title="statement not covered" ></span>onstruc<span class="fstat-no" title="function not covered" >to</span>r.schema;retur<span class="cstat-no" title="statement not covered" >n(e||t).validate(this)}},{key:"patch",va</span>lu</span>e:f</span>un<span class="cstat-no" title="statement not covered" >ction </span>e(<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t)</span>{var e=new o(t);e.<span class="fstat-no" title="function not covered" >ap</span>ply(this<span class="cstat-no" title="statement not covered" >)}},{key:"select",value:function(){}},{key:"project",value</span>:f<span class="cstat-no" title="statement not covered" >unction(e){return e.project(this)}}],[{key:"serialize",val<span class="cstat-no" title="statement not covered" ></span>ue:function(e){return JSON.strin<span class="cstat-no" title="statement not covered" ></span>gify(e)}},{key:"deserialize",value:function(e){try{return JSON.parse(<span class="fstat-no" title="function not covered" >e)}c</span>at<span class="cstat-no" title="statement not covered" >ch(e){throw new Error("Failed to parse JSON")}}}]),e}();e.exports=a},function</span>(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new<span class="fstat-no" title="function not covered" > TypeE</span>rror("Ca<span class="cstat-no" title="statement not covered" >nnot call a class as a function")}var i="function"==typeof</span> S<span class="cstat-no" title="statement not covered" >ymbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return</span> t<span class="cstat-no" title="statement not covered" >ypeof e}:function(e){ret<span class="cstat-no" title="statement not covered" ></span>urn e&amp;&amp;"function"==typeo</span>f Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"sy<span class="fstat-no" title="function not covered" >mbol":</span>typeof e}<span class="cstat-no" title="statement not covered" >,o=function(){function e<span class="cstat-no" title="statement not covered" ></span>(e,t){for(var n=0;n&lt;t.length;</span>n++){var r=t[n];r.enumerable=r<span class="fstat-no" title="function not covered" >.e</span>numerable<span class="cstat-no" title="statement not covered" >||!1,r.co<span class="cstat-no" title="statement not covered" ></span>nfigurable=!0,"</span>value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.ke<span class="fstat-no" title="function not covered" >y,r)}}</span>return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),<span class="fstat-no" title="function not covered" >t}}(),</span>a=n<span class="cstat-no" title="statement not covered" >(99),s=2,u=["add","remov</span>e","replace","move","copy","test"],l=function(){function e(t)<span class="fstat-no" title="function not covered" >{r(thi</span>s,e<span class="cstat-no" title="statement not covered" >),this.ops=t||[]}return o(</span>e,[{key:"apply",value:function(e){var t=this;this.ops.forEach<span class="fstat-no" title="function not covered" >(funct</span>ion<span class="cstat-no" title="statement not covered" >(n){<span class="cstat-no" title="statement not covered" >var r=n.op;if(!r)throw</span> new Erro<span class="cstat-no" title="statement not covered" >r('Missing "op" in JSON Patch operation')</span>;</span>if(u.in</span>dex<span class="cstat-no" title="statement not covered" ></span>Of(r)===-1)th</span>r<span class="fstat-no" title="function not covered" >ow</span> new Error('Invalid "op" in JSON Pat<span class="fstat-no" title="function not covered" >ch</span> oper<span class="cstat-no" title="statement not covered" >ation');if(!n.path)th<span class="cstat-no" title="statement not covered" >row new Error('Missing "path" in JSON Patch operation');t[</span></span>r](n,e<span class="cstat-no" title="statement not covered" >)})}},{key:"add",value:function(e,t){if(void 0===e.value)thr<span class="fstat-no" title="function not covered" >ow</span> new Error<span class="cstat-no" title="statement not covered" >('Missing "value"</span> <span class="fstat-no" title="function not covered" >in</span> JSON Patc<span class="cstat-no" title="statement not covered" >h add operation');var n=new a(e.path,s);n.add(t,e.value)}},{key:"remove",value:function(e,t){var n=ne</span>w</span> a<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>.path);n.remove(t)<span class="fstat-no" title="function not covered" >}}</span>,{key<span class="cstat-no" title="statement not covered" >:"replace",value:function(e,t){if(<span class="cstat-no" title="statement not covered" >void <span class="cstat-no" title="statement not covered" ></span>0===e.value)throw new Error('Missing "value" in JSON Patch replace operation');var n=new a(e.path);n.replace(t,</span>e<span class="cstat-no" title="statement not covered" ></span>.value)<span class="fstat-no" title="function not covered" >}}</span>,{key:"move",v<span class="cstat-no" title="statement not covered" >alue:function(e,t){if(void 0===e.from)th</span>ro</span>w n</span>ew<span class="cstat-no" title="statement not covered" > Error</span>('<span class="cstat-no" title="statement not covered" >Mi</span>ss<span class="cstat-no" title="statement not covered" >ing "from" in JSON Patch move operation');if(e.p</span>at<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >h.</span>match(new RegExp("<span class="fstat-no" title="function not covered" >^"</span>+e.<span class="cstat-no" title="statement not covered" >from)))throw new Error('In<span class="cstat-no" title="statement not covered" ></span>valid "from" in JSON Patch move operation');var n=new a(e.path),r<span class="fstat-no" title="function not covered" >=new a</span>(e.from),<span class="cstat-no" title="statement not covered" >i=r.g<span class="cstat-no" title="statement not covered" ></span>et(t);r.remove(t)<span class="fstat-no" title="function not covered" >,n</span>.add(t,i)}},{key<span class="cstat-no" title="statement not covered" >:"cop<span class="cstat-no" title="statement not covered" ></span>y",val<span class="cstat-no" title="statement not covered" >ue:function(e,t){if(void 0===e.from)throw new Error('Mis<span class="cstat-no" title="statement not covered" >s</span></span>ing "from" in JSON P<span class="cstat-no" title="statement not covered" >atch copy operation');var n=new a(e.path),r=new a(e.from<span class="cstat-no" title="statement not covered" >)</span></span>,i=r.get(t<span class="cstat-no" title="statement not covered" >);n.add(t,i)}},{key:"test",value:function(e,t){if(void 0==<span class="cstat-no" title="statement not covered" >=</span></span>e.value)th</span>row</span> new Error('Missing "value" in JSON Patch test operat<span class="fstat-no" title="function not covered" >ion');</span>var n<span class="cstat-no" title="statement not covered" >=new a(e.path),r=n.g<span class="cstat-no" title="statement not covered" >et(t);switch(i(e.value)){default:if(r!==e.value)throw new Error(</span></span>"Mism<span class="cstat-no" title="statement not covered" >atching JSON Pat<span class="cstat-no" title="statement not covered" ></span>ch test value")}}}</span>]),e}();e.exports=l},function(e,t){"use strict";function<span class="fstat-no" title="function not covered" > n(e,t</span>){if(!(e in<span class="cstat-no" title="statement not covered" >stanceof t))th<span class="cstat-no" title="statement not covered" ></span>row new TypeE</span>rror("Cannot call a class as a function")}var r=function(<span class="fstat-no" title="function not covered" >){func</span>tion <span class="cstat-no" title="statement not covered" >e(e,t){for(var n=0;n<span class="cstat-no" title="statement not covered" >&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurab</span></span>le=!0<span class="cstat-no" title="statement not covered" >,"value"in r&amp;&amp;<span class="cstat-no" title="statement not covered" ></span>(r.writable=!0),Object</span>.defineProperty(e,r.key,r)}}return function(t,n,r){ret<span class="fstat-no" title="function not covered" >urn n&amp;</span>&amp;e(t.<span class="cstat-no" title="statement not covered" >prototype,n),r&amp;&amp;e(t<span class="cstat-no" title="statement not covered" >,r),t}}(),i=0,o=1,a=2,s=function(){function e(t,r){n(this,e),th<span class="cstat-no" title="statement not covered" >i</span></span>s.expr=t,this.mode=r||i,this.tokens=t&amp;&amp;<span class="cstat-no" title="statement not covered" >"#"===t.charAt(0)?this.parseURIFragmentIdentifier(t):this.parseJ</span></span>SONSt<span class="cstat-no" title="statement not covered" >ring(t)}return</span> r<span class="cstat-no" title="statement not covered" >(e,[{key:"esca</span>pe<span class="cstat-no" title="statement not covered" >",value:f<span class="cstat-no" title="statement not covered" ></span>unction(e){return e.repl</span>ace(/~/g,"~0").replace(/\//g,"~1")}},{key:"unescape",v<span class="fstat-no" title="function not covered" >alue:f</span>uncti<span class="cstat-no" title="statement not covered" >on(e){return e.repl<span class="cstat-no" title="statement not covered" >ace(/~1/g,"/").replace(/~0/g,"~")}},{key:"parseJSONString",value</span></span>:func<span class="cstat-no" title="statement not covered" >tion(e){if("st</span>ri<span class="cstat-no" title="statement not covered" >ng"!=typeof e)</span>th<span class="cstat-no" title="statement not covered" >row new E<span class="cstat-no" title="statement not covered" ></span>rror("JSON P</span>ointer must be a string");if(""===e)return[];if("/"!==<span class="fstat-no" title="function not covered" >e.char</span>At(0)<span class="cstat-no" title="statement not covered" >)throw new Error("In<span class="cstat-no" title="statement not covered" >valid JSON Pointer");return"/"===e?[""]:e.substr(1).split("/").ma</span></span>p(thi<span class="cstat-no" title="statement not covered" >s.unescape)}},</span>{k<span class="cstat-no" title="statement not covered" >ey:"toJSO<span class="cstat-no" title="statement not covered" ></span>NString",value:func<span class="branch-0 cbranch-no" title="branch not covered" >tion(){r<span class="cstat-no" title="statement not covered" >eturn"/"+this.t<span class="cstat-no" title="statement not covered" >okens.map(this.escape).join("/")}},{key:"parseURIFragm</span></span></span>e</span>ntIdent</span>ifi<span class="cstat-no" title="statement not covered" ></span>er",value:fun</span>c<span class="fstat-no" title="function not covered" >ti</span>on(e){if("string"!=typeof e)throw <span class="fstat-no" title="function not covered" >ne</span>w Err<span class="cstat-no" title="statement not covered" >or("JSON Pointer must<span class="cstat-no" title="statement not covered" > be a string");if("#"!==e.charAt(0))throw new Error("Inval</span></span>id JSO<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >N </span>Pointer URI Fragme<span class="fstat-no" title="function not covered" >nt</span> Iden<span class="cstat-no" title="statement not covered" >tifier");return this.parseJSONStri<span class="cstat-no" title="statement not covered" >ng(de<span class="cstat-no" title="statement not covered" ></span>codeURIComponent(e.substr(1)))}},{key:"toURIFragmentIdentifier",value:function(){var e=this,t=this.tokens.map(f</span>u<span class="cstat-no" title="statement not covered" ></span>nction(<span class="fstat-no" title="function not covered" >t)</span>{return encode<span class="cstat-no" title="statement not covered" >URIComponent(e.escape(t))}).join("/");re</span>tu</span>rn"</span>#/<span class="cstat-no" title="statement not covered" >"+</span>t}<span class="cstat-no" title="statement not covered" >},</span>{k<span class="cstat-no" title="statement not covered" >ey</span>:"<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ge</span>t",value:function(<span class="fstat-no" title="function not covered" >e)</span>{for(<span class="cstat-no" title="statement not covered" >var t=e,n=this.tokens,r=0;r&lt;n.length;r++){if(!t||void 0===t[n[r]]){if(this.mode!==i)return;throw new Error("Invalid JSON Pointer r<span class="cstat-no" title="statement not covered" ></span>eference")}t=t[n[r]]}return t}},{key:"add",value:function(e,t){for<span class="fstat-no" title="function not covered" >(var n</span>=th<span class="cstat-no" title="statement not covered" >is.tokens,r=e,s=0;s&lt;n.length;s++){var u=n[s];if(s</span>===n.length-1)"-"===u?r.push(t):Array.isArray(r)?r.splice(<span class="fstat-no" title="function not covered" >u,0,t)</span>:r[<span class="cstat-no" title="statement not covered" >u]=t;else if(r[u])r=r[u];else switch(this.mode){</span>case i:throw new Error("Invalid JSON Pointer reference");case o:r<span class="fstat-no" title="function not covered" >=r[u]=</span>par<span class="cstat-no" title="statement not covered" >seInt(u)?[]:{};break;c<span class="cstat-no" title="statement not covered" >ase a:return;default:throw new Error("Invalid poi<span class="cstat-no" title="statement not covered" >n</span></span>ter mode"<span class="cstat-no" title="statement not covered" >)}}}},{ke<span class="cstat-no" title="statement not covered" >y</span></span>:"replace",value:fun<span class="cstat-no" title="statement not covered" >ction(e,t){for(var n=this.tokens,r=e,i=0<span class="cstat-no" title="statement not covered" >;</span></span>i&lt;n.length;i++){var o=n[i];i===n.length-1?r[o]=t:r=r[o]?r[o]:</span>r[o]=parseInt(o)?[]:{}}}},{key:"remove",value:function(e){for(<span class="fstat-no" title="function not covered" >var t=</span>th<span class="cstat-no" title="statement not covered" >is.tokens,n=e,r=0;r&lt;t.length;r++){var i=t[r];if(vo</span>id 0===n||void 0===n[i])return;if(Array.isArray(n))return void n.splice(i,1)<span class="fstat-no" title="function not covered" >;r===t</span>.le<span class="cstat-no" title="statement not covered" >ngth-1&amp;&amp;delete n[i],n=<span class="cstat-no" title="statement not covered" >n[i]}}}],[{key:"parse",value:function(t){return n<span class="cstat-no" title="statement not covered" >e</span></span>w e(t)}}]),e}();e.ex<span class="cstat-no" title="statement not covered" >ports=s},function(e,t,n){"use strict";function r(e,t){if(!(e ins<span class="cstat-no" title="statement not covered" >t</span></span>anceof t))throw new TypeError("Cannot call a class as a funct</span>ion")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been in<span class="fstat-no" title="function not covered" >itiali</span>sed - su<span class="cstat-no" title="statement not covered" >per()</span> h<span class="cstat-no" title="statement not covered" >asn't been calle<span class="fstat-no" title="function not covered" >d"</span>);return!t<span class="cstat-no" title="statement not covered" >||"object"!=typeof t&amp;&amp;"function"!=typeof</span> t?e:t}funct<span class="cstat-no" title="statement not covered" ></span>ion o(e,t){if(</span>"function"!=typeof t&amp;&amp;null!==t)throw new TypeError("S<span class="fstat-no" title="function not covered" >uper e</span>xpr<span class="cstat-no" title="statement not covered" >ession must either be null or a function, not <span class="cstat-no" title="statement not covered" >"+typeof t);e.prototype=O<span class="cstat-no" title="statement not covered" >bject.create(t&amp;&amp;t<span class="cstat-no" title="statement not covered" >.protot<span class="cstat-no" title="statement not covered" >y</span></span>pe,{constructor:{value:e,enumerable:!1,writable:!0<span class="cstat-no" title="statement not covered" ></span>,</span>configurab<span class="cstat-no" title="statement not covered" ></span>l</span>e:!0}}),t</span>&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e<span class="fstat-no" title="function not covered" >.__pro</span>to__=<span class="cstat-no" title="statement not covered" >t)}var a=function(){function e(e,t){for(var n=0;n&lt;t.<span class="cstat-no" title="statement not covered" >lengt<span class="cstat-no" title="statement not covered" ></span>h;n++){var r=t[n];<span class="cstat-no" title="statement not covered" >r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r</span>&amp;&amp;(r<span class="cstat-no" title="statement not covered" >.writabl<span class="cstat-no" title="statement not covered" >e=!0),Ob</span>ject<span class="cstat-no" title="statement not covered" >.defineProperty(e,r.key,r<span class="cstat-no" title="statement not covered" >)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n</span>),r&amp;&amp;e<span class="cstat-no" title="statement not covered" >(t,r),t}}(),s=n(99),u=1,l<span class="cstat-no" title="statement not covered" >=</span>functi</span>on(e){<span class="cstat-no" title="statement not covered" >function</span> t(e){r<span class="cstat-no" title="statement not covered" >(this,t);var n=i(this,(t.__proto__||Objec</span>t</span></span></span>.</span>getPrototypeOf(t)).call(this));return Object.keys(e).forE<span class="fstat-no" title="function not covered" >ach(fu</span>nctio<span class="cstat-no" title="statement not covered" >n(t){var r=e[t];n.set(new s(t,u),new s(r,u))}),n}ret<span class="cstat-no" title="statement not covered" >urn o<span class="cstat-no" title="statement not covered" ></span>(t,e),a(t,[{key:"map",value:function(e,t){this.forEach(fun</span>c</span>tion(n,r){r.add(e,n.get(t))})}},{key:"project",value:fun<span class="fstat-no" title="function not covered" >ction(</span>e,t<span class="cstat-no" title="statement not covered" >){this.forEach(function(n,r){n.add(t,r.get(e))})}}])<span class="cstat-no" title="statement not covered" >,t}(M<span class="cstat-no" title="statement not covered" ></span>ap);e.exports=l},function(e,t<span class="cstat-no" title="statement not covered" >,n){"us<span class="cstat-no" title="statement not covered" >e</span></span> strict";function r<span class="cstat-no" title="statement not covered" >(e,t,n){return t in e?Obje<span class="cstat-no" title="statement not covered" >c</span></span>t.defineProperty(e,t,{value:n,enume</span>r</span>able:!0,configurable:!0,writable:!0}):e[t]=n,e}function i<span class="fstat-no" title="function not covered" >(e,t){</span>if(<span class="cstat-no" title="statement not covered" >!(e instanceof t)</span>)throw </span>new<span class="cstat-no" title="statement not covered" ></span> TypeError("C</span>a<span class="fstat-no" title="function not covered" >nn</span>ot call a class as a function")}var <span class="fstat-no" title="function not covered" >o=</span>"func<span class="cstat-no" title="statement not covered" >tion"==typeof Symbol&amp;<span class="cstat-no" title="statement not covered" >&amp;"symbol"==typeof Symbol.iterator?function(e){return typeo</span></span>f e}:func<span class="fstat-no" title="function not covered" >ti</span>on(e)<span class="cstat-no" title="statement not covered" >{retur<span class="cstat-no" title="statement not covered" >n e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":<span class="cstat-no" title="statement not covered" >t</span></span>ypeof e},a=function(){function e(e,t){for(var n=0;n&lt;t.l</span>ength;n++<span class="fstat-no" title="function not covered" >){</span>var r<span class="cstat-no" title="statement not covered" >=t[n];r.enumerable=r.enumerable||!<span class="cstat-no" title="statement not covered" >1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return<span class="cstat-no" title="statement not covered" > </span></span>function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s=n(96),u=n(102),l=function(){function e(t){i(this,e),Object.assign(this,t),Object.defineProperties(this,{initialize:</span>{enume<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ra</span>ble:!1,writeable:!<span class="fstat-no" title="function not covered" >1,</span>value<span class="cstat-no" title="statement not covered" >:s.compile(t)},validate:{enumerabl<span class="cstat-no" title="statement not covered" >e:!1,<span class="cstat-no" title="statement not covered" ></span>writeable:!1,value:u.compile(t)}})}return a(e,[{key:"extend",value:function(t){function n(e){return e&amp;&amp;"object"</span>=<span class="cstat-no" title="statement not covered" ></span>==("und<span class="fstat-no" title="function not covered" >ef</span>ined"==typeof <span class="cstat-no" title="statement not covered" >e?"undefined":o(e))&amp;&amp;null!==e&amp;&amp;!Array.is</span>Ar</span>ray</span>(e<span class="cstat-no" title="statement not covered" >)}func</span>ti<span class="cstat-no" title="statement not covered" >on</span> i<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t){var o=Object.as<span class="fstat-no" title="function not covered" >si</span>gn(<span class="cstat-no" title="statement not covered" >{},e);retur</span>n n(e<span class="cstat-no" title="statement not covered" >)&amp;&amp;n(t)&amp;&amp;Object.keys(t).forEach(function(a){n(t[a])&amp;&amp;a in e<span class="cstat-no" title="statement not covered" ></span>?o[a]=i(e[a],t[a]):Object.assi<span class="fstat-no" title="function not covered" >gn</span>(o,r({},a,t[a]))<span class="cstat-no" title="statement not covered" >}),o}<span class="cstat-no" title="statement not covered" ></span>var a=i(this,t);return new e(a</span>)}}])<span class="cstat-no" title="statement not covered" ></span>,e}();e.exports=l},function(e,t,n){"use strict";function r(e,t){if(!(e<span class="fstat-no" title="function not covered" > insta</span>nceof<span class="cstat-no" title="statement not covered" > t))throw new<span class="fstat-no" title="function not covered" > T</span>ypeError("Ca<span class="cstat-no" title="statement not covered" >nnot call a class a</span>s a</span> function")}var i="function"==typeof Symbol&amp;&amp;"symbol"==ty<span class="fstat-no" title="function not covered" >peof S</span>ymbol<span class="cstat-no" title="statement not covered" >.iterator?fun<span class="fstat-no" title="function not covered" >ct</span>ion(e){retur<span class="cstat-no" title="statement not covered" >n typeof e}:functio</span>n(e</span>){retur</span>n e&amp;&amp;"<span class="cstat-no" title="statement not covered" ></span>function"==ty</span>p<span class="fstat-no" title="function not covered" >eo</span>f Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!<span class="fstat-no" title="function not covered" >==</span>Symbol.<span class="cstat-no" title="statement not covered" >prototype?"symbol":typeof e},o=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enum</span>erable=r.<span class="fstat-no" title="function not covered" >en</span>umera<span class="cstat-no" title="statement not covered" >ble||!1,r.configurabl<span class="cstat-no" title="statement not covered" >e=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,</span></span>r.key,<span class="cstat-no" title="statement not covered" >r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t<span class="fstat-no" title="function not covered" >,r</span>),t}}(),a=<span class="cstat-no" title="statement not covered" >n(95),s=function(</span>)<span class="fstat-no" title="function not covered" >{f</span>unction e(<span class="cstat-no" title="statement not covered" >t){var n=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};r(this,e),this.schema=t,Object.ass</span>i</span>gn<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>his,n),this.addres<span class="fstat-no" title="function not covered" >s|</span>|(thi<span class="cstat-no" title="statement not covered" >s.address=""),this.require!==!0&amp;&amp;(<span class="cstat-no" title="statement not covered" >this.<span class="cstat-no" title="statement not covered" ></span>require=!1)}return o(e,null,[{key:"compile",value:function(t){var n=new e(t),r='\n      // "cursor"\n      let </span>v<span class="cstat-no" title="statement not covered" ></span>alue = <span class="fstat-no" title="function not covered" >da</span>ta\n      let <span class="cstat-no" title="statement not covered" >container\n      let stack = []\n      l</span>et</span> to</span>p <span class="cstat-no" title="statement not covered" >= -1\n</span>\n<span class="cstat-no" title="statement not covered" >      /</span>/ <span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >er</span>ror state\n      l<span class="fstat-no" title="function not covered" >et</span> va<span class="cstat-no" title="statement not covered" >lid = true\n      let errors = []\n\n      // complex schema state\n      let initialValidity\n      let anyValid\n      let notValid\n      let countOfValid\n      let initialError<span class="cstat-no" title="statement not covered" ></span>Count\n      let accumulatedErrorCount\n\n      // validation code<span class="fstat-no" title="function not covered" >\n    </span>  '+n.compil<span class="fstat-no" title="function not covered" >e(</span>)+"<span class="cstat-no" title="statement not covered" >\n\n      // validation result\n      return {\n        valid,\n        errors\n      }\n   </span> ";return<span class="fstat-no" title="function not covered" > n</span>ew Function<span class="cstat-no" title="statement not covered" >("data",r)}}]),o(e,[<span class="cstat-no" title="statement not covered" ></span>{key:"compile",value:function(){var e="";r<span class="fstat-no" title="function not covered" >et</span>urn this.r<span class="cstat-no" title="statement not covered" >equire&amp;&amp;(e+=this.required()),e+=this.type(),e+=this.array(),e+=th</span>is.nu</span>mber()<span class="cstat-no" title="statement not covered" >,e+=this.o<span class="cstat-no" title="statement not covered" ></span>bject(),e+=this.s</span>tring()</span>,e+<span class="cstat-no" title="statement not covered" ></span>=this.enum(),</span>e<span class="fstat-no" title="function not covered" >+=</span>this.anyOf(),e+=this.allOf(),e+=this<span class="fstat-no" title="function not covered" >.n</span>ot(),<span class="cstat-no" title="statement not covered" >e+=this.oneOf()}},{ke<span class="cstat-no" title="statement not covered" >y:"push",value:function(){return"\n      stack.push(value)</span></span>\n    <span class="cstat-no" title="statement not covered" >  container = value\n      top++\n    "}},{key:"pop",value:f<span class="fstat-no" title="function not covered" >un</span>ction(){re<span class="cstat-no" title="statement not covered" >turn"\n      if (</span>s<span class="fstat-no" title="function not covered" >ta</span>ck.length <span class="cstat-no" title="statement not covered" >&gt; 1) {\n        top--\n        stack.pop()\n      }\n\n      value = container = stack[top]\n    "}},</span>{</span>ke<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >y:</span>"type",value:funct<span class="fstat-no" title="function not covered" >io</span>n e()<span class="cstat-no" title="statement not covered" >{var e=this.schema.type,t=this.add<span class="cstat-no" title="statement not covered" >ress,<span class="cstat-no" title="statement not covered" ></span>n="";if(e){var r=Array.isArray(e)?e:[e],i=r.map(function(e){return"array"===e?"!Array.isArray(value)":"boolean"</span>=<span class="cstat-no" title="statement not covered" ></span>==e?"ty<span class="fstat-no" title="function not covered" >pe</span>of value !== '<span class="cstat-no" title="statement not covered" >boolean'":"integer"===e?"!Number.isInteg</span>er</span>(va</span>lu<span class="cstat-no" title="statement not covered" >e)":"n</span>ul<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >l"</span>===e?"value !== nu<span class="fstat-no" title="function not covered" >ll</span>":"number<span class="cstat-no" title="statement not covered" >"===e?"typeof value !== 'number'":"object"===e?"(typeof va<span class="cstat-no" title="statement not covered" ></span>lue !== 'object' || Array.isArray(value) || value === null)":"string"===e?"typeof value !== 'string'":void 0}).join(<span class="cstat-no" title="statement not covered" ></span>" &amp;&amp; ");n+="\n      // "+t+" type checking\n      if (value !== undefine<span class="fstat-no" title="function not covered" >d &amp;&amp; "</span>+i+") {\n<span class="cstat-no" title="statement not covered" >        v</span>al<span class="cstat-no" title="statement not covered" >id = false\n        errors.push({\n          keyword: 'type',\n          message: 'invalid type'\n        })\n      }\n      "}return n}},{key:"array",value:function(){var e=["additionalItems","items","minItems","maxItems","uniqueItems"],t=this.validations(e),n="";return t.length&gt;0&amp;&amp;(n+="\n      /**\n       * Array validations\n       */\n      if (Array.isArray(value)) {\n      "+t+"\n      }\n      "),n}},{key:"number",value:function(){var e=["minimum","maximum","multipleOf"],t=this.validations(e),n="";<span class="cstat-no" title="statement not covered" ></span>return t.length&gt;0&amp;&amp;(n+="\n     </span> /**\n       * Number validations\n       */\n      if (typeof v<span class="fstat-no" title="function not covered" >alue =</span>== 'numb<span class="cstat-no" title="statement not covered" >er'<span class="cstat-no" title="statement not covered" ></span>) {\n      "+t+"\n      }\n      "),n}},{key:"object",value:function(){var e=["maxProperties","minProperties","additionalProperties","properties","patternProperties","dependencies","schemaDependencies",</span>"propertyDependencies"],t=this.validations(e),n="";ret<span class="fstat-no" title="function not covered" >urn t.</span>le<span class="cstat-no" title="statement not covered" >ngth&gt;0&amp;&amp;(n+="\n      /**\n       * Object validations\n       */\n      if (typ</span>eof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.is<span class="fstat-no" title="function not covered" >Array(</span>va<span class="cstat-no" title="statement not covered" >lue)) {\n      "+t+"\n      }\n      "),n}},{key:"string",value:function(){var e=["maxLength","minLength","pattern","format"],t=this</span>.validations(e),n="";return t<span class="fstat-no" title="function not covered" >.l</span>ength&gt;0&amp;<span class="cstat-no" title="statement not covered" >&amp;(n+="\n      /**</span>\n<span class="cstat-no" title="statement not covered" >       * Stri</span>ng<span class="cstat-no" title="statement not covered" > va<span class="cstat-no" title="statement not covered" ></span>lidations\n <span class="cstat-no" title="statement not covered" >      */\n      if (typ</span>eo<span class="cstat-no" title="statement not covered" >f valu<span class="fstat-no" title="function not covered" >e </span>=== 'strin<span class="cstat-no" title="statement not covered" >g') {\n      "+t+"\n      }\n      "),n}},{key:"validations",value:function(e){var t=this,n=this.schema,r="",i=Object.keys(n).filter(function(t){return e.indexOf(t)!==-1});return i.forEach(function(e){r+=t[e]()}),r}},{key:"enum",value:function(){var e=this.schema.enum,t=this.address,n=["value !== undefined"],r="";return e&amp;&amp;(e.f</span>orEach(function<span class="cstat-no" title="statement not covered" ></span>(e){switch("undefined"==typeof e?"undefined":i(e)){case"boolean":n.push("value !== "+e);break;case"number":n.push("value !== "+e);break;case"string":n.push('value !== "'+e+'"');break;case"object":null===e?n.push("value<span class="cstat-no" title="statement not covered" ></span> </span>!== null"</span>):n.push("'"+JSON.stringify(e)+"' !== JSON.stringify(va<span class="fstat-no" title="function not covered" >lue)")</span>;break;d<span class="cstat-no" title="statement not covered" >efault:throw new Error("Things are not well in the land of enum"</span>)}<span class="cstat-no" title="statement not covered" >}),r+='\n      /**\n</span>  <span class="cstat-no" title="statement not covered" >   <span class="cstat-no" title="statement not covered" ></span>  * Validate "'+t+'" enum\n       */\n      if ('+n.join(" &amp;&amp; ")+") {\n        valid = false\n        errors.push({\n          keyword: 'enum',\n</span>          message: JSON.stringify(value) + ' is not an e<span class="fstat-no" title="function not covered" >numera</span>ted valu<span class="cstat-no" title="statement not covered" >e'\n        })\n      }\n      "),r</span>}}<span class="cstat-no" title="statement not covered" >,{key:"anyOf",value:</span>fu<span class="cstat-no" title="statement not covered" >nct<span class="cstat-no" title="statement not covered" ></span>ion t(){var t=this.schema.anyOf,n=this.address,r="";return Array.isArray(t)&amp;&amp;(r+="\n        initialValidity = valid\n        initialErrorCount = errors</span>.length\n        anyValid = false\n      ",t.forEach(fun<span class="fstat-no" title="function not covered" >ction(</span>t){var i<span class="cstat-no" title="statement not covered" >=new e(t,{address:n});r+="\n        accumulatedErrorCount = errors.length\n        "+i.compile()+"\n        if (accumulatedErrorCount === errors.leng</span>th<span class="cstat-no" title="statement not covered" >) {\n          anyVa</span>li<span class="cstat-no" title="statement not covered" >d =<span class="cstat-no" title="statement not covered" ></span> true\n        }\n        "}),r+="\n          if (anyValid === true) {\n            valid = initialValidity\n            errors = errors.slice(0, initialErrorCount)\n          }\n      "),r}},{k</span>ey:"allOf",value:function t(){var t=this.schema.allOf,n=<span class="fstat-no" title="function not covered" >this.a</span>ddress,r<span class="cstat-no" title="statement not covered" >="";return Array.isArray(t)&amp;&amp;t.forEach(functi</span>on<span class="cstat-no" title="statement not covered" >(t){var i=new e(t,{a</span>dd<span class="cstat-no" title="statement not covered" >res<span class="cstat-no" title="statement not covered" ></span>s:n});r+="\n        "+i.compile()+"\n        "}),r}},{key:"oneOf",value:function t(){var t=this.schema.oneOf,n=this.address,r="";return Array.isArray(t</span>)&amp;&amp;(r+="\n        /**\n         * Validate "+n+" oneOf\n     <span class="fstat-no" title="function not covered" >    */</span>\n       <span class="cstat-no" title="statement not covered" > init</span>ia<span class="cstat-no" title="statement not covered" >lValidity = </span>va<span class="cstat-no" title="statement not covered" >lid</span>\n<span class="cstat-no" title="statement not covered" >        initialErrorCo<span class="fstat-no" title="function not covered" >un</span>t = errors<span class="cstat-no" title="statement not covered" >.length\n        countOfVa</span>li<span class="cstat-no" title="statement not covered" ></span>d = 0\n      ",t.<span class="fstat-no" title="function not covered" >fo</span>rEach(func<span class="cstat-no" title="statement not covered" >tion(t){var</span> i=ne</span>w e(t,{address:n});r+="\n        accumulatedErrorCount<span class="fstat-no" title="function not covered" > = err</span>ors.leng<span class="cstat-no" title="statement not covered" >th\n        "+i.c</span>om<span class="cstat-no" title="statement not covered" >pile()+"\n   </span>  <span class="cstat-no" title="statement not covered" >   if (accumulatedErrorC</span>ou<span class="cstat-no" title="statement not covered" >nt <span class="cstat-no" title="statement not covered" ></span>=== errors.length) {\<span class="fstat-no" title="function not covered" >n </span>         c<span class="cstat-no" title="statement not covered" >ountOfValid += 1\n        }\n        "}),r+="\n          if (<span class="cstat-no" title="statement not covered" >countOfValid === 1) {\n<span class="cstat-no" title="statement not covered" > </span>      </span>     valid =<span class="cstat-no" title="statement not covered" > initialValidity\n     <span class="cstat-no" title="statement not covered" > </span>      </span>errors = err<span class="cstat-no" title="statement not covered" >ors.slice(0, initialErrorCou<span class="cstat-no" title="statement not covered" >n</span>t)\n  </span>        } el<span class="cstat-no" title="statement not covered" >se {\n            valid = false\n            errors.push({\n              keyword: 'oneOf',\n <span class="cstat-no" title="statement not covered" > </span>      </span>      m<span class="cstat-no" title="statement not covered" >essage: 'what is a reasonable error message for this case?'\</span>n</span>            })\n          }\n      "),r}},{key:"not",value:function t(){var t=this.schema.not,n=this.address,r="";if("object"===("undefined"==typeof t?"undefined":i(t))&amp;&amp;null!==t&amp;&amp;!Array.isArray(t)){var o=t,a=new e(o,{address:n});r+="\n        /**\n         * NOT\n         */</span>\n        if (value !== undefi<span class="fstat-no" title="function not covered" >ne</span>d) {\n  <span class="cstat-no" title="statement not covered" >        initialVal</span>id<span class="cstat-no" title="statement not covered" >ity = valid\n</span>  <span class="cstat-no" title="statement not covered" >   <span class="cstat-no" title="statement not covered" ></span>     initialErrorCount = errors.length\n          notValid = true\n\n          accumulatedErrorCount = errors.length\n\n          "+a.compile()+"\n\n   <span class="fstat-no" title="function not covered" >  </span>     if (accumul<span class="cstat-no" title="statement not covered" >atedErrorCount === er<span class="cstat-no" title="statement not covered" ></span>rors.length) {\n            notValid = false\n          }\n\n          if (notValid === true) {\n            valid = initialValidity\n            errors = errors.slice(0, initialError</span>Count)\n          } else {\n            valid = false\n            errors = errors.slice(0, initialErrorCount)\n            errors.push({\n              keyword: '</span>not',\n              message: <span class="fstat-no" title="function not covered" >'h</span>mm...'\n<span class="cstat-no" title="statement not covered" >            })\n  </span>  <span class="cstat-no" title="statement not covered" >      }\n    </span>  <span class="cstat-no" title="statement not covered" >  }<span class="cstat-no" title="statement not covered" ></span>\n      "}return r}},{key:"properti<span class="fstat-no" title="function not covered" >es</span>",value:function<span class="cstat-no" title="statement not covered" > t(){var n=this.schem<span class="cstat-no" title="statement not covered" ></span>a,r=this.address,t=n.properties,o=n.requir</span>ed,a=</span>this.push();return o=Array.isA<span class="fstat-no" title="function not covered" >rr</span>ay(o)?o:<span class="cstat-no" title="statement not covered" >[],"object"===("un</span>de<span class="cstat-no" title="statement not covered" >fined"==typeo</span>f <span class="cstat-no" title="statement not covered" >t?"<span class="cstat-no" title="statement not covered" ></span>undefined":i(t))&amp;&amp;Object.keys(t).forEach(function(n){var i=t[n],s=o.indexOf(n)!==-1,u=[r,n].filter(function(e){return!!e}).join("."),l=new e(i,{address:u,require:s});a+="\n        value = container['"+n+"']\n   <span class="fstat-no" title="function not covered" >  </span>   ",a+=l.compil<span class="cstat-no" title="statement not covered" >e()}),a+=this.pop()}}<span class="cstat-no" title="statement not covered" ></span>,{key:"otherProperties",value:function(){return"\n      /**\n       * Validate Other Properties\n       */\n      "+this.push()+"\n\n      for (let key in container) {\n        value = </span>container[key]\n        matched = false\n\n        "+this.patternValidations()+"\n        "+this.additionalValidations()+"\n      }\n\n      "+this.pop()+"\n    "}},{key:"patternValidations",value:function(){var t=this.schema.patternProperties,n="";return"object"===("undefined"==typeof t?"undefined":i(t))&amp;&amp;Object.keys(t).forEach(function(r){var i=t[r],o=new e(i</span>);n+="\n          if (key.ma<span class="fstat-no" title="function not covered" >tc</span>h('"+r+"<span class="cstat-no" title="statement not covered" >')) {\n         </span>  <span class="cstat-no" title="statement not covered" > matched = tr</span>ue<span class="cstat-no" title="statement not covered" >\n <span class="cstat-no" title="statement not covered" ></span>           "+o.compile()+"\n          }\n        "}),n}},{key:"additionalValidations",value<span class="cstat-no" title="statement not covered" >:f</span>un<span class="cstat-no" title="statement not covered" >ction(){var t=this.sc<span class="cstat-no" title="statement not covered" ></span>hema,n=t.properties,r=t.additionalProperties,o=this.address,a="",s=["matched !== true"];if(Object.keys(n||{}).forEach(function(e){s.push("key !== '"+e+"'")}),"object"===("undefined"==typeof r?"undefined":i(r))){var u=r,l=new e(u,{address:o+"[APKey]"});a+="\n        // validate additional properties\n        if ("+s.join(" &amp;&amp; ")+") {\n          "+l.compile()+"\n        }\n      "}return r===!1&amp;&amp;(a+="\n        // validate non-presence of additional properties\n        if ("+s.join(" &amp;&amp; ")+") {\n          valid = false\n          errors.push({\n            keyword: 'additionalProperties',\n            message: key + ' is not a defined property'\n          })\n        }\n      "),a}},{key:"patternProperties",value:function(){var e="";return thi<span class="cstat-no" title="statement not covered" ></span>s</span>.otherPro</span>pertiesCalled||(this.otherPropertie<span class="fstat-no" title="function not covered" >sC</span>alled=!0<span class="cstat-no" title="statement not covered" >,e+=this.oth</span>er<span class="cstat-no" title="statement not covered" >Properties())</span>,e<span class="cstat-no" title="statement not covered" >}},{key:"addi</span>ti<span class="cstat-no" title="statement not covered" >onalPropert</span>ie<span class="cstat-no" title="statement not covered" >s",value:fun<span class="cstat-no" title="statement not covered" ></span>ction(){var e="";return this.otherPropertiesCalled||(this.otherPropertiesCalled=!0,e+=this.otherProperties(<span class="fstat-no" title="function not covered" >))</span>,e}},{key:"minPr<span class="cstat-no" title="statement not covered" >opert</span>ie<span class="cstat-no" title="statement not covered" >s",value:function </span>e(<span class="cstat-no" title="statement not covered" >){var e=this.<span class="fstat-no" title="function not covered" >sc</span>hema.minPr<span class="cstat-no" title="statement not covered" >operties,t=</span>this.address</span>;r<span class="cstat-no" title="statement not covered" >eturn"\n        // "+t+" min pr<span class="cstat-no" title="statement not covered" ></span>operties\n        if (Object.keys(value).length &lt; "+e+") {\n        </span>  valid = false\n</span>          errors.push({\n            keyword: 'minProperties',\n <span class="fstat-no" title="function not covered" >      </span>  <span class="cstat-no" title="statement not covered" >   message: 'too few properties'\n          })\n        }\n    "}},{key:"maxProperties",value:function e(){var e=this.schema.maxProperties,t=this.address;return"\n        // "+t+" max properties\n        if (Object.keys(value).length &gt; "+e+") {\n          valid = false\n          errors.push({\n            </span>keyword: 'maxProperties',\n            message: 'too many properties<span class="fstat-no" title="function not covered" >'\n   </span>       }<span class="cstat-no" title="statement not covered" >)\n        }\n    "}},{key:"de</span>pe<span class="cstat-no" title="statement not covered" >nde<span class="cstat-no" title="statement not covered" ></span>ncies",value:function t(){var t=this.schema.dependencies,n=this.address,r=this.pus<span class="fstat-no" title="function not covered" >h(</span>);return"object"<span class="cstat-no" title="statement not covered" >===("</span>un<span class="cstat-no" title="statement not covered" >defined"=<span class="cstat-no" title="statement not covered" ></span>=typeof t?"undefined":i(t))&amp;&amp;Object.keys(t).forEach(function(o){var a=t[o],s=[];if(Array.isArray(a))a.forEach(function(e){s.</span>push(</span>"container['"+e+"'] === undefined")}),r+="\n            if (container['<span class="fstat-no" title="function not covered" >"+o+"'</span>] !== un<span class="cstat-no" title="statement not covered" >defined &amp;&amp; (</span>"+<span class="cstat-no" title="statement not covered" >s.join(" || "</span>)+<span class="cstat-no" title="statement not covered" >")) {\n              va</span>li<span class="cstat-no" title="statement not covered" >d = false\n  </span>  <span class="cstat-no" title="statement not covered" >   </span>  <span class="cstat-no" title="statement not covered" >     errors.push({\n <span class="cstat-no" title="statement not covered" ></span>               keyword: 'depen<span class="fstat-no" title="function not covered" >de</span>ncies',\n <span class="cstat-no" title="statement not covered" >               message: 'un</span>met dependencies'\n              })\n            }\n         <span class="cstat-no" title="statement not covered" > "</span>;e<span class="cstat-no" title="statement not covered" >lse if("object"===("undefined"=<span class="cstat-no" title="statement not covered" ></span>=typeof a?"undefined":i(a))){var u=a,l=new e(u,{address:n});r+="\n            if (container['"+o+"'] !== undefined) {\n            <span class="cstat-no" title="statement not covered" ></span> </span> "+l.compile()+"\n            }\n          "}}),r+=this.pop()}},{key:"required",value:function(){var e=(this.schema.properties,this.address),t="";return t+="\n      // validate "+e+" presence\n      if (value === undefined) {\n        valid = false\n        errors.push({\n          keyword: 'required',\n</span>          message: 'is required'\n        })\n      }\n    "}},{key<span class="fstat-no" title="function not covered" >:"addi</span>tionalIt<span class="cstat-no" title="statement not covered" >ems<span class="cstat-no" title="statement not covered" ></span>",value:function t(){var n=this.schema,r=n.items,t=n.additionalItems,o=(this.address,"");if(t===</span>!1&amp;&amp;Array.isArray(r)&amp;&amp;(o+="\n        // don't allow additional items\n<span class="fstat-no" title="function not covered" >      </span>  if (va<span class="cstat-no" title="statement not covered" >lue<span class="cstat-no" title="statement not covered" ></span>.length &gt; "+r.length+") {\n          valid = false\n          errors.push({\n            keyword</span>: 'additionalItems',\n            mess<span class="fstat-no" title="function not covered" >ag</span>e: 'addi<span class="cstat-no" title="statement not covered" >tional items not allowed'\</span>n <span class="cstat-no" title="statement not covered" >         })\n<span class="cstat-no" title="statement not covered" ></span>        }\n      "),"object"===("undefined"==typeof t?"undefined":i(t))&amp;&amp;null!==t&amp;&amp;Array.isArray(r)){var a=t,s=new e(a);o+="\n        // additional items\n        "+this.push()+"\n\n        for (var i = "+r.length+"; i &lt;= container.length; i++) {\n        </span>  value = container[i]\n          "+s.<span class="fstat-no" title="function not covered" >co</span>mpile()+<span class="cstat-no" title="statement not covered" >"\n        }\n\n        "+</span>th<span class="cstat-no" title="statement not covered" >is.pop()+"\n <span class="cstat-no" title="statement not covered" ></span>     "}return o}},{key:"items",value:function t(){var t=this.schema.items,n=this.address,r="";if(Array.isArray(t))r+=this.push(),t.forEach(function(t,i){var o=t,a=new e(o,{address:n+"["+i+"]"});r+="\n          // item #"+i+"\n          value = container["+i</span>+"]\n          "+a.compile()+"\n     <span class="fstat-no" title="function not covered" >  </span> "}),r+=<span class="cstat-no" title="statement not covered" >this.pop();else if("objec</span>t"<span class="cstat-no" title="statement not covered" >===("undefine</span>d"<span class="cstat-no" title="statement not covered" >==typeof t?"<span class="cstat-no" title="statement not covered" ></span>undefined":i(t))&amp;&amp;null!==t){var o=t,a=new e(o);r+="\n        // items\n        "+t<span class="fstat-no" title="function not covered" >hi</span>s.push()+"\n\n  <span class="cstat-no" title="statement not covered" >     </span> f<span class="cstat-no" title="statement not covered" >or <span class="cstat-no" title="statement not covered" ></span>(var i = 0; i &lt; cont<span class="cstat-no" title="statement not covered" >ainer.leng<span class="fstat-no" title="function not covered" >th</span>; i++) {\n<span class="cstat-no" title="statement not covered" >          // read array element\n          v</span>alue = container[i]\n          "+a.compile()+"\n        }\n\n        "+this.pop()+"\n      "}return r}},{key:"minItems",value:function e(){var e=this.schema.minItems,t=this.address;return"\n        // "+t+" min items\n        if (value.length &lt; "+e+") {\n          valid = false</span>\n  <span class="cstat-no" title="statement not covered" >        errors.push({\n            keyword: 'minItems',\n     <span class="cstat-no" title="statement not covered" >  </span>  <span class="cstat-no" title="statement not covered" >   message: 'too few <span class="cstat-no" title="statement not covered" ></span>properties'\n          })\n        }\n    "}},{key:"maxItems",value:function e(){<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
var e=<span class="cstat-no" title="statement not covered" >this.schema.maxItems,</span>t=<span class="cstat-no" title="statement not covered" >this.address;<span class="cstat-no" title="statement not covered" ></span>return"\n        // "+t+" max items\n        if (value.length &gt; "+e+") {\n          valid = false\n          errors.push({\n            keyword: 'maxItems',\n            message: 'too many properties'\n          })\n        }\n    "}}</span>,{key:"uniqueItems",value:function e<span class="fstat-no" title="function not covered" >()</span>{var e=t<span class="cstat-no" title="statement not covered" >his.schema.uniqueItems,t</span>=t<span class="cstat-no" title="statement not covered" >his.address,n</span>="<span class="cstat-no" title="statement not covered" >";r<span class="cstat-no" title="statement not covered" ></span>eturn e===!0&amp;&amp;(n+="\n        // validate "+t+" unique items\n        let values = value.map(v =&gt; JSON.stringify(v)) // TODO: optimize\n        let set = new Set(values)\n        if (values.length !== set.size) {\n          valid = false\n          errors.push({\n            keyword: 'uniqueItems',\n            message: 'items must be unique'\n          })\n        }\n      "),n}},</span>{key:"minLength",value:function e(<span class="fstat-no" title="function not covered" >){</span>var e=th<span class="cstat-no" title="statement not covered" >is.schema.minLength,t=</span>th<span class="cstat-no" title="statement not covered" >is.address;re<span class="cstat-no" title="statement not covered" ></span>turn"\n        // "+t+" validate minLength\n        if (Array.from(value).length &lt; "+e+") {\n          valid = false\n          errors.push({\n            keyword: 'minLength',\n            message: 'too short'\n          })\n        }\n    "}},{</span>key:"maxLength",value:function e()<span class="fstat-no" title="function not covered" >{v</span>ar e=thi<span class="cstat-no" title="statement not covered" >s.schema.maxLength,t=t</span>hi<span class="cstat-no" title="statement not covered" >s.address;ret<span class="cstat-no" title="statement not covered" ></span>urn"\n        // "+t+" validate maxLength\n        if (Array.from(value).length &gt; "+e+") {\n          valid = false\n          errors.push({\n            keyword: 'maxLength',\n            message: 'too long'\n          })\n        }\n    "}},{k</span>ey:"pattern",value:function e(){<span class="fstat-no" title="function not covered" >va</span>r e=this<span class="cstat-no" title="statement not covered" >.schema.pattern,t=th</span>is<span class="cstat-no" title="statement not covered" >.address;if(e<span class="cstat-no" title="statement not covered" ></span>)retu<span class="cstat-no" title="statement not covered" >rn"\n          // "+t+" validate pattern\n          if (!value.match(new RegExp('"+e+"'))) {\n            valid = false\n            errors.push({\n              keyword: 'pattern',\n              message: 'does not match the required pattern'\n            })\n          }\n      "}},{ke</span></span>y:"format",value:function e(){v<span class="fstat-no" title="function not covered" >ar</span> e=this.<span class="cstat-no" title="statement not covered" >schema.format,t=thi</span>s.<span class="cstat-no" title="statement not covered" >address,n=a.r</span>es<span class="cstat-no" title="statement not covered" >olve(e);if(n)<span class="cstat-no" title="statement not covered" ></span>retur<span class="cstat-no" title="statement not covered" >n"\n      // "+t+" validate format\n      if (!value.match("+n+")) {\n        valid = false\n        errors.push({\n          keyword: 'format',\n          message: 'is not \""+e+"\" format'\n        })\n      }\n      "}},{key</span></span>:"minimum",value:function e(){va<span class="fstat-no" title="function not covered" >r </span>t=this.s<span class="cstat-no" title="statement not covered" >chema,e=t.mi</span>ni<span class="cstat-no" title="statement not covered" >mum,n=t.ex</span>cl<span class="cstat-no" title="statement not covered" >usiveMinimum,r=this</span>.a<span class="cstat-no" title="statement not covered" >ddress,i=n===</span>!0<span class="cstat-no" title="statement not covered" >?"&lt;=":"&lt;";return<span class="cstat-no" title="statement not covered" ></span>"\n        // "+r+" validate minimum\n        if (value "+i+" "+e+") {\n          valid = false\n          errors.push({\n            keyword: 'minimum',\n            message: 'too small'\n          })\n        }\n    "}},{key:</span>"maximum",value:function e(){var<span class="fstat-no" title="function not covered" > t</span>=this.sc<span class="cstat-no" title="statement not covered" >hema,e=t.max</span>im<span class="cstat-no" title="statement not covered" >um,n=t.exc</span>lu<span class="cstat-no" title="statement not covered" >siveMaximum,r=this.</span>ad<span class="cstat-no" title="statement not covered" >dress,i=n===!</span>0?<span class="cstat-no" title="statement not covered" >"&gt;=":"&gt;";return"<span class="cstat-no" title="statement not covered" ></span>\n        // "+r+" validate maximum\n        if (value "+i+" "+e+") {\n          valid = false\n          errors.push({\n            keyword: 'maximum',\n            message: 'too large'\n          })\n        }\n    "}},{key:"</span>multipleOf",value:function e(){var <span class="fstat-no" title="function not covered" >e=</span>this.sch<span class="cstat-no" title="statement not covered" >ema.multipleOf,t="";if(</span>"n<span class="cstat-no" title="statement not covered" >umb<span class="cstat-no" title="statement not covered" ></span>er"==typeof e){var n=e.toStri<span class="cstat-no" title="statement not covered" >ng().length,r=n-e.to</span>Fi<span class="cstat-no" title="statement not covered" >xed(0).length-1,i=r&gt;0?Ma</span>th<span class="cstat-no" title="statement not covered" >.pow(10,r):1,o=void 0</span>;o<span class="cstat-no" title="statement not covered" >=r&gt;0?"(<span class="cstat-no" title="statement not covered" ></span>value * "+i+") % "+e*i+" !== 0":"value % "+e+" !== 0",t+="\n        if ("+o+") {\n          valid = false\n          errors.push({\n            keyword: 'multipleOf',\n            message: 'must be a multiple of "+e+"'\n          })\n        }\n      "}return t}<span class="cstat-no" title="statement not covered" ></span>}</span>]),e}();e</span>.exports=s<span class="cstat-no" title="statement not covered" >},function(e,</span>t<span class="fstat-no" title="function not covered" >,n</span>){"use strict";var r=n(104),i=n(1<span class="cstat-no" title="statement not covered" >16),o=n</span>(1<span class="cstat-no" title="statement not covered" >19),a=n</span>(1<span class="cstat-no" title="statement not covered" >21),s=n</span>(1<span class="cstat-no" title="statement not covered" >26),u=n</span>(1<span class="cstat-no" title="statement not covered" >23),l=n</span>(1<span class="cstat-no" title="statement not covered" >25),c=n</span>(1<span class="cstat-no" title="statement not covered" >17),f=n</span>(1<span class="cstat-no" title="statement not covered" >20),h=n</span>(1<span class="cstat-no" title="statement not covered" >24),d=n</span>(1<span class="cstat-no" title="statement not covered" >22);e.e</span>xp<span class="cstat-no" title="statement not covered" >orts={J<span class="cstat-no" title="statement not covered" ></span>WA:r,JWK:i,JWKSet:o,JWT:a,JWS:s,Base64URLSchema:u,JOSEHeaderSchema:l,JWKSchema:c,JWKSetSchema:f,JWTClaimsSetSchema:h,JWTSchema:d}},function(e,t</span>,<span class="fstat-no" title="function not covered" >n)</span>{"use strict";function r(e,t){if(!(e<span class="fstat-no" title="function not covered" > i</span>nstan<span class="cstat-no" title="statement not covered" >ceof t))throw new Typ<span class="cstat-no" title="statement not covered" >eError("Cannot call a class as a function")}var i=function</span></span>(){fun<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ct</span>ion e(e,t){for(var<span class="fstat-no" title="function not covered" > n</span>=0;n&lt;<span class="cstat-no" title="statement not covered" >t.length;n++){var r=t[n];r.enumera<span class="cstat-no" title="statement not covered" >ble=r<span class="cstat-no" title="statement not covered" ></span>.enumerable||!1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return functio</span>n<span class="cstat-no" title="statement not covered" ></span>(t,n,r)<span class="fstat-no" title="function not covered" >{r</span>eturn n&amp;&amp;e(t.p<span class="cstat-no" title="statement not covered" >rototype,n),r&amp;&amp;e(t,r),t}}(),o=(n(105),n(</span>10</span>6))</span>,a=<span class="cstat-no" title="statement not covered" >n(114),s=a.Not</span>Sup<span class="cstat-no" title="statement not covered" >portedE</span>rr<span class="cstat-no" title="statement not covered" >or,u=function(){func</span>ti<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >on</span> e(){r(this,e)}ret<span class="fstat-no" title="function not covered" >ur</span>n <span class="cstat-no" title="statement not covered" >i(e,null,[{<span class="cstat-no" title="statement not covered" ></span>key:"sign",value:function(e,t,n){var r=o.normalize("sign",e);return r<span class="fstat-no" title="function not covered" > insta</span>nceof Error?P<span class="cstat-no" title="statement not covered" >romise.reject(new s(e)<span class="cstat-no" title="statement not covered" ></span>):r.sign(t,n)}},{key:"verify",value:function(e,t,n,r){var i=o.no</span>rmalize("verify",e);return i instanceof Error?Promise.re<span class="fstat-no" title="function not covered" >ject(n</span>ew s(e)):i.veri<span class="cstat-no" title="statement not covered" >fy(t,n,r)}},{key:"import<span class="cstat-no" title="statement not covered" ></span>Key",value:function(e){var t=o.normalize("importKey",e.alg);return t</span>.importKey(e)}}]),e}();e.exports=u},function(e,t,n){(functi<span class="fstat-no" title="function not covered" >on(t){</span>function <span class="cstat-no" title="statement not covered" >n(e){return e.replace(/=/g,"").<span class="cstat-no" title="statement not covered" ></span>replace(/\+/g,"-").repl</span>ace(/\/</span>/g,<span class="cstat-no" title="statement not covered" ></span>"_")}function</span> <span class="fstat-no" title="function not covered" >r(</span>e){t.isBuffer(<span class="cstat-no" title="statement not covered" >e<span class="fstat-no" title="function not covered" >)&amp;</span>&amp;(e=e.toString());v<span class="fstat-no" title="function not covered" >ar</span> n=<span class="cstat-no" title="statement not covered" >i(e).replace(/\-/g,"+").replace(/_/g,"/");return n}function i(e){</span>var n=4,r<span class="fstat-no" title="function not covered" >=e</span>.le<span class="cstat-no" title="statement not covered" >ngth,i=e.length%n;if(!i)return e;</span>var o<span class="cstat-no" title="statement not covered" >=r,a=n-i,s=r+a,u=t(s);for(u.write(e);a--;)<span class="cstat-no" title="statement not covered" ></span>u.write("=</span>",o++);re<span class="fstat-no" title="function not covered" >tu</span>rn u.toSt<span class="cstat-no" title="statement not covered" >ri</span>ng<span class="cstat-no" title="statement not covered" >()}functi</span>on<span class="cstat-no" title="statement not covered" > o(e,n){ret<span class="cstat-no" title="statement not covered" ></span>urn t(<span class="cstat-no" title="statement not covered" >r(e),"base</span></span>64").<span class="cstat-no" title="statement not covered" >to</span>St<span class="cstat-no" title="statement not covered" >ring</span>(n<span class="cstat-no" title="statement not covered" >)}fu</span>nc<span class="cstat-no" title="statement not covered" >tion <span class="cstat-no" title="statement not covered" ></span>a(e,r){return n(t(e,<span class="cstat-no" title="statement not covered" >r).toString("base<span class="cstat-no" title="statement not covered" >6</span></span>4"))}function s(e){r</span>eturn t(r<span class="fstat-no" title="function not covered" >(e</span>),"ba<span class="cstat-no" title="statement not covered" >se64")}a.toBase64=r,a.fromBase64=n,a.</span>decode=o,<span class="fstat-no" title="function not covered" >a.</span>encod<span class="cstat-no" title="statement not covered" >e=a,a.toBuffer=s,e.exports=a}).call(t</span>,n(47).Bu<span class="fstat-no" title="function not covered" >ff</span>er)<span class="cstat-no" title="statement not covered" >},function(e,t,n){"use st<span class="cstat-no" title="statement not covered" ></span>rict";var r=n(107),i=n(111),o=n(112),a=new o;a.define("HS256","sign",new r({</span>name:"HMAC",hash:{name:"</span>S<span class="fstat-no" title="function not covered" >HA</span>-256"}})),a.define("HS384","sign"<span class="cstat-no" title="statement not covered" >,new r(</span>{n<span class="cstat-no" title="statement not covered" >ame:"HM</span>AC<span class="cstat-no" title="statement not covered" >",hash:</span>{n<span class="cstat-no" title="statement not covered" >ame:"SHA<span class="cstat-no" title="statement not covered" ></span>-384"}})),a.define("HS512","sign",new r({name:"HMAC",hash:{name:"SHA-512"}})),a.define("RS256","sign",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}})),a.define("RS384","sign",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}})),a.define("RS512","sign",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}})),a.define("none","sign",{}),a.define("HS256","verify",new r({name:"HMAC",hash:{name:"SHA-256"}})),a.define("HS384","verify",new r({name:"HMAC",hash:{name:"SHA-384"}})),a.define("HS512","verify",new r({name:"HMAC",hash:{name:"SHA-512"}})),a.define("RS256","verify",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}})),a.define("RS384","verify",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}})),a.define("RS512","verify",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}})),a.define("none","verify",{}),a.define("RS256","importKey",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}})),a.define("RS384","importKey",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}})),a.define("RS512","importKey",new i({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}})),e.exports=a},function(e,t,n){(function(t){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a f</span>u<span class="fstat-no" title="function not covered" >nc</span>tion")}var i=f<span class="cstat-no" title="statement not covered" >u<span class="fstat-no" title="function not covered" >nc</span>tion(){function e(e,t){for(var n<span class="fstat-no" title="function not covered" >=0</span>;n&lt;t.<span class="cstat-no" title="statement not covered" >length;n++){var r=t[n<span class="cstat-no" title="statement not covered" >];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"i</span></span>n r&amp;&amp;(<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r.</span>writable=!0),Objec<span class="fstat-no" title="function not covered" >t.</span>defin<span class="cstat-no" title="statement not covered" >eProperty(e,r.key,r)}}return funct<span class="cstat-no" title="statement not covered" >ion(t<span class="cstat-no" title="statement not covered" ></span>,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),o=n(105),a=n(108),s=n(109),u=function(){function e(t){r(this,e</span>)<span class="cstat-no" title="statement not covered" ></span>,this.p<span class="fstat-no" title="function not covered" >ar</span>ams=t}return i<span class="cstat-no" title="statement not covered" >(e,[{key:"sign",value:function(e,n){var </span>r=</span>thi</span>s.<span class="cstat-no" title="statement not covered" >params;</span>re<span class="cstat-no" title="statement not covered" >turn n=</span>(n<span class="cstat-no" title="statement not covered" >ew s).e</span>nc<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >od</span>e(n),a.subtle.sign<span class="fstat-no" title="function not covered" >(r</span>,e,<span class="cstat-no" title="statement not covered" >n).then(function(e){retur<span class="cstat-no" title="statement not covered" ></span>n o(t.from(e))})}},{key:"verify",value:function(e,t,n){var r=thi<span class="fstat-no" title="function not covered" >s.para</span>ms;return"s<span class="cstat-no" title="statement not covered" >tring"==type<span class="cstat-no" title="statement not covered" ></span>of t&amp;&amp;(t=Uint8Array.from(o.toBuffer(t))),"string"==ty<span class="fstat-no" title="function not covered" >pe</span>of n&amp;&amp;(n=(<span class="cstat-no" title="statement not covered" >new s).encode(n)),a.s</span>ubt</span>le.verify(r,e,t,n)}},{key:"assertSufficientKeyLength",va<span class="fstat-no" title="function not covered" >lue:fu</span>nction(e){if(<span class="cstat-no" title="statement not covered" >e.length&lt;thi<span class="cstat-no" title="statement not covered" ></span>s.bitlength)throw new Error("The key is too short.")}}]),e}();e.exports=u}).call(t,n(47).Buffer)},function(e,t){e.exports=crypto}</span>,function(e,t,n){(function(t){"use strict";var r=t.TextEncoder?t.TextEncode<span class="fstat-no" title="function not covered" >r:n(11</span>0).<span class="cstat-no" title="statement not covered" >TextEncoder;e.exports=r}).c<span class="cstat-no" title="statement not covered" >all(t,function(){return this}())},function</span></span>(e,t){e</span>.ex<span class="cstat-no" title="statement not covered" ></span>ports=TextEnc</span>oder},function(e,t,n){(f</span>u<span class="fstat-no" title="function not covered" >nc</span>tion(t){"use<span class="cstat-no" title="statement not covered" > strict";function </span>r<span class="fstat-no" title="function not covered" >(e</span>,t){if(!(e ins<span class="cstat-no" title="statement not covered" >t<span class="fstat-no" title="function not covered" >an</span>ceof t))throw new TypeError("<span class="cstat-no" title="statement not covered" >Cannot call a class as a function")}var i=funct<span class="cstat-no" title="statement not covered" ></span>ion(){functio</span>n e(e,t){<span class="fstat-no" title="function not covered" >fo</span>r(var n=0<span class="cstat-no" title="statement not covered" >;n&lt;t.length;n</span>++){v</span>a<span class="fstat-no" title="function not covered" >r </span>r=t[n];r.enu<span class="cstat-no" title="statement not covered" >merable=r.enumerable||!</span>1<span class="fstat-no" title="function not covered" >,r</span>.configurable=<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >0,</span>"value"in r&amp;&amp;(r.writable=!0),Obj<span class="fstat-no" title="function not covered" >ec</span>t.def<span class="cstat-no" title="statement not covered" >ineProperty(e,r.key,r<span class="cstat-no" title="statement not covered" >)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(</span></span>t,r),t<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >}}</span>(),o=n(105),a=n(10<span class="fstat-no" title="function not covered" >8)</span>,s=n(<span class="cstat-no" title="statement not covered" >109),u=function(){function e(t){r(<span class="cstat-no" title="statement not covered" >this,<span class="cstat-no" title="statement not covered" ></span>e),this.params=t}return i(e,[{key:"sign",value:function(e,n){var r=this.params;return n=(new s).encode(n),a.sub</span>t<span class="cstat-no" title="statement not covered" ></span>le.sign<span class="fstat-no" title="function not covered" >(r</span>,e,n).then(fun<span class="cstat-no" title="statement not covered" >ction(e){return o(t.from(e))})}},{key:"v</span>er</span>ify</span>",<span class="cstat-no" title="statement not covered" >value:f</span>un<span class="cstat-no" title="statement not covered" >ction(e</span>,t<span class="cstat-no" title="statement not covered" >,n){var</span> r<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >=t</span>his.params;return"<span class="fstat-no" title="function not covered" >st</span>rin<span class="cstat-no" title="statement not covered" >g"==typeof t&amp;&amp;(t=Uint8Arr<span class="cstat-no" title="statement not covered" ></span>ay.from(o.toBuffer(t))),"string"==typeof n&amp;&amp;(n=(new s).encode(n)<span class="fstat-no" title="function not covered" >),a.su</span>btle.verify<span class="cstat-no" title="statement not covered" >(r,e,t,n)}},<span class="cstat-no" title="statement not covered" ></span>{key:"importKey",value:function(e){var t=Object.assig<span class="fstat-no" title="function not covered" >n(</span>{},e),n=th<span class="cstat-no" title="statement not covered" >is.params,r=e.key_ops</span>||[</span>];return"sig"===e.use&amp;&amp;r.push("verify"),"enc"===e.use?Pr<span class="fstat-no" title="function not covered" >omise.</span>resolve(e):(e<span class="cstat-no" title="statement not covered" >.key_ops&amp;&amp;(r<span class="cstat-no" title="statement not covered" ></span>=e.key_ops),a.subtle.importKey("jwk",t,n,!0,r).then(function(e){return Object.defineProperty(t,"cryptoKey",{enumerable:!1,value:e</span>}),t}))}}]),e}();e.exports=u}).call(t,n(47).Buffer)},functi<span class="fstat-no" title="function not covered" >on(e,t</span>,n){"use <span class="cstat-no" title="statement not covered" >strict";function r(e</span>,t<span class="cstat-no" title="statement not covered" >){if(!(e ins</span>ta<span class="cstat-no" title="statement not covered" >nceof t))throw<span class="cstat-no" title="statement not covered" ></span> new TypeError("Cannot call a class as a function")}var i=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=<span class="fstat-no" title="function not covered" >r.</span>enumerable<span class="cstat-no" title="statement not covered" >||!1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProper</span>ty(e</span>,r.key,</span>r)}<span class="cstat-no" title="statement not covered" ></span>}return funct</span>ion(t,n,r){return n&amp;&amp;e(t</span>.<span class="fstat-no" title="function not covered" >pr</span>ototype,n),r&amp;&amp;e(t,r),t}}(),o=n(113),<span class="fstat-no" title="function not covered" >a=</span>["sig<span class="cstat-no" title="statement not covered" >n","verify","encrypt"<span class="cstat-no" title="statement not covered" >,"decrypt","importKey"],s=function(){function e(){var t=th</span></span>is;r(t<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >hi</span>s,e),a.forEach(fun<span class="fstat-no" title="function not covered" >ct</span>ion(e<span class="cstat-no" title="statement not covered" >){t[e]={}})}return i(e,[{key:"defi<span class="cstat-no" title="statement not covered" >ne",v<span class="cstat-no" title="statement not covered" ></span>alue:function(e,t,n){var r=this[t];r[e]=n}},{key:"normalize",value:function(e,t){var n=this[e];if(!n)return new</span> <span class="cstat-no" title="statement not covered" ></span>SyntaxE<span class="fstat-no" title="function not covered" >rr</span>or;var r=n[t];<span class="cstat-no" title="statement not covered" >return r?r:new o(t)}}],[{key:"operations</span>",</span>get</span>:f<span class="cstat-no" title="statement not covered" >unction</span>()<span class="cstat-no" title="statement not covered" >{return a}}]),e}();e.exports=s},function(e,t){"use</span> s<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >tr</span>ict";function n(e,<span class="fstat-no" title="function not covered" >t)</span>{if(!(e <span class="cstat-no" title="statement not covered" >insta<span class="cstat-no" title="statement not covered" ></span>nceof t))throw new T<span class="fstat-no" title="function not covered" >yp</span>eError("Ca<span class="cstat-no" title="statement not covered" >nnot call</span> a <span class="cstat-no" title="statement not covered" ></span>class as a function")}function r(e,t){if(!e)throw new ReferenceErr<span class="fstat-no" title="function not covered" >or("th</span>is hasn't bee<span class="cstat-no" title="statement not covered" >n initia<span class="cstat-no" title="statement not covered" ></span>lised - </span>super() hasn't been called");return!t||"object"!=typeof t&amp;&amp;<span class="fstat-no" title="function not covered" >"funct</span>ion"!=typeo<span class="cstat-no" title="statement not covered" >f t?e:t}<span class="cstat-no" title="statement not covered" ></span>functi<span class="cstat-no" title="statement not covered" >on i(e,t){if("function"!=t</span></span>ypeof<span class="cstat-no" title="statement not covered" > t&amp;&amp;n<span class="cstat-no" title="statement not covered" ></span>ull!==t)throw new Typ</span>eError("Super expression must either be null or a function, <span class="fstat-no" title="function not covered" >not </span>"+<span class="cstat-no" title="statement not covered" >typeof t);</span>e.proto</span>typ<span class="cstat-no" title="statement not covered" ></span>e=Object.crea</span>t<span class="fstat-no" title="function not covered" >e(</span>t&amp;&amp;t.prototype,{constructor:{value<span class="fstat-no" title="function not covered" >:e</span>,enum<span class="cstat-no" title="statement not covered" >erable:!1,writable:!0<span class="cstat-no" title="statement not covered" >,configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setPr</span></span>ototypeOf<span class="fstat-no" title="function not covered" >(e</span>,t):e<span class="cstat-no" title="statement not covered" >.__pro<span class="cstat-no" title="statement not covered" >to__=t)}var o=function(e){function t(e){n(this,t);var i=r(this,(t.__proto__||Object.ge<span class="cstat-no" title="statement not covered" >t</span></span>PrototypeOf(t)).call(this));return i.message=e+" is not</span> a suppor<span class="fstat-no" title="function not covered" >te</span>d alg<span class="cstat-no" title="statement not covered" >orithm",i}return i(t,e),t}(Error);<span class="cstat-no" title="statement not covered" >e.exports=o},function(e,t,n){"use strict";e.exports={DataError:n(115),NotSupportedError:n<span class="cstat-no" title="statement not covered" >(</span></span>113)}},function(e,t){"use strict";function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("</span>this h<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>n't been initialise<span class="fstat-no" title="function not covered" >d </span>- s<span class="cstat-no" title="statement not covered" >uper() hasn</span>'t be<span class="cstat-no" title="statement not covered" >en called");return!t||"object"!=typeof t&amp;&amp;"function"!=typeo<span class="cstat-no" title="statement not covered" ></span>f t?e:t}function i(e,t){if("function"!=typeof t&amp;&amp;null!<span class="cstat-no" title="statement not covered" ></span>==t)throw new Typ</span>eError("<span class="cstat-no" title="statement not covered" ></span>Super express</span>i<span class="fstat-no" title="function not covered" >on</span> must either be null or a f<span class="cstat-no" title="statement not covered" >unction, not "+typeof t);e.prototype=Object.create(t&amp;&amp;t</span>.<span class="fstat-no" title="function not covered" >pr</span>ototype,{constructor:{value:e,enum<span class="fstat-no" title="function not covered" >er</span>able:<span class="cstat-no" title="statement not covered" >!1,writable:!0,config<span class="cstat-no" title="statement not covered" >urable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setPrototype</span></span>Of(e,t):e<span class="fstat-no" title="function not covered" >._</span>_prot<span class="cstat-no" title="statement not covered" >o__=t)<span class="cstat-no" title="statement not covered" >}var o=function(e){function t(e){return n(this,t),r(this,(t.__proto__||Object.getProto<span class="cstat-no" title="statement not covered" >t</span></span>ypeOf(t)).call(this,e))}return i(t,e),t}(Error);e.expor</span>ts=o},fun<span class="fstat-no" title="function not covered" >ct</span>ion(e<span class="cstat-no" title="statement not covered" >,t,n){"use strict";function r(e,t)<span class="cstat-no" title="statement not covered" >{if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i<span class="cstat-no" title="statement not covered" >(</span></span>e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&amp;&amp;"function"!=typeof t?e:t}function o(e,t){if("func</span>tion"!<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >=t</span>ypeof t&amp;&amp;null!==t)t<span class="fstat-no" title="function not covered" >hr</span>ow <span class="cstat-no" title="statement not covered" >new TypeError("Super expression must either be null or a function, not "+typeof<span class="cstat-no" title="statement not covered" ></span> t);e.prototype=O</span>bject.cr<span class="cstat-no" title="statement not covered" ></span>eate(t&amp;&amp;t.pro</span>t<span class="fstat-no" title="function not covered" >ot</span>ype,{constructor:{value:e,enumerable<span class="fstat-no" title="function not covered" >:!</span>1,wri<span class="cstat-no" title="statement not covered" >table:!0,configurable<span class="cstat-no" title="statement not covered" >:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,t</span></span>):e.__pro<span class="fstat-no" title="function not covered" >to</span>__=t)<span class="cstat-no" title="statement not covered" >}var a<span class="cstat-no" title="statement not covered" >=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enum<span class="cstat-no" title="statement not covered" >e</span></span>rable||!1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0</span>),Object.<span class="fstat-no" title="function not covered" >de</span>fineP<span class="cstat-no" title="statement not covered" >roperty(e,r.key,r)}}return functio<span class="cstat-no" title="statement not covered" >n(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s=n(94),u=s.JSONDocument,l=n(117),c=n<span class="cstat-no" title="statement not covered" >(</span></span>104),f=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return o(t,e),a(t,null,[{key:"importKey",value:function(e</span>){retu<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >rn</span> c.importKey(e)}},<span class="fstat-no" title="function not covered" >{k</span>ey:"s<span class="cstat-no" title="statement not covered" >chema",get:function(){return l}}])<span class="cstat-no" title="statement not covered" >,t}(u<span class="cstat-no" title="statement not covered" ></span>);e.exports=f},function(e,t,n){"use strict";var r=n(94),i=r.JSONSchema,o=n(118),a=(o.BASE64_REGEXP,new i({type:</span>"<span class="cstat-no" title="statement not covered" ></span>object"<span class="fstat-no" title="function not covered" >,p</span>roperties:{kty<span class="cstat-no" title="statement not covered" >:{type:"string",enum:["RSA","EC","oct"]}</span>,u</span>se:</span>{t<span class="cstat-no" title="statement not covered" >ype:"s</span>tr<span class="cstat-no" title="statement not covered" >ing",enum:["sig</span>",<span class="cstat-no" title="statement not covered" >"enc"]}</span>,k<span class="cstat-no" title="statement not covered" >ey_ops:</span>{t<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >yp</span>e:"array",enum:["si<span class="fstat-no" title="function not covered" >gn</span>",<span class="cstat-no" title="statement not covered" >"verify","encrypt","decrypt","wrapKey","unwrapKey","deriveKey","deriveBits"]},alg:{type:<span class="cstat-no" title="statement not covered" ></span>"string",enum:["HS256","HS384","HS512","RS256","RS384","RS512","ES256","ES384","E<span class="fstat-no" title="function not covered" >S512",</span>"PS<span class="cstat-no" title="statement not covered" >256","PS384","PS512","n</span>one"]},kid:{type:"string"},x5u:{type:"string"},x5c:{ty<span class="fstat-no" title="function not covered" >pe:"</span>ar<span class="cstat-no" title="statement not covered" >ray"},x5t:</span>{type:"</span>stri<span class="cstat-no" title="statement not covered" ></span>ng"}}}));e.ex</span>p<span class="fstat-no" title="function not covered" >or</span>ts=a},function(e,t,n){"use strict<span class="cstat-no" title="statement not covered" >";var </span>r=<span class="cstat-no" title="statement not covered" >n(94),i=r.For</span>ma<span class="cstat-no" title="statement not covered" >ts;i.re</span>gis<span class="cstat-no" title="statement not covered" >ter("StringOrURI",new RegExp),i.register("NumericDate",new RegExp),i.register("URI",new RegExp),i.register("url",new RegExp),i.register("base64",new RegExp),i.register("base64url",new RegExp),i.register("MediaType",new RegExp)},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called"</span>)<span class="cstat-no" title="statement not covered" >;return!t||"o</span>b<span class="fstat-no" title="function not covered" >je</span>ct"!=typeof t&amp;&amp;"function"!=typeof<span class="cstat-no" title="statement not covered" > t?e:t</span>}f<span class="cstat-no" title="statement not covered" >unction o(<span class="cstat-no" title="statement not covered" ></span>e,t){if("function"!=typeof t&amp;&amp;null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&amp;&amp;t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&amp;&amp;(Object.se</span>t<span class="fstat-no" title="function not covered" >Pr</span>ototypeOf?Object.setPrototypeOf(e,t)<span class="fstat-no" title="function not covered" >:e</span>.__pr<span class="cstat-no" title="statement not covered" >oto__=t)}var a=functi<span class="cstat-no" title="statement not covered" >on(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n</span></span>];r.enume<span class="fstat-no" title="function not covered" >ra</span>ble=r<span class="cstat-no" title="statement not covered" >.enume<span class="cstat-no" title="statement not covered" >rable||!1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key<span class="cstat-no" title="statement not covered" >,</span></span>r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r</span>&amp;&amp;e(t,r),<span class="fstat-no" title="function not covered" >t}</span>}(),s<span class="cstat-no" title="statement not covered" >=n(94),u=s.JSONDocument,l=n(120),c<span class="cstat-no" title="statement not covered" >=n(116),f=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getProtot<span class="cstat-no" title="statement not covered" >y</span></span>peOf(t)).apply(this,arguments))}return o(t,e),a(t,null,[{key:"importKeys",value:function(e){var n=this.schema.validate(e);n.valid||Promise.reject(n);var r=new t(e),i=e.keys.map</span>(funct<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >io</span>n(e){return c.impo<span class="fstat-no" title="function not covered" >rt</span>Key(e<span class="cstat-no" title="statement not covered" >)});return Promise.all(i).then(fun<span class="cstat-no" title="statement not covered" >ction<span class="cstat-no" title="statement not covered" ></span>(e){return r.keys=e,r})}},{key:"schema",get:function(){return l}}]),t}(u);e.exports=f},function(e,t,n){"use str</span>i<span class="cstat-no" title="statement not covered" ></span>ct";var<span class="fstat-no" title="function not covered" > r</span>=n(94),i=r.JSO<span class="cstat-no" title="statement not covered" >NSchema,o=n(117),a=new i({type:"object",</span>pr</span>ope</span>rt<span class="cstat-no" title="statement not covered" >ies:{k</span>ey<span class="cstat-no" title="statement not covered" >s:{type:"array"</span>,i<span class="cstat-no" title="statement not covered" >tems:o}</span>}}<span class="cstat-no" title="statement not covered" >);e.exp</span>or<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ts</span>=a},function(e,t,n)<span class="fstat-no" title="function not covered" >{"</span>us<span class="cstat-no" title="statement not covered" >e strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class <span class="cstat-no" title="statement not covered" ></span>as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been i<span class="fstat-no" title="function not covered" >nitial</span>ised - su<span class="cstat-no" title="statement not covered" >per() hasn't been called<span class="cstat-no" title="statement not covered" ></span>");return!t||"object"!=typeo</span>f t&amp;&amp;<span class="cstat-no" title="statement not covered" >"function</span>"!<span class="cstat-no" title="statement not covered" >=typeof t?e<span class="fstat-no" title="function not covered" >:t</span>}function <span class="cstat-no" title="statement not covered" >o(e,t){if("function"!=t</span>yp<span class="cstat-no" title="statement not covered" ></span>eof t&amp;&amp;null!==t)throw new T<span class="fstat-no" title="function not covered" >yp</span>eError("Su<span class="cstat-no" title="statement not covered" >per expression must</span> ei</span>ther be null or a function, not "+typeof t);e.prototyp<span class="fstat-no" title="function not covered" >e=Ob</span>je<span class="cstat-no" title="statement not covered" >ct.create(</span>t&amp;&amp;t.pr</span>otot<span class="cstat-no" title="statement not covered" ></span>ype,{construc</span>t<span class="fstat-no" title="function not covered" >or</span>:{value:e,enumerable:!1,writable:<span class="cstat-no" title="statement not covered" >!0,con</span>fi<span class="cstat-no" title="statement not covered" >gurable:!0}})</span>,t<span class="cstat-no" title="statement not covered" >&amp;&amp;(Obje</span>ct<span class="cstat-no" title="statement not covered" >.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=<span class="cstat-no" title="statement not covered" ></span>"function"==t</span>y<span class="fstat-no" title="function not covered" >pe</span>of Symbol&amp;&amp;"symbol"==typeof Symbol.i<span class="fstat-no" title="function not covered" >te</span>rator<span class="cstat-no" title="statement not covered" >?function(e){return t<span class="cstat-no" title="statement not covered" >ypeof e}:function(e){return e&amp;&amp;"function"==typeof Symbol&amp;&amp;</span></span>e.constru<span class="fstat-no" title="function not covered" >ct</span>or===<span class="cstat-no" title="statement not covered" >Symbol<span class="cstat-no" title="statement not covered" >&amp;&amp;e!==Symbol.prototype?"symbol":typeof e},s=function(){function e(e,t){for(var n=0;n&lt;t<span class="cstat-no" title="statement not covered" >.</span></span>length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.</span>configura<span class="fstat-no" title="function not covered" >bl</span>e=!0,<span class="cstat-no" title="statement not covered" >"value"in r&amp;&amp;(r.writable=!0),Objec<span class="cstat-no" title="statement not covered" >t.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),<span class="cstat-no" title="statement not covered" >t</span></span>}}(),u=n(105),l=n(94),c=l.JSONDocument,f=n(122),h=n(126),d=n(115),p=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,argument</span>s))}re<span class="cstat-no" title="statement not covered" >turn o(t,e),s(t,[{key:"isJWE",value:function(){return!!this.<span class="fstat-no" title="function not covered" >he</span>ader.enc}}<span class="cstat-no" title="statement not covered" >,{key:"resolveKey</span>s<span class="fstat-no" title="function not covered" >",</span>value:func<span class="cstat-no" title="statement not covered" >tion(e){var t=this.header.kid,n=void 0,r=void 0;if(Array.isArray(e)&amp;&amp;(n=e),e.keys&amp;&amp;(n=e.keys),e.keys|</span>|</span>"o<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >bj</span>ect"!==("undefined<span class="fstat-no" title="function not covered" >"=</span>=type<span class="cstat-no" title="statement not covered" >of e?"undefined":a(e))||(n=[e]),!n<span class="cstat-no" title="statement not covered" >)thro<span class="cstat-no" title="statement not covered" ></span>w new d("Invalid JWK argument");return r=t?n.find(function(e){return e.kid===t}):n.find(function(e){return"sig"</span>=<span class="cstat-no" title="statement not covered" ></span>==e.use<span class="fstat-no" title="function not covered" >})</span>,!!r&amp;&amp;(console<span class="cstat-no" title="statement not covered" >.log(r),this.key=r.cryptoKey,!0)}},{key:</span>"e</span>nco</span>de<span class="cstat-no" title="statement not covered" >",value</span>:f<span class="cstat-no" title="statement not covered" >unctio</span>n(<span class="cstat-no" title="statement not covered" >){var e=this.va</span>li<span class="cstat-no" title="statement not covered" >date();</span>if<span class="cstat-no" title="statement not covered" >(!e.val</span>id<span class="cstat-no" title="statement not covered" >)return</span> P<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ro</span>mise.reject(e);var <span class="fstat-no" title="function not covered" >t=</span>th<span class="cstat-no" title="statement not covered" >is;return this.isJWE()?JWE.encrypt(t):h.sign(t)}},{key:"verify",value:function(){var e=t<span class="cstat-no" title="statement not covered" ></span>his.validate();return e.valid?h.verify(this):Promise.reject(e)}}],[{key:<span class="fstat-no" title="function not covered" >"decod</span>e"<span class="cstat-no" title="statement not covered" >,value:function(e){var t=</span>this,n=void 0;if("string"!=typeof e)throw new d("JWT must be <span class="fstat-no" title="function not covered" >a stri</span>ng");if(e<span class="cstat-no" title="statement not covered" >.startsWith("{")</span>){<span class="cstat-no" title="statement not covered" >try{e=J</span>SO<span class="cstat-no" title="statement not covered" >N.parse<span class="cstat-no" title="statement not covered" ></span>(e,function(){})}catch(e){throw new d("Invalid JWT serialization")}e.signatures||e.recipients?e.serialization="json":e<span class="cstat-no" title="statement not covered" >.serialization="flattened",n=new t(e<span class="cstat-no" title="statement not covered" >)</span></span>}else try{var r="<span class="fstat-no" title="function not covered" >co</span>mpact",i=e<span class="cstat-no" title="statement not covered" >.split("."),o=i.le</span>ngth;if(3<span class="fstat-no" title="function not covered" >!=</span>=o&amp;&amp;5!==o)<span class="cstat-no" title="statement not covered" >throw new Error("Malf</span>ormed JWT");var a=JSON.parse(u.decode(i[0]));if(3</span>===o){var s="JWS",l=JSON.parse(u.decode(i[1])),c=i[2];n=<span class="fstat-no" title="function not covered" >new t(</span>{type:s,<span class="cstat-no" title="statement not covered" >segments:i,heade<span class="cstat-no" title="statement not covered" ></span>r:a,payload:<span class="cstat-no" title="statement not covered" >l,signature:c,serializatio</span></span>n:r})<span class="cstat-no" title="statement not covered" >}}cat<span class="cstat-no" title="statement not covered" ></span>ch(e){throw new d("Invalid JWT compact seriali</span>zation")}return n}},{key:"encode",value:function(e,n,r){<span class="fstat-no" title="function not covered" >var i=</span>new t(e,<span class="cstat-no" title="statement not covered" >n);return i.enco<span class="cstat-no" title="statement not covered" ></span>de(r)}},{key:"verify",value:function(e,n){var r=t</span>.decode(n);return r.key=e,r.verify().then(function(e){retu<span class="fstat-no" title="function not covered" >rn r})</span>}},{key:"<span class="cstat-no" title="statement not covered" >schem</span>a"<span class="cstat-no" title="statement not covered" >,get:fu<span class="cstat-no" title="statement not covered" ></span>nction(){return f}}]),<span class="cstat-no" title="statement not covered" >t}(c);e.exports=p},function(e,t,n){"<span class="cstat-no" title="statement not covered" >u</span></span>se strict";var r=n(12<span class="cstat-no" title="statement not covered" >3),i<span class="cstat-no" title="statement not covered" >=n(124),o=n(125<span class="fstat-no" title="function not covered" >),</span>a=n(94),s=a.J</span>SONSchema<span class="cstat-no" title="statement not covered" >,u=new s({type:"object",properties:{type:{<span class="cstat-no" title="statement not covered" ></span>t</span>ype:"string",enum:["JWS","JWE"]},segments:{type:"array"},header:o,protected:o,unprotected</span>:o,iv<span class="cstat-no" title="statement not covered" >:r,aad:r,c<span class="cstat-no" title="statement not covered" >iphertext:</span>r,<span class="cstat-no" title="statement not covered" >tag:r,recipie</span>nt<span class="cstat-no" title="statement not covered" >s:{type:"<span class="cstat-no" title="statement not covered" ></span>array",items:{ty<span class="cstat-no" title="statement not covered" >pe:"object",properties:{header:o,e</span></span>ncryp<span class="cstat-no" title="statement not covered" >ted_key:r}}},payload:i,sign<span class="cstat-no" title="statement not covered" ></span>atures:{type:"ar<span class="cstat-no" title="statement not covered" >ray",i</span>te<span class="cstat-no" title="statement not covered" >ms:{type:"object",propertie</span>s:<span class="cstat-no" title="statement not covered" >{prot<span class="cstat-no" title="statement not covered" ></span>ected:o,header:o,signature:r,key:{type:"object"}}}},signature:r,verified:{typ</span>e</span>:"boolean<span class="cstat-no" title="statement not covered" >",default:!1},key:{type:"object"},serialization:{t<span class="cstat-no" title="statement not covered" ></span>y</span></span>pe:"strin</span>g",enum:["compact","json","flattened"],default:"compact"<span class="fstat-no" title="function not covered" >}}});e</span>.exports=u},f<span class="cstat-no" title="statement not covered" >unction(e,t<span class="cstat-no" title="statement not covered" ></span>,n){"use strict";var</span> r=n(94),i=r.JSONSchema,o=new i({type:"string",format:"b<span class="fstat-no" title="function not covered" >ase64u</span>rl"});e.exp<span class="cstat-no" title="statement not covered" >orts=o},func<span class="cstat-no" title="statement not covered" ></span>tion(e,t,n){"use strict";var r=<span class="fstat-no" title="function not covered" >n(</span>94),i=r.JS<span class="cstat-no" title="statement not covered" >ONSchema,o</span>=ne</span>w i({properties:{iss:{type:"string",format:"StringOrUR<span class="fstat-no" title="function not covered" >I"},</span>su<span class="cstat-no" title="statement not covered" >b:{type:"s</span>tring",</span>form<span class="cstat-no" title="statement not covered" ></span>at:"StringOrU</span>R<span class="fstat-no" title="function not covered" >I"</span>},aud:{type:["array","string"],fo<span class="cstat-no" title="statement not covered" >rmat:"S</span>tr<span class="cstat-no" title="statement not covered" >ingOrUR</span>I"<span class="cstat-no" title="statement not covered" >,items:</span>{f<span class="cstat-no" title="statement not covered" >ormat:</span>"S<span class="cstat-no" title="statement not covered" >tringOrURI"}}</span>,e<span class="cstat-no" title="statement not covered" >xp:{type:"number",format:"NumericDate"},nbf:{type:"number",format:"NumericDate"},iat:{type:"number",format:"NumericDate"},jti:{type:"string"}}});e.exports=o},function(e,t,n){"use strict";var r=(n(117),n(94)),i=r.JSONSchema,o=new i({type:"object",properties:{typ:{type:"string"},cty:{type:"string",enum:["JWT"]},alg:{type:"string",format:"StringOrURI"},jku:{type:"string",format:"URI"},kid:{type:"string"},x5u:{type:"string",format:"URI"},x5c:{type:"array",items:{type:"string",format:"base64"}},x5t:{type:"string",format:"base64<span class="cstat-no" title="statement not covered" ></span>url"},crit:{t</span>y<span class="fstat-no" title="function not covered" >pe</span>:"array",items:{type:"string"},mi<span class="cstat-no" title="statement not covered" >nItems</span>:1<span class="cstat-no" title="statement not covered" >},enc:{type:"</span>st<span class="cstat-no" title="statement not covered" >ring",format:"StringOrURI"},zip:{type:"str<span class="cstat-no" title="statement not covered" ></span>ing"}}});e.ex</span>p<span class="fstat-no" title="function not covered" >or</span>ts=o},function(e,t,n){"use strict<span class="cstat-no" title="statement not covered" >";func</span>ti<span class="cstat-no" title="statement not covered" >on r(e,t){if(</span>!(<span class="cstat-no" title="statement not covered" >e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=function(){function e(e,t){var n=[],r=!0,i=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(r=(a=s.next()).done)&amp;&amp;(n.push(a.value),!t||n.length!==t);r=!0);}catch(e){i=!0,o=e}finally{try{!r&amp;&amp;s.return&amp;&amp;s.return()}finally{if(i)throw o}}return n}retu<span class="cstat-no" title="statement not covered" ></span>rn function(t</span>,<span class="fstat-no" title="function not covered" >n)</span>{if(Array.isArray(t))return t;if(S<span class="cstat-no" title="statement not covered" >ymbol.iterato</span>r i<span class="cstat-no" title="statement not covered" >n Object(t))r</span>et<span class="cstat-no" title="statement not covered" >urn e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),o="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e},a=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&amp;&amp;(r<span class="cstat-no" title="statement not covered" ></span>.writable=!0)</span>,<span class="fstat-no" title="function not covered" >Ob</span>ject.defineProperty(e,r.key,r)}}retu<span class="fstat-no" title="function not covered" >rn</span> func<span class="cstat-no" title="statement not covered" >tion(t,n,r){return n&amp;<span class="cstat-no" title="statement not covered" >&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),s=n(105),u=n(104),l=n(11</span></span>4),c=l<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >.D</span>ataError,f=functio<span class="fstat-no" title="function not covered" >n(</span>){function <span class="cstat-no" title="statement not covered" >e()</span>{r<span class="cstat-no" title="statement not covered" >(th</span>is<span class="cstat-no" title="statement not covered" >,e)</span>}r<span class="cstat-no" title="statement not covered" >eturn a<span class="cstat-no" title="statement not covered" ></span>(e,n<span class="cstat-no" title="statement not covered" >ull,[{key:"sign",value:function(e){var t=s(JSON.stringify(e.payload));if("compact"===e.serializatio</span>n){var n=<span class="cstat-no" title="statement not covered" >function()</span>{var n=e<span class="cstat-no" title="statement not covered" >.key<span class="cstat-no" title="statement not covered" >,r=e.header.alg,i=s(JSON.s</span>tringify<span class="cstat-no" title="statement not covered" >(e.he<span class="cstat-no" title="statement not covered" >ader)),o=</span></span>i<span class="cstat-no" title="statement not covered" ></span>+</span>"."+t;ret<span class="cstat-no" title="statement not covered" ></span>urn{v:u<span class="fstat-no" title="function not covered" >.s</span>ign(r,n,o).t<span class="cstat-no" title="statement not covered" >hen(function(e){retu<span class="cstat-no" title="statement not covered" >rn o+"."+<span class="cstat-no" title="statement not covered" >e</span></span>})}}();if("object"===("undefine<span class="cstat-no" title="statement not covered" >d"==typeof n?"<span class="cstat-no" title="statement not covered" >u</span></span>ndefined":o(n)))return n.v}return"json"===e.serialization,"flattened"===e.se</span>ri</span>ali</span>za<span class="cstat-no" title="statement not covered" >tion,Promise.reject(new c("Unsupported serialization"))}},{k<span class="fstat-no" title="function not covered" >ey</span>:"verify",<span class="cstat-no" title="statement not covered" >value:function(e)</span>{<span class="fstat-no" title="function not covered" >if</span>(e.signatu<span class="cstat-no" title="statement not covered" >res,e.signature){var t=i(e.segments,2),n=t[0],r=t[1],o=n+"."+r,a=e.key,s=e.signature,l=e.header.alg;r</span>e</span>tu<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >rn</span> u.verify(l,a,s,o)<span class="fstat-no" title="function not covered" >.t</span>hen(f<span class="cstat-no" title="statement not covered" >unction(t){return e.verified=t,t})<span class="cstat-no" title="statement not covered" >}retu<span class="cstat-no" title="statement not covered" ></span>rn Promise.reject(new c("Missing signature(s)"))}}]),e}();e.exports=f},function(e,t,n){(function(t){"use strict</span>"<span class="cstat-no" title="statement not covered" ></span>;functi<span class="fstat-no" title="function not covered" >on</span> r(e,t){if(!(e<span class="cstat-no" title="statement not covered" > instanceof t))throw new TypeError("Cann</span>ot</span> ca</span>ll<span class="cstat-no" title="statement not covered" > a clas</span>s <span class="cstat-no" title="statement not covered" >as a fu</span>nc<span class="cstat-no" title="statement not covered" >tion")}</span>va<span class="cstat-no" title="statement not covered" >r i=function</span>()<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >{f</span>unction e(e,t){for<span class="fstat-no" title="function not covered" >(v</span>ar<span class="cstat-no" title="statement not covered" > n=0;n&lt;t.le<span class="cstat-no" title="statement not covered" ></span>ngth;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,<span class="fstat-no" title="function not covered" >"value</span>"in r&amp;&amp;(r<span class="cstat-no" title="statement not covered" >.writable=!0),Object.definePr<span class="cstat-no" title="statement not covered" ></span>operty(e,r.key,r)}}return function(t,n<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >,r</span>){return n&amp;&amp;e(t<span class="cstat-no" title="statement not covered" >.proto</span>ty<span class="cstat-no" title="statement not covered" >pe,n),r&amp;&amp;e(t,</span>r)<span class="cstat-no" title="statement not covered" >,t}}(),o=n(92),a=n(128),s=n(</span>10<span class="cstat-no" title="statement not covered" >8),u=n(1<span class="cstat-no" title="statement not covered" ></span>31),l=n(132),c=function(){fu<span class="fstat-no" title="function not covered" >nc</span>tion e(){r<span class="cstat-no" title="statement not covered" >(this,e)}return </span>i(e,</span>nul<span class="cstat-no" title="statement not covered" ></span>l,[{key:"create",value:function(e,n,r){return new Promi<span class="cstat-no" title="statement not covered" >se(function(<span class="cstat-no" title="statement not covered" ></span></span>i</span>,c){var f=e.provider,h=e.defaults,d=e.registration;o(f.configuration,"RelyingParty provider OpenID Configuration</span> is missing"),o(h.authenticate,"RelyingParty default aut<span class="fstat-no" title="function not covered" >hentic</span>ati<span class="cstat-no" title="statement not covered" >on parameters are missing"),o(d,"Re<span class="cstat-no" title="statement not covered" >lyingParty clien</span>t <span class="cstat-no" title="statement not covered" >regis</span>tr<span class="cstat-no" title="statement not covered" >ation</span> i<span class="cstat-no" title="statement not covered" >s missin</span>g"<span class="cstat-no" title="statement not covered" >);var </span>p=<span class="cstat-no" title="statement not covered" >f.configurat</span>io<span class="cstat-no" title="statement not covered" >n.issuer,v=f.<span class="cstat-no" title="statement not covered" ></span>configuration.authorization_en<span class="fstat-no" title="function not covered" >dp</span>oint,g={cl<span class="cstat-no" title="statement not covered" >ient_id:d.client_id},y=</span>Obj<span class="cstat-no" title="statement not covered" ></span>e</span>ct.assign(h.authenticate,g,n);return o(p,"Missing iss</span>uer in </span>pro<span class="cstat-no" title="statement not covered" ></span>vider OpenID </span>C<span class="fstat-no" title="function not covered" >on</span>figuration"),o<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >v,</span>"Missing authorization_endpoint <span class="fstat-no" title="function not covered" >in</span> prov<span class="cstat-no" title="statement not covered" >ider OpenID Configura<span class="cstat-no" title="statement not covered" >tion"),o(y.scope,"Missing scope parameter in authenticatio</span></span>n requ<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >es</span>t"),o(y.response_t<span class="fstat-no" title="function not covered" >yp</span>e,"Mi<span class="cstat-no" title="statement not covered" >ssing response_type parameter in a<span class="cstat-no" title="statement not covered" >uthen<span class="cstat-no" title="statement not covered" ></span>tication request"),o(y.client_id,"Missing client_id parameter in authentication request"),o(y.redirect_uri,"Mis</span>s<span class="cstat-no" title="statement not covered" ></span>ing red<span class="fstat-no" title="function not covered" >ir</span>ect_uri parame<span class="cstat-no" title="statement not covered" >ter in authentication request"),y.state=</span>Ar</span>ray</span>.f<span class="cstat-no" title="statement not covered" >rom(s.</span>ge<span class="cstat-no" title="statement not covered" >tRandom</span>Va<span class="cstat-no" title="statement not covered" >lues(ne</span>w <span class="cstat-no" title="statement not covered" >Uint8Ar</span>ra<span class="cstat-no" title="statement not covered" >y(16)))</span>,y<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >.n</span>once=Array.from(s.<span class="fstat-no" title="function not covered" >ge</span>tR<span class="cstat-no" title="statement not covered" >andomValues<span class="cstat-no" title="statement not covered" ></span>(new Uint8Array(16))),Promise.all([s.subtle.digest({name:"SHA-256"},new<span class="fstat-no" title="function not covered" > Uint8</span>Array(y<span class="cstat-no" title="statement not covered" >.state)),s.subtle.d<span class="fstat-no" title="function not covered" >ig</span>est({name:"SHA-256<span class="cstat-no" title="statement not covered" >"},new Uint</span>8A<span class="cstat-no" title="statement not covered" >rray(y.nonc</span>e)<span class="cstat-no" title="statement not covered" >)]).then(functi<span class="cstat-no" title="statement not covered" ></span>on(e){var n=a(t.from(e[0])),i=a(t.from(e[1])),o=p+"/requestHistory/"+n;r[o]=JSON.stringify(y),y.state=n,y.nonce=i}).then(function(){}).then(function(){var e=new l(v);e.search=u.encode(y),i(e.href)})})}}]),e</span>}();e<span class="cstat-no" title="statement not covered" >.exports=c}).call(t,n(4</span>7)<span class="cstat-no" title="statement not covered" >.Buffer)},function(e,t,n){e.exports=n(1</span>29<span class="cstat-no" title="statement not covered" >).default,e.exports.defa</span>ul<span class="cstat-no" title="statement not covered" >t=e.exports},function(e,t,n){(func<span class="cstat-no" title="statement not covered" ></span>tion(e){"use strict";function r(t,n){return void 0===n&amp;&amp;(n="utf8"),a(e.isBuffer(t)?t.toString("base64"):new e(t,n).toString("base64"))}function i(t,n){return void 0===n&amp;&amp;(n="utf8"),new e(o(t),"base64").toString(n)}function o(e){return e=e.toString(),u.default(e).replace(/\-/g,"+").replace(/_/g,"/")}function a(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function s(t){return new e(o(t),"base64")}var u=n(130),l=r;l.encode=r,l.decode=i,l.toBase64=o,l.fromBase64=a,l.toBuffer=s,Object.defineProperty(t,"__esModule",{value:!0}),t.default=l}).call(t,n(47).Buffer)},function(e,t,n){(function(e){"use strict";function n(t){var n=4,r=t.length,i=r%n;if(!i)ret<span class="fstat-no" title="function not covered" >ur</span>n t;var o=r,a=n-<span class="cstat-no" title="statement not covered" >i,s=r+a,u=new e(</span>s)<span class="cstat-no" title="statement not covered" >;for(u.write(t);</span>a-<span class="cstat-no" title="statement not covered" >-;)u.write("=",o++);ret<span class="cstat-no" title="statement not covered" ></span>urn u.toString()}Object.defineProperty(t,"__</span>esModul<span class="fstat-no" title="function not covered" >e"</span>,{value:!0}),t.de<span class="fstat-no" title="function not covered" >fa</span>ult=n}).call(t,<span class="cstat-no" title="statement not covered" >n(47).Buf<span class="cstat-no" title="statement not covered" ></span>fer)},function(e,t){"use strict"</span>;fu</span>nct</span>ion n(e</span>,t)<span class="cstat-no" title="statement not covered" ></span>{if(!(e insta</span>nceof t))throw new TypeE</span>r<span class="fstat-no" title="function not covered" >ro</span>r("Cannot call<span class="cstat-no" title="statement not covered" > a class as a function")}var r=function(){function e(e</span>,<span class="fstat-no" title="function not covered" >t)</span>{for(var n=0;n<span class="cstat-no" title="statement not covered" >&lt;<span class="fstat-no" title="function not covered" >t.</span>length;n++){var r=t[n];r.enumera<span class="fstat-no" title="function not covered" >bl</span>e=r.e<span class="cstat-no" title="statement not covered" >numerable||!1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}retu</span>rn functi<span class="fstat-no" title="function not covered" >on</span>(t,n,<span class="cstat-no" title="statement not covered" >r){return n&amp;&amp;e(t.prototype,n),r&amp;&amp;e(t,r),t}}(),i=function(){funct</span>ion e(){n<span class="fstat-no" title="function not covered" >(t</span>his<span class="cstat-no" title="statement not covered" >,e)}return r(e,null,[{key:"encode",value:function(e){var t=[];return Obje</span>ct.keys(e<span class="fstat-no" title="function not covered" >).</span>for<span class="cstat-no" title="statement not covered" >Each(function(n){t.push(encodeURIComponent(n)+"="+encodeURICompon</span>ent(e[n])<span class="fstat-no" title="function not covered" >)}</span>),t<span class="cstat-no" title="statement not covered" >.join("&amp;")}},{key:"decode",va</span>lue:fu<span class="cstat-no" title="statement not covered" >nction(</span>e)<span class="cstat-no" title="statement not covered" >{v<span class="cstat-no" title="statement not covered" ></span>ar t={};return e.split("&amp;").forEach(function(e){var n=e.split("="),r=decodeURIComponent(n[0]),i=decodeURIComponent(n[1]);t[r]</span>=i}),t}}]),e}();e.export</span>s<span class="fstat-no" title="function not covered" >=i</span>},function(e,t<span class="cstat-no" title="statement not covered" >)<span class="fstat-no" title="function not covered" >{e</span>.exports=URL},function(e,t,n){(f<span class="fstat-no" title="function not covered" >un</span>ction(t,r<span class="cstat-no" title="statement not covered" >){</span>"u<span class="cstat-no" title="statement not covered" >se strict</span>";<span class="cstat-no" title="statement not covered" >func<span class="cstat-no" title="statement not covered" ></span>tion i<span class="cstat-no" title="statement not covered" >(e,t){if(!</span></span>(e in<span class="cstat-no" title="statement not covered" >st</span>an<span class="cstat-no" title="statement not covered" >ceof</span> t<span class="cstat-no" title="statement not covered" >))th</span>ro<span class="cstat-no" title="statement not covered" >w new Typ<span class="cstat-no" title="statement not covered" ></span>eError("Cannot call <span class="cstat-no" title="statement not covered" >a class as a func<span class="cstat-no" title="statement not covered" >t</span></span>ion")}var o=function<span class="cstat-no" title="statement not covered" ></span>(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.en</span>umerable=r.enumerable||!</span>1<span class="fstat-no" title="function not covered" >,r</span>.configurable=!0,"value"in r&amp;&amp;(r.w<span class="fstat-no" title="function not covered" >ri</span>table<span class="cstat-no" title="statement not covered" >=!0),Object.definePro<span class="cstat-no" title="statement not covered" >perty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.pro</span></span>totype<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >,n</span>),r&amp;&amp;e(t,r),t}}(),<span class="fstat-no" title="function not covered" >a=</span>n(132<span class="cstat-no" title="statement not covered" >),s=n(92),u=n(108),l=n(128),c=n(93<span class="cstat-no" title="statement not covered" >),f=c<span class="cstat-no" title="statement not covered" ></span>.Headers?c.Headers:t.Headers,h=n(131),d=n(134),p=function(){function e(){i(this,e)}return o(e,null,[{key:"valid</span>a<span class="cstat-no" title="statement not covered" ></span>teRespo<span class="fstat-no" title="function not covered" >ns</span>e",value:funct<span class="cstat-no" title="statement not covered" >ion(e){return Promise.resolve(e).then(th</span>is</span>.pa</span>rs<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >eR</span>esponse).then(this<span class="fstat-no" title="function not covered" >.m</span>at<span class="cstat-no" title="statement not covered" >chRequest).<span class="cstat-no" title="statement not covered" ></span>then(this.validateStateParam).then(this.errorResponse).then(this.valida<span class="fstat-no" title="function not covered" >teResp</span>onseMode)<span class="cstat-no" title="statement not covered" >.th<span class="cstat-no" title="statement not covered" ></span>en(this.validateResponseParams<span class="fstat-no" title="function not covered" >).</span>then(this.<span class="cstat-no" title="statement not covered" >exchangeAuthorizationCode).then(this.validateIDToken).then(f</span>unction(){retur</span>n e})}},{key:"parseResponse",value:function(e){var t=e.r<span class="fstat-no" title="function not covered" >edirec</span>t,n=e.bod<span class="cstat-no" title="statement not covered" >y;i<span class="cstat-no" title="statement not covered" ></span>f(t&amp;&amp;n||!t&amp;&amp;!n)throw new Err<span class="fstat-no" title="function not covered" >or</span>("Invalid respon<span class="cstat-no" title="statement not covered" >se mode");if(</span>t)<span class="cstat-no" title="statement not covered" >{var r=new a(t),i=r.searc</span>h,<span class="cstat-no" title="statement not covered" >o=r.hash;if(i&amp;&amp;o)throw ne<span class="cstat-no" title="statement not covered" ></span>w Error(</span>"Inva</span>lid res</span>pon<span class="cstat-no" title="statement not covered" ></span>se mode");i&amp;&amp;</span>(<span class="fstat-no" title="function not covered" >e.</span>params=h.dec<span class="cstat-no" title="statement not covered" >ode(i.substring</span>(<span class="fstat-no" title="function not covered" >1)</span>),e.mode="quer<span class="cstat-no" title="statement not covered" >y<span class="fstat-no" title="function not covered" >")</span>,o&amp;&amp;(e.params=h.decode(o.substring<span class="fstat-no" title="function not covered" >(1</span>)),e.<span class="cstat-no" title="statement not covered" >mode="fragment")}retu<span class="cstat-no" title="statement not covered" >rn n&amp;&amp;(e.params=h.decode(n),e.mode="form_post"),e}},{key:"</span></span>matchR<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >eq</span>uest",value:functi<span class="fstat-no" title="function not covered" >on</span>(e){v<span class="cstat-no" title="statement not covered" >ar t=e.rp,n=e.params,r=e.session,i<span class="cstat-no" title="statement not covered" >=n.st<span class="cstat-no" title="statement not covered" ></span>ate,o=t.provider.configuration.issuer;if(!i)throw new Error("Missing state parameter in authentication response</span>"<span class="cstat-no" title="statement not covered" ></span>);var a<span class="fstat-no" title="function not covered" >=o</span>+"/requestHist<span class="cstat-no" title="statement not covered" >ory/"+i,s=r[a];if(!s)throw new Error("Mi</span>sm</span>atc</span>hi<span class="cstat-no" title="statement not covered" >ng stat</span>e <span class="cstat-no" title="statement not covered" >parame</span>te<span class="cstat-no" title="statement not covered" >r in au</span>th<span class="cstat-no" title="statement not covered" >enticat</span>io<span class="cstat-no" title="statement not covered" >n resp</span>on<span class="cstat-no" title="statement not covered" >se");return e.request=JSON.par</span>se<span class="cstat-no" title="statement not covered" >(s),e}}</span>,{<span class="cstat-no" title="statement not covered" >key:"va</span>li<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >da</span>teStateParam",valu<span class="fstat-no" title="function not covered" >e:</span>fu<span class="cstat-no" title="statement not covered" >nction(e){v<span class="cstat-no" title="statement not covered" ></span>ar t=new Uint8Array(e.request.state),n=e.params.state;return u.subtle.digest({nam<span class="fstat-no" title="function not covered" >e:"SHA</span>-25<span class="cstat-no" title="statement not covered" >6"},t).then(function(t){if(n!==l(r.from(t)))throw new Error("Mismatching state parameter in authentication response");return e})}},{key:"errorResponse",value:function(e){var t=e.params.error;return t?Promise.reject(t):Promise.resolve(e)}},{key:"validateResponseMode<span class="fstat-no" title="function not covered" >",</span>value:fun<span class="cstat-no" title="statement not covered" >ction(e){i</span>f("</span>code"!==e.request.response_type&amp;&amp;"query"===e.mode)throw new Err<span class="fstat-no" title="function not covered" >or("In</span>valid res<span class="cstat-no" title="statement not covered" >ponse mode"</span>);<span class="cstat-no" title="statement not covered" >return <span class="cstat-no" title="statement not covered" ></span>e}},{key:"valida<span class="cstat-no" title="statement not covered" >teResponseParams",value:function(e){var t<span class="cstat-no" title="statement not covered" >=</span></span>e.request,n<span class="cstat-no" title="statement not covered" >=e.params</span>,r<span class="cstat-no" title="statement not covered" >=t.respon</span>se<span class="cstat-no" title="statement not covered" >_type.s<span class="cstat-no" title="statement not covered" ></span>plit(" "<span class="cstat-no" title="statement not covered" >);return r.includes("code")&amp;&amp;s(n.code,"Mi<span class="cstat-no" title="statement not covered" >s</span></span>sing authorization code in authentication response"),r.includes("id_token")&amp;&amp;s(n.id_token,"Missing id_token in <span class="cstat-no" title="statement not covered" ></span>a</span>uthentication response"),r.includes("token")&amp;&amp;(s(n.acc</span>ess_token,"Missing access_token in authentication response"),s<span class="fstat-no" title="function not covered" >(n.tok</span>en_type,"<span class="cstat-no" title="statement not covered" >Missi</span>ng<span class="cstat-no" title="statement not covered" > token_ty</span>pe<span class="cstat-no" title="statement not covered" > in authen</span>ti<span class="cstat-no" title="statement not covered" >cation r</span>es<span class="cstat-no" title="statement not covered" >ponse")),e}},{key:"exchangeAutho<span class="cstat-no" title="statement not covered" ></span>rizati<span class="cstat-no" title="statement not covered" >onCode",value:function(e){var t=e.rp,n=e.params,i=e.request,o=n.code;if</span></span>(!o||<span class="cstat-no" title="statement not covered" >"code"!==i.response_typ</span>e)<span class="cstat-no" title="statement not covered" >retur<span class="cstat-no" title="statement not covered" ></span>n Prom<span class="cstat-no" title="statement not covered" >ise.resolve(e);var a=t.provider,u=t.registration,l=u.client_id,d=u.client_<span class="cstat-no" title="statement not covered" >s</span></span>ecret;if(!d)throw new Authenticat</span>ionError("Client cannot exchange authorization code because it is no<span class="fstat-no" title="function not covered" >t a co</span>nfidentia<span class="cstat-no" title="statement not covered" >l client");var p=a.configuration</span>.t<span class="cstat-no" title="statement not covered" >oken_endpoint,v<span class="cstat-no" title="statement not covered" ></span>="POST",g=new f({"Content-Type":"application/x-w<span class="fstat-no" title="function not covered" >ww</span>-form-urle<span class="cstat-no" title="statement not covered" >ncoded"}),y=h.encode<span class="cstat-no" title="statement not covered" >({grant_type:"authorization_code",code:o,redirect_uri:i.redirect_uri}),m=u<span class="cstat-no" title="statement not covered" >.</span></span>token_end</span>poi</span>nt_auth_method||"client_secret_basic";if("client_secret_basic"=<span class="fstat-no" title="function not covered" >==m){v</span>ar b=new <span class="cstat-no" title="statement not covered" >r(l+":"+d).toSt<span class="cstat-no" title="statement not covered" ></span>ring("base64");g.set("Authorization","Basic "+b</span>)}return"client_secret_post"===m&amp;&amp;(y.client_id=l,y.client_secret=d),c(<span class="fstat-no" title="function not covered" >p,{met</span>hod<span class="cstat-no" title="statement not covered" >:v,headers:g,body:y}).then(function(e){return e.json()<span class="cstat-no" title="statement not covered" >}).then(function(t){return s(t.access_tok<span class="cstat-no" title="statement not covered" >e</span></span>n,"Missin</span>g access_token in token response"),s(t.token_type,"Missing token_type in<span class="fstat-no" title="function not covered" > token</span> response<span class="cstat-no" title="statement not covered" >"),s(t.id_</span>to<span class="cstat-no" title="statement not covered" >ken,"Miss</span>in<span class="cstat-no" title="statement not covered" >g id_token in token respons<span class="cstat-no" title="statement not covered" ></span>e"),e.params=Object.assign(e.params,t),e})}},{key:"validateIDToken",value:function(t){var n=t.params.id_token;if(!n)return Promise.resolve(t);var r=t.rp,i=r.provider;r.registration,i.configuration,i.jwks;return Promise.resolve(t).then(e.decryptIDToken).then(e.decodeIDToken).then(e.validateIssuer).then(e.validateAudience).then(e.resol</span>veKeys).then(e.verifySignature).then(e.validateExpires).then(e.verifyNonce)<span class="fstat-no" title="function not covered" >.then(</span>e.validat<span class="cstat-no" title="statement not covered" >eACR)</span>.t<span class="cstat-no" title="statement not covered" >hen(e.val</span>id<span class="cstat-no" title="statement not covered" >ateAuthTim</span>e)<span class="cstat-no" title="statement not covered" >.then(e<span class="cstat-no" title="statement not covered" ></span>.validateAccessTokenHash).then(e<span class="cstat-no" title="statement not covered" >.validateCodeHash)}},{key:"</span></span>decry<span class="cstat-no" title="statement not covered" >ptIDToken",</span>va<span class="cstat-no" title="statement not covered" >lue:function(e)</span>{r<span class="cstat-no" title="statement not covered" >eturn Promis</span>e.<span class="cstat-no" title="statement not covered" >resolve(e)}},{ke<span class="cstat-no" title="statement not covered" ></span>y:"dec<span class="cstat-no" title="statement not covered" >odeIDToken",value:function(e){var t=e.params.id_token;return t&amp;&amp;(e.decoded=d.decode(t)),e}},{key:"validateIssuer",va</span></span>lue:f<span class="cstat-no" title="statement not covered" >unction(e){var t=e.rp.provider.</span>co<span class="cstat-no" title="statement not covered" >nfigura</span>ti<span class="cstat-no" title="statement not covered" >on,n=e.decoded.payload;if(n.iss!==t.issuer)throw new Error("</span>Mi<span class="cstat-no" title="statement not covered" >smatching issuer in ID Token");return e}},{key:"validateAudience",value:functio</span>n(<span class="cstat-no" title="statement not covered" >e){var t=e.rp.registration,n=e.decoded.payload,r=n.a<span class="cstat-no" title="statement not covered" ></span>ud,i=n.azp;if("string"==typeof r&amp;&amp;r!<span class="cstat-no" title="statement not covered" >==t.client_id)throw new Error("Mis<span class="cstat-no" title="statement not covered" ></span>matching audience in id_token");if(<span class="cstat-no" title="statement not covered" ></span>A</span>rray.isArray(r)&amp;&amp;!r.includes(t.client_id))throw new Error("Mismatching audience in id_token");if(Array.<span class="fstat-no" title="function not covered" >is</span>Array(r)&amp;&amp;<span class="cstat-no" title="statement not covered" >!i)throw new Erro</span>r("Miss<span class="fstat-no" title="function not covered" >in</span>g azp clai<span class="cstat-no" title="statement not covered" >m in id_token");if(i&amp;&amp;i!==t.client_id)throw new Error("Mismatching azp claim in id_token");return e}},{key:"resolveKeys",value:function(e){var t=e.rp,n=t.provider,r=(n.jwks,e.decoded);return t.jwks().then(funct</span>ion</span>(t){if(r.resolveKeys(t))return Promise.resolve(e);throw new Error<span class="fstat-no" title="function not covered" >("Cann</span>ot resolv<span class="cstat-no" title="statement not covered" >e signing key for <span class="cstat-no" title="statement not covered" ></span>ID Tok<span class="cstat-no" title="statement not covered" >en.")})}},{key:"verifySigna</span></span>ture"<span class="cstat-no" title="statement not covered" >,valu</span>e:<span class="cstat-no" title="statement not covered" >function(e)<span class="cstat-no" title="statement not covered" ></span>{var t=e.decoded.header.alg,n=e.rp.reg<span class="cstat-no" title="statement not covered" >i</span>stration,r=n.id_token_signed_response_alg||"RS256";if(t!==r)throw new Error("Expected ID Token to be signed with "+r);return e.decoded.verify().then(function(t){if(!t)throw new Error("Invalid ID Token signature");return e})}},{key:"validateExpires",value:function(e){var t=e.decoded.payload.exp;if(t&lt;=Math.flo</span>or(Date.now()/1e3))throw new Error("Expired ID Token");return e}<span class="fstat-no" title="function not covered" >},{key</span>:"v<span class="cstat-no" title="statement not covered" >erifyNonce",value:function(</span>e){var t=new Uint8Array(e.request.nonce),n=e.decoded.payload.no<span class="fstat-no" title="function not covered" >nce;if</span>(!n)throw<span class="cstat-no" title="statement not covered" > new Error("Missin<span class="cstat-no" title="statement not covered" ></span>g nonce in ID Token");return u.subtle</span>.digest({name:"SHA-256"},t).then(function(t){if(n!==l(r.from(t))<span class="fstat-no" title="function not covered" >)throw</span> new Erro<span class="cstat-no" title="statement not covered" >r("Mismatching nonce in ID T</span>ok<span class="cstat-no" title="statement not covered" >en");return e})}},<span class="cstat-no" title="statement not covered" ></span>{key:"validateAcr",v<span class="cstat-no" title="statement not covered" >alue:function(e){return e}},{key:"validateAccessTo<span class="cstat-no" title="statement not covered" >k</span></span>enHash",v</span>alue:function(e){return e}},{key:"validateAuthorizationCodeHash",v<span class="fstat-no" title="function not covered" >alue:f</span>unction(e<span class="cstat-no" title="statement not covered" >){return e}}]),e}(</span>);<span class="cstat-no" title="statement not covered" >e.exports=p}).call</span>(t<span class="cstat-no" title="statement not covered" >,funct</span>io<span class="cstat-no" title="statement not covered" >n(){re<span class="cstat-no" title="statement not covered" ></span>turn this}(),n(47).Buffer)},function(e,<span class="cstat-no" title="statement not covered" >t,n){"use strict";function r(e,t){if(!(e instanceof <span class="cstat-no" title="statement not covered" >t</span></span>))throw new TypeError("Cannot call a class as<span class="cstat-no" title="statement not covered" > a function")}function i(e,t){if(!e)throw new Refere<span class="cstat-no" title="statement not covered" >n</span></span>ceError("this hasn't be<span class="cstat-no" title="statement not covered" >en initialised - super() hasn't been called");ret<span class="cstat-no" title="statement not covered" >u</span></span>rn!t||"object"!=typeo<span class="cstat-no" title="statement not covered" >f t&amp;&amp;"function"!=typeof t?e:t}function o(e,t){if("fun<span class="cstat-no" title="statement not covered" >c</span></span>tion"!=ty</span>peof t&amp;&amp;null!==t)throw new TypeError("Super expression must e<span class="fstat-no" title="function not covered" >ither </span>be null o<span class="cstat-no" title="statement not covered" >r a f</span>un<span class="cstat-no" title="statement not covered" >ction, not </span>"+t<span class="cstat-no" title="statement not covered" >ypeof t);e.protot</span>y<span class="cstat-no" title="statement not covered" >pe=Object.create(t&amp;&amp;t<span class="fstat-no" title="function not covered" >.p</span>rototype,{<span class="cstat-no" title="statement not covered" >constructor:{value:e<span class="cstat-no" title="statement not covered" >,enumerable:!1,writable:!0<span class="cstat-no" title="statement not covered" >,</span></span>configurable:!0}}),t&amp;&amp;(Object.setPrototypeOf?Object.setProto</span>typ</span>eOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var <span class="fstat-no" title="function not covered" >n=0;n&lt;</span>t.length;<span class="cstat-no" title="statement not covered" >n++){var r=t[n];r.enu</span>me<span class="cstat-no" title="statement not covered" >rable=r.enumerable</span>||<span class="cstat-no" title="statement not covered" >!1,r.configurable=!0,"value"in r&amp;&amp;(r.wri<span class="cstat-no" title="statement not covered" ></span>table=!0)<span class="cstat-no" title="statement not covered" >,Object.defineProperty(e,r.key,r)}}return function(t,n,r){<span class="cstat-no" title="statement not covered" >r</span></span>eturn n&amp;&amp;e(t.prototype,n),r&amp;&amp;e<span class="fstat-no" title="function not covered" >(t</span>,r),t}}(),<span class="cstat-no" title="statement not covered" >s=n(10<span class="cstat-no" title="statement not covered" >3),u=s.JWT,l=n(135),c=function(e){function t()<span class="cstat-no" title="statement not covered" >{</span></span>return r(</span>thi</span>s,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,ar<span class="fstat-no" title="function not covered" >gument</span>s))}retur<span class="cstat-no" title="statement not covered" >n o(t,e),a(t,null,[{ke<span class="cstat-no" title="statement not covered" ></span>y:"schema",get:function(){return <span class="cstat-no" title="statement not covered" >l}}]),t}(u);e.exports=c},function(e,<span class="cstat-no" title="statement not covered" >t</span></span>,n){"use </span>strict";var r=n(103),i=r.JWTSchema,o=i.extend({properties:{he<span class="fstat-no" title="function not covered" >ader:{</span>},payload<span class="cstat-no" title="statement not covered" >:{properties:{iss:{type:"string"</span>,f<span class="cstat-no" title="statement not covered" >ormat:"url"},sub:{type:"<span class="cstat-no" title="statement not covered" ></span>string<span class="cstat-no" title="statement not covered" >",maxLength:255},auth_time:{type:"integer",fo<span class="cstat-no" title="statement not covered" >r</span></span>mat:"NumericDate"},nonce:{type:"string"},acr:{t<span class="fstat-no" title="function not covered" >yp</span>e:"string"<span class="cstat-no" title="statement not covered" >},amr:{type:"array",<span class="cstat-no" title="statement not covered" >items:{type:"string"}},azp:{type:"string",format:<span class="cstat-no" title="statement not covered" >"</span></span>StringOrU</span>RI"</span>}},required:["iss","sub","aud","exp","iat"]}}});e.exports=o},<span class="fstat-no" title="function not covered" >functi</span>on(<span class="cstat-no" title="statement not covered" >e,t,n){"us</span>e strict";var r=n(94),i=r.JSONSchema,o=new i({type:"object",properties:{p<span class="fstat-no" title="function not covered" >rovide</span>r:{<span class="cstat-no" title="statement not covered" >type:"obje</span>ct",properties:{name:{type:"string"},url:{<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
type:"string",format:"uri"},configuration:{},jwks:{}},required:["url"]},defaults:{type:"object",properties:{authenticate:{type:"object",properties:{redirect_uri:{type:"string",format:"uri"},response_type:{type:"string",default:"id_token token",enum:["code","token","id_token token","id_token token code"]},display:{type:"string",default:"page",enum:["page","popup"]},scope:{type:["string","array"],default:["openid"]}}},register:{}}},registration:{},store:{type:"object",default:{}}}});<span class="cstat-no" title="statement not covered" >e.exports=o},</span>f<span class="fstat-no" title="function not covered" >un</span>ction(e,t,n){"use strict";function r<span class="fstat-no" title="function not covered" >(e</span>){var t=a<span class="cstat-no" title="statement not covered" >rguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};t<span class="cstat-no" title="statement not covered" ></span>his.rdf=e,this.vocab=d(e),this.config=Object.assign(s,t),this.auth=t.auth}fu</span>nction i(<span class="fstat-no" title="function not covered" >e,</span>t){re<span class="cstat-no" title="statement not covered" >turn new r(e,t)}var</span> o="te<span class="cstat-no" title="statement not covered" >xt/turtle;q=0.8,*/*;q=0.5",a="</span>te<span class="cstat-no" title="statement not covered" >xt/turtle",s=n</span>(1<span class="cstat-no" title="statement not covered" >38),u=n</span>(1<span class="cstat-no" title="statement not covered" >39).composePatchQuery,l=n</span>(1<span class="cstat-no" title="statement not covered" >40),c=n</span>(1<span class="cstat-no" title="statement not covered" >42),f=n</span>(1<span class="cstat-no" title="statement not covered" >46),h=n</span>(1<span class="cstat-no" title="statement not covered" >47),d=n</span>(1<span class="cstat-no" title="statement not covered" >43);r.p<span class="cstat-no" title="statement not covered" ></span>rototype.createContainer=fun<span class="fstat-no" title="function not covered" >ct</span>ion(e,t,n,r){ret<span class="cstat-no" title="statement not covered" >urn this.post(e,r,t,!0)},r.p</span>rototype.createResponse=func<span class="fstat-no" title="function not covered" >ti</span>on(e,t){var n=new <span class="cstat-no" title="statement not covered" >l(this.rdf,e,t);retu<span class="cstat-no" title="statement not covered" ></span>rn"get"===n.method&amp;&amp;n.isContainer()?new c(this.rdf,n.url,n):n},r.pr</span>ototype.currentUrl=funct<span class="fstat-no" title="function not covered" >io</span>n(){retur<span class="cstat-no" title="statement not covered" >n"undefined"!=typeof window?window.location.href:null},r.pro</span>totype.del=functi<span class="fstat-no" title="function not covered" >on</span>(e){return<span class="cstat-no" title="statement not covered" > this.solidRequest(e,"DELETE")},r.prot</span>otype.get=functio<span class="fstat-no" title="function not covered" >n(</span>e){var t=argumen<span class="cstat-no" title="statement not covered" >ts.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};return <span class="cstat-no" title="statement not covered" ></span>t.headers=t.headers||{},t.headers.Accept||(t.headers.Accept=o),this.solidRequest(e,"GET",t)},r.proto</span>type.head=function<span class="fstat-no" title="function not covered" >(e</span>,t){return t<span class="cstat-no" title="statement not covered" >his.solidRequest(e,"HEAD",t)},r.protot</span>ype.loadParsedGraphs=function(<span class="fstat-no" title="function not covered" >e,</span>t){var n=this,r=e.<span class="cstat-no" title="statement not covered" >map(f</span>un<span class="cstat-no" title="statement not covered" >ction(<span class="fstat-no" title="function not covered" >e)</span>{var r;return n.<span class="cstat-no" title="statement not covered" >get(e,t).then(function(<span class="fstat-no" title="function not covered" >e)</span>{return r=<span class="cstat-no" title="statement not covered" >e.url,e.parsedGraph()}).catch(fu</span>nction()<span class="fstat-no" title="function not covered" >{r</span>eturn nul<span class="cstat-no" title="statement not covered" >l}).then(func</span>tion(e)<span class="fstat-no" title="function not covered" >{r</span>eturn{uri:<span class="cstat-no" title="statement not covered" >r,value:e}})});return P</span>rom</span>is<span class="cstat-no" title="statement not covered" ></span>e.all(r)},r.prototype.n</span>eedsProxy=function(e){va<span class="fstat-no" title="function not covered" >r </span>t=this.currentUr<span class="cstat-no" title="statement not covered" >l(),n=t&amp;&amp;"https:"=</span>==<span class="cstat-no" title="statement not covered" >t.slice(0,6),r=e&amp;&amp;"http:"==</span>=e<span class="cstat-no" title="statement not covered" >.slice(0,5);return n&amp;&amp;r},r<span class="cstat-no" title="statement not covered" ></span>.prototype.op</span>tions=function(e){ret<span class="fstat-no" title="function not covered" >ur</span>n this.sol<span class="cstat-no" title="statement not covered" >idRequest(e,"OPTIONS")},r.prototype.pat</span>ch=function(e,t,n,r<span class="fstat-no" title="function not covered" >){</span>var i=u(t,n),o="applic<span class="cstat-no" title="statement not covered" >ation/s</span>pa<span class="cstat-no" title="statement not covered" >rql-update";return r=r||{},r<span class="cstat-no" title="statement not covered" ></span>.headers=r.headers||{},r.headers["Content-Type"]=o,this.solidRequest(e,"PATCH",r,i)},r.prototype.post</span>=function(e,t,n,r,<span class="fstat-no" title="function not covered" >i)</span>{var o;r?(o=this.vocab.l<span class="cstat-no" title="statement not covered" >dp("BasicContainer"),i="text/turtle"):(o=this.vocab.ldp("Resource"),i=i||a);var s={};return s.</span>heade<span class="cstat-no" title="statement not covered" >rs=<span class="cstat-no" title="statement not covered" ></span>{},s.headers.Link=o+'; rel="type"',s.headers["Content-Type"]=i,n&amp;&amp;n.length&gt;0&amp;&amp;(s.headers.Slug=n),this.solidRequest(e,"POST",s,t)},r.prototype.proxy</span>Url=function(e,t){retu<span class="fstat-no" title="function not covered" >rn</span> t=t||this.c<span class="cstat-no" title="statement not covered" >onfig.proxyUrl,t.replace("{uri}",encodeURIComponent(e))},r.prototype.put=fu</span>nction(e,t,n,r){r<span class="fstat-no" title="function not covered" >et</span>urn r=r||{},r.he<span class="cstat-no" title="statement not covered" >aders=r.headers||{},n=n||a,r.headers["Content-Type"]=n,this.solidRequest(e,"PUT",r,t)},r.prototype.solidRe</span>quest=function(e,t,n,r){n=<span class="fstat-no" title="function not covered" >n|</span>|{},n.headers=n.<span class="cstat-no" title="statement not covered" >headers||{},this.auth&amp;&amp;this.auth.accessToken&amp;&amp;(n.headers.Authorization="Bearer "+this.auth.accessToken),n.proxyUrl=n.proxyUrl||this.config.proxyUrl,n.timeout=n.timeout||this.config.timeout,(this.needsProxy(e)||n.forceProxy)&amp;&amp;(e=this.proxyUrl(e));var i=this;return new</span> Prom<span class="cstat-no" title="statement not covered" >ise(f<span class="cstat-no" title="statement not covered" ></span>unction(o,a){var s=<span class="fstat-no" title="function not covered" >ne</span>w f;s.open(t,e),n.<span class="cstat-no" title="statement not covered" >noCreden<span class="cstat-no" title="statement not covered" ></span>tials||(s.withCredentials=!0);for(var u in n.headers<span class="cstat-no" title="statement not covered" >)</span>s.setRequestHeader(u,n<span class="cstat-no" title="statement not covered" >.headers[u]);n.timeout&amp;&amp;(s.timeout=<span class="cstat-no" title="statement not covered" >n</span></span>.timeout),s.onload=function(){this.status<span class="fstat-no" title="function not covered" >&gt;=</span>200&amp;&amp;this<span class="cstat-no" title="statement not covered" >.status&lt;300?o(i.createResponse(this,t)):a(new h(this.status,this.statusText,{xhr:this}))},s.onerror=function(){a</span>(new h(this<span class="fstat-no" title="function not covered" >.s</span>tatus,thi<span class="cstat-no" title="statement not covered" >s.statusText,{xhr:this}))},"undefined"!=typeof r&amp;&amp;</span>r?s.send(r):s.send()})},e.exports=i,e.exports.</span>Sol</span>idWebClient=r},function(e,t){"use strict"</span>;<span class="fstat-no" title="function not covered" >e.</span>exports={proxyUrl:"https:<span class="cstat-no" title="statement not covered" >//databox.me/,proxy?uri={uri}",timeout:5e4}},function(e,t){"use strict";</span>f<span class="fstat-no" title="function not covered" >un</span>ction n(e,t){return t&amp;&amp;"http"!==t.<span class="fstat-no" title="function not covered" >sl</span>ice(0<span class="cstat-no" title="statement not covered" >,4)?[e,t].map(function(e){return"/"===e[0]<span class="fstat-no" title="function not covered" >&amp;&amp;</span>(e=e.slice<span class="cstat-no" title="statement not covered" >(1)),"/"===e[e.length-1]&amp;&amp;(e=e.slice(0,e.length-1)),e}).join("/"):t}function r(e,t)</span>{var n="",r=!0;</span>return e&amp;<span class="fstat-no" title="function not covered" >&amp;e</span>.length&gt;0&amp;&amp;<span class="cstat-no" title="statement not covered" >(e=</span>e.<span class="cstat-no" title="statement not covered" >map<span class="cstat-no" title="statement not covered" ></span>(function(e){return s(e,r)}),n+<span class="fstat-no" title="function not covered" >="</span>DELETE DAT<span class="cstat-no" title="statement not covered" >A { "+e.join(" </span>. ")+" };\n"),t&amp;&amp;t.length&gt;0&amp;&amp;(t=t.map(function(e){return s(e,r)}),n+=<span class="fstat-no" title="function not covered" >"I</span>NSERT DATA<span class="cstat-no" title="statement not covered" > { "+t.join(" .</span> ")+" };\n"),n}function i(e){var t,n,r,i,o=e.spl</span>it("//");<span class="fstat-no" title="function not covered" >re</span>turn 2===o.length<span class="cstat-no" title="statement not covered" >?(t=o[0],n=o[1<span class="cstat-no" title="statement not covered" ></span>]):n=e,i=n.split("/"),r=t?t+"//"+i[0]:i[0],e.startsWith("//")&amp;&amp;(r="//"+r),r}function o(e,t){var n={};if(e){var</span> r=e.spli<span class="fstat-no" title="function not covered" >t(</span>",");r.forE<span class="cstat-no" title="statement not covered" >ach<span class="cstat-no" title="statement not covered" ></span>(function(t)<span class="cstat-no" title="statement not covered" >{t&amp;&amp;e.indexOf<span class="cstat-no" title="statement not covered" ></span>(t)&gt;=0&amp;&amp;(n<span class="fstat-no" title="function not covered" >[t</span>.trim().to<span class="cstat-no" title="statement not covered" >LowerCase()]=!0)})}return t&amp;&amp;t.indexOf("application/</span>spa<span class="cstat-no" title="statement not covered" ></span>r</span>ql-update")&gt;=0&amp;&amp;(n.patch=!0),n}function a(e){if(!e)return{};for(var </span>t=/&lt;[^&gt;]*<span class="fstat-no" title="function not covered" >&gt;\</span>s*(<span class="cstat-no" title="statement not covered" >\s*;\s<span class="cstat-no" title="statement not covered" >*[^\(\)&lt;&gt;<span class="cstat-no" title="statement not covered" >@</span></span>,;:"\/\[\]\?={} \t]+=(([^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t]+)|("[^"]*")))*(,|$)/g,n=/[^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t]+=(([^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g,r=e.match(t),i={},o=0;o&lt;r.length;o++)for(var a=r[o].split("&gt;"),s=a[0].subs<span class="cstat-no" title="statement not covered" >tring(1),u=a[1],l=u.match(n),c=0;c&lt;l.length;c++){var f=l[c],h=f.split("="),d=h[1].replace(/[<span class="cstat-no" title="statement not covered" >"']/g</span>,"<span class="cstat-no" title="statement not covered" >");i[d]||(i[d</span>]=<span class="cstat-no" title="statement not covered" >[]),i[d].push(s),i[d].len<span class="cstat-no" title="statement not covered" ></span>gth&gt;1&amp;&amp;i[d].sort()}return i}function s(e,t){return"string<span class="cstat-no" title="statement not covered" ></span>"</span></span>!=typeof </span>e&amp;&amp;(e=e.t<span class="fstat-no" title="function not covered" >oC</span>anoni<span class="cstat-no" title="statement not covered" >cal()),t&amp;&amp;e.endsWith(".")&amp;&amp;(e=e.slice(0,-1)),e}e.exports.absoluteUrl=n,e.exports.compos<span class="cstat-no" title="statement not covered" ></span>ePatchQuery=r,e.exports.hostname=i,e.exports.parseAllowedMethods=o,e.exports.parseLinkHeader=a,e.exports.statementToNT=s},function(e,t,n){"use strict";function r(</span>e<span class="fstat-no" title="function not covered" >,t</span>,n){if(!t)return this.xhr=null,this.<span class="fstat-no" title="function not covered" >us</span>er="",t<span class="cstat-no" title="statement not covered" >his.me<span class="cstat-no" title="statement not covered" >thod=null,this.types=[],void(this.graph=null);this.rdf=e;var r=t.getResponseHeader("Lin<span class="cstat-no" title="statement not covered" >k</span></span>");this.lin</span>kHead<span class="cstat-no" title="statement not covered" >ers=i.parseLinkHeader(r)||{}<span class="cstat-no" title="statement not covered" ></span>,n=n?n.toLowerCase():"",this.method=n,this.acl=this.linkHeaders.acl,this.acl&amp;&amp;(this.acl=this.acl[0]),this.allowedMethods=this.parseAllowedMethods(t,n),this.graph=null,this.meta=this.linkHeaders.meta||this.linkHeaders.describedBy,this.meta&amp;&amp;(this.meta=this.meta[0]),this.types=this.typeLinkHeaders(),this.url=t.getResponseHeader("Location")?i.absoluteUrl(i.hostname(t.responseURL),t.getResponseHeader("Location")):t.responseURL,this.user=t.getResponseHeader("User")||"",this.websocket=t.getResponseHeader("Updates-Via")||"",this.xhr=t}e.exports=r;var i=n(139),o=n(141);r.protot<span class="cstat-no" title="statement not covered" ></span>ype.aclAbsolu</span>teUrl<span class="cstat-no" title="statement not covered" >=functi</span>on<span class="cstat-no" title="statement not covered" >(){retu<span class="cstat-no" title="statement not covered" ></span>rn this.acl?this.resolveMet<span class="fstat-no" title="function not covered" >aO</span>rAclUrl("<span class="cstat-no" title="statement not covered" >acl"):null},r.prototype.contentType=function(){return </span>this.xhr?this.xhr.getResp<span class="fstat-no" title="function not covered" >on</span>seHeader(<span class="cstat-no" title="statement not covered" >"Content-Type").split(";")[0]:null},r.prototype.exists=function(){return this.x</span>hr&amp;&amp;this.xhr.status&gt;<span class="fstat-no" title="function not covered" >=2</span>00&amp;&amp;this.<span class="cstat-no" title="statement not covered" >xhr.status&lt;400},r.prototype.isContainer=function(){return th</span>is.isType("http://www.w3.<span class="fstat-no" title="function not covered" >or</span>g/ns/ldp#<span class="cstat-no" title="statement not covered" >Container")||this.isType("http://www.w3.org/ns/ldp#BasicContainer")},r.prototype.isLoggedIn=function(){return this</span>.user},r.prototype.isTyp<span class="fstat-no" title="function not covered" >e=</span>function(<span class="cstat-no" title="statement not covered" >e){return this.typ</span>es.indexOf(e)!==-1},<span class="fstat-no" title="function not covered" >r.</span>prototype.<span class="cstat-no" title="statement not covered" >metaAbsoluteUrl=function(){return t</span>his.meta?this.resolveMetaOrAc<span class="fstat-no" title="function not covered" >lU</span>rl("meta"<span class="cstat-no" title="statement not covered" >):null},r.prototype.parseAllowedMethods=function(e,t){re</span>turn"get"===t?{}:i.parseAllowedMe<span class="fstat-no" title="function not covered" >th</span>ods(e.getRes<span class="cstat-no" title="statement not covered" >ponseHeader("Allow"),e.getResponseHeader("Accept-Patch"))},r.prototype.parsedGraph=function(){return this.gr</span>aph||(this.graph=o.parseG<span class="fstat-no" title="function not covered" >ra</span>ph(this.r<span class="cstat-no" title="statement not covered" >df,this.url,this.raw(),this.contentType())),this.graph},r.prototype.raw=function(){return this.xhr?this.xh</span>r.response:null},<span class="fstat-no" title="function not covered" >r.</span>prototype<span class="cstat-no" title="statement not covered" >.resolveMetaOrAclUrl=function(e){if(!thi</span>s.url)return null;var t=this[e],n<span class="fstat-no" title="function not covered" >=t</span>his.url.sl<span class="cstat-no" title="statement not covered" >ice(0,this.ur<span class="cstat-no" title="statement not covered" >l.lastIndexOf</span></span>("/")<span class="cstat-no" title="statement not covered" >+1);retu</span>rn<span class="cstat-no" title="statement not covered" > i.absoluteUrl(n,t)},r.prototype.typeLinkHeade<span class="cstat-no" title="statement not covered" ></span>rs=function(){if(!Array.isA</span>rray(this.linkHeaders.type))r<span class="fstat-no" title="function not covered" >et</span>urn[];var<span class="cstat-no" title="statement not covered" > e=new Set(this.linkHeaders.type||[]);ret<span class="cstat-no" title="statement not covered" >urn Array.</span></span>from(<span class="cstat-no" title="statement not covered" >e)}},function(e,t){"use strict";fun<span class="cstat-no" title="statement not covered" ></span>ction n(e,t,n){t.state</span>me</span>n<span class="fstat-no" title="function not covered" >ts</span>Matching(s).forEach(function(t){e.<span class="fstat-no" title="function not covered" >ad</span>d(t.sub<span class="cstat-no" title="statement not covered" >ject,t.predicate,t.object,t.why)<span class="fstat-no" title="function not covered" >})</span>}function <span class="cstat-no" title="statement not covered" >r(e,t){var n=e.graph();return t.forEach(funct</span>ion</span>(e){n.add<span class="fstat-no" title="function not covered" >St</span>atement(e)}<span class="cstat-no" title="statement not covered" >),n}functi<span class="cstat-no" title="statement not covered" ></span>on i(e,t,n,r){var<span class="fstat-no" title="function not covered" > i</span>=e.graph()<span class="cstat-no" title="statement not covered" >;return e.parse(n,i</span>,t,r)</span>,i}functi<span class="fstat-no" title="function not covered" >on</span> o(e,t,n,r,i){v<span class="cstat-no" title="statement not covered" >ar o={},a=<span class="cstat-no" title="statement not covered" ></span>e.statementsMatching(t,n,r,</span>i);return<span class="fstat-no" title="function not covered" > a</span>.forEach(function<span class="cstat-no" title="statement not covered" >(e)</span>{o<span class="cstat-no" title="statement not covered" >[e.object.uri]=!0}),Object.key<span class="cstat-no" title="statement not covered" ></span>s(o)}function a(e<span class="fstat-no" title="function not covered" >){</span>var t=e.ma<span class="cstat-no" title="statement not covered" >p(function(e){return</span> e.toNT()});return</span> t=t.join<span class="fstat-no" title="function not covered" >("</span>\n")}e.ex<span class="cstat-no" title="statement not covered" >ports.<span class="fstat-no" title="function not covered" >ap</span>pendGraph=<span class="cstat-no" title="statement not covered" >n,e.exports.parse</span>Gr<span class="cstat-no" title="statement not covered" ></span>aph=i,e.exports.parseLi<span class="cstat-no" title="statement not covered" ></span>nks=o,e.exports.serializeStatements=a,e.exports.graphFromStatements=r;var s=null},function(e,t,n){"use strict";function r(e,t,n){s.call</span>(this<span class="cstat-no" title="statement not covered" >,t,n)</span>,t<span class="fstat-no" title="function not covered" >hi</span>s.containers={},this.contentsUris=[]<span class="fstat-no" title="function not covered" >,t</span>his.rdf<span class="cstat-no" title="statement not covered" >=e,this.resources={},this.vocab=a(e),n&amp;&amp;this.initFromResponse(this.uri,n)}e.exports=r;var i=n(141),o=i.parseLinks,a=n(143),s=n(145);r.protot<span class="cstat-no" title="statement not covered" ></span>ype=Object.cr</span>eate(<span class="cstat-no" title="statement not covered" >s.proto</span>ty<span class="cstat-no" title="statement not covered" >pe),r.prototy</span>pe<span class="cstat-no" title="statement not covered" >.constr</span>uc<span class="cstat-no" title="statement not covered" >tor=r,r<span class="cstat-no" title="statement not covered" ></span>.prototype.appendFromGraph=function(e,t){var n=this.rdf.namedNode(this.uri);this.types=Object<span class="fstat-no" title="function not covered" >.k</span>eys(e.findTypeURIs<span class="cstat-no" title="statement not covered" >(n));var i=o(e,null,this.voca<span class="cstat-no" title="statement not covered" ></span>b.ldp("contains"));this.contentsUris=this.c</span>onten<span class="cstat-no" title="statement not covered" >tsUris.concat(i.sort());var a,u=e.eac<span class="cstat-no" title="statement not covered" ></span>h(null,null,this.vocab.ldp("Container")),l=this;u.forE</span>ach(fun<span class="cstat-no" title="statement not covered" >ction(t){t.uri!==l.uri&amp;&amp;(a=new r(l.rdf,t.uri),</span>a.<span class="cstat-no" title="statement not covered" >types<span class="cstat-no" title="statement not covered" ></span>=Object.ke<span class="fstat-no" title="function not covered" >ys</span>(e.findTyp<span class="cstat-no" title="statement not covered" >eURIs(t)),l.containers[a.uri]=a)});var c,f,h,d;i.forEach(function(t){f=t in l.containers,c=t!==l.uri</span>&amp;&amp;!</span>f,c&amp;&amp;(h=new<span class="cstat-no" title="statement not covered" > s(t),d=l.<span class="fstat-no" title="function not covered" >rd</span>f.namedNod<span class="cstat-no" title="statement not covered" >e(t),h.types=Object.keys(e.findTypeURIs(d)),l.resources[t]=h)})},r.prototype.findByType=function(e){var t,n,r=[];for(t in this.con</span>tai</span>ners)n=this.containers[t<span class="fstat-no" title="function not covered" >],</span>n.isType(e)&amp;&amp;r.push(<span class="cstat-no" title="statement not covered" >n);<span class="cstat-no" title="statement not covered" ></span>var i;for(t in this.resou<span class="cstat-no" title="statement not covered" >rces)i=this.resources[t],i.isType(e)&amp;&amp;r.push(</span></span>i);re<span class="cstat-no" title="statement not covered" >turn r},r.prototype.init<span class="cstat-no" title="statement not covered" >FromResponse=function(e,t){var n=t.contentT<span class="cstat-no" title="statement not covered" >y</span></span>pe();if(!</span>n)throw new Error("Cannot pars<span class="fstat-no" title="function not covered" >e </span>container without <span class="cstat-no" title="statement not covered" >a Content-Type: <span class="cstat-no" title="statement not covered" ></span>header<span class="cstat-no" title="statement not covered" >");var r=i.parseGraph(this.rdf,e,t.raw(),n);this.parsedGraph=r,this.append</span></span>FromG<span class="cstat-no" title="statement not covered" >raph(r,e)},s.prototype.isContainer=<span class="cstat-no" title="statement not covered" ></span>function(){return!0},r.prototype.isEmpty=funct</span>ion(){return 0===this.con<span class="fstat-no" title="function not covered" >te</span>ntsUris.l<span class="cstat-no" title="statement not covered" >ength}},fu</span>nction(e,t,n){"use st<span class="fstat-no" title="function not covered" >ri</span>ct";funct<span class="cstat-no" title="statement not covered" >ion r(e){var t=n(144)(e),r={acl:t.bas</span>e(</span>"<span class="fstat-no" title="function not covered" >ht</span>tp://www.w3.org/ns/auth/acl#"),app:t<span class="fstat-no" title="function not covered" >.b</span>ase("http<span class="cstat-no" title="statement not covered" >://www.w3.</span>or<span class="cstat-no" title="statement not covered" >g/ns/solid/app#"),dct:t.base("http://purl.org/dc/terms/"),foaf:t.base("http://xmlns.com/foaf/0.1/"),ldp:t.base("http://www.w3.org/ns/ldp#"),owl:t.base("http://www.w3.org/2002/07/owl#"),pim:t.base("http://www.w3.org/ns/pim/space#"),rdf:t.base("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),rdfs:t.base("http://www.w3.org/2000/01/rdf-schema#"),schema:t.base("http://schema.org/"),sioc:t.base("http://rdfs.org/sioc/ns#"),solid:t.base("http://www.w3.org/ns/solid/terms#"),vcard:t.base("http://www.w3.org/2006/vcard/ns#"),xsd:t.base("http://www.w3.org/2001/XMLSchema#")};return r}e.exports=r},function(e,t){"use strict";function n(e){this.rdf=e}<span class="cstat-no" title="statement not covered" ></span>function r<span class="cstat-no" title="statement not covered" ></span>(e){return ne</span>w<span class="fstat-no" title="function not covered" > n</span>(e)}e.exports=r,n.prototype.base=f<span class="fstat-no" title="function not covered" >un</span>cti<span class="cstat-no" title="statement not covered" >on(e){var t=</span>this;retu<span class="fstat-no" title="function not covered" >rn</span> fu<span class="cstat-no" title="statement not covered" >nction(n){return <span class="cstat-no" title="statement not covered" ></span>t.rdf?t.rdf.namedNode(e+n):e+<span class="fstat-no" title="function not covered" >n}</span>}},function(e,t)<span class="cstat-no" title="statement not covered" >{"use<span class="cstat-no" title="statement not covered" ></span> strict<span class="fstat-no" title="function not covered" >";</span>function n<span class="cstat-no" title="statement not covered" >(e,t){this.name=null,this.parsedGraph=n</span>ul</span>l,</span>t<span class="fstat-no" title="function not covered" >hi</span>s.response=t,this.types=[],this.ur<span class="fstat-no" title="function not covered" >i=</span>e,t&amp;&amp;<span class="cstat-no" title="statement not covered" >t.url!==e&amp;&amp;(this.uri=t.url),this.initName()}e.exports=n,n.prototype.initName=function(){if(this.uri){var e=this.uri.split("/")<span class="cstat-no" title="statement not covered" ></span>;this.name=e.pop(),!this.name&amp;&amp;e.<span class="fstat-no" title="function not covered" >le</span>ngth&gt;0&amp;&amp;(<span class="cstat-no" title="statement not covered" >this.name=e.pop())}<span class="cstat-no" title="statement not covered" >},n.prototype.isCont<span class="cstat-no" title="statement not covered" ></span>ainer=function(){return!1},n.prototype.isType=function(e){retur</span>n</span> this.types.indexOf(e)!==<span class="fstat-no" title="function not covered" >-1</span>}},functi<span class="cstat-no" title="statement not covered" >on(e,t,n){</span>"use strict";var r;r<span class="fstat-no" title="function not covered" >="</span>undefined"<span class="cstat-no" title="statement not covered" >!=typeof tabulator&amp;&amp;tabulator.isExt</span>en</span>s<span class="fstat-no" title="function not covered" >io</span>n?Components.classes["@mozilla.or<span class="cstat-no" title="statement not covered" >g/xmlextras/xmlhttprequest;1"].createInstance().QueryInterface(Components.interfaces.nsIXMLHttpRequest):"undefined"!=typeof window&amp;&amp;"XMLHttpRequest"in window?window.XMLHttpRequest:n(19),e.exports=r},function(e,t,n){function r(e,t,n){if("string"==typeof e&amp;&amp;(e=s[e]),"number"!=typeof e)t</span>h<span class="fstat-no" title="function not covered" >ro</span>w new TypeError("Non-nu<span class="fstat-no" title="function not covered" >me</span>ric HTT<span class="cstat-no" title="statement not covered" >P code");"object"==typeof t&amp;&amp;null!=t&amp;&amp;(n=t,t=null),<span class="cstat-no" title="statement not covered" >o.call(this,t||a[e],n),this.code=e}function i<span class="cstat-no" title="statement not covered" >(</span></span>e){return{configurable:!0,get:function(){return this[e]},set:function(t){retu</span>rn this[e<span class="fstat-no" title="function not covered" >]=</span>t}}<span class="cstat-no" title="statement not covered" >}t=e.exports=r;var o=n(148),a=n(149),s=t;r.prototype=Object.c<span class="fstat-no" title="function not covered" >reat</span>e(<span class="cstat-no" title="statement not covered" >o.prototype,{con</span>structor:{value:r,configurable:!0,writa<span class="fstat-no" title="function not covered" >ble:</span>!0}<span class="cstat-no" title="statement not covered" >}),r.prototype.nam</span>e="<span class="cstat-no" title="statement not covered" ></span>HttpError",Obje</span>ct.de<span class="cstat-no" title="statement not covered" >finePro</span>pe<span class="cstat-no" title="statement not covered" >rties(r</span>.p<span class="cstat-no" title="statement not covered" >ro<span class="cstat-no" title="statement not covered" ></span>totype,{statusCode:i("code"),statusMessage:i("message"),status:{configurable:!0,get:function(){return this.code},set:function(e){Object.defineProperty(this,"status",{value:e,configurable:!0,enumerable:!0,writable:!0})}}}),r.prototype.toString=function(){return this.n<span class="fstat-no" title="function not covered" >ame+</span>":<span class="cstat-no" title="statement not covered" > "+this.code+" "+t</span>his.message};for(var u in a){var l=a[u]<span class="fstat-no" title="function not covered" >;t[l</span>.re<span class="cstat-no" title="statement not covered" >place("'","").replace(/[- ]/g,"_").toUpperCase()]=+u}},function(e,t){function n(e,t){if(e&amp;</span>&amp;"object"==typeof e?(t=e,<span class="fstat-no" title="function not covered" >e=</span>void 0):t<span class="cstat-no" title="statement not covered" >his.message=e,t)for(var n in t)this[n]=t[n];r.call</span>(<span class="cstat-no" title="statement not covered" >t</span>his,"name")||(this.na<span class="cstat-no" title="statement not covered" >me=r.<span class="cstat-no" title="statement not covered" ></span>call(i(this),"name")?this.name:this.constructor.name),!o||"s</span>t</span>a<span class="fstat-no" title="function not covered" >ck</span>"in this||o(this,this<span class="fstat-no" title="function not covered" >.c</span>onstr<span class="cstat-no" title="statement not covered" >uctor)}var r=Object.hasOwnProperty,i=Object.getPrototypeO<span class="cstat-no" title="statement not covered" >f,o=Error.captu<span class="cstat-no" title="statement not covered" >reStackTrace;<span class="cstat-no" title="statement not covered" >e</span></span></span>.exports=n,n.prototype=Object.create(Error.prototype,{constructor:{value:n,configurable:!0,writable:!0}}),n.prototype.name="StandardE</span>rror"}<span class="cstat-no" title="statement not covered" >,function(e,t){e.expor</span>ts<span class="cstat-no" title="statement not covered" >={100:"Continue",101:"</span>Sw<span class="cstat-no" title="statement not covered" >itching Protocols",102:"<span class="cstat-no" title="statement not covered" ></span>Processing",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Conte</span>n<span class="fstat-no" title="function not covered" >t"</span>,207:"Multi-<span class="cstat-no" title="statement not covered" >Status",208:"Already Reported",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",308:"Permanent Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",416:"Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Unordered Collection",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",508:"Loop Detected",509:"Bandwidth Limit Exceeded",510:"Not Extended",511:"Network Authentication Required"}},function(e,t,n){"use strict";function r(e,t){this.webClient=e,this.config=t||i}e.exports=r;var i=n(151);r.prototype.currentUser=function(){if("undefined"==typeof window)return null;var e=window.location.href;retur</span>n<span class="fstat-no" title="function not covered" > t</span>his.login(e).catch(function(e){retur<span class="fstat-no" title="function not covered" >n </span>conso<span class="cstat-no" title="statement not covered" >le.log("Detecting current user fail<span class="cstat-no" title="statement not covered" ></span>ed: %o",e),nu</span>ll})}<span class="cstat-no" title="statement not covered" >,r.prot<span class="cstat-no" title="statement not covered" ></span>otype.listen=function(){<span class="fstat-no" title="function not covered" >va</span>r e=new P<span class="cstat-no" title="statement not covered" >romise(function(e,t){var n=win<span class="cstat-no" title="statement not covered" >dow.addEventL</span></span>isten<span class="cstat-no" title="statement not covered" >er?"addEventListener"<span class="cstat-no" title="statement not covered" ></span>:"attachEvent",r=window[n],<span class="fstat-no" title="function not covered" >i=</span>"attachEve<span class="cstat-no" title="statement not covered" >nt"===n?"onmessage":"message";r(i,function(n){var r=n.data;if("U</span>ser</span>:"===r.slice(0,5)){v<span class="fstat-no" title="function not covered" >ar</span> i=r.slice(5,r.<span class="cstat-no" title="statement not covered" >length);retu<span class="fstat-no" title="function not covered" >rn</span> i&amp;&amp;i.length&gt;0&amp;&amp;"h<span class="cstat-no" title="statement not covered" >ttp"===i.slice(0,4)?e(i):t(i)}},!0)});return e},r.prototy</span>pe<span class="cstat-no" title="statement not covered" >.login=fun</span>ct<span class="cstat-no" title="statement not covered" >ion(e,t){var n=this.config.authEndpoint;<span class="cstat-no" title="statement not covered" ></span>e=e|<span class="fstat-no" title="function not covered" >|w</span>indow.location.o<span class="cstat-no" title="statement not covered" >rigin+w<span class="cstat-no" title="statement not covered" ></span>indow.location.pathname,t=t||n;va<span class="cstat-no" title="statement not covered" >r r=this.webClient;r<span class="cstat-no" title="statement not covered" ></span>eturn r.head(e).then(function(e){return e.isLoggedIn()?</span>e</span>.user:</span>r.<span class="cstat-no" title="statement not covered" ></span>head(t).th</span>en(function(e){retu<span class="fstat-no" title="function not covered" >rn</span> e.user})})},r.pro<span class="cstat-no" title="statement not covered" >totype.signup=function(e)<span class="cstat-no" title="statement not covered" ></span>{e=e||this.config.signupEndpoint;var t=this.config.signupWind</span>owWid<span class="cstat-no" title="statement not covered" >th,n=this.confi<span class="cstat-no" title="statement not covered" ></span>g.signupWindowHeight,r<span class="fstat-no" title="function not covered" >=w</span>indow.scre<span class="cstat-no" title="statement not covered" >en.width/2-(t/2+10),i=window.screen.height/2<span class="fstat-no" title="function not covered" >-(</span>n/2+50),o=<span class="cstat-no" title="statement not covered" >"Solid signup",</span>a=e</span>+"?</span>origin="+encodeURICo<span class="fstat-no" title="function not covered" >mp</span>onent(wind<span class="cstat-no" title="statement not covered" >ow.location.origin),s="resizable,</span>scrol<span class="cstat-no" title="statement not covered" >lbars,status,width="+t+",heigh</span>t=<span class="cstat-no" title="statement not covered" >"+n+",left="+r+",top="+i;window</span>.o<span class="cstat-no" title="statement not covered" >pen(a,o,s);var u=this;return ne</span>w <span class="cstat-no" title="statement not covered" >Promise(function(e){u.listen().t</span>he<span class="cstat-no" title="statement not covered" >n(function(t){r</span>et<span class="cstat-no" title="statement not covered" >urn e(t)})})}},function(e,t){"use strict";e.exports={aut</span>hE<span class="cstat-no" title="statement not covered" >ndpoint:"https://databox.me/",signupEndpoint:"https://solid.github.io/sol<span class="cstat-no" title="statement not covered" ></span>id-idps/",signupWind</span>owHei<span class="cstat-no" title="statement not covered" >ght:6<span class="cstat-no" title="statement not covered" ></span>00,signupWindowWidt<span class="fstat-no" title="function not covered" >h:</span>1024}},fun<span class="cstat-no" title="statement not covered" >ction(e,t,n){"us<span class="fstat-no" title="function not covered" >e </span>strict";fu<span class="cstat-no" title="statement not covered" >nction r(e,t,</span>n){</span>ret</span>ur</span>n<span class="fstat-no" title="function not covered" > t</span>.options(e).then(function<span class="cstat-no" title="statement not covered" >(e){var n=e.metaAbsoluteUrl();if(!n)throw new Error("Could not find a meta URL in the Link header");return t.get(n)}).then(function(t){var r=t.pars</span>e<span class="fstat-no" title="function not covered" >dG</span>raph(),i=r.any(void 0,n.solid("accou<span class="fstat-no" title="function not covered" >nt</span>"));if(<span class="cstat-no" title="statement not covered" >!i||!i.uri)throw new Erro<span class="fstat-no" title="function not covered" >r(</span>"Could not find <span class="cstat-no" title="statement not covered" >a WebID matching the<span class="cstat-no" title="statement not covered" ></span> domai<span class="cstat-no" title="statement not covered" >n "+e);return i})}function i(e,t,n,r){return t=t||{},t.headers=t<span class="cstat-no" title="statement not covered" >.</span></span>headers||{Accept</span>:"text/<span class="fstat-no" title="function not covered" >tu</span>rtle"},t.noCrede<span class="cstat-no" title="statement not covered" >ntials=!0,n.get(</span>e,<span class="cstat-no" title="statement not covered" >t).then(function(e){var i=e.parse<span class="cstat-no" title="statement not covered" ></span>dGraph(),s=new<span class="cstat-no" title="statement not covered" > a(e.url,i,r,n,e);return s.isLoaded=!0,t.ignoreExtended?s:o(s,t,n<span class="cstat-no" title="statement not covered" >)</span></span>})}functi</span>on </span>o(e,t,n){<span class="fstat-no" title="function not covered" >va</span>r r=e.rel<span class="cstat-no" title="statement not covered" >atedProfilesLinks();return n.loadParsedGraphs(r,t).then(function(t){return t.forEach(function(<span class="fstat-no" title="function not covered" >t)</span>{t&amp;&amp;t.value&amp;&amp;e.a<span class="cstat-no" title="statement not covered" >ppendFromGraph(t</span>.v<span class="cstat-no" title="statement not covered" >alue,t.uri)}),e})}e.e<span class="cstat-no" title="statement not covered" ></span>xports.discoverWebID=r,e.exports.getProfile=i,e.ex</span>por</span>ts.loadEx<span class="fstat-no" title="function not covered" >te</span>ndedProfile=o<span class="cstat-no" title="statement not covered" >;var a=n(153)},function(e<span class="cstat-no" title="statement not covered" ></span>,t,n){"use strict";function r(e,t,n,<span class="fstat-no" title="function not covered" >r,</span>i){this.ap<span class="cstat-no" title="statement not covered" >pRegistryListed={<span class="fstat-no" title="function not covered" >ur</span>i:null,gra<span class="cstat-no" title="statement not covered" >ph:null},this.appRegistryUnlisted={uri:null,gr</span>aph:n</span>ull<span class="cstat-no" title="statement not covered" ></span>},this.inbox={uri:null,graph:null},this.isLoaded=!1,this.picture=null,this.name=nu</span>ll,th<span class="cstat-no" title="statement not covered" >is.rdf=</span>n,<span class="fstat-no" title="function not covered" >th</span>is.storage=[],this.typeIndexListed={<span class="fstat-no" title="function not covered" >ur</span>i:null,grap<span class="cstat-no" title="statement not covered" >h:null},this.typeIndexUnlisted={uri:null,graph:null},this.parsedGraph=null,this.preferences={uri:null,graph:null},this.response=i,this.relatedProfiles={sameAs:[],seeAlso:[]},this.webId=null,this.webClient=r,e&amp;&amp;(this.baseProfileUrl=e.indexOf("#")&gt;=0?e.slice(0,e.indexOf("#")):e,t&amp;&amp;(this.initWebId(t),this.appendFromGraph(t,this.baseProfileUrl)))}function i(e,t,n){var r=s(n),i=n.namedNode(e),o=r.foaf("primaryTopic"),a=t.any(i,o);return a}function o(e,t,n,r,i){var o=e.any(t,n,r,i);return o?o.uri:null}e.exports=r;var a=n(154),s=n(158),u=n(159),l=n(162),c=n(160),f=c.parseLinks,h="/se</span>ttings/pr<span class="fstat-no" title="function not covered" >ef</span>s.ttl",d="/pr<span class="cstat-no" title="statement not covered" >ofile</span>/"<span class="cstat-no" title="statement not covered" >;r.prototype.ap</span>pe<span class="cstat-no" title="statement not covered" >ndFromGraph=function(e,</span>t)<span class="cstat-no" title="statement not covered" >{if(e){var <span class="cstat-no" title="statement not covered" ></span>n=this.rdf</span>,r=s(n);t<span class="fstat-no" title="function not covered" >hi</span>s.parsedGraph=thi<span class="cstat-no" title="statement not covered" >s.parsedGraph||<span class="cstat-no" title="statement not covered" ></span>n.graph(),c.appendGra<span class="cstat-no" title="statement not covered" ></span>ph(this.parse</span>dGrap<span class="cstat-no" title="statement not covered" >h,e,t);</span>va<span class="cstat-no" title="statement not covered" >r i,a=n</span>.n<span class="cstat-no" title="statement not covered" >amedNod</span>e(<span class="cstat-no" title="statement not covered" >this.we</span>bI<span class="cstat-no" title="statement not covered" >d);this</span>.n<span class="cstat-no" title="statement not covered" >ame||(this.na</span>me<span class="cstat-no" title="statement not covered" >=this.find(r.foaf("nam</span>e"<span class="cstat-no" title="statement not covered" >))),this.pic<span class="cstat-no" title="statement not covered" ></span>ture||(this.picture=this.fin<span class="fstat-no" title="function not covered" >d(</span>r.foaf("img"<span class="cstat-no" title="statement not covered" >))),i=f(e,nu<span class="cstat-no" title="statement not covered" >ll,r.owl(</span>"s<span class="cstat-no" title="statement not covered" >ameAs<span class="cstat-no" title="statement not covered" ></span>")),this.relatedProfiles.sameAs=this.relatedProfiles.sameAs.concat(i),i=f(e,null,r</span>.rdfs("<span class="cstat-no" title="statement not covered" >seeAlso")),this.relatedP<span class="cstat-no" title="statement not covered" ></span>rofiles.seeAlso=this.relatedProfiles.seeAlso.concat(i),this.preferences.uri||(this.preferences.uri=o(e,a,r.pim("preferencesFile"))),this.inbox.uri||(this.inbox.uri=o(e,a,r.solid("inbox"))),i=f(e,a,r.pim("storage")),this.storage=this.storage.concat(i),this.typeIndexListed.uri||(this.typeIndexListed.uri=o(e,a,r.solid("publicTypeIndex"))),this.typeIndexUnlisted.uri||(this.typeIndexUnlisted.uri=o(e,a,r.solid("privateTypeIndex"))),this.appRegistryListed.uri||(this.appRegistryListed.uri=o(e,a,r.solid("publicAppRegistry"))),this.appRegistryUnlisted.uri||(this.appRegistryUnlisted.uri=o(e,a,r.solid("privateAppRegistry")))}},r.prototype.appRegistryDefaultContainer=function(){var e,t=this.webId||this.baseProfileUrl;return e=t?t.replace(/\\/g,"/").replace(/\/[^\/]*\/?$/,"")+"/":d},r.prototype.appsForType=function(e){return a.appsForType(this,e,this.rdf)},r.proto</span>t</span>ype.find=function(e){if(!this.parsedGraph<span class="fstat-no" title="function not covered" >)t</span>hrow new Error("P<span class="cstat-no" title="statement not covered" >rofile graph not yet loaded.");v<span class="cstat-no" title="statement not covered" ></span>ar t=this.rdf.namedNode(this.webId),n=this.parsedGraph.any(t,e);re</span>turn n?n.value||n.uri:n},<span class="fstat-no" title="function not covered" >r.</span>prototype.<span class="cstat-no" title="statement not covered" >findAll=function(e){if(!this.parsedGrap</span>h)throw new Error(<span class="fstat-no" title="function not covered" >"P</span>rofile gra<span class="cstat-no" title="statement not covered" >ph not yet loaded.");<span class="cstat-no" title="statement not covered" >var t=this.rdf.namedNode(this.webId),n=this.parsed</span></span>Graph<span class="cstat-no" title="statement not covered" >.statementsMatching(t,e);return</span> n<span class="cstat-no" title="statement not covered" >=n.map(function(e){return <span class="cstat-no" title="statement not covered" ></span>e.object.value||e.object.ur</span>i}),n.sort()},r.proto<span class="fstat-no" title="function not covered" >ty</span>pe.initWeb<span class="cstat-no" title="statement not covered" >Id=function(e){if(e)t<span class="cstat-no" title="statement not covered" >ry{this.webId=i(this.baseProfileUrl,e,this.rdf).ur</span></span>i}cat<span class="cstat-no" title="statement not covered" >ch(e){throw new Error("Unable t</span>o <span class="cstat-no" title="statement not covered" >parse WebID from profile: "+e)}},r.protot<span class="cstat-no" title="statement not covered" ></span>ype.relatedProf<span class="fstat-no" title="function not covered" >il</span>esLinks=fu<span class="cstat-no" title="statement not covered" >nction(){var e=[];return e=e.concat(t</span>his.relatedP</span>rofiles.sameAs).concat(<span class="fstat-no" title="function not covered" >th</span>is.related<span class="cstat-no" title="statement not covered" >Profi<span class="cstat-no" title="statement not covered" >les.<span class="cstat-no" title="statement not covered" >seeAlso),this.preferences.uri&amp;&amp;(e=e.concat(this.pr</span>eferences<span class="cstat-no" title="statement not covered" >.uri)),e},r.prototype.hasAppRegistryPrivate=function(){if(!</span>t</span></span>his.isLoaded)throw new Error("Must<span class="fstat-no" title="function not covered" > l</span>oad profile bef<span class="cstat-no" title="statement not covered" >ore<span class="cstat-no" title="statement not covered" ></span> checking if registry exists.");return this.appRegistryUnlisted.uri},r.prototype.hasAppRegistryPublic=function(){if(!this.isLoaded)throw new Err</span>or("Must load profile before checki<span class="fstat-no" title="function not covered" >ng</span> if regis<span class="cstat-no" title="statement not covered" >try exists.");retu<span class="cstat-no" title="statement not covered" >rn this.appRegistryListed.uri},r.prototype.hasStorage=function(){return t<span class="cstat-no" title="statement not covered" >h</span></span>is.storage&amp;&amp;this.storage.length&gt;0},r</span>.prototype.hasTypeRegistryPrivate=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.isLoaded)<span class="cstat-no" title="statement not covered" >throw new Error("Must load profile before checking if registry exists.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.typeIndexUnlisted.uri},</span>r.prototype.hasTypeRegis<span class="fstat-no" title="function not covered" >tr</span>yPublic=f<span class="cstat-no" title="statement not covered" >unction(){if(!this.isLoaded)throw new Error(</span>"Must load profile before checking i<span class="fstat-no" title="function not covered" >f </span>registry <span class="cstat-no" title="statement not covered" >exists.");return t<span class="cstat-no" title="statement not covered" >his.typeIndexListed.uri},r.prototype.loadAppRegistry=function(e,t){return<span class="cstat-no" title="statement not covered" > </span></span>e=e||this.webClient,a.loadAppRegis</span>try(this,e,t)},r.prototype.loadType<span class="fstat-no" title="function not covered" >Re</span>gistry=fu<span class="cstat-no" title="statement not covered" >nction(e,t){return<span class="cstat-no" title="statement not covered" > e=e||this.webClient,l.loadTypeRegistry(this,e,t)},r.prototype.addAppRegi<span class="cstat-no" title="statement not covered" >s</span></span>try=function(e,t){if(u.isListed(</span>e,this.rdf))this.appRegistryL<span class="fstat-no" title="function not covered" >is</span>ted.graph||(<span class="cstat-no" title="statement not covered" >this.appRegistryListed.uri=t,this.appRegistryListed.grap</span>h=e);else{if(!u.isUnlisted(e,t<span class="fstat-no" title="function not covered" >hi</span>s.rdf))throw<span class="cstat-no" title="statement not covered" > console.log(e),new Error("Attempting to add an invalid a</span>pp registry resource");this.<span class="fstat-no" title="function not covered" >ap</span>pRegistryUnl<span class="cstat-no" title="statement not covered" >isted.graph||(this.appRegi<span class="cstat-no" title="statement not covered" >stryUnlisted.uri=t,this.appRegistryUnlisted.graph=e)}},r.prototype.addTypeRegistry=function(e</span>,t){<span class="cstat-no" title="statement not covered" >if(u.isListed(e,this.rdf))thi<span class="cstat-no" title="statement not covered" >s.typeIndexListed.graph||(this.typeIndexListed.uri=t,this.typeIndexListed.graph=e);el<span class="cstat-no" title="statement not covered" >s</span></span>e{if(!u.isUnlisted(e,this.rdf))throw new Error("Attempting to add an invalid type registry index")</span>;</span>this.typeIndexUnlisted.graph|<span class="fstat-no" title="function not covered" >|(</span>this.typeInd<span class="cstat-no" title="statement not covered" >exUnlisted.uri=t,this.type<span class="cstat-no" title="statement not covered" >IndexUnlisted.graph=e)}},r.prototype.reloadAppRegistry=function(e){return this.resetApp</span>Regi<span class="cstat-no" title="statement not covered" >stry(),this.loadAppRegistry(e<span class="cstat-no" title="statement not covered" >)},r.prototype.reloadTypeRegistry=function(e){return this.resetTypeR<span class="cstat-no" title="statement not covered" >e</span></span>gistry(),this.loadTypeRegistry(e)},r.prototype.resetAppRegistry=function(){this.appRegistryL</span>i</span>sted.graph=null,this.appRegistr<span class="fstat-no" title="function not covered" >yU</span>nlisted.gr<span class="cstat-no" title="statement not covered" >aph=null},r.prototype.resetTypeRegistry=function(){this.</span>typeIndexListed.graph=null,this.<span class="fstat-no" title="function not covered" >ty</span>peIndexUnl<span class="cstat-no" title="statement not covered" >isted.graph=null},r.prototype.typeRegistryForClass=functio</span>n(e){return l.typeRegistryForC<span class="fstat-no" title="function not covered" >la</span>ss(this,e<span class="cstat-no" title="statement not covered" >,this.rdf)},r.prototype.typeRegistryDefaultContainer=function(){var e,t</span>=this.webId||this.baseProfileUr<span class="fstat-no" title="function not covered" >l;</span>return e=<span class="cstat-no" title="statement not covered" >t?t.replace(/\\/g,"/").replace(/\/[^\/]*\/?$/,"")+"/":d},r.prototyp</span>e.privateProfileUri=function(){ret<span class="fstat-no" title="function not covered" >ur</span>n this.pre<span class="cstat-no" title="statement not covered" >ferences&amp;&amp;this.preferences.uri?this.preferences.</span>uri:h},r.prototype.registerApp=function(e,<span class="fstat-no" title="function not covered" >t)</span>{return t=t||this<span class="cstat-no" title="statement not covered" >.webClient,a.registerApp(this,e,<span class="cstat-no" title="statement not covered" ></span>t)},r.prototype.registerType=function(e,t,n,r){return l.registerTy</span>pe(this,e,t,n,r,this.webClient)<span class="fstat-no" title="function not covered" >},</span>r.prototy<span class="cstat-no" title="statement not covered" >pe.unregisterType=function(e,t,n){return l.unregisterType(this,e,t,n,t</span>his.webClient)}},function<span class="fstat-no" title="function not covered" >(e</span>,t,n){"use s<span class="cstat-no" title="statement not covered" >trict";function r(e,t,n){var r,i;if(t.isListed?(r=e.</span>appRegistryListed.uri,i=e.<span class="fstat-no" title="function not covered" >ap</span>pRegistryListed.<span class="cstat-no" title="statement not covered" >graph):(r=e.appRegistryUnlisted.uri,i=e.appRegistryU</span>nlisted.graph),!r)throw new <span class="fstat-no" title="function not covered" >Er</span>ror("Cannot re<span class="cstat-no" title="statement not covered" >gister app, registry URL missing");var o=e.rdf,a=[],</span>s=</span>t<span class="fstat-no" title="function not covered" >.r</span>dfStatements(o);return n.patch(r,a,s<span class="fstat-no" title="function not covered" >).</span>then(function(n<span class="cstat-no" title="statement not covered" >){var r=d.graphFromStatements(s,o);return i?d.appendGraph(i,r):e[t.isListed?"appRegistryListed":"appRegistryUnlisted"].graph=r,e})}fu<span class="cstat-no" title="statement not covered" >nction i(e,t,n){var r=[];return r.concat(f(e.appRegistryListed</span></span>.grap<span class="cstat-no" title="statement not covered" >h,t,n)</span>).<span class="cstat-no" title="statement not covered" >con</span>ca<span class="cstat-no" title="statement not covered" >t(f(e.appRegistryUn<span class="cstat-no" title="statement not covered" ></span>listed.graph,t,n))}function<span class="fstat-no" title="function not covered" > o</span>(e){var t=v(e),n<span class="cstat-no" title="statement not covered" >=e.namedNode(""),r=[e.tripl<span class="cstat-no" title="statement not covered" ></span>e(n,t.rdf("type"),t.solid("AppRegistry")),e.triple(n,t.rdf("type"),t.solid("UnlistedDocument"))</span>],i</span>={data:d.<span class="fstat-no" title="function not covered" >se</span>rializeStatem<span class="cstat-no" title="statement not covered" >ent<span class="cstat-no" title="statement not covered" ></span>s(r),graph:d.graphFromStatements(r,e),slug:"privateAppRegistry.ttl",uri:null};return i}functio</span>n a(e){va<span class="fstat-no" title="function not covered" >r </span>t=v(e),n=<span class="cstat-no" title="statement not covered" >e.nam</span>ed<span class="cstat-no" title="statement not covered" >Node(""),r=[e.tr</span>ip<span class="cstat-no" title="statement not covered" >le(n,t.rdf("type"),t.solid("AppRegistry")),e.triple(n,t.rdf("type"),t.solid("ListedDocument"))],i={data:d</span>.s<span class="cstat-no" title="statement not covered" >erializeStatements(r),graph:d.graphFromStatements(r,e),slug:"publicAppRegistry.ttl",uri:null};return i}f<span class="cstat-no" title="statement not covered" ></span>unction s(</span>e,t,n){n=<span class="fstat-no" title="function not covered" >n|</span>|{};var r<span class="cstat-no" title="statement not covered" >=e.rd</span>f,<span class="cstat-no" title="statement not covered" >i=v(r),a=e.appRe</span>gi<span class="cstat-no" title="statement not covered" >stryDefaultContainer(),s=r.namedNode(e.webId),u=o(r);return t.post(a,u.data,u.slug).catch(function(e){t</span>hr<span class="cstat-no" title="statement not covered" >ow new Error("Could not create private registry document:",e)}).then(function(o){u.uri=p.absoluteUrl(g.<span class="cstat-no" title="statement not covered" ></span>hostname(a</span>),o.url);<span class="fstat-no" title="function not covered" >va</span>r l=[r.<span class="cstat-no" title="statement not covered" >triple(s,</span>i.sol<span class="cstat-no" title="statement not covered" >id("pr</span>iv<span class="cstat-no" title="statement not covered" >ateAp</span>pR<span class="cstat-no" title="statement not covered" >egistry"),r.namedNode(u.uri))],c</span>=[<span class="cstat-no" title="statement not covered" >];return t.patch(e.pr</span>iv<span class="cstat-no" title="statement not covered" >atePr<span class="cstat-no" title="statement not covered" ></span>ofileUri(),c,l,n)}).catch(function(e)<span class="fstat-no" title="function not covered" >{t</span>hrow new E<span class="cstat-no" title="statement not covered" >rror("Could not update profile with private registry:"+e)}).then(f</span>unction<span class="fstat-no" title="function not covered" >(t</span>){return e<span class="cstat-no" title="statement not covered" >.appRegistryUnlisted=u,e})}function u(e,t,</span>n){n=<span class="cstat-no" title="statement not covered" >n||{};var r=e.rdf,i=v(r),o=e.appRegistryDefaultContainer(),s=r.</span>na<span class="cstat-no" title="statement not covered" >med<span class="cstat-no" title="statement not covered" ></span>Node(e.webId),u=a(r);return t.post(o,u.data,u</span>.slug).c<span class="fstat-no" title="function not covered" >at</span>ch(functio<span class="cstat-no" title="statement not covered" >n(e){throw new Error("Could not create public registry document:",e)})</span>.then(f<span class="fstat-no" title="function not covered" >un</span>ction(a){u<span class="cstat-no" title="statement not covered" >.uri=p.absoluteUrl(g.hostname(o),a</span>.ur</span>l);var l=<span class="fstat-no" title="function not covered" >[r</span>.triple<span class="cstat-no" title="statement not covered" >(s,i.soli</span>d("pu<span class="cstat-no" title="statement not covered" >blicAp</span>pR<span class="cstat-no" title="statement not covered" >egist</span>ry<span class="cstat-no" title="statement not covered" >"),r.namedNode(u.uri))],c=[];ret</span>ur<span class="cstat-no" title="statement not covered" >n t.patch(e.webId,c,l</span>,n<span class="cstat-no" title="statement not covered" >)}).c<span class="cstat-no" title="statement not covered" ></span>atch(function(e){throw new Error("Cou<span class="fstat-no" title="function not covered" >ld</span> not updat<span class="cstat-no" title="statement not covered" >e profile with public registry:",e)}).then(function(t){return e.a</span>ppRegis<span class="fstat-no" title="function not covered" >tr</span>yListed=u,<span class="cstat-no" title="statement not covered" >e})}function l(e,t,n){n=n||{},n.headers=n.</span>heade<span class="cstat-no" title="statement not covered" >rs||{},n.headers.Accept||(n.headers.Accept="text/turtle");var </span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.appRegistryListed.uri&amp;</span>&amp;r.push(<span class="fstat-no" title="function not covered" >e.</span>appRegistr<span class="cstat-no" title="statement not covered" >yListed.uri),e.appRegistryUnlisted.uri&amp;&amp;r.push(e.appRegistryUnlisted.</span>uri),t.<span class="fstat-no" title="function not covered" >lo</span>adParsedGr<span class="cstat-no" title="statement not covered" >aphs(r,n).then(function(t){retur</span>n t</span>.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(<span class="cstat-no" title="statement not covered" >t){t&amp;&amp;t.value&amp;&amp;e.addAppRegistry(t.value,t.uri)}),e})}function c(e,t,n){if(!e)throw n</span>ew Er<span class="cstat-no" title="statement not covered" >ror<span class="cstat-no" title="statement not covered" ></span>("No profile provided");if(!e.isLoaded)throw new Error("Profile is not loaded");if(!t||!t.isValid())throw new Error("Invalid app registration");return l(e<span class="fstat-no" title="function not covered" >,n</span>).then(fun<span class="cstat-no" title="statement not covered" >ction(e){return t<span class="fstat-no" title="function not covered" >.i</span>sListed&amp;&amp;!<span class="cstat-no" title="statement not covered" >e.hasAppRegistryPublic()?u(e,n):t.isListed||e</span>.hasA</span>ppR</span>egistryPr<span class="fstat-no" title="function not covered" >iv</span>ate()?e<span class="cstat-no" title="statement not covered" >:s(e,n<span class="cstat-no" title="statement not covered" >)}).then(function(e){return r(e,t,n)})}<span class="cstat-no" title="statement not covered" >f</span></span>unction f(e,t,<span class="cstat-no" title="statement not covered" >n){var r,i=v(n),o=[];return e?(e.statemen<span class="cstat-no" title="statement not covered" >t</span></span>sMatching(null,i.ap<span class="cstat-no" title="statement not covered" >p("commonType"),t).forEach(function(t){r=t.s<span class="cstat-no" title="statement not covered" >u</span></span>bject;var i=new h;<span class="fstat-no" title="function not covered" >i.</span>initFromGr<span class="cstat-no" title="statement not covered" >aph(r,e,n),o.push(i)}),o):o}e.exports.addToAppRegistry=r,e.exports.blankPrivateAppRegistry=o,e.expor</span>ts.blan<span class="fstat-no" title="function not covered" >kP</span>ublicAppRe<span class="cstat-no" title="statement not covered" >gistry=a,e.export</span>s.i</span>nitAppReg<span class="fstat-no" title="function not covered" >is</span>tryPrivate=s,e.<span class="cstat-no" title="statement not covered" >expor</span>ts<span class="cstat-no" title="statement not covered" >.in<span class="cstat-no" title="statement not covered" ></span>itAppRegistryPublic=u,e.exports.loadAppRegistry=l,e.exports.appsFor<span class="fstat-no" title="function not covered" >Ty</span>pe=i,e.exp<span class="cstat-no" title="statement not covered" >orts.register</span>App=c<span class="cstat-no" title="statement not covered" >,e.expor<span class="cstat-no" title="statement not covered" ></span>ts.registrationsFromGraph=f;var h=</span>n(155),d<span class="cstat-no" title="statement not covered" ></span>=n(160),p=n(161),v=n(158),g=n(161)},function(e,t,n){"use strict";function r(e,t,n){e=e||{},this.isListed=n,this.name=e.name,this.redirectTemplateUri=e.redirectTemplateUri,this.registrationUri=null,this.shortdesc=e.shortdesc,this.types=t||[]}e.exports=r;var i=n(156),o=n(158),a=n(15</span>9);r.<span class="cstat-no" title="statement not covered" >prototy</span>pe<span class="cstat-no" title="statement not covered" >.hashFr</span>ag<span class="cstat-no" title="statement not covered" >ment=fu</span>nc<span class="cstat-no" title="statement not covered" >tion(){</span>va<span class="cstat-no" title="statement not covered" >r e=i.u</span>ni<span class="fstat-no" title="function not covered" >qu</span>e(this.redirectTemplateUri);return e<span class="fstat-no" title="function not covered" >},</span>r.proto<span class="cstat-no" title="statement not covered" >type.initFromGraph=function(e,t,n){this.registrationUri=e.uri,this.isListed=!!a.isListed(t,n),this.types=[];var r=this,i=o(n);t.statementsMatching(e,i.app("com<span class="cstat-no" title="statement not covered" ></span>monType")).fo</span>rEach<span class="cstat-no" title="statement not covered" >(functi</span>on<span class="cstat-no" title="statement not covered" >(e){r.t</span>yp<span class="cstat-no" title="statement not covered" >es.push<span class="cstat-no" title="statement not covered" ></span>(e.object.uri)});var s;s=<span class="fstat-no" title="function not covered" >t.</span>any(e,i.app("na<span class="cstat-no" title="statement not covered" >me")),s&amp;&amp;(this.name=s.value),s=t.an<span class="cstat-no" title="statement not covered" ></span>y(e,i.app(</span>"shortdesc")),s&amp;&amp;(this.shor<span class="fstat-no" title="function not covered" >td</span>esc=s.value),s<span class="cstat-no" title="statement not covered" >=t.any(e,i.app("redirectTemplateUri")),s&amp;&amp;(this.redirectTemplateUri=s.valu</span>e)},r<span class="cstat-no" title="statement not covered" >.prot</span>ot<span class="cstat-no" title="statement not covered" >ype.i<span class="cstat-no" title="statement not covered" ></span>sValid=function(){return this.name&amp;&amp;this.redirectTem<span class="fstat-no" title="function not covered" >pl</span>ateUri&amp;&amp;th<span class="cstat-no" title="statement not covered" >is.types.length&gt;0},r.prototy</span>pe.</span>rdfSt<span class="cstat-no" title="statement not covered" >atements=function(e){var t=e.namedNode("#"+this.hashFragment()),n=[],r=o(e);return n.push(e.triple(t,r.rdf("type"),r.solid("AppRegistration")),e.triple(t,r.app("name"),this.name),e.trip</span>le(t,r.app("shortdesc<span class="fstat-no" title="function not covered" >")</span>,this.sho<span class="cstat-no" title="statement not covered" >rtdesc),e.triple(t,r.app("redirectTemplateUri"),this.redirectTemp</span>lateUri)),this.types.forEac<span class="fstat-no" title="function not covered" >h(</span>function(i){n.pu<span class="cstat-no" title="statement not covered" >sh(e.triple(t,r.app("commonType"),i))</span>})<span class="cstat-no" title="statement not covered" >,n}</span>},<span class="cstat-no" title="statement not covered" >funct<span class="cstat-no" title="statement not covered" ></span>ion(e,t,n){e.exports=n(157)},function(e,t){function n(e){var t=0;if(0==e.length)return t;for(var n=0;n&lt;e.length;n++){var r=e.charCodeAt(n);t=(t&lt;&lt;5)-t+r,t&amp;=t}return t}function r(e,t){function n(e){var t="0123456789abcdefghijklmnopqrstuv<span class="fstat-no" title="function not covered" >wx</span>yzABCDEFGH<span class="cstat-no" title="statement not covered" >IJKLMNOPQRSTUVWXYZ";return t[e]}t=t||62;var</span> r,i=</span>[]</span>,<span class="fstat-no" title="function not covered" >o=</span>"",a=e&lt;0?"-":"<span class="cstat-no" title="statement not covered" >";for(e=Math.abs(e</span>)<span class="fstat-no" title="function not covered" >;e</span>&gt;=t;)r=e%t,e=Math.flo<span class="fstat-no" title="function not covered" >or</span>(e/t),i.p<span class="cstat-no" title="statement not covered" >us<span class="cstat-no" title="statement not covered" ></span>h(n(r));e&gt;0&amp;&amp;i.<span class="cstat-no" title="statement not covered" >push(n(e)<span class="cstat-no" title="statement not covered" >)</span></span>;for(var s=i.length-1;s&gt;=0;s--)o+<span class="cstat-no" title="statement not covered" >=i[s];return a+o<span class="cstat-no" title="statement not covered" ></span>}function i(e){var <span class="cstat-no" title="statement not covered" ></span>t</span>=r(n(e),6</span>1);return<span class="fstat-no" title="function not covered" > t</span>.replace("-","<span class="fstat-no" title="function not covered" >Z"</span>)}functio<span class="cstat-no" title="statement not covered" >n o(e){for(var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghikl<span class="cstat-no" title="statement not covered" ></span>mnopqrstuvwxy<span class="cstat-no" title="statement not covered" ></span>z",n="",r</span>=e||8,i<span class="cstat-no" title="statement not covered" >=0;</span>i&lt;<span class="cstat-no" title="statement not covered" >r;i</span>++<span class="cstat-no" title="statement not covered" >){var o=Mat<span class="cstat-no" title="statement not covered" ></span>h.floor(Math.random()*t.<span class="cstat-no" title="statement not covered" >length);n+=t.substring(o,o+1)}return <span class="cstat-no" title="statement not covered" >n</span></span>}t.bitwise=n,t.bi<span class="cstat-no" title="statement not covered" >n</span>aryTransfer=r,t.unique=i,t.ra<span class="cstat-no" title="statement not covered" >ndom=o},<span class="cstat-no" title="statement not covered" >f</span></span>unction(e,t</span>,n){"use <span class="fstat-no" title="function not covered" >st</span>rict";fun<span class="cstat-no" title="statement not covered" >ction r(e){<span class="cstat-no" title="statement not covered" ></span>var t=n(144)(e),r={acl:t.ba</span>se("http:<span class="fstat-no" title="function not covered" >//</span>www<span class="cstat-no" title="statement not covered" >.w3.org/ns/auth/acl#"),app:t.base("http://www.w3.org/ns/solid/app#"),cert:t.base("http://www.w3.org/ns/au<span class="cstat-no" title="statement not covered" >th/cert#"),dct:t.base("http://purl.<span class="cstat-no" title="statement not covered" ></span>org/dc/terms/"),foaf:t.<span class="cstat-no" title="statement not covered" ></span>b</span>ase("http<span class="cstat-no" title="statement not covered" ></span>://xmlns.com/foaf/0.1/"),ldp:t.base("http://www.w3.org</span>/<span class="fstat-no" title="function not covered" >ns</span>/ldp#"),owl:t.base("http://www.w3.or<span class="fstat-no" title="function not covered" >g/</span>2002/07/o<span class="cstat-no" title="statement not covered" >wl#"),pim:</span>t.<span class="cstat-no" title="statement not covered" >base("http://www.w3.org/ns/pim/space#"),rdf:t.base("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),rdfs:t.base("http://www.w3.org/2000/01/rdf-schema#"),schema:t.base("http://schema.org/"),sioc:t.base("http://rdfs.org/sioc/ns#"),solid:t.base("http://www.w3.org/ns/solid/terms#"),stat:t.base("http://www.w3.org/ns/posix/stat#"),vcard:t.base("http://www.w3.org/2006/vcard/ns#"),xsd:t.base("http://www.w3.org/2001/XMLSchema#")};return r}e.exports=r},function(e,t,n){"use strict";function r(e,t){var n=o(t);return e.any(null,null,n.solid("UnlistedDocument"),e.uri)}function i(e,t){var n=o(t);return e.any(null,null,n.solid("ListedDocument"),e.uri)}e.exports.isListed=i,e.exports.isUnlisted=r;var o=n(158)},function(e,t){"use strict";function<span class="cstat-no" title="statement not covered" ></span> n(e,t){t.<span class="cstat-no" title="statement not covered" ></span>statementsMat</span>c<span class="fstat-no" title="function not covered" >hi</span>ng(u).forEach(function(t){e.add(t.su<span class="fstat-no" title="function not covered" >bj</span>ect,t.predi<span class="cstat-no" title="statement not covered" >cate,<span class="cstat-no" title="statement not covered" ></span>t.object,t.why)})}function r(e,t){return"string"!=typeof e&amp;</span>&amp;(e=e.toN<span class="fstat-no" title="function not covered" >T(</span>)),t&amp;&amp;e.end<span class="cstat-no" title="statement not covered" >sWith<span class="cstat-no" title="statement not covered" ></span>(".")&amp;&amp;(e=e.slice(0,-1)),e}function i(e,t){var n=t.graph(<span class="cstat-no" title="statement not covered" ></span>);return e.forEach(function(e){n.add(e)}),n}f</span>uncti<span class="cstat-no" title="statement not covered" >on o(e,</span>t,<span class="fstat-no" title="function not covered" >n,</span>r){var i=r.graph();return r.parse(<span class="fstat-no" title="function not covered" >t,</span>i,e,n<span class="cstat-no" title="statement not covered" >),i}function a(e,t,n,r,i){var o=<span class="fstat-no" title="function not covered" >{}</span>,a=e.state<span class="cstat-no" title="statement not covered" >mentsMatching(t,n,r,i);return a.forEach(funct</span>ion</span>(e){o[e.o<span class="fstat-no" title="function not covered" >bj</span>ect.u<span class="cstat-no" title="statement not covered" >ri]=!0}),Object.keys(o)}function s(e){var t=e.map(function(e){return e.toNT()});</span>return t=<span class="fstat-no" title="function not covered" >t.</span>join("\n")}<span class="cstat-no" title="statement not covered" >e.exports.<span class="cstat-no" title="statement not covered" ></span>appendGraph=n,e.e<span class="fstat-no" title="function not covered" >xp</span>orts.parse<span class="cstat-no" title="statement not covered" >Graph=o,e.</span>expor</span>ts.parseL<span class="fstat-no" title="function not covered" >in</span>ks=a,e.exports.<span class="cstat-no" title="statement not covered" >serializeS<span class="cstat-no" title="statement not covered" ></span>tatements=s,e.exports.graph</span>FromState<span class="fstat-no" title="function not covered" >me</span>nts=i,e.exports.s<span class="cstat-no" title="statement not covered" >tat</span>em<span class="cstat-no" title="statement not covered" >entToNT=r;var u=null},function<span class="cstat-no" title="statement not covered" ></span>(e,t,n){"use stri<span class="fstat-no" title="function not covered" >ct</span>";function<span class="cstat-no" title="statement not covered" > r(e,t){var n={};if(</span>e){var r=e.split("</span>,");r.for<span class="fstat-no" title="function not covered" >Ea</span>ch(functi<span class="cstat-no" title="statement not covered" >on(t){<span class="fstat-no" title="function not covered" >t&amp;</span>&amp;e.indexOf<span class="cstat-no" title="statement not covered" >(t)&gt;=0&amp;&amp;(n[t.trim</span>()<span class="cstat-no" title="statement not covered" ></span>.toLowerCase()]=!0)})}r<span class="cstat-no" title="statement not covered" ></span>eturn t&amp;&amp;t.indexOf("application/sparql-update")&gt;=0&amp;&amp;(n.patch=!0),n}function i(e){if(!e)return{};for(var t=/&lt;[^&gt;]*&gt;\s*(\s*;\s*[^\(\)&lt;&gt;@,;:"\/\[\]\?={} \t]+=(([^\(</span>\)&lt;&gt;@<span class="cstat-no" title="statement not covered" >,;:"\</span>/\<span class="fstat-no" title="function not covered" >[\</span>]\?={} \t]+)|("[^"]*")))*(,|$)/g,n=/<span class="fstat-no" title="function not covered" >[^</span>\(\)&lt;&gt;@,;:"<span class="cstat-no" title="statement not covered" >\/\<span class="cstat-no" title="statement not covered" ></span>[\]\?={} \t]<span class="cstat-no" title="statement not covered" >+=(([^\(\)&lt;&gt;@<span class="cstat-no" title="statement not covered" ></span>,;:"\/\[\]<span class="fstat-no" title="function not covered" >\?</span>={} \t]+)|<span class="cstat-no" title="statement not covered" >("[^"]*"))/g,r=e.match(t),i={},o=0;o&lt;r.length;o++)fo</span>r(v<span class="cstat-no" title="statement not covered" ></span>a</span>r a=r[o].split("&gt;"),s=a[0].substring(1),u=a[1],l=u.match(n),c=0;c&lt;l.</span>length;c+<span class="fstat-no" title="function not covered" >+)</span>{va<span class="cstat-no" title="statement not covered" >r f=l[<span class="cstat-no" title="statement not covered" >c],h=f.sp<span class="cstat-no" title="statement not covered" >l</span></span>it("="),d=h[1].replace(/["']/g,"");i[d]||(i[d]=[]),i[d].push(s),i[d].length&gt;1&amp;&amp;i[d].sort()}return i}function o(e){var t,n,r,i,o=e.split("//");return 2===o.length?(t=o[0],n=o[1]):n=e,i=n.split("/"),r=t?t+"//"+i[0]:i[0],e.startsW<span class="cstat-no" title="statement not covered" >ith("//")&amp;&amp;(r="//"+r),r}function a(e,t){return t&amp;&amp;"http"!==t.slice(0,4)?[e,t].map(function(e<span class="cstat-no" title="statement not covered" >){ret</span>ur<span class="cstat-no" title="statement not covered" >n"/"===e[0]&amp;&amp;</span>(e<span class="cstat-no" title="statement not covered" >=e.slice(1)),"/"===e[e.le<span class="cstat-no" title="statement not covered" ></span>ngth-1]&amp;&amp;(e=e.slice(0,e.length-1)),e}).join("/"):t}functi<span class="cstat-no" title="statement not covered" ></span>o</span></span>n s(e,t){</span>var n="",<span class="fstat-no" title="function not covered" >r=</span>!0;return e&amp;&amp;e.le<span class="cstat-no" title="statement not covered" >ngth&gt;0&amp;&amp;(e=e.m<span class="cstat-no" title="statement not covered" ></span>ap(function(e){return u.statementToNT(e,r)}),n+="DELETE DATA { "+e.join(" . ")+" };\n"),t&amp;&amp;t.length&gt;0&amp;&amp;(t=t.ma</span>p(functio<span class="fstat-no" title="function not covered" >n(</span>e){re<span class="cstat-no" title="statement not covered" >turn u.statementToNT(e,r)}),n+="INSERT DAT<span class="fstat-no" title="function not covered" >A </span>{ "+t.join<span class="cstat-no" title="statement not covered" >(" . ")+" };\n"),n}e.exports.composePatchQuery=s,e.exports.parseAllowedMethods=r,e.</span>exports.parseLi</span>nkHeader=<span class="fstat-no" title="function not covered" >i,</span>e.exports.a<span class="cstat-no" title="statement not covered" >bso</span>lu<span class="cstat-no" title="statement not covered" >teU<span class="cstat-no" title="statement not covered" ></span>rl=a,e.exports.hostname=o;var u<span class="fstat-no" title="function not covered" >=n</span>(160)},fun<span class="cstat-no" title="statement not covered" >ction(e,t,n){"use strict";fun</span>ction r(e){var t=e.namedNode(""),n=m(e),r=[e.triple(t,n.rdf("type"),n<span class="fstat-no" title="function not covered" >.s</span>olid("Type<span class="cstat-no" title="statement not covered" >Index")),e.triple(t,n.rdf("ty</span>pe"),n.solid("UnlistedDocument"))],i={data:g.ser<span class="cstat-no" title="statement not covered" ></span>ializeStatements(r),graph:g.graphFromStatements(r,e),slug:"privateTypeIndex.ttl",uri:null};return i}function i(e){var t=e.namedNode(""),</span>n=m(e<span class="cstat-no" title="statement not covered" >),r=[e.</span>tr<span class="fstat-no" title="function not covered" >ip</span>le(t,n.rdf("type"),n.solid("TypeInde<span class="fstat-no" title="function not covered" >x"</span>)),e.trip<span class="cstat-no" title="statement not covered" >le(t,n.rdf("type</span>")<span class="cstat-no" title="statement not covered" >,n.so</span>li<span class="cstat-no" title="statement not covered" >d("ListedDocument"))],i={data:g.serializeStatements(r),graph:g.graphFromStatements(r,e),slug:"publicTyp</span>eI<span class="cstat-no" title="statement not covered" >ndex.ttl",uri:null};return i}function o(e,t,n){n=n||{};var i=t.rdf,o=m(i),a=e.typeRegistryDefaultConta<span class="cstat-no" title="statement not covered" ></span>iner(),s=i</span>.namedNod<span class="fstat-no" title="function not covered" >e(</span>e.webId),<span class="cstat-no" title="statement not covered" >u=r(i);return t.</span>po<span class="cstat-no" title="statement not covered" >st(a,</span>u.<span class="cstat-no" title="statement not covered" >data,u.slug).catch(function(e){throw new Error("Could not create privateIndex document:",e)}).then(fu</span>nc<span class="cstat-no" title="statement not covered" >tion(r){u.uri=v.absoluteUrl(y.hostname(a),r.url);var l=[i.triple(s,o.solid("privateTypeIndex"),i.name<span class="cstat-no" title="statement not covered" ></span>dNode(u.ur</span>i))],c=[]<span class="fstat-no" title="function not covered" >;r</span>eturn t<span class="cstat-no" title="statement not covered" >.patch(e.</span>priva<span class="cstat-no" title="statement not covered" >teProf</span>il<span class="cstat-no" title="statement not covered" >eUri(</span>),<span class="cstat-no" title="statement not covered" >c,l,n)}).catch(function(e){throw </span>ne<span class="cstat-no" title="statement not covered" >w Error("Could not up</span>da<span class="cstat-no" title="statement not covered" >te pr<span class="cstat-no" title="statement not covered" ></span>ofile with private index:"+e)}).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.typeIndexUnlisted=u,e})}function a(e,t,n){n=n||{};var</span> r=t.rd<span class="fstat-no" title="function not covered" >f,</span>o=m(r),a=e<span class="cstat-no" title="statement not covered" >.typeRegistryDefaultContainer(),s=r.namedN</span>ode(e<span class="cstat-no" title="statement not covered" >.webId),u=i(r);return t.post(a,u.data,u.slug).catch(function(</span>e)<span class="cstat-no" title="statement not covered" >{th<span class="cstat-no" title="statement not covered" ></span>row new Error("Could not create publicIndex d</span>ocument:<span class="fstat-no" title="function not covered" >",</span>e)}).then(<span class="cstat-no" title="statement not covered" >function(i){u.uri=v.absoluteUrl(y.hostname(a),i.url);var l=[r.tripl</span>e(s,o.s<span class="fstat-no" title="function not covered" >ol</span>id("public<span class="cstat-no" title="statement not covered" >TypeIndex"),r.namedNode(u.uri))]</span>,c=</span>[];return<span class="fstat-no" title="function not covered" > t</span>.patch(<span class="cstat-no" title="statement not covered" >e.webId,c</span>,l,n)<span class="cstat-no" title="statement not covered" >}).cat</span>ch<span class="cstat-no" title="statement not covered" >(func</span>ti<span class="cstat-no" title="statement not covered" >on(e){throw console.log(e),new Er</span>ro<span class="cstat-no" title="statement not covered" >r("Could not update p</span>ro<span class="cstat-no" title="statement not covered" >file <span class="cstat-no" title="statement not covered" ></span>with public index:",e)}).then(functio<span class="fstat-no" title="function not covered" >n(</span>t){return <span class="cstat-no" title="statement not covered" >e.typeIndexListed=u,e})}function s(e,t,r,i,o,a){var s,u,l=n(1</span>56),c=i<span class="fstat-no" title="function not covered" >.r</span>df,f=m(c),<span class="cstat-no" title="statement not covered" >h=l.unique(t.uri);<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(a?(s=e.typeIndexListed.uri,u=e.typeIndexListed.graph):(s=e.typeIndexUnlisted.uri,u=e.typeIndexUnlisted.graph),!s)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot register type, registry URL missing");v</span></span>ar d,p=<span class="cstat-no" title="statement not covered" >c.namedNode(s+"#"+h);<span class="cstat-no" title="statement not covered" ></span>"instance"===o?d=f.solid("instance"):(d=f.solid("instanceContainer"),r.lastIndexOf("/")!==r.length-1&amp;&amp;(r+="/"));v</span>ar v=<span class="cstat-no" title="statement not covered" >[],</span>y=<span class="cstat-no" title="statement not covered" >[c.triple(p,f.rdf("type"),f.solid("TypeRegistration")),c.triple(p,f.solid("forClass"),t),c.triple(p,d,c.namedNode(r))];<span class="cstat-no" title="statement not covered" ></span>return i.patch(s,v,y).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >g.graphFromStatements(y,c);<span class="cstat-no" title="statement not covered" ></span>return u?g.appendGraph(u,n):e[a?"typeIndexListed":"typeIndexUnlisted"].graph=n,e})</span>}fu</span>nction u(<span class="fstat-no" title="function not covered" >e,</span>t,n){n=<span class="cstat-no" title="statement not covered" >n||{},n.headers=n.headers||{},n.headers.Accept||(n.headers.Accept="text/turtle");var</span> r=[]<span class="cstat-no" title="statement not covered" >;re<span class="cstat-no" title="statement not covered" ></span>turn e.typeIndexListed.uri&amp;&amp;r.push(e.typeIndexListed.uri),e.typeIndexUnlisted.uri&amp;&amp;r.push(e.typeIndexUnlisted.uri),t.loadParsedGraphs(r,n).then(fu<span class="fstat-no" title="function not covered" >nc</span>tion(t){var n=t.<span class="cstat-no" title="statement not covered" >length&amp;&amp;t.reduce(fu<span class="fstat-no" title="function not covered" >nc</span>tion(e,t){re<span class="cstat-no" title="statement not covered" >turn e&amp;&amp;!t.value},!0</span>);if(<span class="cstat-no" title="statement not covered" ></span>n)thr<span class="cstat-no" title="statement not covered" >ow new Error("Could not load any type index");ret<span class="cstat-no" title="statement not covered" >u</span></span>rn t.forEach(fun<span class="fstat-no" title="function not covered" >ct</span>ion(t){t&amp;&amp;<span class="cstat-no" title="statement not covered" >t.value&amp;&amp;e.addTypeRegistry(t.value,t.uri)}),e}</span>)}fun</span>cti</span>on l(e,t,<span class="fstat-no" title="function not covered" >n,</span>r,i,l){if(!e)<span class="cstat-no" title="statement not covered" >throw <span class="cstat-no" title="statement not covered" >new Error("No profile provided");if(!e.<span class="cstat-no" title="statement not covered" >i</span></span>sLoaded)throw <span class="cstat-no" title="statement not covered" >new Error("Profile is not loaded");if(!t|<span class="cstat-no" title="statement not covered" >|</span></span>!n)throw <span class="cstat-no" title="statement not covered" >new Error("Type registration requires type class and location");if(r=r<span class="cstat-no" title="statement not covered" >|</span></span>|"container","container"!==r&amp;&amp;"instance"!==r)throw <span class="cstat-no" title="statement not covered" >new Error("Invalid location type");return<span class="cstat-no" title="statement not covered" > </span></span>u(e,l).then(functi<span class="fstat-no" title="function not covered" >on</span>(e){return<span class="cstat-no" title="statement not covered" > i&amp;&amp;!e.hasTypeRegistryPublic()?a(e,l):i||e.hasTypeRegistryPrivate()?e:o(e,l)}).then(</span>functio<span class="fstat-no" title="function not covered" >n(</span>e){return <span class="cstat-no" title="statement not covered" >s(e,t,n,l,r,i)})}functi</span>on </span>c(e,t,n){<span class="fstat-no" title="function not covered" >va</span>r r=[],i=!0;r<span class="cstat-no" title="statement not covered" >etu</span>rn<span class="cstat-no" title="statement not covered" > r.<span class="cstat-no" title="statement not covered" ></span>concat(f(e.typeIndexListed.graph,t,i,n)).concat(f(e.typeIndexUnlisted.graph,t,!i,n))}function f</span>(e,t,n,r)<span class="fstat-no" title="function not covered" >{v</span>ar i,o,a,s=m(r),u=[];<span class="cstat-no" title="statement not covered" >if(!e</span>)r<span class="cstat-no" title="statement not covered" >etu<span class="cstat-no" title="statement not covered" ></span>rn u;v<span class="cstat-no" title="statement not covered" >ar l=e.sta</span></span>temen<span class="cstat-no" title="statement not covered" >tsMatching(null,null,t);return l.f<span class="cstat-no" title="statement not covered" ></span>orEach(function(r<span class="fstat-no" title="function not covered" >){</span>i=r.subjec<span class="cstat-no" title="statement not covered" >t,o=e.statementsMatching(i,s.solid("instance")),o.forEach(function(e<span class="fstat-no" title="function not covered" >){</span>u.push(new<span class="cstat-no" title="statement not covered" > p(i.uri,t,"instance",e.object.uri,n))}),a=e.state</span>mentsMatching(i,s.solid("instanceContainer")),a.forEach(function(e)<span class="fstat-no" title="function not covered" >{u</span>.push(new <span class="cstat-no" title="statement not covered" >p(i.uri,t,"container",e.object.uri,n))})}),u}functi</span>on </span>h(e,t</span>,n,r,i){v<span class="fstat-no" title="function not covered" >ar</span> o,a,s=n.rdf;if(r?(o=<span class="cstat-no" title="statement not covered" >e.type<span class="cstat-no" title="statement not covered" ></span>IndexListed.uri,a=e.typeIndexListed.graph):(o=e.typeIndexUnlisted.uri,a=e.typeIndexUnlisted.graph),!o)throw new Erro<span class="cstat-no" title="statement not covered" >r("Cannot unregister type, registry URL missing");var u=f(a,t,r,s</span></span>);if(<span class="cstat-no" title="statement not covered" >0===u.lengt<span class="cstat-no" title="statement not covered" ></span>h)return Promise<span class="cstat-no" title="statement not covered" >.resolve(e);i&amp;&amp;(u=u.filter<span class="cstat-no" title="statement not covered" >(</span></span>function(e){re<span class="fstat-no" title="function not covered" >tu</span>rn e.locat<span class="cstat-no" title="statement not covered" >ionUri===i}));var l=[];u.f</span>orEa</span>ch(fu<span class="cstat-no" title="statement not covered" >nct<span class="cstat-no" title="statement not covered" ></span>ion(e){a.s<span class="fstat-no" title="function not covered" >ta</span>tementsMat<span class="cstat-no" title="statement not covered" >ching(s.namedNode(e.registrationUri)).forEach(function(e){l.p<span class="fstat-no" title="function not covered" >us</span>h(e)})});v<span class="cstat-no" title="statement not covered" >ar c=[];ret</span>urn</span> n.</span>patch<span class="cstat-no" title="statement not covered" >(o,<span class="cstat-no" title="statement not covered" ></span>l,c).then(function(t){retur<span class="fstat-no" title="function not covered" >n </span>e.reloadTy<span class="cstat-no" title="statement not covered" >peRegistry(n)})}function d(e,t,n</span>,r,</span>i){if(!e)<span class="fstat-no" title="function not covered" >th</span>row new Err<span class="cstat-no" title="statement not covered" >or("No<span class="cstat-no" title="statement not covered" > profile provided");if(!e.isLoaded)thro<span class="cstat-no" title="statement not covered" >w</span></span> new Error("Pr<span class="cstat-no" title="statement not covered" >ofile is not loaded");if(!t)throw new Err<span class="cstat-no" title="statement not covered" >o</span></span>r("Un<span class="cstat-no" title="statement not covered" >registering a type requires type class");return u(e,i).then(<span class="cstat-no" title="statement not covered" >f</span></span>unction(e){if(n&amp;&amp;!<span class="fstat-no" title="function not covered" >e.</span>typeIndexL<span class="cstat-no" title="statement not covered" >isted.graph)throw new Error("Pr<span class="cstat-no" title="statement not covered" >ofile has no Listed type index");if(!n&amp;&amp;!e.typeIndex<span class="cstat-no" title="statement not covered" >U</span></span>nlisted.graph)throw new Error("Pr<span class="cstat-no" title="statement not covered" >ofile has no Unlisted type index");return h(e,t,i,n,r)<span class="cstat-no" title="statement not covered" >}</span></span>)}e.exports.addToTyp</span>eIn<span class="cstat-no" title="statement not covered" ></span>dex=s,e.exports.blankPrivateTypeIndex=r,e.exports.blankPublicTypeIndex=i,e.exports.initTypeRegistryPrivate=o,e.exports.initTypeRegistryPublic=a,e.exports.loadTypeRegistry=u,e.exports.registerType=l,e.exports.typeRegistryForClass=c,e.exports.unregisterType=d;var p=n(163),v=n(161),</span>g=n(1<span class="cstat-no" title="statement not covered" >60),y=n</span>(1<span class="cstat-no" title="statement not covered" >61),m=n</span>(1<span class="cstat-no" title="statement not covered" >58)},fu</span>nc<span class="cstat-no" title="statement not covered" >tion(e,</span>t)<span class="cstat-no" title="statement not covered" >{"use s</span>tr<span class="fstat-no" title="function not covered" >ic</span>t";function n(e,t,n,r,i){this.isLi<span class="fstat-no" title="function not covered" >st</span>ed=i,this.l<span class="cstat-no" title="statement not covered" >ocationType=n,this.locationUri=r,this.rdfClass=t,this.registrationUri=e}e.exports=n,n.prototype<span class="cstat-no" title="statement not covered" ></span>.isContainer=function(){return"conta<span class="fstat-no" title="function not covered" >in</span>er"===thi<span class="cstat-no" title="statement not covered" >s.locationType},n.prototype.isInstance=</span>function(){return"instan<span class="fstat-no" title="function not covered" >ce</span>"===this.<span class="cstat-no" title="statement not covered" >locationType}},function(e,t,n){"use st</span>ri</span>c<span class="fstat-no" title="function not covered" >t"</span>;function r(e,t){var n;return t.head<span class="fstat-no" title="function not covered" >(e</span>).then(func<span class="cstat-no" title="statement not covered" >tion(e){if(n=e.aclAbso<span class="fstat-no" title="function not covered" >lu</span>teUrl(),!n<span class="cstat-no" title="statement not covered" >)throw new Error("ACL URL n<span class="cstat-no" title="statement not covered" >ot found for resource.");return t.del(n)})}function<span class="cstat-no" title="statement not covered" > </span></span>i(e,t,n){var r,i</span>;re</span>turn t.he<span class="fstat-no" title="function not covered" >ad</span>(e).then(functi<span class="cstat-no" title="statement not covered" >on(a){if(r=a.aclAbsolu<span class="fstat-no" title="function not covered" >te</span>Url(),!r)t<span class="cstat-no" title="statement not covered" >hrow new Error("ACL URL not<span class="cstat-no" title="statement not covered" > found for resource.");return i=new o(e,r,a.isConta<span class="cstat-no" title="statement not covered" >i</span></span>ner(),{rdf:n,webClient:t}),t.get(r).then(function(e){return e.parsedG<span class="fstat-no" title="function not covered" >ra</span>ph()})}).t<span class="cstat-no" title="statement not covered" >hen(function(e){return i</span>.in</span>itFromG<span class="fstat-no" title="function not covered" >ra</span>ph(e),i})}<span class="cstat-no" title="statement not covered" >var o=n(165),a=n(166),s=n(167</span>);e</span>.expor<span class="cstat-no" title="statement not covered" >ts.clea</span>rP<span class="cstat-no" title="statement not covered" >ermissi</span>on<span class="cstat-no" title="statement not covered" >s=r,e.e<span class="cstat-no" title="statement not covered" ></span>xports.getPermissions=i,e.exports.PermissionSet=o,e.exports.Authorization=a,Object.assign(e.exports,s.acl)},function(e,t,n){"use strict";fun</span>c<span class="fstat-no" title="function not covered" >ti</span>on r(e,t){if(!(e instanceof t))throw<span class="fstat-no" title="function not covered" > n</span>ew Ty<span class="cstat-no" title="statement not covered" >peError("Cannot call <span class="cstat-no" title="statement not covered" >a class as a function")}function i(e){return o(e)?e:e+h}fu</span></span>nction o(<span class="fstat-no" title="function not covered" >e)</span>{re<span class="cstat-no" title="statement not covered" >turn e.endsWith(h)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >return"string"==typeof</span> e?e.star<span class="fstat-no" title="function not covered" >ts</span>Wit<span class="cstat-no" title="statement not covered" >h("mailto:"):e.object.value.startsWith("mailto:")}var s=function(){function e(e,t){for(</span>var n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >0;</span>n&lt;t.length;n++){va<span class="fstat-no" title="function not covered" >r </span>r=t[n<span class="cstat-no" title="statement not covered" >];r.enumerable=r.enumerable||!1,r.<span class="cstat-no" title="statement not covered" >confi<span class="cstat-no" title="statement not covered" ></span>gurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.</span>p<span class="cstat-no" title="statement not covered" ></span>rototyp<span class="fstat-no" title="function not covered" >e,</span>n),r&amp;&amp;e(t,r),t<span class="cstat-no" title="statement not covered" >}}(),u=n(166),l=n(167),c=l.acl,f=n(158),</span>h=</span>".a</span>cl<span class="cstat-no" title="statement not covered" >",d="te</span>xt<span class="cstat-no" title="statement not covered" >/turtle</span>",<span class="cstat-no" title="statement not covered" >p="res</span>ou<span class="cstat-no" title="statement not covered" >rce",v=</span>"c<span class="cstat-no" title="statement not covered" >ontaine</span>r"<span class="cstat-no" title="statement not covered" >,g="agents",y=</span>"g<span class="cstat-no" title="statement not covered" >roups",m=fu</span>nc<span class="cstat-no" title="statement not covered" >tion(){funct</span>io<span class="cstat-no" title="statement not covered" >n e(t,n,a</span>){<span class="cstat-no" title="statement not covered" >var s=arg</span>um<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >en</span>ts.length&lt;=3||void<span class="fstat-no" title="function not covered" > 0</span>===arguments[<span class="cstat-no" title="statement not covered" >3]?{}:arguments[3];r(this,e),this.authorizations={},this.ac<span class="cstat-no" title="statement not covered" ></span>lUrl=n,this.host=s.host,this.index={agents:{},groups:{}},this.rdf=s.rdf,this.resourceType=a?v:p,this.resourceUrl=t,this.strictOrigin=s.strictOrigin,this.origin=s.origin,this.webClient=s.webClient,this.aclUrlFor=s.aclUrlFor?s.aclUrlFor:i,this.aclUrlFor.bind(this),this.isAcl=s.isAcl?s.isAcl:o,this.isAcl.bind(this),s.graph&amp;&amp;this.initFromGraph(s.graph)}return s(e,[{key:"addAuthorization",value<span class="cstat-no" title="statement not covered" ></span>:function(e){var t=e.hashFragment();return t in this.authorizations?this.aut<span class="fstat-no" title="function not covered" >horiza</span>tions[t].<span class="cstat-no" title="statement not covered" >mergeWith(e):this<span class="cstat-no" title="statement not covered" ></span>.authorizations[t]=e,!e.virtual&amp;&amp;e.allowsControl()&amp;&amp;this.addControlPermissionsFor(e),this.addToAgentIndex(e.webId(),e.accessType,e.resourceUrl,e),e.isPublic()&amp;&amp;this.addToPublicIndex(e.resourceUrl,e.accessType,e),this}},{key:"addAuthorizationFor",value:function(e,t,n,r){var i=arguments.leng</span>th&lt;=4||void 0===arguments[4]?[]:arguments[4],o=arguments.length&lt;=5||v<span class="fstat-no" title="function not covered" >oid 0=</span>==arguments[5]?<span class="cstat-no" title="statement not covered" >[]:arguments[5],a=new u(e,t);return a.setAgent(n),a.addMode</span>(r<span class="cstat-no" title="statement not covered" >),a.addOrigin(i),o.forEach(function(e){a.addMailTo(e)}),thi</span>s.<span class="cstat-no" title="statement not covered" >addAuthoriz<span class="cstat-no" title="statement not covered" ></span>ation(a),a}},{key:"addControlPermissionsFor",value:function<span class="fstat-no" title="function not covered" >(e</span>){var t=e.<span class="cstat-no" title="statement not covered" >clone();t.resour</span>ceUrl=this.aclUrlFor(e.resourc</span>eUrl),t.virtual=!0,t.addMode(c.ALL_MODES),this.addAuthorization(t)}},{key:<span class="fstat-no" title="function not covered" >"addGr</span>oupPermis<span class="cstat-no" title="statement not covered" >sion",valu<span class="cstat-no" title="statement not covered" ></span>e:function(e,t){var n=new u(this.resourceUrl,this.isAuthInherited());return n.setGroup(e),n.addMode(t),thi</span>s.addAuthorization(n),this}},{key:"addPermission",value:function(e,t<span class="fstat-no" title="function not covered" >,n){if</span>(!e)throw n<span class="cstat-no" title="statement not covered" >ew Error("addPermission() requires a valid webI<span class="cstat-no" title="statement not covered" ></span>d");if(!t)throw new Error("addPermission() requires a valid acces</span>sMode");var r=new u(this.resourceUrl,this.isAuthInherited());re<span class="fstat-no" title="function not covered" >turn r</span>.setAge<span class="cstat-no" title="statement not covered" >nt(e),<span class="cstat-no" title="statement not covered" >r.addMode(t),n&amp;&amp;r.addOrigin(n),this.addAuthorization(r),th<span class="cstat-no" title="statement not covered" >i</span></span>s}},{<span class="cstat-no" title="statement not covered" >key:"addToAgentIndex",value:function(e,t,n,r){var i=this.index.a</span></span>gents<span class="cstat-no" title="statement not covered" >;i[e]||(i[e]={}),i[e][t]||(i[e][t]={}),i[e][t][<span class="cstat-no" title="statement not covered" ></span>n]?i[e][t][n].mergeWith(r):i[e][t][n]=r}},{key:"addToGroupIndex",value:function(e,t</span>,n,r){var i=this.index.groups;i[e]||(i[e]={}),i[e][t]||(i[e][t]={<span class="fstat-no" title="function not covered" >}),i[e</span>][t][n]?i[e][t]<span class="cstat-no" title="statement not covered" >[n].mergeWith(r):i<span class="cstat-no" title="statement not covered" ></span>[e][t][n]=r}},{key:"addToPublicIndex",value:function(e,t,n){this.addToGroupIndex(c.EVER</span>YONE,t,e,n)}},{key:"allAuthorizations",value:function(){var e,t=t<span class="fstat-no" title="function not covered" >his,n=</span>[];return Objec<span class="cstat-no" title="statement not covered" >t.keys(this.author<span class="cstat-no" title="statement not covered" ></span>izations).forEach(function(r){e=t.authorizations[r],n.push(e)}),n}},{key:"allowsPublic"</span>,value:function(e,t){t=t||this.resourceUrl;var n=this.findPublicAu<span class="fstat-no" title="function not covered" >th(t);</span>return!<span class="cstat-no" title="statement not covered" >!n&amp;&amp;(this.checkOrigin(n)&amp;&amp;n.allowsMode(e</span>))}},{key:"buildGraph",value:function(e){var t=e.graph();return thi<span class="fstat-no" title="function not covered" >s.allA</span>uthorizati<span class="cstat-no" title="statement not covered" >ons()</span>.f<span class="cstat-no" title="statement not covered" >orE<span class="cstat-no" title="statement not covered" ></span>ach(function(n){t.add(n.rdfStatements(e))}),t}},<span class="fstat-no" title="function not covered" >{k</span>ey:"checkA<span class="cstat-no" title="statement not covered" >ccess",value:function(e,t,n){var </span>r=voi</span>d 0;if(this.allowsPublic(n,e))r=!0;else{var i=this.findAuthByA<span class="fstat-no" title="function not covered" >gent(t</span>,e);r<span class="cstat-no" title="statement not covered" >=i&amp;&amp;this.checkOrigin(i)</span>&amp;&amp;i.a<span class="cstat-no" title="statement not covered" >llowsMode(n)}return Pro<span class="cstat-no" title="statement not covered" ></span>mise.resolve(r)}},{key:"checkOrigin",value:functi</span>on(e){return!this.strictOrigin||!this.origin||this.origin===<span class="fstat-no" title="function not covered" >this.h</span>ost||e.al<span class="cstat-no" title="statement not covered" >lowsOrigin<span class="cstat-no" title="statement not covered" ></span>(this.origin)}},{key:"clear",value:funct<span class="fstat-no" title="function not covered" >io</span>n(e){if(e=<span class="cstat-no" title="statement not covered" >e||this.webClient,!e)return</span> Prom</span>ise.reject(new Error("Cannot clear - no web client"));var t=t<span class="fstat-no" title="function not covered" >his.ac</span>lUrl;return t<span class="cstat-no" title="statement not covered" >?e.del(<span class="cstat-no" title="statement not covered" ></span>t):Promise.reject(new Erro<span class="cstat-no" title="statement not covered" >r("Can</span>not clear <span class="cstat-no" title="statement not covered" >- unknown target url"))}},<span class="cstat-no" title="statement not covered" ></span>{key:"equals",value:function(e){var t=this,<span class="cstat-no" title="statement not covered" ></span>n</span>=this.resourceUrl===e.reso</span>urceUrl,r=this.aclUrl===e.aclUrl,i=this.resourceType===e.reso<span class="fstat-no" title="function not covered" >urceTy</span>pe,<span class="cstat-no" title="statement not covered" >o=Object.keys(this.authorizations),a=Object.keys(e.authorizations);if(o.length!==a.length)retu</span>rn!1;var s,u,l=!0;return o.forEach(function(n){s=t.auth<span class="fstat-no" title="function not covered" >orizat</span>ion<span class="cstat-no" title="statement not covered" >s[n],u=e.authorizations[n]<span class="cstat-no" title="statement not covered" >,u||(l=!1),s.equals(u)||(l=!1)}),n&amp;&amp;r&amp;&amp;i&amp;&amp;l}},{key:"findAuthByAgen</span></span>t",va<span class="cstat-no" title="statement not covered" >lue:function<span class="cstat-no" title="statement not covered" ></span>(e,t){var n=arguments.length&lt;=2||void 0===arguments[2]?g:arguments[2],r=this.index</span>[n];if(!r[e])return!1;var i=r[e][c.ACCESS_TO],o=void 0;i<span class="fstat-no" title="function not covered" >f(i&amp;&amp;(</span>o=i[t]),o<span class="cstat-no" title="statement not covered" >)retu</span>rn<span class="cstat-no" title="statement not covered" > o;var a=r[e][c.DEFAULT],s=void 0</span>;i<span class="cstat-no" title="statement not covered" >f(a&amp;&amp;(s=a[t],!s)){var u</span>=O<span class="cstat-no" title="statement not covered" >bject.keys(a).sort().reverse(),l=!0</span>,f<span class="cstat-no" title="statement not covered" >=!1,h=void 0;try{for(var d,p=u[Sy</span>mb<span class="cstat-no" title="statement not covered" >ol.iterator]();!(l=(d=p.next()<span class="cstat-no" title="statement not covered" ></span>).done);l=!0){var v=d.v<span class="cstat-no" title="statement not covered" >alue;if(t.</span></span>startsWit<span class="cstat-no" title="statement not covered" >h(v<span class="cstat-no" title="statement not covered" ></span>)){s=a[v];break}}<span class="fstat-no" title="function not covered" >}c</span>atch(e){f=<span class="cstat-no" title="statement not covered" >!0,h=e}finally{try{!l&amp;&amp;p.return&amp;&amp;p.return()}finally{if(f)throw h}}}return s</span>}},{key:"findP</span>ublicAuth",value:function(e){return this.findAuthByAgent(c.EVERYO<span class="fstat-no" title="function not covered" >NE,e,y</span>)}},{key:"f<span class="cstat-no" title="statement not covered" >orEach",value:function(e){var t=this;this.allAuthorization</span>s(<span class="cstat-no" title="statement not covered" >).forEach(func<span class="cstat-no" title="statement not covered" ></span>tion(n){e<span class="cstat-no" title="statement not covered" >.call(t,n)</span></span>})}},<span class="cstat-no" title="statement not covered" >{key:"initFromGrap</span>h"<span class="cstat-no" title="statement not covered" >,value:<span class="cstat-no" title="statement not covered" ></span>function(e){var t<span class="cstat-no" title="statement not covered" >=this,n=f(</span></span>this.<span class="cstat-no" title="statement not covered" >rdf),r=e.match(n</span>ul<span class="cstat-no" title="statement not covered" >l,null,<span class="cstat-no" title="statement not covered" ></span>n.acl("Authorization"));r<span class="cstat-no" title="statement not covered" >.length?r=r.map(function(e){retu</span>rn<span class="cstat-no" title="statement not covered" > e.</span>su<span class="cstat-no" title="statement not covered" >bje</span>ct<span class="cstat-no" title="statement not covered" >}):!fun<span class="cstat-no" title="statement not covered" ></span>ctio<span class="cstat-no" title="statement not covered" >n(){var t={};r=e.match(null,n.acl("mode")),r.forEach(function(e){t[e<span class="cstat-no" title="statement not covered" >.subject<span class="cstat-no" title="statement not covered" ></span>.value]=e.subject}),<span class="cstat-no" title="statement not covered" >r=Objec<span class="cstat-no" title="statement not covered" >t</span>.keys(</span>t</span>)</span>.map(func<span class="cstat-no" title="statement not covered" >tion(e){re</span>turn t[e<span class="cstat-no" title="statement not covered" >]})}<span class="cstat-no" title="statement not covered" >(),r.forEach(function(r){v</span>ar i=e.m<span class="cstat-no" title="statement not covered" >atch(<span class="cstat-no" title="statement not covered" >r,n.acl("</span></span>m</span>o<span class="cstat-no" title="statement not covered" ></span>d</span>e")),o=e.</span>match(r,n.acl("origin")),s=e.match(r,n.acl("agent")),u=s.filter(<span class="fstat-no" title="function not covered" >a);s=s</span>.fi<span class="cstat-no" title="statement not covered" >lter(function(e){return!a(e)});var l=e.match(</span>r,n.acl("agentClass"),n.foaf("Agent")),f=e.match(r,n.acl(<span class="fstat-no" title="function not covered" >"agent</span>Group")),<span class="cstat-no" title="statement not covered" >h=s.c<span class="cstat-no" title="statement not covered" ></span>oncat(l).concat(f);h.forEach(func<span class="fstat-no" title="function not covered" >ti</span>on(a){var <span class="cstat-no" title="statement not covered" >s=e.match(r,n</span>.ac</span>l("accessTo"));s.forEach(function(e){var n=e.object.value;t.add<span class="fstat-no" title="function not covered" >Author</span>izationFo<span class="cstat-no" title="statement not covered" >r(n,c</span>.N<span class="cstat-no" title="statement not covered" >OT_INHERIT,a</span>,i<span class="cstat-no" title="statement not covered" >,o,u)});var l=e.match(r,n.acl("default")).<span class="cstat-no" title="statement not covered" ></span>concat(e.match(r,<span class="fstat-no" title="function not covered" >n.</span>acl("defau<span class="cstat-no" title="statement not covered" >ltForNew")));l.for</span>Eac<span class="fstat-no" title="function not covered" >h(</span>function(e){var<span class="cstat-no" title="statement not covered" > n=<span class="cstat-no" title="statement not covered" ></span>e.object.value;t.addAuthorizationFor(n,c<span class="fstat-no" title="function not covered" >.I</span>NHERIT,a,i<span class="cstat-no" title="statement not covered" >,o,u)})})})}},{key:"isAuthInhe</span>rited",value:function()<span class="fstat-no" title="function not covered" >{r</span>eturn this<span class="cstat-no" title="statement not covered" >.resourceType</span>===</span>v}},{key:"isE<span class="fstat-no" title="function not covered" >mp</span>ty",value:functi<span class="cstat-no" title="statement not covered" >on(){return 0===this.coun</span>t}<span class="cstat-no" title="statement not covered" >},{key:"permissionFor",valu</span>e:<span class="cstat-no" title="statement not covered" >function(e,t){if(!e)return</span> n<span class="cstat-no" title="statement not covered" >ull;t=t||thi<span class="cstat-no" title="statement not covered" ></span>s.resourceU<span class="fstat-no" title="function not covered" >rl</span>;var n=u.h<span class="cstat-no" title="statement not covered" >ashFragmentFo</span>r(e</span>,t);r<span class="cstat-no" title="statement not covered" >eturn this.authorizations[n]}},{key:"removeAuth</span>or<span class="cstat-no" title="statement not covered" >ization",value:function(e){var </span>t=<span class="cstat-no" title="statement not covered" >e.hashFragment();retur<span class="cstat-no" title="statement not covered" ></span>n delete t<span class="fstat-no" title="function not covered" >hi</span>s.authorizations<span class="cstat-no" title="statement not covered" >[t],this}},{key:"removePermis<span class="cstat-no" title="statement not covered" ></span>sion",valu<span class="fstat-no" title="function not covered" >e:</span>function(e,t){va<span class="cstat-no" title="statement not covered" >r n=this.permis<span class="cstat-no" title="statement not covered" ></span>sionFor(e,this.resourceUrl);return n?(n.removeMo</span>de(</span>t),n.<span class="cstat-no" title="statement not covered" >isEmpty()&amp;&amp;this.removeAuthorization(n),this):this}},{key:"save",value:<span class="cstat-no" title="statement not covered" ></span>function()<span class="fstat-no" title="function not covered" >{v</span>ar e=this,t=argu<span class="cstat-no" title="statement not covered" >ments.length&lt;=0<span class="cstat-no" title="statement not covered" ></span>||void 0===arguments[0]?{}:arguments[0],n=t.</span>acl</span>Url</span>||t</span>his.aclUrl,r=t.contentType||d;return n?this.webClient?this.serial<span class="fstat-no" title="function not covered" >ize({c</span>on<span class="cstat-no" title="statement not covered" >tentType:r}).then(function(t){</span>return e.webClient.put(n,t,r)}):Promise.reject(new Error(<span class="fstat-no" title="function not covered" >"Canno</span>t <span class="cstat-no" title="statement not covered" >save - no web client"))</span>:Promise.reject(new Error("Cannot save - unknown target url"))}<span class="fstat-no" title="function not covered" >},{key</span>:"ser<span class="cstat-no" title="statement not covered" >ialize<span class="cstat-no" title="statement not covered" >",value:func<span class="cstat-no" title="statement not covered" >t</span></span>ion(){var e=arguments.</span>lengt<span class="cstat-no" title="statement not covered" >h&lt;=0||void 0===argument<span class="cstat-no" title="statement not covered" ></span>s[0]?{}:arguments[0],t=e.conten</span>tType||d,n=e.rdf||this.rdf;if(!n)return Promise.reject(new Error("Can<span class="fstat-no" title="function not covered" >not sa</span>ve - no r<span class="cstat-no" title="statement not covered" >df library"));var<span class="cstat-no" title="statement not covered" ></span> r=this.buildGraph(n),i=null,o=null;return </span>new Promise(function(e,a){n.serialize(i,r,o,t,function(n,r){return<span class="fstat-no" title="function not covered" > n?a(n</span>):r?void e(<span class="cstat-no" title="statement not covered" >r):a(new Error("Error serializing the g<span class="cstat-no" title="statement not covered" ></span>raph to "+t))})})}},{key:"count",get:function(){return Object.keys(this.authori</span>zations).length}}]),e}();m.RESOURCE=p,m.CONTAINER=v,e.<span class="fstat-no" title="function not covered" >export</span>s=m},fun<span class="cstat-no" title="statement not covered" >ction</span>(e<span class="cstat-no" title="statement not covered" >,t,n){"use strict";function r(e,t){if(!(e instanceof t))thr</span>ow<span class="cstat-no" title="statement not covered" > new TypeError("Cannot</span> c<span class="cstat-no" title="statement not covered" >all a class as a <span class="cstat-no" title="statement not covered" ></span>function")}function i(e,t){var n=arguments.length&lt;=2||void 0=<span class="fstat-no" title="function not covered" >==</span>arguments[<span class="cstat-no" title="statement not covered" >2]?u.ACCESS_TO:arguments[2],r=e</span>+"-"+t+"-"+n;return r}var o=function(){function e(e,t){for(var n=0;n&lt;t.length;n++){var r=t[n];r.enumerable=r.enumerable||!</span>1,r.configurable=!0,"value"in r&amp;&amp;(r.writable=!0),Object.def<span class="fstat-no" title="function not covered" >inePro</span>perty(e,<span class="cstat-no" title="statement not covered" >r.key,r)}}return function(t,n,r){return n&amp;&amp;e(t.prototype,n)</span>,r<span class="cstat-no" title="statement not covered" >&amp;&amp;e(t,r),t}}(),a=</span>n(<span class="cstat-no" title="statement not covered" >158),s=n(167),u=<span class="cstat-no" title="statement not covered" ></span>s.acl,<span class="cstat-no" title="statement not covered" >l=function(){function e(t,n){r(this,e),this.accessModes={},this.ac</span></span>cessT<span class="cstat-no" title="statement not covered" >ype=n?u.DEFAULT:u.A</span>CC<span class="cstat-no" title="statement not covered" >ESS_T</span>O,<span class="cstat-no" title="statement not covered" >this.<span class="cstat-no" title="statement not covered" ></span>agent=null,this.gro<span class="fstat-no" title="function not covered" >up</span>=null,this.i<span class="cstat-no" title="statement not covered" >nherited=n,this.mail<span class="fstat-no" title="function not covered" >To</span>=[],this.ori<span class="cstat-no" title="statement not covered" >ginsAllowed={},this.resourceUrl=t,this.virtual=!1}return o(e,[{key:"addMailTo</span>",v</span>alu</span>e:function(e){"string"!=typeof e&amp;&amp;(e=e.object.value),<span class="fstat-no" title="function not covered" >e.st</span>ar<span class="cstat-no" title="statement not covered" >tsWith("mailto:")&amp;&amp;(e=e.split(":")[1]),this.mail</span>To.push</span>(e)<span class="cstat-no" title="statement not covered" ></span>,this.mailTo.sort()}},{key:"addMode",val</span>u<span class="fstat-no" title="function not covered" >e:</span>function(e){var t=this;return Array.<span class="fstat-no" title="function not covered" >is</span>Array<span class="cstat-no" title="statement not covered" >(e)?e.forEach(functio<span class="cstat-no" title="statement not covered" >n(e){t.addModeSingle(e)}):this.addModeSingle(e),this}},{ke</span></span>y:"addMod<span class="fstat-no" title="function not covered" >eS</span>ingle",valu<span class="cstat-no" title="statement not covered" >e:function(e){return"string"!=typeof e&amp;&amp;(e=e.object.value),this.acce</span>ss<span class="cstat-no" title="statement not covered" >Modes[e]=!0,th<span class="cstat-no" title="statement not covered" ></span>is}},{key:</span>"addOr<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ig</span>in",value:function<span class="fstat-no" title="function not covered" >(e</span>){var<span class="cstat-no" title="statement not covered" > t=this;return Array.isArray(e)?e.<span class="cstat-no" title="statement not covered" >forEa<span class="cstat-no" title="statement not covered" ></span>ch(function(e){t.addOriginSingle(e)}):this.addOriginSingle(e),this}},{key:"addOriginSingle",value:function(e){r</span>e<span class="cstat-no" title="statement not covered" ></span>turn"st<span class="fstat-no" title="function not covered" >ri</span>ng"!=typeof e&amp;<span class="cstat-no" title="statement not covered" >&amp;(e=e.object.value),this.originsAllowed[</span>e]</span>=!0</span>,t<span class="cstat-no" title="statement not covered" >his}},{</span>ke<span class="cstat-no" title="statement not covered" >y:"allM</span>od<span class="cstat-no" title="statement not covered" >es",va</span>lu<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e:</span>function(){return <span class="fstat-no" title="function not covered" >Ob</span>ject.<span class="cstat-no" title="statement not covered" >keys(this.accessModes)}},{key:"allOrigins",value:function(){return Object.keys(this.originsAllowed)}},{key:"allowsMode",value:function(e){return e=u[e.toUpperCase()]||e,e===u.APPEND?this.allows<span class="cstat-no" title="statement not covered" ></span>Append():this.accessModes[e]}},{key:"allowsOrigin",value:function(e){<span class="fstat-no" title="function not covered" >return</span> e <span class="cstat-no" title="statement not covered" >in this.originsAllowed}},{key:"allowsRead",value:function(){return this.accessModes[u.READ]}},{key:"allowsWrite",value:funct</span>ion(){return this.accessModes[u.WRITE]}},{key:"allowsAppe<span class="fstat-no" title="function not covered" >nd",va</span>lue:funct<span class="cstat-no" title="statement not covered" >ion()<span class="cstat-no" title="statement not covered" ></span>{return this.accessModes[u.APPEND]<span class="fstat-no" title="function not covered" >||</span>this.acces<span class="cstat-no" title="statement not covered" >sModes[u.WRITE]}},{k</span>ey:"allowsControl",value:funct</span>ion(){return this.accessModes[u.CONTROL]}},{key:"clone",value:f<span class="fstat-no" title="function not covered" >unctio</span>n()<span class="cstat-no" title="statement not covered" >{var t=new e;return Object.assign(t,JSON.parse(JSON.stringify(this))),t}},</span>{key:"equals",value:function(e){var t=this.agent===e.agent,<span class="fstat-no" title="function not covered" >n=this</span>.group===<span class="cstat-no" title="statement not covered" >e.gro<span class="cstat-no" title="statement not covered" ></span>up,r=this.resourceUrl===e.resource<span class="fstat-no" title="function not covered" >Ur</span>l,i=Object<span class="cstat-no" title="statement not covered" >.keys(this.accessModes</span>),o=Object.keys(e.accessModes),a</span>=i.length===o.length,s=JSON.stringify(this.inherited)===JSON.stri<span class="fstat-no" title="function not covered" >ngify(</span>e.i<span class="cstat-no" title="statement not covered" >nherited),u=!0;i.forEach(function(t){e.accessModes[t]||(u=!1)});var l=JSON.st</span>ringify(this.mailTo)===JSON.stringify(e.mailTo),c=JSON.str<span class="fstat-no" title="function not covered" >ingify</span>(t<span class="cstat-no" title="statement not covered" >his.originsAllowed)===JSON.stringify(e</span>.originsAllowed);return t&amp;&amp;n&amp;&amp;r&amp;&amp;a&amp;&amp;u&amp;&amp;s&amp;&amp;l&amp;&amp;c}},{key:"hashF<span class="fstat-no" title="function not covered" >ragmen</span>t"<span class="cstat-no" title="statement not covered" >,value:function e(){if(!this.webId||!this</span>.resourceUrl)throw new Error("Cannot call hashFragment() on <span class="fstat-no" title="function not covered" >an inc</span>omp<span class="cstat-no" title="statement not covered" >lete authorization");var e=i(this.webId(),this.resourceUrl,this.accessType);return e}</span>},{key:"isAgent",value:function(){return this.agent}},{key:"is<span class="fstat-no" title="function not covered" >Empty"</span>,va<span class="cstat-no" title="statement not covered" >lue:function(){return 0===Object.</span>keys(this.accessModes).length}},{key:"isPublic",value:functi<span class="fstat-no" title="function not covered" >on(){r</span>et<span class="cstat-no" title="statement not covered" >urn this.group===u.EVERYONE}},{ke</span>y:"isGroup",value:function(){return this.group}},{key:"isInhe<span class="fstat-no" title="function not covered" >rited"</span>,v<span class="cstat-no" title="statement not covered" >alue:function(){return this.inheri</span>ted}},{key:"isValid",value:function(){return this.webId()&amp;&amp;thi<span class="fstat-no" title="function not covered" >s.reso</span>ur<span class="cstat-no" title="statement not covered" >ceUrl&amp;&amp;!this.isEmpty()}},{key:"mergeWith",value:function(e){if</span>(this.hashFragment()!==e.hashFragment())throw new Error("Cannot<span class="fstat-no" title="function not covered" > merge</span> a<span class="cstat-no" title="statement not covered" >uthorizations with different agent i</span>d or resource url (accessTo)");for(var t in e.accessMod<span class="fstat-no" title="function not covered" >es)thi</span>s.addMod<span class="cstat-no" title="statement not covered" >e(t)}},{<span class="cstat-no" title="statement not covered" ></span>key:"rdfStatements",value:function(e){if(!this.webId()||!thi</span>s.resourceUrl)return[];if(this.virtual)return[];var t,n=<span class="fstat-no" title="function not covered" >e.name</span>dNode("#"<span class="cstat-no" title="statement not covered" >+this.hashFragment())</span>,r<span class="cstat-no" title="statement not covered" >=a(e),i=[e.triple(n,r</span>.r<span class="cstat-no" title="statement not covered" >df("type"),r.acl("Authorization")</span>)]<span class="cstat-no" title="statement not covered" >;this.agent&amp;&amp;(t=e.triple(n,r.a</span>cl<span class="cstat-no" title="statement not covered" >("agent"),e.namedNode(this.</span>ag<span class="cstat-no" title="statement not covered" >ent)),i.push(t)),thi</span>s.<span class="cstat-no" title="statement not covered" >mailTo.length&gt;0&amp;&amp;this.mailTo.forEach(function(o){t=e.triple(n</span>,r<span class="cstat-no" title="statement not covered" >.ac<span class="cstat-no" title="statement not covered" ></span>l("agent")<span class="fstat-no" title="function not covered" >,e</span>.namedNode<span class="cstat-no" title="statement not covered" >("mailto:"+o)),i.push(t)})</span>,th</span>is.gr<span class="cstat-no" title="statement not covered" >oup&amp;&amp;(t=e.triple(n,r.acl("agentClass"),e.namedNode(this</span>.g<span class="cstat-no" title="statement not covered" >roup)),i.push(t)),t=e.triple(n,r.acl("accessTo"),e.namedNode(this.resou<span class="cstat-no" title="statement not covered" ></span>rceUrl)),i.push(t);var o=Object</span>.keys(this.accessModes);return o.forE<span class="fstat-no" title="function not covered" >ac</span>h(<span class="cstat-no" title="statement not covered" >function(o){t=e.triple(n,r.acl("mo<span class="cstat-no" title="statement not covered" >de"),e.namedNode(o)),i.push(t)}),this.inherited&amp;&amp;(t=e.triple(n,r.acl("defaultF</span></span>orNew<span class="cstat-no" title="statement not covered" >"),e.namedNode(this.resourceUrl)),i.push(t)),this<span class="cstat-no" title="statement not covered" ></span>.allOrigin</span>s().forEach(function(o){t=e.triple(n,r.acl("origin"),e.na<span class="fstat-no" title="function not covered" >medNod</span>e(<span class="cstat-no" title="statement not covered" >o)),i.push(t)}),i}}</span>,{key:"removeMode",value:function(e){var t=this;return Ar<span class="fstat-no" title="function not covered" >ray.is</span>Ar<span class="cstat-no" title="statement not covered" >ray(e)?e.forEach(function(e){t.removeModeSingle(e</span>)}):this.removeModeSingle(e),this}},{key:"removeModeSingle<span class="fstat-no" title="function not covered" >",valu</span>e:<span class="cstat-no" title="statement not covered" >function(e){"string"!=typeof e&amp;&amp;</span>(e=e.object.value),delete this.accessModes[e]}},{key:"rem<span class="fstat-no" title="function not covered" >oveOri</span>gi<span class="cstat-no" title="statement not covered" >n",value:function(e</span>){var t=this;return Array.isArray(e)?e.forEach(function(e){t.<span class="fstat-no" title="function not covered" >remove</span>Or<span class="cstat-no" title="statement not covered" >iginSingle(e)}):this.re</span>moveOriginSingle(e),this}},{key:"removeOriginSingle",valu<span class="fstat-no" title="function not covered" >e:func</span>ti<span class="cstat-no" title="statement not covered" >on(e){"string"!=typeof e&amp;&amp;(e=e.object.value),delete this</span>.originsAllowed[e]}},{key:"setAgent",value:function(e){if("<span class="fstat-no" title="function not covered" >string</span>"!=<span class="cstat-no" title="statement not covered" >typeof e&amp;&amp;(e=e.object.value),e===u.EVERYON<span class="cstat-no" title="statement not covered" >E)this.setPublic();else if(this.group)throw new Error("Cannot set agent, authorization already has<span class="cstat-no" title="statement not covered" > </span></span>a group set");e.startsWith<span class="cstat-no" title="statement not covered" >("mailto:")?this.</span></span>addMailTo(e):this.agent=e}},{key:"setGroup",value:function(e){i<span class="fstat-no" title="function not covered" >f("str</span>ing<span class="cstat-no" title="statement not covered" >"!=typeof e&amp;&amp;(e=e.object.value),this<span class="cstat-no" title="statement not covered" >.agent)th<span class="cstat-no" title="statement not covered" >r</span></span>ow new Error("C<span class="cstat-no" title="statement not covered" >annot set </span></span>group, <span class="cstat-no" title="statement not covered" >authorization already has an agent se</span>t"<span class="cstat-no" title="statement not covered" >);thi</span>s.<span class="cstat-no" title="statement not covered" >group=e}},{key:"setPublic",value:function(){this.se<span class="cstat-no" title="statement not covered" ></span>tGroup(u.EVERYONE)}},{key:"webId",value:function(){return this.agent||this.group}}]),e}();l.hashFragmentFor=i,e.exports<span class="fstat-no" title="function not covered" >=l</span>},function<span class="cstat-no" title="statement not covered" >(e,t,n){"use strict";var r=n(158),i=r(),o=i.acl("Read"),a=i.acl("</span>Write"),s=i.acl("Append"),u=i.acl("Control"),l=i.foaf("Agent"),c=[o,a,u],f=!0,h=!f,d="accessTo",p="default";e.exports.acl={ALL_MODES:c,READ:o,WRITE:a,APPEND:</span>s,CON<span class="cstat-no" title="statement not covered" >TROL:u,EVERYONE:l,INHERIT:f,NO<span class="cstat-no" title="statement not covered" ></span>T_INHERIT:h,ACCES<span class="fstat-no" title="function not covered" >S_</span>TO:d,DEFAU<span class="cstat-no" title="statement not covered" >LT:p}},function(e,t){"use strict";e.exports={authEndpo</span>int:"https://yodata.me",signupEndpoint:"https://yodata.me/signup",signupWindowHeight:600,signupWindowWidth:1024}},function(<span class="fstat-no" title="function not covered" >e,</span>t,n){"use <span class="cstat-no" title="statement not covered" >strict";var r=n(170);e.exports.version=function(){return</span> r.ve</span>rsion}},function(e,t){e.exports={name:"solid-client",version<span class="fstat-no" title="function not covered" >:"0.23</span>.6",descr<span class="cstat-no" title="statement not covered" >iptio<span class="cstat-no" title="statement not covered" ></span>n:"Common library for writing Soli<span class="fstat-no" title="function not covered" >d </span>read-write<span class="cstat-no" title="statement not covered" >-web applications",main</span>:"./lib/index.js",files:["config.</span>js","lib","dist"],scripts:{"build-lib":"babel src -d lib","build-f<span class="fstat-no" title="function not covered" >ull":"</span>web<span class="cstat-no" title="statement not covered" >pack --progress --config webpack.config.js --output-filename solid-</span>client-full.js","build-with-rdflib":"webpack --progress --colo<span class="fstat-no" title="function not covered" >rs --o</span>ptimize-m<span class="cstat-no" title="statement not covered" >inimi<span class="cstat-no" title="statement not covered" ></span>ze --optimize-occurrence-order --o<span class="fstat-no" title="function not covered" >pt</span>imize-dedu<span class="cstat-no" title="statement not covered" >pe --config webpack.confi</span>g.js","build-without-rdflib":"webpa</span>ck --progress --colors --optimize-minimize --optimize-occurrence-ord<span class="fstat-no" title="function not covered" >er --o</span>pti<span class="cstat-no" title="statement not covered" >mize-dedupe --config webpack-no-rdflib.config.js","build-qunit-resourc</span>es":"npm run clean &amp;&amp; mkdir -p dist/resources &amp;&amp; npm run b<span class="fstat-no" title="function not covered" >uild-f</span>ull<span class="cstat-no" title="statement not covered" > &amp;&amp; browserify -r ./test/resources/profile-minimal.js:tes<span class="cstat-no" title="statement not covered" >t-minimal-profile </span>-o d<span class="cstat-no" title="statement not covered" >ist/resources/<span class="cstat-no" title="statement not covered" >test-minimal-profile.js &amp;&amp; browserify -r ./test/resources/profile-private.j<span class="cstat-no" title="statement not covered" >s</span></span></span>:test-minimal-prefs -o dist/resources/test-minimal-pref</span>s.js",build:"npm run clean &amp;&amp; mkdir dist &amp;&amp; npm run build-<span class="fstat-no" title="function not covered" >lib &amp;&amp;</span> np<span class="cstat-no" title="statement not covered" >m run build-with-rdflib &amp;&amp; npm run build-without-rdfl<span class="cstat-no" title="statement not covered" >ib",clean:"rm -rf dist/",standard:"standard src/*",tape:"tape test/unit/*.js<span class="cstat-no" title="statement not covered" >"</span></span>,test:"npm ru</span>n standard &amp;&amp; npm run tape",qunit:"npm run build-qunit-reso<span class="fstat-no" title="function not covered" >urces </span>&amp;&amp;<span class="cstat-no" title="statement not covered" > open test/integration/inde</span>x.html",preversion:"npm test",postversion:"git push --f<span class="fstat-no" title="function not covered" >ollow-</span>ta<span class="cstat-no" title="statement not covered" >gs",prepublish:"npm run test &amp;&amp;</span> npm ru</span>n b<span class="cstat-no" title="statement not covered" ></span>uild"},babel:{presets:["es2015"]}</span>,<span class="fstat-no" title="function not covered" >re</span>pository:{type:"git",url:"https:/<span class="cstat-no" title="statement not covered" >/github</span>.c<span class="cstat-no" title="statement not covered" >om/s</span>ol<span class="cstat-no" title="statement not covered" >id/solid-clien</span>t"<span class="cstat-no" title="statement not covered" >},keywords:["so</span>li<span class="cstat-no" title="statement not covered" >d","decentralize</span>d"<span class="cstat-no" title="statement not covered" >,"web","rdf","ldp</span>",<span class="cstat-no" title="statement not covered" >"linked","data"]</span>,a<span class="cstat-no" title="statement not covered" >uthor:"A</span>nd<span class="cstat-no" title="statement not covered" >rei</span> S<span class="cstat-no" title="statement not covered" >amb</span>ra<span class="cstat-no" title="statement not covered" > &lt;andrei@fc</span>ns<span class="cstat-no" title="statement not covered" >.eu&gt;",main<span class="cstat-no" title="statement not covered" ></span>tainers:[{name:"Dmitri Zagidulin",url:"https://github.com/dmitrizagidulin/"}],license:"MIT",bugs:{url:"https://github.co</span>m<span class="fstat-no" title="function not covered" >/s</span>olid/solid-client/issues"<span class="cstat-no" title="statement not covered" >},homepage:"https://github.com/solid/solid-client",dependencies:{rdflib:"^0.13.0",shorthash:"0.0.2","solid-auth-oidc":"0.0.2","solid-a</span>u<span class="fstat-no" title="function not covered" >th</span>-tls":"0.0.4","solid-namespace":"<span class="cstat-no" title="statement not covered" >^0.1.0"<span class="cstat-no" title="statement not covered" ></span>,"solid-permission<span class="fstat-no" title="function not covered" >s"</span>:"^0.5.1"<span class="cstat-no" title="statement not covered" >,"solid-web-client</span>":</span>"<span class="fstat-no" title="function not covered" >gi</span>t://github.c<span class="cstat-no" title="statement not covered" >om/solid/solid-web-client.git#dz_oidc"},devDependencies:{"babel-cli":"^6.18.0","babel-loader":"^6.2.10","babel-preset-es2015":"^6.18.0","json-loader":"^0.5.4",nock:"^9.0.2",qunit:"^0.9.0",sinon:"^1.17.6",standard:"^5.4.1",tape:"^4.4.0",webpack:"^1.13.1"},standard:{globals:["$rdf","SolidClient","tabulator","QUnit"]}}},function(e,t){"use strict";function n(){return window.navigator.onLine}function r(e){window.addEventListener("offline",e,!1)}function i(e){window.addEventListener("online",e,!1)}e.exports.isOnline=n,e.exports.onOffline=r,e.exports.onOnline=i}]));<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span>
//# sourceMappingURL=solid-client.min.js.map</pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Sat May 27 2017 11:22:52 GMT-0700 (PDT)
</div>
</div>
<script src="../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../sorter.js"></script>
</body>
</html>
